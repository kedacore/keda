/*
Akeyless API

The purpose of this application is to provide access to Akeyless API.

API version: 3.0
Contact: support@akeyless.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package akeyless

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// V2ApiService V2Api service
type V2ApiService service

type ApiAccountCustomFieldCreateRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	accountCustomFieldCreate *AccountCustomFieldCreate
    body interface{}
}

func (r ApiAccountCustomFieldCreateRequest) AccountCustomFieldCreate(accountCustomFieldCreate AccountCustomFieldCreate) ApiAccountCustomFieldCreateRequest {
	r.accountCustomFieldCreate = &accountCustomFieldCreate
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAccountCustomFieldCreateRequest) Body(body AccountCustomFieldCreate) ApiAccountCustomFieldCreateRequest {
    r.body = body
    return r
}

func (r ApiAccountCustomFieldCreateRequest) Execute() (*AccountCustomFieldCreateOutput, *http.Response, error) {
	return r.ApiService.AccountCustomFieldCreateExecute(r)
}

/*
AccountCustomFieldCreate Create a new custom field.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAccountCustomFieldCreateRequest
*/
func (a *V2ApiService) AccountCustomFieldCreate(ctx context.Context) ApiAccountCustomFieldCreateRequest {
	return ApiAccountCustomFieldCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccountCustomFieldCreateOutput
func (a *V2ApiService) AccountCustomFieldCreateExecute(r ApiAccountCustomFieldCreateRequest) (*AccountCustomFieldCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountCustomFieldCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AccountCustomFieldCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/account-custom-field-create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccountCustomFieldDeleteRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	accountCustomFieldDelete *AccountCustomFieldDelete
    body interface{}
}

func (r ApiAccountCustomFieldDeleteRequest) AccountCustomFieldDelete(accountCustomFieldDelete AccountCustomFieldDelete) ApiAccountCustomFieldDeleteRequest {
	r.accountCustomFieldDelete = &accountCustomFieldDelete
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAccountCustomFieldDeleteRequest) Body(body AccountCustomFieldDelete) ApiAccountCustomFieldDeleteRequest {
    r.body = body
    return r
}

func (r ApiAccountCustomFieldDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AccountCustomFieldDeleteExecute(r)
}

/*
AccountCustomFieldDelete Delete a custom field.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAccountCustomFieldDeleteRequest
*/
func (a *V2ApiService) AccountCustomFieldDelete(ctx context.Context) ApiAccountCustomFieldDeleteRequest {
	return ApiAccountCustomFieldDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) AccountCustomFieldDeleteExecute(r ApiAccountCustomFieldDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AccountCustomFieldDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/account-custom-field-delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccountCustomFieldGetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	accountCustomFieldGet *AccountCustomFieldGet
    body interface{}
}

func (r ApiAccountCustomFieldGetRequest) AccountCustomFieldGet(accountCustomFieldGet AccountCustomFieldGet) ApiAccountCustomFieldGetRequest {
	r.accountCustomFieldGet = &accountCustomFieldGet
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAccountCustomFieldGetRequest) Body(body AccountCustomFieldGet) ApiAccountCustomFieldGetRequest {
    r.body = body
    return r
}

func (r ApiAccountCustomFieldGetRequest) Execute() (*AccountCustomFieldGetOutput, *http.Response, error) {
	return r.ApiService.AccountCustomFieldGetExecute(r)
}

/*
AccountCustomFieldGet Get an account custom field by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAccountCustomFieldGetRequest
*/
func (a *V2ApiService) AccountCustomFieldGet(ctx context.Context) ApiAccountCustomFieldGetRequest {
	return ApiAccountCustomFieldGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccountCustomFieldGetOutput
func (a *V2ApiService) AccountCustomFieldGetExecute(r ApiAccountCustomFieldGetRequest) (*AccountCustomFieldGetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountCustomFieldGetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AccountCustomFieldGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/account-custom-field-get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccountCustomFieldListRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	accountCustomFieldList *AccountCustomFieldList
    body interface{}
}

func (r ApiAccountCustomFieldListRequest) AccountCustomFieldList(accountCustomFieldList AccountCustomFieldList) ApiAccountCustomFieldListRequest {
	r.accountCustomFieldList = &accountCustomFieldList
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAccountCustomFieldListRequest) Body(body AccountCustomFieldList) ApiAccountCustomFieldListRequest {
    r.body = body
    return r
}

func (r ApiAccountCustomFieldListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AccountCustomFieldListExecute(r)
}

/*
AccountCustomFieldList List all account custom fields.

Returns a list of all custom fields configured for the account, optionally filtered by object and object type.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAccountCustomFieldListRequest
*/
func (a *V2ApiService) AccountCustomFieldList(ctx context.Context) ApiAccountCustomFieldListRequest {
	return ApiAccountCustomFieldListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) AccountCustomFieldListExecute(r ApiAccountCustomFieldListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AccountCustomFieldList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/account-custom-field-list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccountCustomFieldUpdateRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	accountCustomFieldUpdate *AccountCustomFieldUpdate
    body interface{}
}

func (r ApiAccountCustomFieldUpdateRequest) AccountCustomFieldUpdate(accountCustomFieldUpdate AccountCustomFieldUpdate) ApiAccountCustomFieldUpdateRequest {
	r.accountCustomFieldUpdate = &accountCustomFieldUpdate
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAccountCustomFieldUpdateRequest) Body(body AccountCustomFieldUpdate) ApiAccountCustomFieldUpdateRequest {
    r.body = body
    return r
}

func (r ApiAccountCustomFieldUpdateRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AccountCustomFieldUpdateExecute(r)
}

/*
AccountCustomFieldUpdate Update a custom field.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAccountCustomFieldUpdateRequest
*/
func (a *V2ApiService) AccountCustomFieldUpdate(ctx context.Context) ApiAccountCustomFieldUpdateRequest {
	return ApiAccountCustomFieldUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) AccountCustomFieldUpdateExecute(r ApiAccountCustomFieldUpdateRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AccountCustomFieldUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/account-custom-field-update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAliasDetailsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	aliasDetails *AliasDetails
    body interface{}
}

func (r ApiAliasDetailsRequest) AliasDetails(aliasDetails AliasDetails) ApiAliasDetailsRequest {
	r.aliasDetails = &aliasDetails
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAliasDetailsRequest) Body(body AliasDetails) ApiAliasDetailsRequest {
    r.body = body
    return r
}

func (r ApiAliasDetailsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AliasDetailsExecute(r)
}

/*
AliasDetails Method for AliasDetails

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAliasDetailsRequest
*/
func (a *V2ApiService) AliasDetails(ctx context.Context) ApiAliasDetailsRequest {
	return ApiAliasDetailsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) AliasDetailsExecute(r ApiAliasDetailsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AliasDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alias-details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssocRoleAuthMethodRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	assocRoleAuthMethod *AssocRoleAuthMethod
    body interface{}
}

func (r ApiAssocRoleAuthMethodRequest) AssocRoleAuthMethod(assocRoleAuthMethod AssocRoleAuthMethod) ApiAssocRoleAuthMethodRequest {
	r.assocRoleAuthMethod = &assocRoleAuthMethod
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAssocRoleAuthMethodRequest) Body(body AssocRoleAuthMethod) ApiAssocRoleAuthMethodRequest {
    r.body = body
    return r
}

func (r ApiAssocRoleAuthMethodRequest) Execute() (*CreateRoleAuthMethodAssocOutput, *http.Response, error) {
	return r.ApiService.AssocRoleAuthMethodExecute(r)
}

/*
AssocRoleAuthMethod Method for AssocRoleAuthMethod

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAssocRoleAuthMethodRequest
*/
func (a *V2ApiService) AssocRoleAuthMethod(ctx context.Context) ApiAssocRoleAuthMethodRequest {
	return ApiAssocRoleAuthMethodRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateRoleAuthMethodAssocOutput
func (a *V2ApiService) AssocRoleAuthMethodExecute(r ApiAssocRoleAuthMethodRequest) (*CreateRoleAuthMethodAssocOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateRoleAuthMethodAssocOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AssocRoleAuthMethod")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assoc-role-am"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssocTargetItemRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	assocTargetItem *AssocTargetItem
    body interface{}
}

func (r ApiAssocTargetItemRequest) AssocTargetItem(assocTargetItem AssocTargetItem) ApiAssocTargetItemRequest {
	r.assocTargetItem = &assocTargetItem
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAssocTargetItemRequest) Body(body AssocTargetItem) ApiAssocTargetItemRequest {
    r.body = body
    return r
}

func (r ApiAssocTargetItemRequest) Execute() (*CreateTargetItemAssocOutput, *http.Response, error) {
	return r.ApiService.AssocTargetItemExecute(r)
}

/*
AssocTargetItem Method for AssocTargetItem

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAssocTargetItemRequest
*/
func (a *V2ApiService) AssocTargetItem(ctx context.Context) ApiAssocTargetItemRequest {
	return ApiAssocTargetItemRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateTargetItemAssocOutput
func (a *V2ApiService) AssocTargetItemExecute(r ApiAssocTargetItemRequest) (*CreateTargetItemAssocOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateTargetItemAssocOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AssocTargetItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assoc-target-item"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	auth *Auth
    body interface{}
}

func (r ApiAuthRequest) Auth(auth Auth) ApiAuthRequest {
	r.auth = &auth
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAuthRequest) Body(body Auth) ApiAuthRequest {
    r.body = body
    return r
}

func (r ApiAuthRequest) Execute() (*AuthOutput, *http.Response, error) {
	return r.ApiService.AuthExecute(r)
}

/*
Auth Method for Auth

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthRequest
*/
func (a *V2ApiService) Auth(ctx context.Context) ApiAuthRequest {
	return ApiAuthRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthOutput
func (a *V2ApiService) AuthExecute(r ApiAuthRequest) (*AuthOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.Auth")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthMethodCreateApiKeyRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	authMethodCreateApiKey *AuthMethodCreateApiKey
    body interface{}
}

func (r ApiAuthMethodCreateApiKeyRequest) AuthMethodCreateApiKey(authMethodCreateApiKey AuthMethodCreateApiKey) ApiAuthMethodCreateApiKeyRequest {
	r.authMethodCreateApiKey = &authMethodCreateApiKey
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAuthMethodCreateApiKeyRequest) Body(body AuthMethodCreateApiKey) ApiAuthMethodCreateApiKeyRequest {
    r.body = body
    return r
}

func (r ApiAuthMethodCreateApiKeyRequest) Execute() (*AuthMethodCreateOutput, *http.Response, error) {
	return r.ApiService.AuthMethodCreateApiKeyExecute(r)
}

/*
AuthMethodCreateApiKey Method for AuthMethodCreateApiKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthMethodCreateApiKeyRequest
*/
func (a *V2ApiService) AuthMethodCreateApiKey(ctx context.Context) ApiAuthMethodCreateApiKeyRequest {
	return ApiAuthMethodCreateApiKeyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthMethodCreateOutput
func (a *V2ApiService) AuthMethodCreateApiKeyExecute(r ApiAuthMethodCreateApiKeyRequest) (*AuthMethodCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthMethodCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AuthMethodCreateApiKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth-method-create-api-key"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthMethodCreateAwsIamRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	authMethodCreateAwsIam *AuthMethodCreateAwsIam
    body interface{}
}

func (r ApiAuthMethodCreateAwsIamRequest) AuthMethodCreateAwsIam(authMethodCreateAwsIam AuthMethodCreateAwsIam) ApiAuthMethodCreateAwsIamRequest {
	r.authMethodCreateAwsIam = &authMethodCreateAwsIam
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAuthMethodCreateAwsIamRequest) Body(body AuthMethodCreateAwsIam) ApiAuthMethodCreateAwsIamRequest {
    r.body = body
    return r
}

func (r ApiAuthMethodCreateAwsIamRequest) Execute() (*AuthMethodCreateOutput, *http.Response, error) {
	return r.ApiService.AuthMethodCreateAwsIamExecute(r)
}

/*
AuthMethodCreateAwsIam Method for AuthMethodCreateAwsIam

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthMethodCreateAwsIamRequest
*/
func (a *V2ApiService) AuthMethodCreateAwsIam(ctx context.Context) ApiAuthMethodCreateAwsIamRequest {
	return ApiAuthMethodCreateAwsIamRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthMethodCreateOutput
func (a *V2ApiService) AuthMethodCreateAwsIamExecute(r ApiAuthMethodCreateAwsIamRequest) (*AuthMethodCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthMethodCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AuthMethodCreateAwsIam")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth-method-create-aws-iam"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthMethodCreateAzureADRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	authMethodCreateAzureAD *AuthMethodCreateAzureAD
    body interface{}
}

func (r ApiAuthMethodCreateAzureADRequest) AuthMethodCreateAzureAD(authMethodCreateAzureAD AuthMethodCreateAzureAD) ApiAuthMethodCreateAzureADRequest {
	r.authMethodCreateAzureAD = &authMethodCreateAzureAD
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAuthMethodCreateAzureADRequest) Body(body AuthMethodCreateAzureAD) ApiAuthMethodCreateAzureADRequest {
    r.body = body
    return r
}

func (r ApiAuthMethodCreateAzureADRequest) Execute() (*AuthMethodCreateOutput, *http.Response, error) {
	return r.ApiService.AuthMethodCreateAzureADExecute(r)
}

/*
AuthMethodCreateAzureAD Method for AuthMethodCreateAzureAD

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthMethodCreateAzureADRequest
*/
func (a *V2ApiService) AuthMethodCreateAzureAD(ctx context.Context) ApiAuthMethodCreateAzureADRequest {
	return ApiAuthMethodCreateAzureADRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthMethodCreateOutput
func (a *V2ApiService) AuthMethodCreateAzureADExecute(r ApiAuthMethodCreateAzureADRequest) (*AuthMethodCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthMethodCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AuthMethodCreateAzureAD")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth-method-create-azure-ad"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthMethodCreateCertRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	authMethodCreateCert *AuthMethodCreateCert
    body interface{}
}

func (r ApiAuthMethodCreateCertRequest) AuthMethodCreateCert(authMethodCreateCert AuthMethodCreateCert) ApiAuthMethodCreateCertRequest {
	r.authMethodCreateCert = &authMethodCreateCert
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAuthMethodCreateCertRequest) Body(body AuthMethodCreateCert) ApiAuthMethodCreateCertRequest {
    r.body = body
    return r
}

func (r ApiAuthMethodCreateCertRequest) Execute() (*AuthMethodCreateOutput, *http.Response, error) {
	return r.ApiService.AuthMethodCreateCertExecute(r)
}

/*
AuthMethodCreateCert Method for AuthMethodCreateCert

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthMethodCreateCertRequest
*/
func (a *V2ApiService) AuthMethodCreateCert(ctx context.Context) ApiAuthMethodCreateCertRequest {
	return ApiAuthMethodCreateCertRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthMethodCreateOutput
func (a *V2ApiService) AuthMethodCreateCertExecute(r ApiAuthMethodCreateCertRequest) (*AuthMethodCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthMethodCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AuthMethodCreateCert")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth-method-create-cert"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthMethodCreateEmailRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	authMethodCreateEmail *AuthMethodCreateEmail
    body interface{}
}

func (r ApiAuthMethodCreateEmailRequest) AuthMethodCreateEmail(authMethodCreateEmail AuthMethodCreateEmail) ApiAuthMethodCreateEmailRequest {
	r.authMethodCreateEmail = &authMethodCreateEmail
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAuthMethodCreateEmailRequest) Body(body AuthMethodCreateEmail) ApiAuthMethodCreateEmailRequest {
    r.body = body
    return r
}

func (r ApiAuthMethodCreateEmailRequest) Execute() (*AuthMethodCreateOutput, *http.Response, error) {
	return r.ApiService.AuthMethodCreateEmailExecute(r)
}

/*
AuthMethodCreateEmail Method for AuthMethodCreateEmail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthMethodCreateEmailRequest
*/
func (a *V2ApiService) AuthMethodCreateEmail(ctx context.Context) ApiAuthMethodCreateEmailRequest {
	return ApiAuthMethodCreateEmailRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthMethodCreateOutput
func (a *V2ApiService) AuthMethodCreateEmailExecute(r ApiAuthMethodCreateEmailRequest) (*AuthMethodCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthMethodCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AuthMethodCreateEmail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth-method-create-email"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthMethodCreateGcpRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	authMethodCreateGcp *AuthMethodCreateGcp
    body interface{}
}

func (r ApiAuthMethodCreateGcpRequest) AuthMethodCreateGcp(authMethodCreateGcp AuthMethodCreateGcp) ApiAuthMethodCreateGcpRequest {
	r.authMethodCreateGcp = &authMethodCreateGcp
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAuthMethodCreateGcpRequest) Body(body AuthMethodCreateGcp) ApiAuthMethodCreateGcpRequest {
    r.body = body
    return r
}

func (r ApiAuthMethodCreateGcpRequest) Execute() (*AuthMethodCreateOutput, *http.Response, error) {
	return r.ApiService.AuthMethodCreateGcpExecute(r)
}

/*
AuthMethodCreateGcp Method for AuthMethodCreateGcp

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthMethodCreateGcpRequest
*/
func (a *V2ApiService) AuthMethodCreateGcp(ctx context.Context) ApiAuthMethodCreateGcpRequest {
	return ApiAuthMethodCreateGcpRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthMethodCreateOutput
func (a *V2ApiService) AuthMethodCreateGcpExecute(r ApiAuthMethodCreateGcpRequest) (*AuthMethodCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthMethodCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AuthMethodCreateGcp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth-method-create-gcp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthMethodCreateK8sRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	authMethodCreateK8s *AuthMethodCreateK8s
    body interface{}
}

func (r ApiAuthMethodCreateK8sRequest) AuthMethodCreateK8s(authMethodCreateK8s AuthMethodCreateK8s) ApiAuthMethodCreateK8sRequest {
	r.authMethodCreateK8s = &authMethodCreateK8s
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAuthMethodCreateK8sRequest) Body(body AuthMethodCreateK8s) ApiAuthMethodCreateK8sRequest {
    r.body = body
    return r
}

func (r ApiAuthMethodCreateK8sRequest) Execute() (*AuthMethodCreateOutput, *http.Response, error) {
	return r.ApiService.AuthMethodCreateK8sExecute(r)
}

/*
AuthMethodCreateK8s Method for AuthMethodCreateK8s

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthMethodCreateK8sRequest
*/
func (a *V2ApiService) AuthMethodCreateK8s(ctx context.Context) ApiAuthMethodCreateK8sRequest {
	return ApiAuthMethodCreateK8sRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthMethodCreateOutput
func (a *V2ApiService) AuthMethodCreateK8sExecute(r ApiAuthMethodCreateK8sRequest) (*AuthMethodCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthMethodCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AuthMethodCreateK8s")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth-method-create-k8s"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthMethodCreateKerberosRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	authMethodCreateKerberos *AuthMethodCreateKerberos
    body interface{}
}

func (r ApiAuthMethodCreateKerberosRequest) AuthMethodCreateKerberos(authMethodCreateKerberos AuthMethodCreateKerberos) ApiAuthMethodCreateKerberosRequest {
	r.authMethodCreateKerberos = &authMethodCreateKerberos
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAuthMethodCreateKerberosRequest) Body(body AuthMethodCreateKerberos) ApiAuthMethodCreateKerberosRequest {
    r.body = body
    return r
}

func (r ApiAuthMethodCreateKerberosRequest) Execute() (*AuthMethodCreateOutput, *http.Response, error) {
	return r.ApiService.AuthMethodCreateKerberosExecute(r)
}

/*
AuthMethodCreateKerberos Method for AuthMethodCreateKerberos

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthMethodCreateKerberosRequest
*/
func (a *V2ApiService) AuthMethodCreateKerberos(ctx context.Context) ApiAuthMethodCreateKerberosRequest {
	return ApiAuthMethodCreateKerberosRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthMethodCreateOutput
func (a *V2ApiService) AuthMethodCreateKerberosExecute(r ApiAuthMethodCreateKerberosRequest) (*AuthMethodCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthMethodCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AuthMethodCreateKerberos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth-method-create-kerberos"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthMethodCreateLdapRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	authMethodCreateLdap *AuthMethodCreateLdap
    body interface{}
}

func (r ApiAuthMethodCreateLdapRequest) AuthMethodCreateLdap(authMethodCreateLdap AuthMethodCreateLdap) ApiAuthMethodCreateLdapRequest {
	r.authMethodCreateLdap = &authMethodCreateLdap
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAuthMethodCreateLdapRequest) Body(body AuthMethodCreateLdap) ApiAuthMethodCreateLdapRequest {
    r.body = body
    return r
}

func (r ApiAuthMethodCreateLdapRequest) Execute() (*AuthMethodCreateOutput, *http.Response, error) {
	return r.ApiService.AuthMethodCreateLdapExecute(r)
}

/*
AuthMethodCreateLdap Method for AuthMethodCreateLdap

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthMethodCreateLdapRequest
*/
func (a *V2ApiService) AuthMethodCreateLdap(ctx context.Context) ApiAuthMethodCreateLdapRequest {
	return ApiAuthMethodCreateLdapRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthMethodCreateOutput
func (a *V2ApiService) AuthMethodCreateLdapExecute(r ApiAuthMethodCreateLdapRequest) (*AuthMethodCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthMethodCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AuthMethodCreateLdap")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth-method-create-ldap"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthMethodCreateOCIRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	authMethodCreateOCI *AuthMethodCreateOCI
    body interface{}
}

func (r ApiAuthMethodCreateOCIRequest) AuthMethodCreateOCI(authMethodCreateOCI AuthMethodCreateOCI) ApiAuthMethodCreateOCIRequest {
	r.authMethodCreateOCI = &authMethodCreateOCI
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAuthMethodCreateOCIRequest) Body(body AuthMethodCreateOCI) ApiAuthMethodCreateOCIRequest {
    r.body = body
    return r
}

func (r ApiAuthMethodCreateOCIRequest) Execute() (*AuthMethodCreateOutput, *http.Response, error) {
	return r.ApiService.AuthMethodCreateOCIExecute(r)
}

/*
AuthMethodCreateOCI Method for AuthMethodCreateOCI

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthMethodCreateOCIRequest
*/
func (a *V2ApiService) AuthMethodCreateOCI(ctx context.Context) ApiAuthMethodCreateOCIRequest {
	return ApiAuthMethodCreateOCIRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthMethodCreateOutput
func (a *V2ApiService) AuthMethodCreateOCIExecute(r ApiAuthMethodCreateOCIRequest) (*AuthMethodCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthMethodCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AuthMethodCreateOCI")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth-method-create-oci"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthMethodCreateOIDCRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	authMethodCreateOIDC *AuthMethodCreateOIDC
    body interface{}
}

func (r ApiAuthMethodCreateOIDCRequest) AuthMethodCreateOIDC(authMethodCreateOIDC AuthMethodCreateOIDC) ApiAuthMethodCreateOIDCRequest {
	r.authMethodCreateOIDC = &authMethodCreateOIDC
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAuthMethodCreateOIDCRequest) Body(body AuthMethodCreateOIDC) ApiAuthMethodCreateOIDCRequest {
    r.body = body
    return r
}

func (r ApiAuthMethodCreateOIDCRequest) Execute() (*AuthMethodCreateOutput, *http.Response, error) {
	return r.ApiService.AuthMethodCreateOIDCExecute(r)
}

/*
AuthMethodCreateOIDC Method for AuthMethodCreateOIDC

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthMethodCreateOIDCRequest
*/
func (a *V2ApiService) AuthMethodCreateOIDC(ctx context.Context) ApiAuthMethodCreateOIDCRequest {
	return ApiAuthMethodCreateOIDCRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthMethodCreateOutput
func (a *V2ApiService) AuthMethodCreateOIDCExecute(r ApiAuthMethodCreateOIDCRequest) (*AuthMethodCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthMethodCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AuthMethodCreateOIDC")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth-method-create-oidc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthMethodCreateOauth2Request struct {
	ctx context.Context
	ApiService *V2ApiService
	authMethodCreateOauth2 *AuthMethodCreateOauth2
    body interface{}
}

func (r ApiAuthMethodCreateOauth2Request) AuthMethodCreateOauth2(authMethodCreateOauth2 AuthMethodCreateOauth2) ApiAuthMethodCreateOauth2Request {
	r.authMethodCreateOauth2 = &authMethodCreateOauth2
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAuthMethodCreateOauth2Request) Body(body AuthMethodCreateOauth2) ApiAuthMethodCreateOauth2Request {
    r.body = body
    return r
}

func (r ApiAuthMethodCreateOauth2Request) Execute() (*AuthMethodCreateOutput, *http.Response, error) {
	return r.ApiService.AuthMethodCreateOauth2Execute(r)
}

/*
AuthMethodCreateOauth2 Method for AuthMethodCreateOauth2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthMethodCreateOauth2Request
*/
func (a *V2ApiService) AuthMethodCreateOauth2(ctx context.Context) ApiAuthMethodCreateOauth2Request {
	return ApiAuthMethodCreateOauth2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthMethodCreateOutput
func (a *V2ApiService) AuthMethodCreateOauth2Execute(r ApiAuthMethodCreateOauth2Request) (*AuthMethodCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthMethodCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AuthMethodCreateOauth2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth-method-create-oauth2"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthMethodCreateSAMLRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	authMethodCreateSAML *AuthMethodCreateSAML
    body interface{}
}

func (r ApiAuthMethodCreateSAMLRequest) AuthMethodCreateSAML(authMethodCreateSAML AuthMethodCreateSAML) ApiAuthMethodCreateSAMLRequest {
	r.authMethodCreateSAML = &authMethodCreateSAML
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAuthMethodCreateSAMLRequest) Body(body AuthMethodCreateSAML) ApiAuthMethodCreateSAMLRequest {
    r.body = body
    return r
}

func (r ApiAuthMethodCreateSAMLRequest) Execute() (*AuthMethodCreateOutput, *http.Response, error) {
	return r.ApiService.AuthMethodCreateSAMLExecute(r)
}

/*
AuthMethodCreateSAML Method for AuthMethodCreateSAML

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthMethodCreateSAMLRequest
*/
func (a *V2ApiService) AuthMethodCreateSAML(ctx context.Context) ApiAuthMethodCreateSAMLRequest {
	return ApiAuthMethodCreateSAMLRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthMethodCreateOutput
func (a *V2ApiService) AuthMethodCreateSAMLExecute(r ApiAuthMethodCreateSAMLRequest) (*AuthMethodCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthMethodCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AuthMethodCreateSAML")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth-method-create-saml"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthMethodCreateUniversalIdentityRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	authMethodCreateUniversalIdentity *AuthMethodCreateUniversalIdentity
    body interface{}
}

func (r ApiAuthMethodCreateUniversalIdentityRequest) AuthMethodCreateUniversalIdentity(authMethodCreateUniversalIdentity AuthMethodCreateUniversalIdentity) ApiAuthMethodCreateUniversalIdentityRequest {
	r.authMethodCreateUniversalIdentity = &authMethodCreateUniversalIdentity
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAuthMethodCreateUniversalIdentityRequest) Body(body AuthMethodCreateUniversalIdentity) ApiAuthMethodCreateUniversalIdentityRequest {
    r.body = body
    return r
}

func (r ApiAuthMethodCreateUniversalIdentityRequest) Execute() (*AuthMethodCreateOutput, *http.Response, error) {
	return r.ApiService.AuthMethodCreateUniversalIdentityExecute(r)
}

/*
AuthMethodCreateUniversalIdentity Method for AuthMethodCreateUniversalIdentity

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthMethodCreateUniversalIdentityRequest
*/
func (a *V2ApiService) AuthMethodCreateUniversalIdentity(ctx context.Context) ApiAuthMethodCreateUniversalIdentityRequest {
	return ApiAuthMethodCreateUniversalIdentityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthMethodCreateOutput
func (a *V2ApiService) AuthMethodCreateUniversalIdentityExecute(r ApiAuthMethodCreateUniversalIdentityRequest) (*AuthMethodCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthMethodCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AuthMethodCreateUniversalIdentity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth-method-create-universal-identity"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthMethodDeleteRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	authMethodDelete *AuthMethodDelete
    body interface{}
}

func (r ApiAuthMethodDeleteRequest) AuthMethodDelete(authMethodDelete AuthMethodDelete) ApiAuthMethodDeleteRequest {
	r.authMethodDelete = &authMethodDelete
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAuthMethodDeleteRequest) Body(body AuthMethodDelete) ApiAuthMethodDeleteRequest {
    r.body = body
    return r
}

func (r ApiAuthMethodDeleteRequest) Execute() (*AuthMethodDeleteOutput, *http.Response, error) {
	return r.ApiService.AuthMethodDeleteExecute(r)
}

/*
AuthMethodDelete Method for AuthMethodDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthMethodDeleteRequest
*/
func (a *V2ApiService) AuthMethodDelete(ctx context.Context) ApiAuthMethodDeleteRequest {
	return ApiAuthMethodDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthMethodDeleteOutput
func (a *V2ApiService) AuthMethodDeleteExecute(r ApiAuthMethodDeleteRequest) (*AuthMethodDeleteOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthMethodDeleteOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AuthMethodDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth-method-delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthMethodGetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	authMethodGet *AuthMethodGet
    body interface{}
}

func (r ApiAuthMethodGetRequest) AuthMethodGet(authMethodGet AuthMethodGet) ApiAuthMethodGetRequest {
	r.authMethodGet = &authMethodGet
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAuthMethodGetRequest) Body(body AuthMethodGet) ApiAuthMethodGetRequest {
    r.body = body
    return r
}

func (r ApiAuthMethodGetRequest) Execute() (*AuthMethod, *http.Response, error) {
	return r.ApiService.AuthMethodGetExecute(r)
}

/*
AuthMethodGet Method for AuthMethodGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthMethodGetRequest
*/
func (a *V2ApiService) AuthMethodGet(ctx context.Context) ApiAuthMethodGetRequest {
	return ApiAuthMethodGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthMethod
func (a *V2ApiService) AuthMethodGetExecute(r ApiAuthMethodGetRequest) (*AuthMethod, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthMethod
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AuthMethodGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth-method-get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthMethodListRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	authMethodList *AuthMethodList
    body interface{}
}

func (r ApiAuthMethodListRequest) AuthMethodList(authMethodList AuthMethodList) ApiAuthMethodListRequest {
	r.authMethodList = &authMethodList
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAuthMethodListRequest) Body(body AuthMethodList) ApiAuthMethodListRequest {
    r.body = body
    return r
}

func (r ApiAuthMethodListRequest) Execute() (*ListAuthMethodsOutput, *http.Response, error) {
	return r.ApiService.AuthMethodListExecute(r)
}

/*
AuthMethodList Method for AuthMethodList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthMethodListRequest
*/
func (a *V2ApiService) AuthMethodList(ctx context.Context) ApiAuthMethodListRequest {
	return ApiAuthMethodListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListAuthMethodsOutput
func (a *V2ApiService) AuthMethodListExecute(r ApiAuthMethodListRequest) (*ListAuthMethodsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAuthMethodsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AuthMethodList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth-method-list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthMethodUpdateApiKeyRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	authMethodUpdateApiKey *AuthMethodUpdateApiKey
    body interface{}
}

func (r ApiAuthMethodUpdateApiKeyRequest) AuthMethodUpdateApiKey(authMethodUpdateApiKey AuthMethodUpdateApiKey) ApiAuthMethodUpdateApiKeyRequest {
	r.authMethodUpdateApiKey = &authMethodUpdateApiKey
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAuthMethodUpdateApiKeyRequest) Body(body AuthMethodUpdateApiKey) ApiAuthMethodUpdateApiKeyRequest {
    r.body = body
    return r
}

func (r ApiAuthMethodUpdateApiKeyRequest) Execute() (*AuthMethodUpdateOutput, *http.Response, error) {
	return r.ApiService.AuthMethodUpdateApiKeyExecute(r)
}

/*
AuthMethodUpdateApiKey Method for AuthMethodUpdateApiKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthMethodUpdateApiKeyRequest
*/
func (a *V2ApiService) AuthMethodUpdateApiKey(ctx context.Context) ApiAuthMethodUpdateApiKeyRequest {
	return ApiAuthMethodUpdateApiKeyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthMethodUpdateOutput
func (a *V2ApiService) AuthMethodUpdateApiKeyExecute(r ApiAuthMethodUpdateApiKeyRequest) (*AuthMethodUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthMethodUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AuthMethodUpdateApiKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth-method-update-api-key"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthMethodUpdateAwsIamRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	authMethodUpdateAwsIam *AuthMethodUpdateAwsIam
    body interface{}
}

func (r ApiAuthMethodUpdateAwsIamRequest) AuthMethodUpdateAwsIam(authMethodUpdateAwsIam AuthMethodUpdateAwsIam) ApiAuthMethodUpdateAwsIamRequest {
	r.authMethodUpdateAwsIam = &authMethodUpdateAwsIam
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAuthMethodUpdateAwsIamRequest) Body(body AuthMethodUpdateAwsIam) ApiAuthMethodUpdateAwsIamRequest {
    r.body = body
    return r
}

func (r ApiAuthMethodUpdateAwsIamRequest) Execute() (*AuthMethodUpdateOutput, *http.Response, error) {
	return r.ApiService.AuthMethodUpdateAwsIamExecute(r)
}

/*
AuthMethodUpdateAwsIam Method for AuthMethodUpdateAwsIam

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthMethodUpdateAwsIamRequest
*/
func (a *V2ApiService) AuthMethodUpdateAwsIam(ctx context.Context) ApiAuthMethodUpdateAwsIamRequest {
	return ApiAuthMethodUpdateAwsIamRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthMethodUpdateOutput
func (a *V2ApiService) AuthMethodUpdateAwsIamExecute(r ApiAuthMethodUpdateAwsIamRequest) (*AuthMethodUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthMethodUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AuthMethodUpdateAwsIam")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth-method-update-aws-iam"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthMethodUpdateAzureADRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	authMethodUpdateAzureAD *AuthMethodUpdateAzureAD
    body interface{}
}

func (r ApiAuthMethodUpdateAzureADRequest) AuthMethodUpdateAzureAD(authMethodUpdateAzureAD AuthMethodUpdateAzureAD) ApiAuthMethodUpdateAzureADRequest {
	r.authMethodUpdateAzureAD = &authMethodUpdateAzureAD
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAuthMethodUpdateAzureADRequest) Body(body AuthMethodUpdateAzureAD) ApiAuthMethodUpdateAzureADRequest {
    r.body = body
    return r
}

func (r ApiAuthMethodUpdateAzureADRequest) Execute() (*AuthMethodUpdateOutput, *http.Response, error) {
	return r.ApiService.AuthMethodUpdateAzureADExecute(r)
}

/*
AuthMethodUpdateAzureAD Method for AuthMethodUpdateAzureAD

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthMethodUpdateAzureADRequest
*/
func (a *V2ApiService) AuthMethodUpdateAzureAD(ctx context.Context) ApiAuthMethodUpdateAzureADRequest {
	return ApiAuthMethodUpdateAzureADRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthMethodUpdateOutput
func (a *V2ApiService) AuthMethodUpdateAzureADExecute(r ApiAuthMethodUpdateAzureADRequest) (*AuthMethodUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthMethodUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AuthMethodUpdateAzureAD")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth-method-update-azure-ad"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthMethodUpdateCertRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	authMethodUpdateCert *AuthMethodUpdateCert
    body interface{}
}

func (r ApiAuthMethodUpdateCertRequest) AuthMethodUpdateCert(authMethodUpdateCert AuthMethodUpdateCert) ApiAuthMethodUpdateCertRequest {
	r.authMethodUpdateCert = &authMethodUpdateCert
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAuthMethodUpdateCertRequest) Body(body AuthMethodUpdateCert) ApiAuthMethodUpdateCertRequest {
    r.body = body
    return r
}

func (r ApiAuthMethodUpdateCertRequest) Execute() (*AuthMethodUpdateOutput, *http.Response, error) {
	return r.ApiService.AuthMethodUpdateCertExecute(r)
}

/*
AuthMethodUpdateCert Method for AuthMethodUpdateCert

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthMethodUpdateCertRequest
*/
func (a *V2ApiService) AuthMethodUpdateCert(ctx context.Context) ApiAuthMethodUpdateCertRequest {
	return ApiAuthMethodUpdateCertRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthMethodUpdateOutput
func (a *V2ApiService) AuthMethodUpdateCertExecute(r ApiAuthMethodUpdateCertRequest) (*AuthMethodUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthMethodUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AuthMethodUpdateCert")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth-method-update-cert"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthMethodUpdateEmailRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	authMethodUpdateEmail *AuthMethodUpdateEmail
    body interface{}
}

func (r ApiAuthMethodUpdateEmailRequest) AuthMethodUpdateEmail(authMethodUpdateEmail AuthMethodUpdateEmail) ApiAuthMethodUpdateEmailRequest {
	r.authMethodUpdateEmail = &authMethodUpdateEmail
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAuthMethodUpdateEmailRequest) Body(body AuthMethodUpdateEmail) ApiAuthMethodUpdateEmailRequest {
    r.body = body
    return r
}

func (r ApiAuthMethodUpdateEmailRequest) Execute() (*AuthMethodUpdateOutput, *http.Response, error) {
	return r.ApiService.AuthMethodUpdateEmailExecute(r)
}

/*
AuthMethodUpdateEmail Method for AuthMethodUpdateEmail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthMethodUpdateEmailRequest
*/
func (a *V2ApiService) AuthMethodUpdateEmail(ctx context.Context) ApiAuthMethodUpdateEmailRequest {
	return ApiAuthMethodUpdateEmailRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthMethodUpdateOutput
func (a *V2ApiService) AuthMethodUpdateEmailExecute(r ApiAuthMethodUpdateEmailRequest) (*AuthMethodUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthMethodUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AuthMethodUpdateEmail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth-method-update-email"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthMethodUpdateGcpRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	authMethodUpdateGcp *AuthMethodUpdateGcp
    body interface{}
}

func (r ApiAuthMethodUpdateGcpRequest) AuthMethodUpdateGcp(authMethodUpdateGcp AuthMethodUpdateGcp) ApiAuthMethodUpdateGcpRequest {
	r.authMethodUpdateGcp = &authMethodUpdateGcp
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAuthMethodUpdateGcpRequest) Body(body AuthMethodUpdateGcp) ApiAuthMethodUpdateGcpRequest {
    r.body = body
    return r
}

func (r ApiAuthMethodUpdateGcpRequest) Execute() (*AuthMethodUpdateOutput, *http.Response, error) {
	return r.ApiService.AuthMethodUpdateGcpExecute(r)
}

/*
AuthMethodUpdateGcp Method for AuthMethodUpdateGcp

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthMethodUpdateGcpRequest
*/
func (a *V2ApiService) AuthMethodUpdateGcp(ctx context.Context) ApiAuthMethodUpdateGcpRequest {
	return ApiAuthMethodUpdateGcpRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthMethodUpdateOutput
func (a *V2ApiService) AuthMethodUpdateGcpExecute(r ApiAuthMethodUpdateGcpRequest) (*AuthMethodUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthMethodUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AuthMethodUpdateGcp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth-method-update-gcp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthMethodUpdateK8sRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	authMethodUpdateK8s *AuthMethodUpdateK8s
    body interface{}
}

func (r ApiAuthMethodUpdateK8sRequest) AuthMethodUpdateK8s(authMethodUpdateK8s AuthMethodUpdateK8s) ApiAuthMethodUpdateK8sRequest {
	r.authMethodUpdateK8s = &authMethodUpdateK8s
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAuthMethodUpdateK8sRequest) Body(body AuthMethodUpdateK8s) ApiAuthMethodUpdateK8sRequest {
    r.body = body
    return r
}

func (r ApiAuthMethodUpdateK8sRequest) Execute() (*AuthMethodUpdateOutput, *http.Response, error) {
	return r.ApiService.AuthMethodUpdateK8sExecute(r)
}

/*
AuthMethodUpdateK8s Method for AuthMethodUpdateK8s

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthMethodUpdateK8sRequest
*/
func (a *V2ApiService) AuthMethodUpdateK8s(ctx context.Context) ApiAuthMethodUpdateK8sRequest {
	return ApiAuthMethodUpdateK8sRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthMethodUpdateOutput
func (a *V2ApiService) AuthMethodUpdateK8sExecute(r ApiAuthMethodUpdateK8sRequest) (*AuthMethodUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthMethodUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AuthMethodUpdateK8s")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth-method-update-k8s"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthMethodUpdateKerberosRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	authMethodUpdateKerberos *AuthMethodUpdateKerberos
    body interface{}
}

func (r ApiAuthMethodUpdateKerberosRequest) AuthMethodUpdateKerberos(authMethodUpdateKerberos AuthMethodUpdateKerberos) ApiAuthMethodUpdateKerberosRequest {
	r.authMethodUpdateKerberos = &authMethodUpdateKerberos
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAuthMethodUpdateKerberosRequest) Body(body AuthMethodUpdateKerberos) ApiAuthMethodUpdateKerberosRequest {
    r.body = body
    return r
}

func (r ApiAuthMethodUpdateKerberosRequest) Execute() (*AuthMethodCreateOutput, *http.Response, error) {
	return r.ApiService.AuthMethodUpdateKerberosExecute(r)
}

/*
AuthMethodUpdateKerberos Method for AuthMethodUpdateKerberos

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthMethodUpdateKerberosRequest
*/
func (a *V2ApiService) AuthMethodUpdateKerberos(ctx context.Context) ApiAuthMethodUpdateKerberosRequest {
	return ApiAuthMethodUpdateKerberosRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthMethodCreateOutput
func (a *V2ApiService) AuthMethodUpdateKerberosExecute(r ApiAuthMethodUpdateKerberosRequest) (*AuthMethodCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthMethodCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AuthMethodUpdateKerberos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth-method-update-kerberos"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthMethodUpdateLdapRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	authMethodUpdateLdap *AuthMethodUpdateLdap
    body interface{}
}

func (r ApiAuthMethodUpdateLdapRequest) AuthMethodUpdateLdap(authMethodUpdateLdap AuthMethodUpdateLdap) ApiAuthMethodUpdateLdapRequest {
	r.authMethodUpdateLdap = &authMethodUpdateLdap
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAuthMethodUpdateLdapRequest) Body(body AuthMethodUpdateLdap) ApiAuthMethodUpdateLdapRequest {
    r.body = body
    return r
}

func (r ApiAuthMethodUpdateLdapRequest) Execute() (*AuthMethodUpdateOutput, *http.Response, error) {
	return r.ApiService.AuthMethodUpdateLdapExecute(r)
}

/*
AuthMethodUpdateLdap Method for AuthMethodUpdateLdap

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthMethodUpdateLdapRequest
*/
func (a *V2ApiService) AuthMethodUpdateLdap(ctx context.Context) ApiAuthMethodUpdateLdapRequest {
	return ApiAuthMethodUpdateLdapRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthMethodUpdateOutput
func (a *V2ApiService) AuthMethodUpdateLdapExecute(r ApiAuthMethodUpdateLdapRequest) (*AuthMethodUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthMethodUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AuthMethodUpdateLdap")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth-method-update-ldap"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthMethodUpdateOCIRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	authMethodUpdateOCI *AuthMethodUpdateOCI
    body interface{}
}

func (r ApiAuthMethodUpdateOCIRequest) AuthMethodUpdateOCI(authMethodUpdateOCI AuthMethodUpdateOCI) ApiAuthMethodUpdateOCIRequest {
	r.authMethodUpdateOCI = &authMethodUpdateOCI
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAuthMethodUpdateOCIRequest) Body(body AuthMethodUpdateOCI) ApiAuthMethodUpdateOCIRequest {
    r.body = body
    return r
}

func (r ApiAuthMethodUpdateOCIRequest) Execute() (*AuthMethodUpdateOutput, *http.Response, error) {
	return r.ApiService.AuthMethodUpdateOCIExecute(r)
}

/*
AuthMethodUpdateOCI Method for AuthMethodUpdateOCI

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthMethodUpdateOCIRequest
*/
func (a *V2ApiService) AuthMethodUpdateOCI(ctx context.Context) ApiAuthMethodUpdateOCIRequest {
	return ApiAuthMethodUpdateOCIRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthMethodUpdateOutput
func (a *V2ApiService) AuthMethodUpdateOCIExecute(r ApiAuthMethodUpdateOCIRequest) (*AuthMethodUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthMethodUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AuthMethodUpdateOCI")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth-method-update-oci"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthMethodUpdateOIDCRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	authMethodUpdateOIDC *AuthMethodUpdateOIDC
    body interface{}
}

func (r ApiAuthMethodUpdateOIDCRequest) AuthMethodUpdateOIDC(authMethodUpdateOIDC AuthMethodUpdateOIDC) ApiAuthMethodUpdateOIDCRequest {
	r.authMethodUpdateOIDC = &authMethodUpdateOIDC
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAuthMethodUpdateOIDCRequest) Body(body AuthMethodUpdateOIDC) ApiAuthMethodUpdateOIDCRequest {
    r.body = body
    return r
}

func (r ApiAuthMethodUpdateOIDCRequest) Execute() (*AuthMethodUpdateOutput, *http.Response, error) {
	return r.ApiService.AuthMethodUpdateOIDCExecute(r)
}

/*
AuthMethodUpdateOIDC Method for AuthMethodUpdateOIDC

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthMethodUpdateOIDCRequest
*/
func (a *V2ApiService) AuthMethodUpdateOIDC(ctx context.Context) ApiAuthMethodUpdateOIDCRequest {
	return ApiAuthMethodUpdateOIDCRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthMethodUpdateOutput
func (a *V2ApiService) AuthMethodUpdateOIDCExecute(r ApiAuthMethodUpdateOIDCRequest) (*AuthMethodUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthMethodUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AuthMethodUpdateOIDC")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth-method-update-oidc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthMethodUpdateOauth2Request struct {
	ctx context.Context
	ApiService *V2ApiService
	authMethodUpdateOauth2 *AuthMethodUpdateOauth2
    body interface{}
}

func (r ApiAuthMethodUpdateOauth2Request) AuthMethodUpdateOauth2(authMethodUpdateOauth2 AuthMethodUpdateOauth2) ApiAuthMethodUpdateOauth2Request {
	r.authMethodUpdateOauth2 = &authMethodUpdateOauth2
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAuthMethodUpdateOauth2Request) Body(body AuthMethodUpdateOauth2) ApiAuthMethodUpdateOauth2Request {
    r.body = body
    return r
}

func (r ApiAuthMethodUpdateOauth2Request) Execute() (*AuthMethodUpdateOutput, *http.Response, error) {
	return r.ApiService.AuthMethodUpdateOauth2Execute(r)
}

/*
AuthMethodUpdateOauth2 Method for AuthMethodUpdateOauth2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthMethodUpdateOauth2Request
*/
func (a *V2ApiService) AuthMethodUpdateOauth2(ctx context.Context) ApiAuthMethodUpdateOauth2Request {
	return ApiAuthMethodUpdateOauth2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthMethodUpdateOutput
func (a *V2ApiService) AuthMethodUpdateOauth2Execute(r ApiAuthMethodUpdateOauth2Request) (*AuthMethodUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthMethodUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AuthMethodUpdateOauth2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth-method-update-oauth2"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthMethodUpdateSAMLRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	authMethodUpdateSAML *AuthMethodUpdateSAML
    body interface{}
}

func (r ApiAuthMethodUpdateSAMLRequest) AuthMethodUpdateSAML(authMethodUpdateSAML AuthMethodUpdateSAML) ApiAuthMethodUpdateSAMLRequest {
	r.authMethodUpdateSAML = &authMethodUpdateSAML
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAuthMethodUpdateSAMLRequest) Body(body AuthMethodUpdateSAML) ApiAuthMethodUpdateSAMLRequest {
    r.body = body
    return r
}

func (r ApiAuthMethodUpdateSAMLRequest) Execute() (*AuthMethodUpdateOutput, *http.Response, error) {
	return r.ApiService.AuthMethodUpdateSAMLExecute(r)
}

/*
AuthMethodUpdateSAML Method for AuthMethodUpdateSAML

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthMethodUpdateSAMLRequest
*/
func (a *V2ApiService) AuthMethodUpdateSAML(ctx context.Context) ApiAuthMethodUpdateSAMLRequest {
	return ApiAuthMethodUpdateSAMLRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthMethodUpdateOutput
func (a *V2ApiService) AuthMethodUpdateSAMLExecute(r ApiAuthMethodUpdateSAMLRequest) (*AuthMethodUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthMethodUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AuthMethodUpdateSAML")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth-method-update-saml"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthMethodUpdateUniversalIdentityRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	authMethodUpdateUniversalIdentity *AuthMethodUpdateUniversalIdentity
    body interface{}
}

func (r ApiAuthMethodUpdateUniversalIdentityRequest) AuthMethodUpdateUniversalIdentity(authMethodUpdateUniversalIdentity AuthMethodUpdateUniversalIdentity) ApiAuthMethodUpdateUniversalIdentityRequest {
	r.authMethodUpdateUniversalIdentity = &authMethodUpdateUniversalIdentity
	return r
}


    // Body sets the body payload for the API call.
func (r ApiAuthMethodUpdateUniversalIdentityRequest) Body(body AuthMethodUpdateUniversalIdentity) ApiAuthMethodUpdateUniversalIdentityRequest {
    r.body = body
    return r
}

func (r ApiAuthMethodUpdateUniversalIdentityRequest) Execute() (*AuthMethodUpdateOutput, *http.Response, error) {
	return r.ApiService.AuthMethodUpdateUniversalIdentityExecute(r)
}

/*
AuthMethodUpdateUniversalIdentity Method for AuthMethodUpdateUniversalIdentity

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthMethodUpdateUniversalIdentityRequest
*/
func (a *V2ApiService) AuthMethodUpdateUniversalIdentity(ctx context.Context) ApiAuthMethodUpdateUniversalIdentityRequest {
	return ApiAuthMethodUpdateUniversalIdentityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthMethodUpdateOutput
func (a *V2ApiService) AuthMethodUpdateUniversalIdentityExecute(r ApiAuthMethodUpdateUniversalIdentityRequest) (*AuthMethodUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthMethodUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.AuthMethodUpdateUniversalIdentity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth-method-update-universal-identity"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCalcPasswordSecurityInfoRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	calcPasswordSecurityInfo *CalcPasswordSecurityInfo
    body interface{}
}

func (r ApiCalcPasswordSecurityInfoRequest) CalcPasswordSecurityInfo(calcPasswordSecurityInfo CalcPasswordSecurityInfo) ApiCalcPasswordSecurityInfoRequest {
	r.calcPasswordSecurityInfo = &calcPasswordSecurityInfo
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCalcPasswordSecurityInfoRequest) Body(body CalcPasswordSecurityInfo) ApiCalcPasswordSecurityInfoRequest {
    r.body = body
    return r
}

func (r ApiCalcPasswordSecurityInfoRequest) Execute() (*PasswordSecurityInfo, *http.Response, error) {
	return r.ApiService.CalcPasswordSecurityInfoExecute(r)
}

/*
CalcPasswordSecurityInfo Method for CalcPasswordSecurityInfo

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCalcPasswordSecurityInfoRequest
*/
func (a *V2ApiService) CalcPasswordSecurityInfo(ctx context.Context) ApiCalcPasswordSecurityInfoRequest {
	return ApiCalcPasswordSecurityInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PasswordSecurityInfo
func (a *V2ApiService) CalcPasswordSecurityInfoExecute(r ApiCalcPasswordSecurityInfoRequest) (*PasswordSecurityInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PasswordSecurityInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CalcPasswordSecurityInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calc-password-security-info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChangeAdminAccountPasswordRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	changeAdminAccountPassword *ChangeAdminAccountPassword
    body interface{}
}

func (r ApiChangeAdminAccountPasswordRequest) ChangeAdminAccountPassword(changeAdminAccountPassword ChangeAdminAccountPassword) ApiChangeAdminAccountPasswordRequest {
	r.changeAdminAccountPassword = &changeAdminAccountPassword
	return r
}


    // Body sets the body payload for the API call.
func (r ApiChangeAdminAccountPasswordRequest) Body(body ChangeAdminAccountPassword) ApiChangeAdminAccountPasswordRequest {
    r.body = body
    return r
}

func (r ApiChangeAdminAccountPasswordRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.ChangeAdminAccountPasswordExecute(r)
}

/*
ChangeAdminAccountPassword Method for ChangeAdminAccountPassword

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiChangeAdminAccountPasswordRequest
*/
func (a *V2ApiService) ChangeAdminAccountPassword(ctx context.Context) ApiChangeAdminAccountPasswordRequest {
	return ApiChangeAdminAccountPasswordRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *V2ApiService) ChangeAdminAccountPasswordExecute(r ApiChangeAdminAccountPasswordRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.ChangeAdminAccountPassword")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/change-admin-account-password"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConfigureRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	configure *Configure
    body interface{}
}

func (r ApiConfigureRequest) Configure(configure Configure) ApiConfigureRequest {
	r.configure = &configure
	return r
}


    // Body sets the body payload for the API call.
func (r ApiConfigureRequest) Body(body Configure) ApiConfigureRequest {
    r.body = body
    return r
}

func (r ApiConfigureRequest) Execute() (*ConfigureOutput, *http.Response, error) {
	return r.ApiService.ConfigureExecute(r)
}

/*
Configure Method for Configure

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConfigureRequest
*/
func (a *V2ApiService) Configure(ctx context.Context) ApiConfigureRequest {
	return ApiConfigureRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConfigureOutput
func (a *V2ApiService) ConfigureExecute(r ApiConfigureRequest) (*ConfigureOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConfigureOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.Configure")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/configure"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	connect *Connect
    body interface{}
}

func (r ApiConnectRequest) Connect(connect Connect) ApiConnectRequest {
	r.connect = &connect
	return r
}


    // Body sets the body payload for the API call.
func (r ApiConnectRequest) Body(body Connect) ApiConnectRequest {
    r.body = body
    return r
}

func (r ApiConnectRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ConnectExecute(r)
}

/*
Connect Method for Connect

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConnectRequest
*/
func (a *V2ApiService) Connect(ctx context.Context) ApiConnectRequest {
	return ApiConnectRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) ConnectExecute(r ApiConnectRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.Connect")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connect"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAWSTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createAWSTarget *CreateAWSTarget
    body interface{}
}

func (r ApiCreateAWSTargetRequest) CreateAWSTarget(createAWSTarget CreateAWSTarget) ApiCreateAWSTargetRequest {
	r.createAWSTarget = &createAWSTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateAWSTargetRequest) Body(body CreateAWSTarget) ApiCreateAWSTargetRequest {
    r.body = body
    return r
}

func (r ApiCreateAWSTargetRequest) Execute() (*CreateAWSTargetOutput, *http.Response, error) {
	return r.ApiService.CreateAWSTargetExecute(r)
}

/*
CreateAWSTarget Method for CreateAWSTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAWSTargetRequest
*/
func (a *V2ApiService) CreateAWSTarget(ctx context.Context) ApiCreateAWSTargetRequest {
	return ApiCreateAWSTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAWSTargetOutput
func (a *V2ApiService) CreateAWSTargetExecute(r ApiCreateAWSTargetRequest) (*CreateAWSTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAWSTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateAWSTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-aws-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateArtifactoryTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createArtifactoryTarget *CreateArtifactoryTarget
    body interface{}
}

func (r ApiCreateArtifactoryTargetRequest) CreateArtifactoryTarget(createArtifactoryTarget CreateArtifactoryTarget) ApiCreateArtifactoryTargetRequest {
	r.createArtifactoryTarget = &createArtifactoryTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateArtifactoryTargetRequest) Body(body CreateArtifactoryTarget) ApiCreateArtifactoryTargetRequest {
    r.body = body
    return r
}

func (r ApiCreateArtifactoryTargetRequest) Execute() (*CreateArtifactoryTargetOutput, *http.Response, error) {
	return r.ApiService.CreateArtifactoryTargetExecute(r)
}

/*
CreateArtifactoryTarget Method for CreateArtifactoryTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateArtifactoryTargetRequest
*/
func (a *V2ApiService) CreateArtifactoryTarget(ctx context.Context) ApiCreateArtifactoryTargetRequest {
	return ApiCreateArtifactoryTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateArtifactoryTargetOutput
func (a *V2ApiService) CreateArtifactoryTargetExecute(r ApiCreateArtifactoryTargetRequest) (*CreateArtifactoryTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateArtifactoryTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateArtifactoryTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-artifactory-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAuthMethodRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createAuthMethod *CreateAuthMethod
    body interface{}
}

func (r ApiCreateAuthMethodRequest) CreateAuthMethod(createAuthMethod CreateAuthMethod) ApiCreateAuthMethodRequest {
	r.createAuthMethod = &createAuthMethod
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateAuthMethodRequest) Body(body CreateAuthMethod) ApiCreateAuthMethodRequest {
    r.body = body
    return r
}

func (r ApiCreateAuthMethodRequest) Execute() (*CreateAuthMethodOutput, *http.Response, error) {
	return r.ApiService.CreateAuthMethodExecute(r)
}

/*
CreateAuthMethod Method for CreateAuthMethod

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAuthMethodRequest
*/
func (a *V2ApiService) CreateAuthMethod(ctx context.Context) ApiCreateAuthMethodRequest {
	return ApiCreateAuthMethodRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAuthMethodOutput
func (a *V2ApiService) CreateAuthMethodExecute(r ApiCreateAuthMethodRequest) (*CreateAuthMethodOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAuthMethodOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateAuthMethod")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-auth-method"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAuthMethodAWSIAMRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createAuthMethodAWSIAM *CreateAuthMethodAWSIAM
    body interface{}
}

func (r ApiCreateAuthMethodAWSIAMRequest) CreateAuthMethodAWSIAM(createAuthMethodAWSIAM CreateAuthMethodAWSIAM) ApiCreateAuthMethodAWSIAMRequest {
	r.createAuthMethodAWSIAM = &createAuthMethodAWSIAM
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateAuthMethodAWSIAMRequest) Body(body CreateAuthMethodAWSIAM) ApiCreateAuthMethodAWSIAMRequest {
    r.body = body
    return r
}

func (r ApiCreateAuthMethodAWSIAMRequest) Execute() (*CreateAuthMethodAWSIAMOutput, *http.Response, error) {
	return r.ApiService.CreateAuthMethodAWSIAMExecute(r)
}

/*
CreateAuthMethodAWSIAM Method for CreateAuthMethodAWSIAM

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAuthMethodAWSIAMRequest
*/
func (a *V2ApiService) CreateAuthMethodAWSIAM(ctx context.Context) ApiCreateAuthMethodAWSIAMRequest {
	return ApiCreateAuthMethodAWSIAMRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAuthMethodAWSIAMOutput
func (a *V2ApiService) CreateAuthMethodAWSIAMExecute(r ApiCreateAuthMethodAWSIAMRequest) (*CreateAuthMethodAWSIAMOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAuthMethodAWSIAMOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateAuthMethodAWSIAM")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-auth-method-aws-iam"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAuthMethodAzureADRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createAuthMethodAzureAD *CreateAuthMethodAzureAD
    body interface{}
}

func (r ApiCreateAuthMethodAzureADRequest) CreateAuthMethodAzureAD(createAuthMethodAzureAD CreateAuthMethodAzureAD) ApiCreateAuthMethodAzureADRequest {
	r.createAuthMethodAzureAD = &createAuthMethodAzureAD
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateAuthMethodAzureADRequest) Body(body CreateAuthMethodAzureAD) ApiCreateAuthMethodAzureADRequest {
    r.body = body
    return r
}

func (r ApiCreateAuthMethodAzureADRequest) Execute() (*CreateAuthMethodAzureADOutput, *http.Response, error) {
	return r.ApiService.CreateAuthMethodAzureADExecute(r)
}

/*
CreateAuthMethodAzureAD Method for CreateAuthMethodAzureAD

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAuthMethodAzureADRequest
*/
func (a *V2ApiService) CreateAuthMethodAzureAD(ctx context.Context) ApiCreateAuthMethodAzureADRequest {
	return ApiCreateAuthMethodAzureADRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAuthMethodAzureADOutput
func (a *V2ApiService) CreateAuthMethodAzureADExecute(r ApiCreateAuthMethodAzureADRequest) (*CreateAuthMethodAzureADOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAuthMethodAzureADOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateAuthMethodAzureAD")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-auth-method-azure-ad"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAuthMethodCertRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createAuthMethodCert *CreateAuthMethodCert
    body interface{}
}

func (r ApiCreateAuthMethodCertRequest) CreateAuthMethodCert(createAuthMethodCert CreateAuthMethodCert) ApiCreateAuthMethodCertRequest {
	r.createAuthMethodCert = &createAuthMethodCert
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateAuthMethodCertRequest) Body(body CreateAuthMethodCert) ApiCreateAuthMethodCertRequest {
    r.body = body
    return r
}

func (r ApiCreateAuthMethodCertRequest) Execute() (*CreateAuthMethodCertOutput, *http.Response, error) {
	return r.ApiService.CreateAuthMethodCertExecute(r)
}

/*
CreateAuthMethodCert Method for CreateAuthMethodCert

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAuthMethodCertRequest
*/
func (a *V2ApiService) CreateAuthMethodCert(ctx context.Context) ApiCreateAuthMethodCertRequest {
	return ApiCreateAuthMethodCertRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAuthMethodCertOutput
func (a *V2ApiService) CreateAuthMethodCertExecute(r ApiCreateAuthMethodCertRequest) (*CreateAuthMethodCertOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAuthMethodCertOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateAuthMethodCert")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-auth-method-cert"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAuthMethodEmailRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createAuthMethodEmail *CreateAuthMethodEmail
    body interface{}
}

func (r ApiCreateAuthMethodEmailRequest) CreateAuthMethodEmail(createAuthMethodEmail CreateAuthMethodEmail) ApiCreateAuthMethodEmailRequest {
	r.createAuthMethodEmail = &createAuthMethodEmail
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateAuthMethodEmailRequest) Body(body CreateAuthMethodEmail) ApiCreateAuthMethodEmailRequest {
    r.body = body
    return r
}

func (r ApiCreateAuthMethodEmailRequest) Execute() (*CreateAuthMethodEmailOutput, *http.Response, error) {
	return r.ApiService.CreateAuthMethodEmailExecute(r)
}

/*
CreateAuthMethodEmail Method for CreateAuthMethodEmail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAuthMethodEmailRequest
*/
func (a *V2ApiService) CreateAuthMethodEmail(ctx context.Context) ApiCreateAuthMethodEmailRequest {
	return ApiCreateAuthMethodEmailRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAuthMethodEmailOutput
func (a *V2ApiService) CreateAuthMethodEmailExecute(r ApiCreateAuthMethodEmailRequest) (*CreateAuthMethodEmailOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAuthMethodEmailOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateAuthMethodEmail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-auth-method-email"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAuthMethodGCPRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createAuthMethodGCP *CreateAuthMethodGCP
    body interface{}
}

func (r ApiCreateAuthMethodGCPRequest) CreateAuthMethodGCP(createAuthMethodGCP CreateAuthMethodGCP) ApiCreateAuthMethodGCPRequest {
	r.createAuthMethodGCP = &createAuthMethodGCP
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateAuthMethodGCPRequest) Body(body CreateAuthMethodGCP) ApiCreateAuthMethodGCPRequest {
    r.body = body
    return r
}

func (r ApiCreateAuthMethodGCPRequest) Execute() (*CreateAuthMethodGCPOutput, *http.Response, error) {
	return r.ApiService.CreateAuthMethodGCPExecute(r)
}

/*
CreateAuthMethodGCP Method for CreateAuthMethodGCP

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAuthMethodGCPRequest
*/
func (a *V2ApiService) CreateAuthMethodGCP(ctx context.Context) ApiCreateAuthMethodGCPRequest {
	return ApiCreateAuthMethodGCPRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAuthMethodGCPOutput
func (a *V2ApiService) CreateAuthMethodGCPExecute(r ApiCreateAuthMethodGCPRequest) (*CreateAuthMethodGCPOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAuthMethodGCPOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateAuthMethodGCP")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-auth-method-gcp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAuthMethodHuaweiRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createAuthMethodHuawei *CreateAuthMethodHuawei
    body interface{}
}

func (r ApiCreateAuthMethodHuaweiRequest) CreateAuthMethodHuawei(createAuthMethodHuawei CreateAuthMethodHuawei) ApiCreateAuthMethodHuaweiRequest {
	r.createAuthMethodHuawei = &createAuthMethodHuawei
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateAuthMethodHuaweiRequest) Body(body CreateAuthMethodHuawei) ApiCreateAuthMethodHuaweiRequest {
    r.body = body
    return r
}

func (r ApiCreateAuthMethodHuaweiRequest) Execute() (*CreateAuthMethodHuaweiOutput, *http.Response, error) {
	return r.ApiService.CreateAuthMethodHuaweiExecute(r)
}

/*
CreateAuthMethodHuawei Method for CreateAuthMethodHuawei

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAuthMethodHuaweiRequest
*/
func (a *V2ApiService) CreateAuthMethodHuawei(ctx context.Context) ApiCreateAuthMethodHuaweiRequest {
	return ApiCreateAuthMethodHuaweiRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAuthMethodHuaweiOutput
func (a *V2ApiService) CreateAuthMethodHuaweiExecute(r ApiCreateAuthMethodHuaweiRequest) (*CreateAuthMethodHuaweiOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAuthMethodHuaweiOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateAuthMethodHuawei")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-auth-method-huawei"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAuthMethodK8SRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createAuthMethodK8S *CreateAuthMethodK8S
    body interface{}
}

func (r ApiCreateAuthMethodK8SRequest) CreateAuthMethodK8S(createAuthMethodK8S CreateAuthMethodK8S) ApiCreateAuthMethodK8SRequest {
	r.createAuthMethodK8S = &createAuthMethodK8S
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateAuthMethodK8SRequest) Body(body CreateAuthMethodK8S) ApiCreateAuthMethodK8SRequest {
    r.body = body
    return r
}

func (r ApiCreateAuthMethodK8SRequest) Execute() (*CreateAuthMethodK8SOutput, *http.Response, error) {
	return r.ApiService.CreateAuthMethodK8SExecute(r)
}

/*
CreateAuthMethodK8S Method for CreateAuthMethodK8S

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAuthMethodK8SRequest
*/
func (a *V2ApiService) CreateAuthMethodK8S(ctx context.Context) ApiCreateAuthMethodK8SRequest {
	return ApiCreateAuthMethodK8SRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAuthMethodK8SOutput
func (a *V2ApiService) CreateAuthMethodK8SExecute(r ApiCreateAuthMethodK8SRequest) (*CreateAuthMethodK8SOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAuthMethodK8SOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateAuthMethodK8S")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-auth-method-k8s"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAuthMethodLDAPRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createAuthMethodLDAP *CreateAuthMethodLDAP
    body interface{}
}

func (r ApiCreateAuthMethodLDAPRequest) CreateAuthMethodLDAP(createAuthMethodLDAP CreateAuthMethodLDAP) ApiCreateAuthMethodLDAPRequest {
	r.createAuthMethodLDAP = &createAuthMethodLDAP
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateAuthMethodLDAPRequest) Body(body CreateAuthMethodLDAP) ApiCreateAuthMethodLDAPRequest {
    r.body = body
    return r
}

func (r ApiCreateAuthMethodLDAPRequest) Execute() (*CreateAuthMethodLDAPOutput, *http.Response, error) {
	return r.ApiService.CreateAuthMethodLDAPExecute(r)
}

/*
CreateAuthMethodLDAP Method for CreateAuthMethodLDAP

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAuthMethodLDAPRequest
*/
func (a *V2ApiService) CreateAuthMethodLDAP(ctx context.Context) ApiCreateAuthMethodLDAPRequest {
	return ApiCreateAuthMethodLDAPRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAuthMethodLDAPOutput
func (a *V2ApiService) CreateAuthMethodLDAPExecute(r ApiCreateAuthMethodLDAPRequest) (*CreateAuthMethodLDAPOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAuthMethodLDAPOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateAuthMethodLDAP")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-auth-method-ldap"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAuthMethodOAuth2Request struct {
	ctx context.Context
	ApiService *V2ApiService
	createAuthMethodOAuth2 *CreateAuthMethodOAuth2
    body interface{}
}

func (r ApiCreateAuthMethodOAuth2Request) CreateAuthMethodOAuth2(createAuthMethodOAuth2 CreateAuthMethodOAuth2) ApiCreateAuthMethodOAuth2Request {
	r.createAuthMethodOAuth2 = &createAuthMethodOAuth2
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateAuthMethodOAuth2Request) Body(body CreateAuthMethodOAuth2) ApiCreateAuthMethodOAuth2Request {
    r.body = body
    return r
}

func (r ApiCreateAuthMethodOAuth2Request) Execute() (*CreateAuthMethodOAuth2Output, *http.Response, error) {
	return r.ApiService.CreateAuthMethodOAuth2Execute(r)
}

/*
CreateAuthMethodOAuth2 Method for CreateAuthMethodOAuth2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAuthMethodOAuth2Request
*/
func (a *V2ApiService) CreateAuthMethodOAuth2(ctx context.Context) ApiCreateAuthMethodOAuth2Request {
	return ApiCreateAuthMethodOAuth2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAuthMethodOAuth2Output
func (a *V2ApiService) CreateAuthMethodOAuth2Execute(r ApiCreateAuthMethodOAuth2Request) (*CreateAuthMethodOAuth2Output, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAuthMethodOAuth2Output
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateAuthMethodOAuth2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-auth-method-oauth2"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAuthMethodOCIRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createAuthMethodOCI *CreateAuthMethodOCI
    body interface{}
}

func (r ApiCreateAuthMethodOCIRequest) CreateAuthMethodOCI(createAuthMethodOCI CreateAuthMethodOCI) ApiCreateAuthMethodOCIRequest {
	r.createAuthMethodOCI = &createAuthMethodOCI
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateAuthMethodOCIRequest) Body(body CreateAuthMethodOCI) ApiCreateAuthMethodOCIRequest {
    r.body = body
    return r
}

func (r ApiCreateAuthMethodOCIRequest) Execute() (*CreateAuthMethodOCIOutput, *http.Response, error) {
	return r.ApiService.CreateAuthMethodOCIExecute(r)
}

/*
CreateAuthMethodOCI Method for CreateAuthMethodOCI

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAuthMethodOCIRequest
*/
func (a *V2ApiService) CreateAuthMethodOCI(ctx context.Context) ApiCreateAuthMethodOCIRequest {
	return ApiCreateAuthMethodOCIRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAuthMethodOCIOutput
func (a *V2ApiService) CreateAuthMethodOCIExecute(r ApiCreateAuthMethodOCIRequest) (*CreateAuthMethodOCIOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAuthMethodOCIOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateAuthMethodOCI")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-auth-method-oci"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAuthMethodOIDCRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createAuthMethodOIDC *CreateAuthMethodOIDC
    body interface{}
}

func (r ApiCreateAuthMethodOIDCRequest) CreateAuthMethodOIDC(createAuthMethodOIDC CreateAuthMethodOIDC) ApiCreateAuthMethodOIDCRequest {
	r.createAuthMethodOIDC = &createAuthMethodOIDC
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateAuthMethodOIDCRequest) Body(body CreateAuthMethodOIDC) ApiCreateAuthMethodOIDCRequest {
    r.body = body
    return r
}

func (r ApiCreateAuthMethodOIDCRequest) Execute() (*CreateAuthMethodOIDCOutput, *http.Response, error) {
	return r.ApiService.CreateAuthMethodOIDCExecute(r)
}

/*
CreateAuthMethodOIDC Method for CreateAuthMethodOIDC

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAuthMethodOIDCRequest
*/
func (a *V2ApiService) CreateAuthMethodOIDC(ctx context.Context) ApiCreateAuthMethodOIDCRequest {
	return ApiCreateAuthMethodOIDCRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAuthMethodOIDCOutput
func (a *V2ApiService) CreateAuthMethodOIDCExecute(r ApiCreateAuthMethodOIDCRequest) (*CreateAuthMethodOIDCOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAuthMethodOIDCOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateAuthMethodOIDC")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-auth-method-oidc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAuthMethodSAMLRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createAuthMethodSAML *CreateAuthMethodSAML
    body interface{}
}

func (r ApiCreateAuthMethodSAMLRequest) CreateAuthMethodSAML(createAuthMethodSAML CreateAuthMethodSAML) ApiCreateAuthMethodSAMLRequest {
	r.createAuthMethodSAML = &createAuthMethodSAML
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateAuthMethodSAMLRequest) Body(body CreateAuthMethodSAML) ApiCreateAuthMethodSAMLRequest {
    r.body = body
    return r
}

func (r ApiCreateAuthMethodSAMLRequest) Execute() (*CreateAuthMethodSAMLOutput, *http.Response, error) {
	return r.ApiService.CreateAuthMethodSAMLExecute(r)
}

/*
CreateAuthMethodSAML Method for CreateAuthMethodSAML

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAuthMethodSAMLRequest
*/
func (a *V2ApiService) CreateAuthMethodSAML(ctx context.Context) ApiCreateAuthMethodSAMLRequest {
	return ApiCreateAuthMethodSAMLRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAuthMethodSAMLOutput
func (a *V2ApiService) CreateAuthMethodSAMLExecute(r ApiCreateAuthMethodSAMLRequest) (*CreateAuthMethodSAMLOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAuthMethodSAMLOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateAuthMethodSAML")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-auth-method-saml"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAuthMethodUniversalIdentityRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createAuthMethodUniversalIdentity *CreateAuthMethodUniversalIdentity
    body interface{}
}

func (r ApiCreateAuthMethodUniversalIdentityRequest) CreateAuthMethodUniversalIdentity(createAuthMethodUniversalIdentity CreateAuthMethodUniversalIdentity) ApiCreateAuthMethodUniversalIdentityRequest {
	r.createAuthMethodUniversalIdentity = &createAuthMethodUniversalIdentity
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateAuthMethodUniversalIdentityRequest) Body(body CreateAuthMethodUniversalIdentity) ApiCreateAuthMethodUniversalIdentityRequest {
    r.body = body
    return r
}

func (r ApiCreateAuthMethodUniversalIdentityRequest) Execute() (*CreateAuthMethodUniversalIdentityOutput, *http.Response, error) {
	return r.ApiService.CreateAuthMethodUniversalIdentityExecute(r)
}

/*
CreateAuthMethodUniversalIdentity Method for CreateAuthMethodUniversalIdentity

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAuthMethodUniversalIdentityRequest
*/
func (a *V2ApiService) CreateAuthMethodUniversalIdentity(ctx context.Context) ApiCreateAuthMethodUniversalIdentityRequest {
	return ApiCreateAuthMethodUniversalIdentityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAuthMethodUniversalIdentityOutput
func (a *V2ApiService) CreateAuthMethodUniversalIdentityExecute(r ApiCreateAuthMethodUniversalIdentityRequest) (*CreateAuthMethodUniversalIdentityOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAuthMethodUniversalIdentityOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateAuthMethodUniversalIdentity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-auth-method-universal-identity"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAzureTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createAzureTarget *CreateAzureTarget
    body interface{}
}

func (r ApiCreateAzureTargetRequest) CreateAzureTarget(createAzureTarget CreateAzureTarget) ApiCreateAzureTargetRequest {
	r.createAzureTarget = &createAzureTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateAzureTargetRequest) Body(body CreateAzureTarget) ApiCreateAzureTargetRequest {
    r.body = body
    return r
}

func (r ApiCreateAzureTargetRequest) Execute() (*CreateAzureTargetOutput, *http.Response, error) {
	return r.ApiService.CreateAzureTargetExecute(r)
}

/*
CreateAzureTarget Method for CreateAzureTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAzureTargetRequest
*/
func (a *V2ApiService) CreateAzureTarget(ctx context.Context) ApiCreateAzureTargetRequest {
	return ApiCreateAzureTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAzureTargetOutput
func (a *V2ApiService) CreateAzureTargetExecute(r ApiCreateAzureTargetRequest) (*CreateAzureTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAzureTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateAzureTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-azure-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCertificateRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createCertificate *CreateCertificate
    body interface{}
}

func (r ApiCreateCertificateRequest) CreateCertificate(createCertificate CreateCertificate) ApiCreateCertificateRequest {
	r.createCertificate = &createCertificate
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateCertificateRequest) Body(body CreateCertificate) ApiCreateCertificateRequest {
    r.body = body
    return r
}

func (r ApiCreateCertificateRequest) Execute() (*CreateCertificateOutput, *http.Response, error) {
	return r.ApiService.CreateCertificateExecute(r)
}

/*
CreateCertificate Method for CreateCertificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCertificateRequest
*/
func (a *V2ApiService) CreateCertificate(ctx context.Context) ApiCreateCertificateRequest {
	return ApiCreateCertificateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateCertificateOutput
func (a *V2ApiService) CreateCertificateExecute(r ApiCreateCertificateRequest) (*CreateCertificateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateCertificateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateCertificate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-certificate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateClassicKeyRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createClassicKey *CreateClassicKey
    body interface{}
}

func (r ApiCreateClassicKeyRequest) CreateClassicKey(createClassicKey CreateClassicKey) ApiCreateClassicKeyRequest {
	r.createClassicKey = &createClassicKey
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateClassicKeyRequest) Body(body CreateClassicKey) ApiCreateClassicKeyRequest {
    r.body = body
    return r
}

func (r ApiCreateClassicKeyRequest) Execute() (*CreateClassicKeyOutput, *http.Response, error) {
	return r.ApiService.CreateClassicKeyExecute(r)
}

/*
CreateClassicKey Method for CreateClassicKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateClassicKeyRequest
*/
func (a *V2ApiService) CreateClassicKey(ctx context.Context) ApiCreateClassicKeyRequest {
	return ApiCreateClassicKeyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateClassicKeyOutput
func (a *V2ApiService) CreateClassicKeyExecute(r ApiCreateClassicKeyRequest) (*CreateClassicKeyOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateClassicKeyOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateClassicKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-classic-key"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateDBTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createDBTarget *CreateDBTarget
    body interface{}
}

func (r ApiCreateDBTargetRequest) CreateDBTarget(createDBTarget CreateDBTarget) ApiCreateDBTargetRequest {
	r.createDBTarget = &createDBTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateDBTargetRequest) Body(body CreateDBTarget) ApiCreateDBTargetRequest {
    r.body = body
    return r
}

func (r ApiCreateDBTargetRequest) Execute() (*CreateDBTargetOutput, *http.Response, error) {
	return r.ApiService.CreateDBTargetExecute(r)
}

/*
CreateDBTarget Method for CreateDBTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateDBTargetRequest
*/
func (a *V2ApiService) CreateDBTarget(ctx context.Context) ApiCreateDBTargetRequest {
	return ApiCreateDBTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateDBTargetOutput
func (a *V2ApiService) CreateDBTargetExecute(r ApiCreateDBTargetRequest) (*CreateDBTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateDBTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateDBTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-db-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateDFCKeyRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createDFCKey *CreateDFCKey
    body interface{}
}

func (r ApiCreateDFCKeyRequest) CreateDFCKey(createDFCKey CreateDFCKey) ApiCreateDFCKeyRequest {
	r.createDFCKey = &createDFCKey
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateDFCKeyRequest) Body(body CreateDFCKey) ApiCreateDFCKeyRequest {
    r.body = body
    return r
}

func (r ApiCreateDFCKeyRequest) Execute() (*CreateDFCKeyOutput, *http.Response, error) {
	return r.ApiService.CreateDFCKeyExecute(r)
}

/*
CreateDFCKey Method for CreateDFCKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateDFCKeyRequest
*/
func (a *V2ApiService) CreateDFCKey(ctx context.Context) ApiCreateDFCKeyRequest {
	return ApiCreateDFCKeyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateDFCKeyOutput
func (a *V2ApiService) CreateDFCKeyExecute(r ApiCreateDFCKeyRequest) (*CreateDFCKeyOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateDFCKeyOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateDFCKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-dfc-key"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateDockerhubTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createDockerhubTarget *CreateDockerhubTarget
    body interface{}
}

func (r ApiCreateDockerhubTargetRequest) CreateDockerhubTarget(createDockerhubTarget CreateDockerhubTarget) ApiCreateDockerhubTargetRequest {
	r.createDockerhubTarget = &createDockerhubTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateDockerhubTargetRequest) Body(body CreateDockerhubTarget) ApiCreateDockerhubTargetRequest {
    r.body = body
    return r
}

func (r ApiCreateDockerhubTargetRequest) Execute() (*CreateDockerhubTargetOutput, *http.Response, error) {
	return r.ApiService.CreateDockerhubTargetExecute(r)
}

/*
CreateDockerhubTarget Method for CreateDockerhubTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateDockerhubTargetRequest
*/
func (a *V2ApiService) CreateDockerhubTarget(ctx context.Context) ApiCreateDockerhubTargetRequest {
	return ApiCreateDockerhubTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateDockerhubTargetOutput
func (a *V2ApiService) CreateDockerhubTargetExecute(r ApiCreateDockerhubTargetRequest) (*CreateDockerhubTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateDockerhubTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateDockerhubTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-dockerhub-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateDynamicSecretRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createDynamicSecret *CreateDynamicSecret
    body interface{}
}

func (r ApiCreateDynamicSecretRequest) CreateDynamicSecret(createDynamicSecret CreateDynamicSecret) ApiCreateDynamicSecretRequest {
	r.createDynamicSecret = &createDynamicSecret
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateDynamicSecretRequest) Body(body CreateDynamicSecret) ApiCreateDynamicSecretRequest {
    r.body = body
    return r
}

func (r ApiCreateDynamicSecretRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateDynamicSecretExecute(r)
}

/*
CreateDynamicSecret Method for CreateDynamicSecret

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateDynamicSecretRequest
*/
func (a *V2ApiService) CreateDynamicSecret(ctx context.Context) ApiCreateDynamicSecretRequest {
	return ApiCreateDynamicSecretRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) CreateDynamicSecretExecute(r ApiCreateDynamicSecretRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateDynamicSecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-dynamic-secret"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateEKSTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createEKSTarget *CreateEKSTarget
    body interface{}
}

func (r ApiCreateEKSTargetRequest) CreateEKSTarget(createEKSTarget CreateEKSTarget) ApiCreateEKSTargetRequest {
	r.createEKSTarget = &createEKSTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateEKSTargetRequest) Body(body CreateEKSTarget) ApiCreateEKSTargetRequest {
    r.body = body
    return r
}

func (r ApiCreateEKSTargetRequest) Execute() (*CreateEKSTargetOutput, *http.Response, error) {
	return r.ApiService.CreateEKSTargetExecute(r)
}

/*
CreateEKSTarget Method for CreateEKSTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateEKSTargetRequest
*/
func (a *V2ApiService) CreateEKSTarget(ctx context.Context) ApiCreateEKSTargetRequest {
	return ApiCreateEKSTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateEKSTargetOutput
func (a *V2ApiService) CreateEKSTargetExecute(r ApiCreateEKSTargetRequest) (*CreateEKSTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateEKSTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateEKSTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-eks-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateESMRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createESM *CreateESM
    body interface{}
}

func (r ApiCreateESMRequest) CreateESM(createESM CreateESM) ApiCreateESMRequest {
	r.createESM = &createESM
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateESMRequest) Body(body CreateESM) ApiCreateESMRequest {
    r.body = body
    return r
}

func (r ApiCreateESMRequest) Execute() (*CreateESMOutput, *http.Response, error) {
	return r.ApiService.CreateESMExecute(r)
}

/*
CreateESM Method for CreateESM

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateESMRequest
*/
func (a *V2ApiService) CreateESM(ctx context.Context) ApiCreateESMRequest {
	return ApiCreateESMRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateESMOutput
func (a *V2ApiService) CreateESMExecute(r ApiCreateESMRequest) (*CreateESMOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateESMOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateESM")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-esm"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateEventForwarderRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createEventForwarder *CreateEventForwarder
    body interface{}
}

func (r ApiCreateEventForwarderRequest) CreateEventForwarder(createEventForwarder CreateEventForwarder) ApiCreateEventForwarderRequest {
	r.createEventForwarder = &createEventForwarder
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateEventForwarderRequest) Body(body CreateEventForwarder) ApiCreateEventForwarderRequest {
    r.body = body
    return r
}

func (r ApiCreateEventForwarderRequest) Execute() (*CreateEventForwarderOutput, *http.Response, error) {
	return r.ApiService.CreateEventForwarderExecute(r)
}

/*
CreateEventForwarder Method for CreateEventForwarder

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateEventForwarderRequest
*/
func (a *V2ApiService) CreateEventForwarder(ctx context.Context) ApiCreateEventForwarderRequest {
	return ApiCreateEventForwarderRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateEventForwarderOutput
func (a *V2ApiService) CreateEventForwarderExecute(r ApiCreateEventForwarderRequest) (*CreateEventForwarderOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateEventForwarderOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateEventForwarder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-event-forwarder"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateGKETargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createGKETarget *CreateGKETarget
    body interface{}
}

func (r ApiCreateGKETargetRequest) CreateGKETarget(createGKETarget CreateGKETarget) ApiCreateGKETargetRequest {
	r.createGKETarget = &createGKETarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateGKETargetRequest) Body(body CreateGKETarget) ApiCreateGKETargetRequest {
    r.body = body
    return r
}

func (r ApiCreateGKETargetRequest) Execute() (*CreateGKETargetOutput, *http.Response, error) {
	return r.ApiService.CreateGKETargetExecute(r)
}

/*
CreateGKETarget Method for CreateGKETarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateGKETargetRequest
*/
func (a *V2ApiService) CreateGKETarget(ctx context.Context) ApiCreateGKETargetRequest {
	return ApiCreateGKETargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateGKETargetOutput
func (a *V2ApiService) CreateGKETargetExecute(r ApiCreateGKETargetRequest) (*CreateGKETargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateGKETargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateGKETarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-gke-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateGcpTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createGcpTarget *CreateGcpTarget
    body interface{}
}

func (r ApiCreateGcpTargetRequest) CreateGcpTarget(createGcpTarget CreateGcpTarget) ApiCreateGcpTargetRequest {
	r.createGcpTarget = &createGcpTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateGcpTargetRequest) Body(body CreateGcpTarget) ApiCreateGcpTargetRequest {
    r.body = body
    return r
}

func (r ApiCreateGcpTargetRequest) Execute() (*CreateGcpTargetOutput, *http.Response, error) {
	return r.ApiService.CreateGcpTargetExecute(r)
}

/*
CreateGcpTarget Method for CreateGcpTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateGcpTargetRequest
*/
func (a *V2ApiService) CreateGcpTarget(ctx context.Context) ApiCreateGcpTargetRequest {
	return ApiCreateGcpTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateGcpTargetOutput
func (a *V2ApiService) CreateGcpTargetExecute(r ApiCreateGcpTargetRequest) (*CreateGcpTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateGcpTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateGcpTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-gcp-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateGithubTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createGithubTarget *CreateGithubTarget
    body interface{}
}

func (r ApiCreateGithubTargetRequest) CreateGithubTarget(createGithubTarget CreateGithubTarget) ApiCreateGithubTargetRequest {
	r.createGithubTarget = &createGithubTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateGithubTargetRequest) Body(body CreateGithubTarget) ApiCreateGithubTargetRequest {
    r.body = body
    return r
}

func (r ApiCreateGithubTargetRequest) Execute() (*CreateGithubTargetOutput, *http.Response, error) {
	return r.ApiService.CreateGithubTargetExecute(r)
}

/*
CreateGithubTarget Method for CreateGithubTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateGithubTargetRequest
*/
func (a *V2ApiService) CreateGithubTarget(ctx context.Context) ApiCreateGithubTargetRequest {
	return ApiCreateGithubTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateGithubTargetOutput
func (a *V2ApiService) CreateGithubTargetExecute(r ApiCreateGithubTargetRequest) (*CreateGithubTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateGithubTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateGithubTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-github-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateGitlabTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createGitlabTarget *CreateGitlabTarget
    body interface{}
}

func (r ApiCreateGitlabTargetRequest) CreateGitlabTarget(createGitlabTarget CreateGitlabTarget) ApiCreateGitlabTargetRequest {
	r.createGitlabTarget = &createGitlabTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateGitlabTargetRequest) Body(body CreateGitlabTarget) ApiCreateGitlabTargetRequest {
    r.body = body
    return r
}

func (r ApiCreateGitlabTargetRequest) Execute() (*CreateGitlabTargetOutput, *http.Response, error) {
	return r.ApiService.CreateGitlabTargetExecute(r)
}

/*
CreateGitlabTarget Method for CreateGitlabTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateGitlabTargetRequest
*/
func (a *V2ApiService) CreateGitlabTarget(ctx context.Context) ApiCreateGitlabTargetRequest {
	return ApiCreateGitlabTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateGitlabTargetOutput
func (a *V2ApiService) CreateGitlabTargetExecute(r ApiCreateGitlabTargetRequest) (*CreateGitlabTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateGitlabTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateGitlabTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-gitlab-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateGlobalSignAtlasTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createGlobalSignAtlasTarget *CreateGlobalSignAtlasTarget
    body interface{}
}

func (r ApiCreateGlobalSignAtlasTargetRequest) CreateGlobalSignAtlasTarget(createGlobalSignAtlasTarget CreateGlobalSignAtlasTarget) ApiCreateGlobalSignAtlasTargetRequest {
	r.createGlobalSignAtlasTarget = &createGlobalSignAtlasTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateGlobalSignAtlasTargetRequest) Body(body CreateGlobalSignAtlasTarget) ApiCreateGlobalSignAtlasTargetRequest {
    r.body = body
    return r
}

func (r ApiCreateGlobalSignAtlasTargetRequest) Execute() (*CreateGlobalSignAtlasTargetOutput, *http.Response, error) {
	return r.ApiService.CreateGlobalSignAtlasTargetExecute(r)
}

/*
CreateGlobalSignAtlasTarget Method for CreateGlobalSignAtlasTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateGlobalSignAtlasTargetRequest
*/
func (a *V2ApiService) CreateGlobalSignAtlasTarget(ctx context.Context) ApiCreateGlobalSignAtlasTargetRequest {
	return ApiCreateGlobalSignAtlasTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateGlobalSignAtlasTargetOutput
func (a *V2ApiService) CreateGlobalSignAtlasTargetExecute(r ApiCreateGlobalSignAtlasTargetRequest) (*CreateGlobalSignAtlasTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateGlobalSignAtlasTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateGlobalSignAtlasTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-globalsign-atlas-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateGlobalSignTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createGlobalSignTarget *CreateGlobalSignTarget
    body interface{}
}

func (r ApiCreateGlobalSignTargetRequest) CreateGlobalSignTarget(createGlobalSignTarget CreateGlobalSignTarget) ApiCreateGlobalSignTargetRequest {
	r.createGlobalSignTarget = &createGlobalSignTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateGlobalSignTargetRequest) Body(body CreateGlobalSignTarget) ApiCreateGlobalSignTargetRequest {
    r.body = body
    return r
}

func (r ApiCreateGlobalSignTargetRequest) Execute() (*CreateGlobalSignTargetOutput, *http.Response, error) {
	return r.ApiService.CreateGlobalSignTargetExecute(r)
}

/*
CreateGlobalSignTarget Method for CreateGlobalSignTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateGlobalSignTargetRequest
*/
func (a *V2ApiService) CreateGlobalSignTarget(ctx context.Context) ApiCreateGlobalSignTargetRequest {
	return ApiCreateGlobalSignTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateGlobalSignTargetOutput
func (a *V2ApiService) CreateGlobalSignTargetExecute(r ApiCreateGlobalSignTargetRequest) (*CreateGlobalSignTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateGlobalSignTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateGlobalSignTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-globalsign-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateGodaddyTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createGodaddyTarget *CreateGodaddyTarget
    body interface{}
}

func (r ApiCreateGodaddyTargetRequest) CreateGodaddyTarget(createGodaddyTarget CreateGodaddyTarget) ApiCreateGodaddyTargetRequest {
	r.createGodaddyTarget = &createGodaddyTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateGodaddyTargetRequest) Body(body CreateGodaddyTarget) ApiCreateGodaddyTargetRequest {
    r.body = body
    return r
}

func (r ApiCreateGodaddyTargetRequest) Execute() (*CreateGodaddyTargetOutput, *http.Response, error) {
	return r.ApiService.CreateGodaddyTargetExecute(r)
}

/*
CreateGodaddyTarget Method for CreateGodaddyTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateGodaddyTargetRequest
*/
func (a *V2ApiService) CreateGodaddyTarget(ctx context.Context) ApiCreateGodaddyTargetRequest {
	return ApiCreateGodaddyTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateGodaddyTargetOutput
func (a *V2ApiService) CreateGodaddyTargetExecute(r ApiCreateGodaddyTargetRequest) (*CreateGodaddyTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateGodaddyTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateGodaddyTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-godaddy-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateGroupRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createGroup *CreateGroup
    body interface{}
}

func (r ApiCreateGroupRequest) CreateGroup(createGroup CreateGroup) ApiCreateGroupRequest {
	r.createGroup = &createGroup
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateGroupRequest) Body(body CreateGroup) ApiCreateGroupRequest {
    r.body = body
    return r
}

func (r ApiCreateGroupRequest) Execute() (*CreateGroupOutput, *http.Response, error) {
	return r.ApiService.CreateGroupExecute(r)
}

/*
CreateGroup Method for CreateGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateGroupRequest
*/
func (a *V2ApiService) CreateGroup(ctx context.Context) ApiCreateGroupRequest {
	return ApiCreateGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateGroupOutput
func (a *V2ApiService) CreateGroupExecute(r ApiCreateGroupRequest) (*CreateGroupOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateGroupOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-group"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateHashiVaultTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createHashiVaultTarget *CreateHashiVaultTarget
    body interface{}
}

func (r ApiCreateHashiVaultTargetRequest) CreateHashiVaultTarget(createHashiVaultTarget CreateHashiVaultTarget) ApiCreateHashiVaultTargetRequest {
	r.createHashiVaultTarget = &createHashiVaultTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateHashiVaultTargetRequest) Body(body CreateHashiVaultTarget) ApiCreateHashiVaultTargetRequest {
    r.body = body
    return r
}

func (r ApiCreateHashiVaultTargetRequest) Execute() (*CreateHashiVaultTargetOutput, *http.Response, error) {
	return r.ApiService.CreateHashiVaultTargetExecute(r)
}

/*
CreateHashiVaultTarget Method for CreateHashiVaultTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateHashiVaultTargetRequest
*/
func (a *V2ApiService) CreateHashiVaultTarget(ctx context.Context) ApiCreateHashiVaultTargetRequest {
	return ApiCreateHashiVaultTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateHashiVaultTargetOutput
func (a *V2ApiService) CreateHashiVaultTargetExecute(r ApiCreateHashiVaultTargetRequest) (*CreateHashiVaultTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateHashiVaultTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateHashiVaultTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-hashi-vault-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateKeyRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createKey *CreateKey
    body interface{}
}

func (r ApiCreateKeyRequest) CreateKey(createKey CreateKey) ApiCreateKeyRequest {
	r.createKey = &createKey
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateKeyRequest) Body(body CreateKey) ApiCreateKeyRequest {
    r.body = body
    return r
}

func (r ApiCreateKeyRequest) Execute() (*CreateKeyOutput, *http.Response, error) {
	return r.ApiService.CreateKeyExecute(r)
}

/*
CreateKey Method for CreateKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateKeyRequest
*/
func (a *V2ApiService) CreateKey(ctx context.Context) ApiCreateKeyRequest {
	return ApiCreateKeyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateKeyOutput
func (a *V2ApiService) CreateKeyExecute(r ApiCreateKeyRequest) (*CreateKeyOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateKeyOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-key"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateLinkedTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createLinkedTarget *CreateLinkedTarget
    body interface{}
}

func (r ApiCreateLinkedTargetRequest) CreateLinkedTarget(createLinkedTarget CreateLinkedTarget) ApiCreateLinkedTargetRequest {
	r.createLinkedTarget = &createLinkedTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateLinkedTargetRequest) Body(body CreateLinkedTarget) ApiCreateLinkedTargetRequest {
    r.body = body
    return r
}

func (r ApiCreateLinkedTargetRequest) Execute() (*CreateLinkedTargetOutput, *http.Response, error) {
	return r.ApiService.CreateLinkedTargetExecute(r)
}

/*
CreateLinkedTarget Method for CreateLinkedTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateLinkedTargetRequest
*/
func (a *V2ApiService) CreateLinkedTarget(ctx context.Context) ApiCreateLinkedTargetRequest {
	return ApiCreateLinkedTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateLinkedTargetOutput
func (a *V2ApiService) CreateLinkedTargetExecute(r ApiCreateLinkedTargetRequest) (*CreateLinkedTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLinkedTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateLinkedTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-linked-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateNativeK8STargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createNativeK8STarget *CreateNativeK8STarget
    body interface{}
}

func (r ApiCreateNativeK8STargetRequest) CreateNativeK8STarget(createNativeK8STarget CreateNativeK8STarget) ApiCreateNativeK8STargetRequest {
	r.createNativeK8STarget = &createNativeK8STarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateNativeK8STargetRequest) Body(body CreateNativeK8STarget) ApiCreateNativeK8STargetRequest {
    r.body = body
    return r
}

func (r ApiCreateNativeK8STargetRequest) Execute() (*CreateNativeK8STargetOutput, *http.Response, error) {
	return r.ApiService.CreateNativeK8STargetExecute(r)
}

/*
CreateNativeK8STarget Method for CreateNativeK8STarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateNativeK8STargetRequest
*/
func (a *V2ApiService) CreateNativeK8STarget(ctx context.Context) ApiCreateNativeK8STargetRequest {
	return ApiCreateNativeK8STargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateNativeK8STargetOutput
func (a *V2ApiService) CreateNativeK8STargetExecute(r ApiCreateNativeK8STargetRequest) (*CreateNativeK8STargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateNativeK8STargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateNativeK8STarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-k8s-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateOidcAppRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createOidcApp *CreateOidcApp
    body interface{}
}

func (r ApiCreateOidcAppRequest) CreateOidcApp(createOidcApp CreateOidcApp) ApiCreateOidcAppRequest {
	r.createOidcApp = &createOidcApp
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateOidcAppRequest) Body(body CreateOidcApp) ApiCreateOidcAppRequest {
    r.body = body
    return r
}

func (r ApiCreateOidcAppRequest) Execute() (*CreateOidcAppOutput, *http.Response, error) {
	return r.ApiService.CreateOidcAppExecute(r)
}

/*
CreateOidcApp Method for CreateOidcApp

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateOidcAppRequest
*/
func (a *V2ApiService) CreateOidcApp(ctx context.Context) ApiCreateOidcAppRequest {
	return ApiCreateOidcAppRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateOidcAppOutput
func (a *V2ApiService) CreateOidcAppExecute(r ApiCreateOidcAppRequest) (*CreateOidcAppOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateOidcAppOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateOidcApp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-oidc-app"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatePKICertIssuerRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createPKICertIssuer *CreatePKICertIssuer
    body interface{}
}

func (r ApiCreatePKICertIssuerRequest) CreatePKICertIssuer(createPKICertIssuer CreatePKICertIssuer) ApiCreatePKICertIssuerRequest {
	r.createPKICertIssuer = &createPKICertIssuer
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreatePKICertIssuerRequest) Body(body CreatePKICertIssuer) ApiCreatePKICertIssuerRequest {
    r.body = body
    return r
}

func (r ApiCreatePKICertIssuerRequest) Execute() (*CreatePKICertIssuerOutput, *http.Response, error) {
	return r.ApiService.CreatePKICertIssuerExecute(r)
}

/*
CreatePKICertIssuer Method for CreatePKICertIssuer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreatePKICertIssuerRequest
*/
func (a *V2ApiService) CreatePKICertIssuer(ctx context.Context) ApiCreatePKICertIssuerRequest {
	return ApiCreatePKICertIssuerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreatePKICertIssuerOutput
func (a *V2ApiService) CreatePKICertIssuerExecute(r ApiCreatePKICertIssuerRequest) (*CreatePKICertIssuerOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreatePKICertIssuerOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreatePKICertIssuer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-pki-cert-issuer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatePasskeyRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createPasskey *CreatePasskey
    body interface{}
}

func (r ApiCreatePasskeyRequest) CreatePasskey(createPasskey CreatePasskey) ApiCreatePasskeyRequest {
	r.createPasskey = &createPasskey
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreatePasskeyRequest) Body(body CreatePasskey) ApiCreatePasskeyRequest {
    r.body = body
    return r
}

func (r ApiCreatePasskeyRequest) Execute() (*CreatePasskeyOutput, *http.Response, error) {
	return r.ApiService.CreatePasskeyExecute(r)
}

/*
CreatePasskey Method for CreatePasskey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreatePasskeyRequest
*/
func (a *V2ApiService) CreatePasskey(ctx context.Context) ApiCreatePasskeyRequest {
	return ApiCreatePasskeyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreatePasskeyOutput
func (a *V2ApiService) CreatePasskeyExecute(r ApiCreatePasskeyRequest) (*CreatePasskeyOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreatePasskeyOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreatePasskey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-passkey"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatePingTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createPingTarget *CreatePingTarget
    body interface{}
}

func (r ApiCreatePingTargetRequest) CreatePingTarget(createPingTarget CreatePingTarget) ApiCreatePingTargetRequest {
	r.createPingTarget = &createPingTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreatePingTargetRequest) Body(body CreatePingTarget) ApiCreatePingTargetRequest {
    r.body = body
    return r
}

func (r ApiCreatePingTargetRequest) Execute() (*CreatePingTargetOutput, *http.Response, error) {
	return r.ApiService.CreatePingTargetExecute(r)
}

/*
CreatePingTarget Method for CreatePingTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreatePingTargetRequest
*/
func (a *V2ApiService) CreatePingTarget(ctx context.Context) ApiCreatePingTargetRequest {
	return ApiCreatePingTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreatePingTargetOutput
func (a *V2ApiService) CreatePingTargetExecute(r ApiCreatePingTargetRequest) (*CreatePingTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreatePingTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreatePingTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-ping-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateRabbitMQTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createRabbitMQTarget *CreateRabbitMQTarget
    body interface{}
}

func (r ApiCreateRabbitMQTargetRequest) CreateRabbitMQTarget(createRabbitMQTarget CreateRabbitMQTarget) ApiCreateRabbitMQTargetRequest {
	r.createRabbitMQTarget = &createRabbitMQTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateRabbitMQTargetRequest) Body(body CreateRabbitMQTarget) ApiCreateRabbitMQTargetRequest {
    r.body = body
    return r
}

func (r ApiCreateRabbitMQTargetRequest) Execute() (*CreateRabbitMQTargetOutput, *http.Response, error) {
	return r.ApiService.CreateRabbitMQTargetExecute(r)
}

/*
CreateRabbitMQTarget Method for CreateRabbitMQTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateRabbitMQTargetRequest
*/
func (a *V2ApiService) CreateRabbitMQTarget(ctx context.Context) ApiCreateRabbitMQTargetRequest {
	return ApiCreateRabbitMQTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateRabbitMQTargetOutput
func (a *V2ApiService) CreateRabbitMQTargetExecute(r ApiCreateRabbitMQTargetRequest) (*CreateRabbitMQTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateRabbitMQTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateRabbitMQTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-rabbitmq-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateRoleRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createRole *CreateRole
    body interface{}
}

func (r ApiCreateRoleRequest) CreateRole(createRole CreateRole) ApiCreateRoleRequest {
	r.createRole = &createRole
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateRoleRequest) Body(body CreateRole) ApiCreateRoleRequest {
    r.body = body
    return r
}

func (r ApiCreateRoleRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateRoleExecute(r)
}

/*
CreateRole Method for CreateRole

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateRoleRequest
*/
func (a *V2ApiService) CreateRole(ctx context.Context) ApiCreateRoleRequest {
	return ApiCreateRoleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) CreateRoleExecute(r ApiCreateRoleRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-role"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateRotatedSecretRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createRotatedSecret *CreateRotatedSecret
    body interface{}
}

func (r ApiCreateRotatedSecretRequest) CreateRotatedSecret(createRotatedSecret CreateRotatedSecret) ApiCreateRotatedSecretRequest {
	r.createRotatedSecret = &createRotatedSecret
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateRotatedSecretRequest) Body(body CreateRotatedSecret) ApiCreateRotatedSecretRequest {
    r.body = body
    return r
}

func (r ApiCreateRotatedSecretRequest) Execute() (*CreateRotatedSecretOutput, *http.Response, error) {
	return r.ApiService.CreateRotatedSecretExecute(r)
}

/*
CreateRotatedSecret Method for CreateRotatedSecret

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateRotatedSecretRequest
*/
func (a *V2ApiService) CreateRotatedSecret(ctx context.Context) ApiCreateRotatedSecretRequest {
	return ApiCreateRotatedSecretRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateRotatedSecretOutput
func (a *V2ApiService) CreateRotatedSecretExecute(r ApiCreateRotatedSecretRequest) (*CreateRotatedSecretOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateRotatedSecretOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateRotatedSecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-rotated-secret"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSSHCertIssuerRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createSSHCertIssuer *CreateSSHCertIssuer
    body interface{}
}

func (r ApiCreateSSHCertIssuerRequest) CreateSSHCertIssuer(createSSHCertIssuer CreateSSHCertIssuer) ApiCreateSSHCertIssuerRequest {
	r.createSSHCertIssuer = &createSSHCertIssuer
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateSSHCertIssuerRequest) Body(body CreateSSHCertIssuer) ApiCreateSSHCertIssuerRequest {
    r.body = body
    return r
}

func (r ApiCreateSSHCertIssuerRequest) Execute() (*CreateSSHCertIssuerOutput, *http.Response, error) {
	return r.ApiService.CreateSSHCertIssuerExecute(r)
}

/*
CreateSSHCertIssuer Method for CreateSSHCertIssuer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSSHCertIssuerRequest
*/
func (a *V2ApiService) CreateSSHCertIssuer(ctx context.Context) ApiCreateSSHCertIssuerRequest {
	return ApiCreateSSHCertIssuerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateSSHCertIssuerOutput
func (a *V2ApiService) CreateSSHCertIssuerExecute(r ApiCreateSSHCertIssuerRequest) (*CreateSSHCertIssuerOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSSHCertIssuerOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateSSHCertIssuer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-ssh-cert-issuer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSSHTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createSSHTarget *CreateSSHTarget
    body interface{}
}

func (r ApiCreateSSHTargetRequest) CreateSSHTarget(createSSHTarget CreateSSHTarget) ApiCreateSSHTargetRequest {
	r.createSSHTarget = &createSSHTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateSSHTargetRequest) Body(body CreateSSHTarget) ApiCreateSSHTargetRequest {
    r.body = body
    return r
}

func (r ApiCreateSSHTargetRequest) Execute() (*CreateSSHTargetOutput, *http.Response, error) {
	return r.ApiService.CreateSSHTargetExecute(r)
}

/*
CreateSSHTarget Method for CreateSSHTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSSHTargetRequest
*/
func (a *V2ApiService) CreateSSHTarget(ctx context.Context) ApiCreateSSHTargetRequest {
	return ApiCreateSSHTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateSSHTargetOutput
func (a *V2ApiService) CreateSSHTargetExecute(r ApiCreateSSHTargetRequest) (*CreateSSHTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSSHTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateSSHTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-ssh-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSalesforceTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createSalesforceTarget *CreateSalesforceTarget
    body interface{}
}

func (r ApiCreateSalesforceTargetRequest) CreateSalesforceTarget(createSalesforceTarget CreateSalesforceTarget) ApiCreateSalesforceTargetRequest {
	r.createSalesforceTarget = &createSalesforceTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateSalesforceTargetRequest) Body(body CreateSalesforceTarget) ApiCreateSalesforceTargetRequest {
    r.body = body
    return r
}

func (r ApiCreateSalesforceTargetRequest) Execute() (*CreateSalesforceTargetOutput, *http.Response, error) {
	return r.ApiService.CreateSalesforceTargetExecute(r)
}

/*
CreateSalesforceTarget Method for CreateSalesforceTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSalesforceTargetRequest
*/
func (a *V2ApiService) CreateSalesforceTarget(ctx context.Context) ApiCreateSalesforceTargetRequest {
	return ApiCreateSalesforceTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateSalesforceTargetOutput
func (a *V2ApiService) CreateSalesforceTargetExecute(r ApiCreateSalesforceTargetRequest) (*CreateSalesforceTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSalesforceTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateSalesforceTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-salesforce-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSecretRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createSecret *CreateSecret
    body interface{}
}

func (r ApiCreateSecretRequest) CreateSecret(createSecret CreateSecret) ApiCreateSecretRequest {
	r.createSecret = &createSecret
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateSecretRequest) Body(body CreateSecret) ApiCreateSecretRequest {
    r.body = body
    return r
}

func (r ApiCreateSecretRequest) Execute() (*CreateSecretOutput, *http.Response, error) {
	return r.ApiService.CreateSecretExecute(r)
}

/*
CreateSecret Method for CreateSecret

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSecretRequest
*/
func (a *V2ApiService) CreateSecret(ctx context.Context) ApiCreateSecretRequest {
	return ApiCreateSecretRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateSecretOutput
func (a *V2ApiService) CreateSecretExecute(r ApiCreateSecretRequest) (*CreateSecretOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSecretOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateSecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-secret"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTokenizerRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createTokenizer *CreateTokenizer
    body interface{}
}

func (r ApiCreateTokenizerRequest) CreateTokenizer(createTokenizer CreateTokenizer) ApiCreateTokenizerRequest {
	r.createTokenizer = &createTokenizer
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateTokenizerRequest) Body(body CreateTokenizer) ApiCreateTokenizerRequest {
    r.body = body
    return r
}

func (r ApiCreateTokenizerRequest) Execute() (*CreateTokenizerOutput, *http.Response, error) {
	return r.ApiService.CreateTokenizerExecute(r)
}

/*
CreateTokenizer Method for CreateTokenizer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTokenizerRequest
*/
func (a *V2ApiService) CreateTokenizer(ctx context.Context) ApiCreateTokenizerRequest {
	return ApiCreateTokenizerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateTokenizerOutput
func (a *V2ApiService) CreateTokenizerExecute(r ApiCreateTokenizerRequest) (*CreateTokenizerOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateTokenizerOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateTokenizer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-tokenizer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateUSCRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createUSC *CreateUSC
    body interface{}
}

func (r ApiCreateUSCRequest) CreateUSC(createUSC CreateUSC) ApiCreateUSCRequest {
	r.createUSC = &createUSC
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateUSCRequest) Body(body CreateUSC) ApiCreateUSCRequest {
    r.body = body
    return r
}

func (r ApiCreateUSCRequest) Execute() (*CreateUSCOutput, *http.Response, error) {
	return r.ApiService.CreateUSCExecute(r)
}

/*
CreateUSC Method for CreateUSC

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateUSCRequest
*/
func (a *V2ApiService) CreateUSC(ctx context.Context) ApiCreateUSCRequest {
	return ApiCreateUSCRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateUSCOutput
func (a *V2ApiService) CreateUSCExecute(r ApiCreateUSCRequest) (*CreateUSCOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateUSCOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateUSC")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-usc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateUserEventRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createUserEvent *CreateUserEvent
    body interface{}
}

func (r ApiCreateUserEventRequest) CreateUserEvent(createUserEvent CreateUserEvent) ApiCreateUserEventRequest {
	r.createUserEvent = &createUserEvent
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateUserEventRequest) Body(body CreateUserEvent) ApiCreateUserEventRequest {
    r.body = body
    return r
}

func (r ApiCreateUserEventRequest) Execute() (*CreateUserEventOutput, *http.Response, error) {
	return r.ApiService.CreateUserEventExecute(r)
}

/*
CreateUserEvent Method for CreateUserEvent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateUserEventRequest
*/
func (a *V2ApiService) CreateUserEvent(ctx context.Context) ApiCreateUserEventRequest {
	return ApiCreateUserEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateUserEventOutput
func (a *V2ApiService) CreateUserEventExecute(r ApiCreateUserEventRequest) (*CreateUserEventOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateUserEventOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateUserEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-user-event"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateWebTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createWebTarget *CreateWebTarget
    body interface{}
}

func (r ApiCreateWebTargetRequest) CreateWebTarget(createWebTarget CreateWebTarget) ApiCreateWebTargetRequest {
	r.createWebTarget = &createWebTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateWebTargetRequest) Body(body CreateWebTarget) ApiCreateWebTargetRequest {
    r.body = body
    return r
}

func (r ApiCreateWebTargetRequest) Execute() (*CreateWebTargetOutput, *http.Response, error) {
	return r.ApiService.CreateWebTargetExecute(r)
}

/*
CreateWebTarget Method for CreateWebTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateWebTargetRequest
*/
func (a *V2ApiService) CreateWebTarget(ctx context.Context) ApiCreateWebTargetRequest {
	return ApiCreateWebTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateWebTargetOutput
func (a *V2ApiService) CreateWebTargetExecute(r ApiCreateWebTargetRequest) (*CreateWebTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateWebTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateWebTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-web-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateWindowsTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createWindowsTarget *CreateWindowsTarget
    body interface{}
}

func (r ApiCreateWindowsTargetRequest) CreateWindowsTarget(createWindowsTarget CreateWindowsTarget) ApiCreateWindowsTargetRequest {
	r.createWindowsTarget = &createWindowsTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateWindowsTargetRequest) Body(body CreateWindowsTarget) ApiCreateWindowsTargetRequest {
    r.body = body
    return r
}

func (r ApiCreateWindowsTargetRequest) Execute() (*CreateWindowsTargetOutput, *http.Response, error) {
	return r.ApiService.CreateWindowsTargetExecute(r)
}

/*
CreateWindowsTarget Method for CreateWindowsTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateWindowsTargetRequest
*/
func (a *V2ApiService) CreateWindowsTarget(ctx context.Context) ApiCreateWindowsTargetRequest {
	return ApiCreateWindowsTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateWindowsTargetOutput
func (a *V2ApiService) CreateWindowsTargetExecute(r ApiCreateWindowsTargetRequest) (*CreateWindowsTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateWindowsTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateWindowsTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-windows-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateZeroSSLTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createZeroSSLTarget *CreateZeroSSLTarget
    body interface{}
}

func (r ApiCreateZeroSSLTargetRequest) CreateZeroSSLTarget(createZeroSSLTarget CreateZeroSSLTarget) ApiCreateZeroSSLTargetRequest {
	r.createZeroSSLTarget = &createZeroSSLTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateZeroSSLTargetRequest) Body(body CreateZeroSSLTarget) ApiCreateZeroSSLTargetRequest {
    r.body = body
    return r
}

func (r ApiCreateZeroSSLTargetRequest) Execute() (*CreateZeroSSLTargetOutput, *http.Response, error) {
	return r.ApiService.CreateZeroSSLTargetExecute(r)
}

/*
CreateZeroSSLTarget Method for CreateZeroSSLTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateZeroSSLTargetRequest
*/
func (a *V2ApiService) CreateZeroSSLTarget(ctx context.Context) ApiCreateZeroSSLTargetRequest {
	return ApiCreateZeroSSLTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateZeroSSLTargetOutput
func (a *V2ApiService) CreateZeroSSLTargetExecute(r ApiCreateZeroSSLTargetRequest) (*CreateZeroSSLTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateZeroSSLTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateZeroSSLTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-zerossl-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateldapTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	createLdapTarget *CreateLdapTarget
    body interface{}
}

func (r ApiCreateldapTargetRequest) CreateLdapTarget(createLdapTarget CreateLdapTarget) ApiCreateldapTargetRequest {
	r.createLdapTarget = &createLdapTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiCreateldapTargetRequest) Body(body CreateLdapTarget) ApiCreateldapTargetRequest {
    r.body = body
    return r
}

func (r ApiCreateldapTargetRequest) Execute() (*CreateLdapTargetOutput, *http.Response, error) {
	return r.ApiService.CreateldapTargetExecute(r)
}

/*
CreateldapTarget Method for CreateldapTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateldapTargetRequest
*/
func (a *V2ApiService) CreateldapTarget(ctx context.Context) ApiCreateldapTargetRequest {
	return ApiCreateldapTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateLdapTargetOutput
func (a *V2ApiService) CreateldapTargetExecute(r ApiCreateldapTargetRequest) (*CreateLdapTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLdapTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.CreateldapTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/create-ldap-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeactivateAcmeAccountRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	deactivateAcmeAccount *DeactivateAcmeAccount
    body interface{}
}

func (r ApiDeactivateAcmeAccountRequest) DeactivateAcmeAccount(deactivateAcmeAccount DeactivateAcmeAccount) ApiDeactivateAcmeAccountRequest {
	r.deactivateAcmeAccount = &deactivateAcmeAccount
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDeactivateAcmeAccountRequest) Body(body DeactivateAcmeAccount) ApiDeactivateAcmeAccountRequest {
    r.body = body
    return r
}

func (r ApiDeactivateAcmeAccountRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeactivateAcmeAccountExecute(r)
}

/*
DeactivateAcmeAccount Method for DeactivateAcmeAccount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeactivateAcmeAccountRequest
*/
func (a *V2ApiService) DeactivateAcmeAccount(ctx context.Context) ApiDeactivateAcmeAccountRequest {
	return ApiDeactivateAcmeAccountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) DeactivateAcmeAccountExecute(r ApiDeactivateAcmeAccountRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DeactivateAcmeAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deactivate-acme-account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDecryptRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	decrypt *Decrypt
    body interface{}
}

func (r ApiDecryptRequest) Decrypt(decrypt Decrypt) ApiDecryptRequest {
	r.decrypt = &decrypt
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDecryptRequest) Body(body Decrypt) ApiDecryptRequest {
    r.body = body
    return r
}

func (r ApiDecryptRequest) Execute() (*DecryptOutput, *http.Response, error) {
	return r.ApiService.DecryptExecute(r)
}

/*
Decrypt Method for Decrypt

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDecryptRequest
*/
func (a *V2ApiService) Decrypt(ctx context.Context) ApiDecryptRequest {
	return ApiDecryptRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DecryptOutput
func (a *V2ApiService) DecryptExecute(r ApiDecryptRequest) (*DecryptOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DecryptOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.Decrypt")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/decrypt"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDecryptBatchRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	batchEncryptionRequestLine *[]BatchEncryptionRequestLine
    body interface{}
}

func (r ApiDecryptBatchRequest) BatchEncryptionRequestLine(batchEncryptionRequestLine []BatchEncryptionRequestLine) ApiDecryptBatchRequest {
	r.batchEncryptionRequestLine = &batchEncryptionRequestLine
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDecryptBatchRequest) Body(body []BatchEncryptionRequestLine) ApiDecryptBatchRequest {
    r.body = body
    return r
}

func (r ApiDecryptBatchRequest) Execute() (*DecryptOutput, *http.Response, error) {
	return r.ApiService.DecryptBatchExecute(r)
}

/*
DecryptBatch Method for DecryptBatch

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDecryptBatchRequest
*/
func (a *V2ApiService) DecryptBatch(ctx context.Context) ApiDecryptBatchRequest {
	return ApiDecryptBatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DecryptOutput
func (a *V2ApiService) DecryptBatchExecute(r ApiDecryptBatchRequest) (*DecryptOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DecryptOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DecryptBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/decrypt-batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDecryptGPGRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	decryptGPG *DecryptGPG
    body interface{}
}

func (r ApiDecryptGPGRequest) DecryptGPG(decryptGPG DecryptGPG) ApiDecryptGPGRequest {
	r.decryptGPG = &decryptGPG
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDecryptGPGRequest) Body(body DecryptGPG) ApiDecryptGPGRequest {
    r.body = body
    return r
}

func (r ApiDecryptGPGRequest) Execute() (*DecryptGPGOutput, *http.Response, error) {
	return r.ApiService.DecryptGPGExecute(r)
}

/*
DecryptGPG Method for DecryptGPG

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDecryptGPGRequest
*/
func (a *V2ApiService) DecryptGPG(ctx context.Context) ApiDecryptGPGRequest {
	return ApiDecryptGPGRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DecryptGPGOutput
func (a *V2ApiService) DecryptGPGExecute(r ApiDecryptGPGRequest) (*DecryptGPGOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DecryptGPGOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DecryptGPG")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/decrypt-gpg"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDecryptPKCS1Request struct {
	ctx context.Context
	ApiService *V2ApiService
	decryptPKCS1 *DecryptPKCS1
    body interface{}
}

func (r ApiDecryptPKCS1Request) DecryptPKCS1(decryptPKCS1 DecryptPKCS1) ApiDecryptPKCS1Request {
	r.decryptPKCS1 = &decryptPKCS1
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDecryptPKCS1Request) Body(body DecryptPKCS1) ApiDecryptPKCS1Request {
    r.body = body
    return r
}

func (r ApiDecryptPKCS1Request) Execute() (*DecryptPKCS1Output, *http.Response, error) {
	return r.ApiService.DecryptPKCS1Execute(r)
}

/*
DecryptPKCS1 Method for DecryptPKCS1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDecryptPKCS1Request
*/
func (a *V2ApiService) DecryptPKCS1(ctx context.Context) ApiDecryptPKCS1Request {
	return ApiDecryptPKCS1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DecryptPKCS1Output
func (a *V2ApiService) DecryptPKCS1Execute(r ApiDecryptPKCS1Request) (*DecryptPKCS1Output, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DecryptPKCS1Output
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DecryptPKCS1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/decrypt-pkcs1"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDecryptWithClassicKeyRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	decryptWithClassicKey *DecryptWithClassicKey
    body interface{}
}

func (r ApiDecryptWithClassicKeyRequest) DecryptWithClassicKey(decryptWithClassicKey DecryptWithClassicKey) ApiDecryptWithClassicKeyRequest {
	r.decryptWithClassicKey = &decryptWithClassicKey
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDecryptWithClassicKeyRequest) Body(body DecryptWithClassicKey) ApiDecryptWithClassicKeyRequest {
    r.body = body
    return r
}

func (r ApiDecryptWithClassicKeyRequest) Execute() (*DecryptWithClassicKeyOutput, *http.Response, error) {
	return r.ApiService.DecryptWithClassicKeyExecute(r)
}

/*
DecryptWithClassicKey Method for DecryptWithClassicKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDecryptWithClassicKeyRequest
*/
func (a *V2ApiService) DecryptWithClassicKey(ctx context.Context) ApiDecryptWithClassicKeyRequest {
	return ApiDecryptWithClassicKeyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DecryptWithClassicKeyOutput
func (a *V2ApiService) DecryptWithClassicKeyExecute(r ApiDecryptWithClassicKeyRequest) (*DecryptWithClassicKeyOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DecryptWithClassicKeyOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DecryptWithClassicKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/decrypt-with-classic-key"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAuthMethodRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	deleteAuthMethod *DeleteAuthMethod
    body interface{}
}

func (r ApiDeleteAuthMethodRequest) DeleteAuthMethod(deleteAuthMethod DeleteAuthMethod) ApiDeleteAuthMethodRequest {
	r.deleteAuthMethod = &deleteAuthMethod
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDeleteAuthMethodRequest) Body(body DeleteAuthMethod) ApiDeleteAuthMethodRequest {
    r.body = body
    return r
}

func (r ApiDeleteAuthMethodRequest) Execute() (*DeleteAuthMethodOutput, *http.Response, error) {
	return r.ApiService.DeleteAuthMethodExecute(r)
}

/*
DeleteAuthMethod Method for DeleteAuthMethod

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteAuthMethodRequest
*/
func (a *V2ApiService) DeleteAuthMethod(ctx context.Context) ApiDeleteAuthMethodRequest {
	return ApiDeleteAuthMethodRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeleteAuthMethodOutput
func (a *V2ApiService) DeleteAuthMethodExecute(r ApiDeleteAuthMethodRequest) (*DeleteAuthMethodOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteAuthMethodOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DeleteAuthMethod")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delete-auth-method"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAuthMethodsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	deleteAuthMethods *DeleteAuthMethods
    body interface{}
}

func (r ApiDeleteAuthMethodsRequest) DeleteAuthMethods(deleteAuthMethods DeleteAuthMethods) ApiDeleteAuthMethodsRequest {
	r.deleteAuthMethods = &deleteAuthMethods
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDeleteAuthMethodsRequest) Body(body DeleteAuthMethods) ApiDeleteAuthMethodsRequest {
    r.body = body
    return r
}

func (r ApiDeleteAuthMethodsRequest) Execute() (*DeleteAuthMethodsOutput, *http.Response, error) {
	return r.ApiService.DeleteAuthMethodsExecute(r)
}

/*
DeleteAuthMethods Method for DeleteAuthMethods

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteAuthMethodsRequest
*/
func (a *V2ApiService) DeleteAuthMethods(ctx context.Context) ApiDeleteAuthMethodsRequest {
	return ApiDeleteAuthMethodsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeleteAuthMethodsOutput
func (a *V2ApiService) DeleteAuthMethodsExecute(r ApiDeleteAuthMethodsRequest) (*DeleteAuthMethodsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteAuthMethodsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DeleteAuthMethods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delete-auth-methods"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteEventForwarderRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	deleteEventForwarder *DeleteEventForwarder
    body interface{}
}

func (r ApiDeleteEventForwarderRequest) DeleteEventForwarder(deleteEventForwarder DeleteEventForwarder) ApiDeleteEventForwarderRequest {
	r.deleteEventForwarder = &deleteEventForwarder
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDeleteEventForwarderRequest) Body(body DeleteEventForwarder) ApiDeleteEventForwarderRequest {
    r.body = body
    return r
}

func (r ApiDeleteEventForwarderRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteEventForwarderExecute(r)
}

/*
DeleteEventForwarder Method for DeleteEventForwarder

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteEventForwarderRequest
*/
func (a *V2ApiService) DeleteEventForwarder(ctx context.Context) ApiDeleteEventForwarderRequest {
	return ApiDeleteEventForwarderRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) DeleteEventForwarderExecute(r ApiDeleteEventForwarderRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DeleteEventForwarder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delete-event-forwarder"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteGatewayAllowedAccessIdRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	deleteGatewayAllowedAccessId *DeleteGatewayAllowedAccessId
    body interface{}
}

func (r ApiDeleteGatewayAllowedAccessIdRequest) DeleteGatewayAllowedAccessId(deleteGatewayAllowedAccessId DeleteGatewayAllowedAccessId) ApiDeleteGatewayAllowedAccessIdRequest {
	r.deleteGatewayAllowedAccessId = &deleteGatewayAllowedAccessId
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDeleteGatewayAllowedAccessIdRequest) Body(body DeleteGatewayAllowedAccessId) ApiDeleteGatewayAllowedAccessIdRequest {
    r.body = body
    return r
}

func (r ApiDeleteGatewayAllowedAccessIdRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteGatewayAllowedAccessIdExecute(r)
}

/*
DeleteGatewayAllowedAccessId Method for DeleteGatewayAllowedAccessId

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteGatewayAllowedAccessIdRequest
*/
func (a *V2ApiService) DeleteGatewayAllowedAccessId(ctx context.Context) ApiDeleteGatewayAllowedAccessIdRequest {
	return ApiDeleteGatewayAllowedAccessIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) DeleteGatewayAllowedAccessIdExecute(r ApiDeleteGatewayAllowedAccessIdRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DeleteGatewayAllowedAccessId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-delete-allowed-management-access"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteGroupRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	deleteGroup *DeleteGroup
    body interface{}
}

func (r ApiDeleteGroupRequest) DeleteGroup(deleteGroup DeleteGroup) ApiDeleteGroupRequest {
	r.deleteGroup = &deleteGroup
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDeleteGroupRequest) Body(body DeleteGroup) ApiDeleteGroupRequest {
    r.body = body
    return r
}

func (r ApiDeleteGroupRequest) Execute() (*DeleteGroupOutput, *http.Response, error) {
	return r.ApiService.DeleteGroupExecute(r)
}

/*
DeleteGroup Method for DeleteGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteGroupRequest
*/
func (a *V2ApiService) DeleteGroup(ctx context.Context) ApiDeleteGroupRequest {
	return ApiDeleteGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeleteGroupOutput
func (a *V2ApiService) DeleteGroupExecute(r ApiDeleteGroupRequest) (*DeleteGroupOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteGroupOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DeleteGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delete-group"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteGwClusterRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	deleteGwCluster *DeleteGwCluster
    body interface{}
}

func (r ApiDeleteGwClusterRequest) DeleteGwCluster(deleteGwCluster DeleteGwCluster) ApiDeleteGwClusterRequest {
	r.deleteGwCluster = &deleteGwCluster
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDeleteGwClusterRequest) Body(body DeleteGwCluster) ApiDeleteGwClusterRequest {
    r.body = body
    return r
}

func (r ApiDeleteGwClusterRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteGwClusterExecute(r)
}

/*
DeleteGwCluster Method for DeleteGwCluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteGwClusterRequest
*/
func (a *V2ApiService) DeleteGwCluster(ctx context.Context) ApiDeleteGwClusterRequest {
	return ApiDeleteGwClusterRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) DeleteGwClusterExecute(r ApiDeleteGwClusterRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DeleteGwCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delete-gateway-cluster"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteItemRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	deleteItem *DeleteItem
    body interface{}
}

func (r ApiDeleteItemRequest) DeleteItem(deleteItem DeleteItem) ApiDeleteItemRequest {
	r.deleteItem = &deleteItem
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDeleteItemRequest) Body(body DeleteItem) ApiDeleteItemRequest {
    r.body = body
    return r
}

func (r ApiDeleteItemRequest) Execute() (*DeleteItemOutput, *http.Response, error) {
	return r.ApiService.DeleteItemExecute(r)
}

/*
DeleteItem Method for DeleteItem

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteItemRequest
*/
func (a *V2ApiService) DeleteItem(ctx context.Context) ApiDeleteItemRequest {
	return ApiDeleteItemRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeleteItemOutput
func (a *V2ApiService) DeleteItemExecute(r ApiDeleteItemRequest) (*DeleteItemOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteItemOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DeleteItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delete-item"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteItemsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	deleteItems *DeleteItems
    body interface{}
}

func (r ApiDeleteItemsRequest) DeleteItems(deleteItems DeleteItems) ApiDeleteItemsRequest {
	r.deleteItems = &deleteItems
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDeleteItemsRequest) Body(body DeleteItems) ApiDeleteItemsRequest {
    r.body = body
    return r
}

func (r ApiDeleteItemsRequest) Execute() (*DeleteItemsOutput, *http.Response, error) {
	return r.ApiService.DeleteItemsExecute(r)
}

/*
DeleteItems Method for DeleteItems

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteItemsRequest
*/
func (a *V2ApiService) DeleteItems(ctx context.Context) ApiDeleteItemsRequest {
	return ApiDeleteItemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeleteItemsOutput
func (a *V2ApiService) DeleteItemsExecute(r ApiDeleteItemsRequest) (*DeleteItemsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteItemsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DeleteItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delete-items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteRoleRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	deleteRole *DeleteRole
    body interface{}
}

func (r ApiDeleteRoleRequest) DeleteRole(deleteRole DeleteRole) ApiDeleteRoleRequest {
	r.deleteRole = &deleteRole
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDeleteRoleRequest) Body(body DeleteRole) ApiDeleteRoleRequest {
    r.body = body
    return r
}

func (r ApiDeleteRoleRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteRoleExecute(r)
}

/*
DeleteRole Method for DeleteRole

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteRoleRequest
*/
func (a *V2ApiService) DeleteRole(ctx context.Context) ApiDeleteRoleRequest {
	return ApiDeleteRoleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) DeleteRoleExecute(r ApiDeleteRoleRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DeleteRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delete-role"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteRoleAssociationRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	deleteRoleAssociation *DeleteRoleAssociation
    body interface{}
}

func (r ApiDeleteRoleAssociationRequest) DeleteRoleAssociation(deleteRoleAssociation DeleteRoleAssociation) ApiDeleteRoleAssociationRequest {
	r.deleteRoleAssociation = &deleteRoleAssociation
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDeleteRoleAssociationRequest) Body(body DeleteRoleAssociation) ApiDeleteRoleAssociationRequest {
    r.body = body
    return r
}

func (r ApiDeleteRoleAssociationRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteRoleAssociationExecute(r)
}

/*
DeleteRoleAssociation Method for DeleteRoleAssociation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteRoleAssociationRequest
*/
func (a *V2ApiService) DeleteRoleAssociation(ctx context.Context) ApiDeleteRoleAssociationRequest {
	return ApiDeleteRoleAssociationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) DeleteRoleAssociationExecute(r ApiDeleteRoleAssociationRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DeleteRoleAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delete-assoc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteRoleRuleRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	deleteRoleRule *DeleteRoleRule
    body interface{}
}

func (r ApiDeleteRoleRuleRequest) DeleteRoleRule(deleteRoleRule DeleteRoleRule) ApiDeleteRoleRuleRequest {
	r.deleteRoleRule = &deleteRoleRule
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDeleteRoleRuleRequest) Body(body DeleteRoleRule) ApiDeleteRoleRuleRequest {
    r.body = body
    return r
}

func (r ApiDeleteRoleRuleRequest) Execute() (*DeleteRoleRuleOutput, *http.Response, error) {
	return r.ApiService.DeleteRoleRuleExecute(r)
}

/*
DeleteRoleRule Method for DeleteRoleRule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteRoleRuleRequest
*/
func (a *V2ApiService) DeleteRoleRule(ctx context.Context) ApiDeleteRoleRuleRequest {
	return ApiDeleteRoleRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeleteRoleRuleOutput
func (a *V2ApiService) DeleteRoleRuleExecute(r ApiDeleteRoleRuleRequest) (*DeleteRoleRuleOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteRoleRuleOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DeleteRoleRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delete-role-rule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteRolesRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	deleteRoles *DeleteRoles
    body interface{}
}

func (r ApiDeleteRolesRequest) DeleteRoles(deleteRoles DeleteRoles) ApiDeleteRolesRequest {
	r.deleteRoles = &deleteRoles
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDeleteRolesRequest) Body(body DeleteRoles) ApiDeleteRolesRequest {
    r.body = body
    return r
}

func (r ApiDeleteRolesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteRolesExecute(r)
}

/*
DeleteRoles Method for DeleteRoles

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteRolesRequest
*/
func (a *V2ApiService) DeleteRoles(ctx context.Context) ApiDeleteRolesRequest {
	return ApiDeleteRolesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) DeleteRolesExecute(r ApiDeleteRolesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DeleteRoles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delete-roles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	deleteTarget *DeleteTarget
    body interface{}
}

func (r ApiDeleteTargetRequest) DeleteTarget(deleteTarget DeleteTarget) ApiDeleteTargetRequest {
	r.deleteTarget = &deleteTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDeleteTargetRequest) Body(body DeleteTarget) ApiDeleteTargetRequest {
    r.body = body
    return r
}

func (r ApiDeleteTargetRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteTargetExecute(r)
}

/*
DeleteTarget Method for DeleteTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteTargetRequest
*/
func (a *V2ApiService) DeleteTarget(ctx context.Context) ApiDeleteTargetRequest {
	return ApiDeleteTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) DeleteTargetExecute(r ApiDeleteTargetRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DeleteTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delete-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteTargetAssociationRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	deleteTargetAssociation *DeleteTargetAssociation
    body interface{}
}

func (r ApiDeleteTargetAssociationRequest) DeleteTargetAssociation(deleteTargetAssociation DeleteTargetAssociation) ApiDeleteTargetAssociationRequest {
	r.deleteTargetAssociation = &deleteTargetAssociation
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDeleteTargetAssociationRequest) Body(body DeleteTargetAssociation) ApiDeleteTargetAssociationRequest {
    r.body = body
    return r
}

func (r ApiDeleteTargetAssociationRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteTargetAssociationExecute(r)
}

/*
DeleteTargetAssociation Method for DeleteTargetAssociation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteTargetAssociationRequest
*/
func (a *V2ApiService) DeleteTargetAssociation(ctx context.Context) ApiDeleteTargetAssociationRequest {
	return ApiDeleteTargetAssociationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) DeleteTargetAssociationExecute(r ApiDeleteTargetAssociationRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DeleteTargetAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delete-assoc-target-item"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteTargetsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	deleteTargets *DeleteTargets
    body interface{}
}

func (r ApiDeleteTargetsRequest) DeleteTargets(deleteTargets DeleteTargets) ApiDeleteTargetsRequest {
	r.deleteTargets = &deleteTargets
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDeleteTargetsRequest) Body(body DeleteTargets) ApiDeleteTargetsRequest {
    r.body = body
    return r
}

func (r ApiDeleteTargetsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteTargetsExecute(r)
}

/*
DeleteTargets Method for DeleteTargets

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteTargetsRequest
*/
func (a *V2ApiService) DeleteTargets(ctx context.Context) ApiDeleteTargetsRequest {
	return ApiDeleteTargetsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) DeleteTargetsExecute(r ApiDeleteTargetsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DeleteTargets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delete-targets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeriveKeyRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	deriveKey *DeriveKey
    body interface{}
}

func (r ApiDeriveKeyRequest) DeriveKey(deriveKey DeriveKey) ApiDeriveKeyRequest {
	r.deriveKey = &deriveKey
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDeriveKeyRequest) Body(body DeriveKey) ApiDeriveKeyRequest {
    r.body = body
    return r
}

func (r ApiDeriveKeyRequest) Execute() (*DeriveKeyOutput, *http.Response, error) {
	return r.ApiService.DeriveKeyExecute(r)
}

/*
DeriveKey Method for DeriveKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeriveKeyRequest
*/
func (a *V2ApiService) DeriveKey(ctx context.Context) ApiDeriveKeyRequest {
	return ApiDeriveKeyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeriveKeyOutput
func (a *V2ApiService) DeriveKeyExecute(r ApiDeriveKeyRequest) (*DeriveKeyOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeriveKeyOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DeriveKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/derive-key"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDescribeAssocRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	describeAssoc *DescribeAssoc
    body interface{}
}

func (r ApiDescribeAssocRequest) DescribeAssoc(describeAssoc DescribeAssoc) ApiDescribeAssocRequest {
	r.describeAssoc = &describeAssoc
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDescribeAssocRequest) Body(body DescribeAssoc) ApiDescribeAssocRequest {
    r.body = body
    return r
}

func (r ApiDescribeAssocRequest) Execute() (*RoleAssociationDetails, *http.Response, error) {
	return r.ApiService.DescribeAssocExecute(r)
}

/*
DescribeAssoc Method for DescribeAssoc

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDescribeAssocRequest
*/
func (a *V2ApiService) DescribeAssoc(ctx context.Context) ApiDescribeAssocRequest {
	return ApiDescribeAssocRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RoleAssociationDetails
func (a *V2ApiService) DescribeAssocExecute(r ApiDescribeAssocRequest) (*RoleAssociationDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoleAssociationDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DescribeAssoc")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/describe-role-am-assoc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDescribeItemRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	describeItem *DescribeItem
    body interface{}
}

func (r ApiDescribeItemRequest) DescribeItem(describeItem DescribeItem) ApiDescribeItemRequest {
	r.describeItem = &describeItem
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDescribeItemRequest) Body(body DescribeItem) ApiDescribeItemRequest {
    r.body = body
    return r
}

func (r ApiDescribeItemRequest) Execute() (*Item, *http.Response, error) {
	return r.ApiService.DescribeItemExecute(r)
}

/*
DescribeItem Method for DescribeItem

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDescribeItemRequest
*/
func (a *V2ApiService) DescribeItem(ctx context.Context) ApiDescribeItemRequest {
	return ApiDescribeItemRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Item
func (a *V2ApiService) DescribeItemExecute(r ApiDescribeItemRequest) (*Item, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Item
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DescribeItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/describe-item"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDescribePermissionsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	describePermissions *DescribePermissions
    body interface{}
}

func (r ApiDescribePermissionsRequest) DescribePermissions(describePermissions DescribePermissions) ApiDescribePermissionsRequest {
	r.describePermissions = &describePermissions
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDescribePermissionsRequest) Body(body DescribePermissions) ApiDescribePermissionsRequest {
    r.body = body
    return r
}

func (r ApiDescribePermissionsRequest) Execute() (*DescribePermissionsOutput, *http.Response, error) {
	return r.ApiService.DescribePermissionsExecute(r)
}

/*
DescribePermissions Method for DescribePermissions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDescribePermissionsRequest
*/
func (a *V2ApiService) DescribePermissions(ctx context.Context) ApiDescribePermissionsRequest {
	return ApiDescribePermissionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DescribePermissionsOutput
func (a *V2ApiService) DescribePermissionsExecute(r ApiDescribePermissionsRequest) (*DescribePermissionsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DescribePermissionsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DescribePermissions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/describe-permissions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDescribeSubClaimsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	describeSubClaims *DescribeSubClaims
    body interface{}
}

func (r ApiDescribeSubClaimsRequest) DescribeSubClaims(describeSubClaims DescribeSubClaims) ApiDescribeSubClaimsRequest {
	r.describeSubClaims = &describeSubClaims
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDescribeSubClaimsRequest) Body(body DescribeSubClaims) ApiDescribeSubClaimsRequest {
    r.body = body
    return r
}

func (r ApiDescribeSubClaimsRequest) Execute() (*DescribeSubClaimsOutput, *http.Response, error) {
	return r.ApiService.DescribeSubClaimsExecute(r)
}

/*
DescribeSubClaims Method for DescribeSubClaims

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDescribeSubClaimsRequest
*/
func (a *V2ApiService) DescribeSubClaims(ctx context.Context) ApiDescribeSubClaimsRequest {
	return ApiDescribeSubClaimsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DescribeSubClaimsOutput
func (a *V2ApiService) DescribeSubClaimsExecute(r ApiDescribeSubClaimsRequest) (*DescribeSubClaimsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DescribeSubClaimsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DescribeSubClaims")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/describe-sub-claims"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDetokenizeRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	detokenize *Detokenize
    body interface{}
}

func (r ApiDetokenizeRequest) Detokenize(detokenize Detokenize) ApiDetokenizeRequest {
	r.detokenize = &detokenize
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDetokenizeRequest) Body(body Detokenize) ApiDetokenizeRequest {
    r.body = body
    return r
}

func (r ApiDetokenizeRequest) Execute() (*DetokenizeOutput, *http.Response, error) {
	return r.ApiService.DetokenizeExecute(r)
}

/*
Detokenize Method for Detokenize

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDetokenizeRequest
*/
func (a *V2ApiService) Detokenize(ctx context.Context) ApiDetokenizeRequest {
	return ApiDetokenizeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DetokenizeOutput
func (a *V2ApiService) DetokenizeExecute(r ApiDetokenizeRequest) (*DetokenizeOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DetokenizeOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.Detokenize")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/detokenize"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDetokenizeBatchRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	batchTokenizationRequestLine *[]BatchTokenizationRequestLine
    body interface{}
}

func (r ApiDetokenizeBatchRequest) BatchTokenizationRequestLine(batchTokenizationRequestLine []BatchTokenizationRequestLine) ApiDetokenizeBatchRequest {
	r.batchTokenizationRequestLine = &batchTokenizationRequestLine
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDetokenizeBatchRequest) Body(body []BatchTokenizationRequestLine) ApiDetokenizeBatchRequest {
    r.body = body
    return r
}

func (r ApiDetokenizeBatchRequest) Execute() (*DetokenizeOutput, *http.Response, error) {
	return r.ApiService.DetokenizeBatchExecute(r)
}

/*
DetokenizeBatch Method for DetokenizeBatch

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDetokenizeBatchRequest
*/
func (a *V2ApiService) DetokenizeBatch(ctx context.Context) ApiDetokenizeBatchRequest {
	return ApiDetokenizeBatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DetokenizeOutput
func (a *V2ApiService) DetokenizeBatchExecute(r ApiDetokenizeBatchRequest) (*DetokenizeOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DetokenizeOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DetokenizeBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/detokenize-batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretCreateArtifactoryRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretCreateArtifactory *DynamicSecretCreateArtifactory
    body interface{}
}

func (r ApiDynamicSecretCreateArtifactoryRequest) DynamicSecretCreateArtifactory(dynamicSecretCreateArtifactory DynamicSecretCreateArtifactory) ApiDynamicSecretCreateArtifactoryRequest {
	r.dynamicSecretCreateArtifactory = &dynamicSecretCreateArtifactory
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretCreateArtifactoryRequest) Body(body DynamicSecretCreateArtifactory) ApiDynamicSecretCreateArtifactoryRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretCreateArtifactoryRequest) Execute() (*DynamicSecretCreateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretCreateArtifactoryExecute(r)
}

/*
DynamicSecretCreateArtifactory Method for DynamicSecretCreateArtifactory

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretCreateArtifactoryRequest
*/
func (a *V2ApiService) DynamicSecretCreateArtifactory(ctx context.Context) ApiDynamicSecretCreateArtifactoryRequest {
	return ApiDynamicSecretCreateArtifactoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretCreateOutput
func (a *V2ApiService) DynamicSecretCreateArtifactoryExecute(r ApiDynamicSecretCreateArtifactoryRequest) (*DynamicSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretCreateArtifactory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-create-artifactory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretCreateAwsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretCreateAws *DynamicSecretCreateAws
    body interface{}
}

func (r ApiDynamicSecretCreateAwsRequest) DynamicSecretCreateAws(dynamicSecretCreateAws DynamicSecretCreateAws) ApiDynamicSecretCreateAwsRequest {
	r.dynamicSecretCreateAws = &dynamicSecretCreateAws
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretCreateAwsRequest) Body(body DynamicSecretCreateAws) ApiDynamicSecretCreateAwsRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretCreateAwsRequest) Execute() (*DynamicSecretCreateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretCreateAwsExecute(r)
}

/*
DynamicSecretCreateAws Method for DynamicSecretCreateAws

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretCreateAwsRequest
*/
func (a *V2ApiService) DynamicSecretCreateAws(ctx context.Context) ApiDynamicSecretCreateAwsRequest {
	return ApiDynamicSecretCreateAwsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretCreateOutput
func (a *V2ApiService) DynamicSecretCreateAwsExecute(r ApiDynamicSecretCreateAwsRequest) (*DynamicSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretCreateAws")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-create-aws"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretCreateAzureRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretCreateAzure *DynamicSecretCreateAzure
    body interface{}
}

func (r ApiDynamicSecretCreateAzureRequest) DynamicSecretCreateAzure(dynamicSecretCreateAzure DynamicSecretCreateAzure) ApiDynamicSecretCreateAzureRequest {
	r.dynamicSecretCreateAzure = &dynamicSecretCreateAzure
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretCreateAzureRequest) Body(body DynamicSecretCreateAzure) ApiDynamicSecretCreateAzureRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretCreateAzureRequest) Execute() (*DynamicSecretCreateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretCreateAzureExecute(r)
}

/*
DynamicSecretCreateAzure Method for DynamicSecretCreateAzure

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretCreateAzureRequest
*/
func (a *V2ApiService) DynamicSecretCreateAzure(ctx context.Context) ApiDynamicSecretCreateAzureRequest {
	return ApiDynamicSecretCreateAzureRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretCreateOutput
func (a *V2ApiService) DynamicSecretCreateAzureExecute(r ApiDynamicSecretCreateAzureRequest) (*DynamicSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretCreateAzure")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-create-azure"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretCreateCassandraRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretCreateCassandra *DynamicSecretCreateCassandra
    body interface{}
}

func (r ApiDynamicSecretCreateCassandraRequest) DynamicSecretCreateCassandra(dynamicSecretCreateCassandra DynamicSecretCreateCassandra) ApiDynamicSecretCreateCassandraRequest {
	r.dynamicSecretCreateCassandra = &dynamicSecretCreateCassandra
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretCreateCassandraRequest) Body(body DynamicSecretCreateCassandra) ApiDynamicSecretCreateCassandraRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretCreateCassandraRequest) Execute() (*DynamicSecretCreateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretCreateCassandraExecute(r)
}

/*
DynamicSecretCreateCassandra Method for DynamicSecretCreateCassandra

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretCreateCassandraRequest
*/
func (a *V2ApiService) DynamicSecretCreateCassandra(ctx context.Context) ApiDynamicSecretCreateCassandraRequest {
	return ApiDynamicSecretCreateCassandraRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretCreateOutput
func (a *V2ApiService) DynamicSecretCreateCassandraExecute(r ApiDynamicSecretCreateCassandraRequest) (*DynamicSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretCreateCassandra")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-create-cassandra"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretCreateCustomRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretCreateCustom *DynamicSecretCreateCustom
    body interface{}
}

func (r ApiDynamicSecretCreateCustomRequest) DynamicSecretCreateCustom(dynamicSecretCreateCustom DynamicSecretCreateCustom) ApiDynamicSecretCreateCustomRequest {
	r.dynamicSecretCreateCustom = &dynamicSecretCreateCustom
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretCreateCustomRequest) Body(body DynamicSecretCreateCustom) ApiDynamicSecretCreateCustomRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretCreateCustomRequest) Execute() (*DynamicSecretCreateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretCreateCustomExecute(r)
}

/*
DynamicSecretCreateCustom Method for DynamicSecretCreateCustom

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretCreateCustomRequest
*/
func (a *V2ApiService) DynamicSecretCreateCustom(ctx context.Context) ApiDynamicSecretCreateCustomRequest {
	return ApiDynamicSecretCreateCustomRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretCreateOutput
func (a *V2ApiService) DynamicSecretCreateCustomExecute(r ApiDynamicSecretCreateCustomRequest) (*DynamicSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretCreateCustom")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-create-custom"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretCreateDockerhubRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretCreateDockerhub *DynamicSecretCreateDockerhub
    body interface{}
}

func (r ApiDynamicSecretCreateDockerhubRequest) DynamicSecretCreateDockerhub(dynamicSecretCreateDockerhub DynamicSecretCreateDockerhub) ApiDynamicSecretCreateDockerhubRequest {
	r.dynamicSecretCreateDockerhub = &dynamicSecretCreateDockerhub
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretCreateDockerhubRequest) Body(body DynamicSecretCreateDockerhub) ApiDynamicSecretCreateDockerhubRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretCreateDockerhubRequest) Execute() (*DynamicSecretCreateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretCreateDockerhubExecute(r)
}

/*
DynamicSecretCreateDockerhub Method for DynamicSecretCreateDockerhub

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretCreateDockerhubRequest
*/
func (a *V2ApiService) DynamicSecretCreateDockerhub(ctx context.Context) ApiDynamicSecretCreateDockerhubRequest {
	return ApiDynamicSecretCreateDockerhubRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretCreateOutput
func (a *V2ApiService) DynamicSecretCreateDockerhubExecute(r ApiDynamicSecretCreateDockerhubRequest) (*DynamicSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretCreateDockerhub")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-create-dockerhub"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretCreateEksRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretCreateEks *DynamicSecretCreateEks
    body interface{}
}

func (r ApiDynamicSecretCreateEksRequest) DynamicSecretCreateEks(dynamicSecretCreateEks DynamicSecretCreateEks) ApiDynamicSecretCreateEksRequest {
	r.dynamicSecretCreateEks = &dynamicSecretCreateEks
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretCreateEksRequest) Body(body DynamicSecretCreateEks) ApiDynamicSecretCreateEksRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretCreateEksRequest) Execute() (*DynamicSecretCreateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretCreateEksExecute(r)
}

/*
DynamicSecretCreateEks Method for DynamicSecretCreateEks

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretCreateEksRequest
*/
func (a *V2ApiService) DynamicSecretCreateEks(ctx context.Context) ApiDynamicSecretCreateEksRequest {
	return ApiDynamicSecretCreateEksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretCreateOutput
func (a *V2ApiService) DynamicSecretCreateEksExecute(r ApiDynamicSecretCreateEksRequest) (*DynamicSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretCreateEks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-create-eks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretCreateGcpRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretCreateGcp *DynamicSecretCreateGcp
    body interface{}
}

func (r ApiDynamicSecretCreateGcpRequest) DynamicSecretCreateGcp(dynamicSecretCreateGcp DynamicSecretCreateGcp) ApiDynamicSecretCreateGcpRequest {
	r.dynamicSecretCreateGcp = &dynamicSecretCreateGcp
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretCreateGcpRequest) Body(body DynamicSecretCreateGcp) ApiDynamicSecretCreateGcpRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretCreateGcpRequest) Execute() (*DynamicSecretCreateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretCreateGcpExecute(r)
}

/*
DynamicSecretCreateGcp Method for DynamicSecretCreateGcp

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretCreateGcpRequest
*/
func (a *V2ApiService) DynamicSecretCreateGcp(ctx context.Context) ApiDynamicSecretCreateGcpRequest {
	return ApiDynamicSecretCreateGcpRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretCreateOutput
func (a *V2ApiService) DynamicSecretCreateGcpExecute(r ApiDynamicSecretCreateGcpRequest) (*DynamicSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretCreateGcp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-create-gcp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretCreateGithubRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretCreateGithub *DynamicSecretCreateGithub
    body interface{}
}

func (r ApiDynamicSecretCreateGithubRequest) DynamicSecretCreateGithub(dynamicSecretCreateGithub DynamicSecretCreateGithub) ApiDynamicSecretCreateGithubRequest {
	r.dynamicSecretCreateGithub = &dynamicSecretCreateGithub
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretCreateGithubRequest) Body(body DynamicSecretCreateGithub) ApiDynamicSecretCreateGithubRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretCreateGithubRequest) Execute() (*DynamicSecretCreateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretCreateGithubExecute(r)
}

/*
DynamicSecretCreateGithub Method for DynamicSecretCreateGithub

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretCreateGithubRequest
*/
func (a *V2ApiService) DynamicSecretCreateGithub(ctx context.Context) ApiDynamicSecretCreateGithubRequest {
	return ApiDynamicSecretCreateGithubRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretCreateOutput
func (a *V2ApiService) DynamicSecretCreateGithubExecute(r ApiDynamicSecretCreateGithubRequest) (*DynamicSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretCreateGithub")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-create-github"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretCreateGitlabRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretCreateGitlab *DynamicSecretCreateGitlab
    body interface{}
}

func (r ApiDynamicSecretCreateGitlabRequest) DynamicSecretCreateGitlab(dynamicSecretCreateGitlab DynamicSecretCreateGitlab) ApiDynamicSecretCreateGitlabRequest {
	r.dynamicSecretCreateGitlab = &dynamicSecretCreateGitlab
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretCreateGitlabRequest) Body(body DynamicSecretCreateGitlab) ApiDynamicSecretCreateGitlabRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretCreateGitlabRequest) Execute() (*DynamicSecretCreateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretCreateGitlabExecute(r)
}

/*
DynamicSecretCreateGitlab Method for DynamicSecretCreateGitlab

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretCreateGitlabRequest
*/
func (a *V2ApiService) DynamicSecretCreateGitlab(ctx context.Context) ApiDynamicSecretCreateGitlabRequest {
	return ApiDynamicSecretCreateGitlabRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretCreateOutput
func (a *V2ApiService) DynamicSecretCreateGitlabExecute(r ApiDynamicSecretCreateGitlabRequest) (*DynamicSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretCreateGitlab")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-create-gitlab"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretCreateGkeRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretCreateGke *DynamicSecretCreateGke
    body interface{}
}

func (r ApiDynamicSecretCreateGkeRequest) DynamicSecretCreateGke(dynamicSecretCreateGke DynamicSecretCreateGke) ApiDynamicSecretCreateGkeRequest {
	r.dynamicSecretCreateGke = &dynamicSecretCreateGke
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretCreateGkeRequest) Body(body DynamicSecretCreateGke) ApiDynamicSecretCreateGkeRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretCreateGkeRequest) Execute() (*DynamicSecretCreateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretCreateGkeExecute(r)
}

/*
DynamicSecretCreateGke Method for DynamicSecretCreateGke

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretCreateGkeRequest
*/
func (a *V2ApiService) DynamicSecretCreateGke(ctx context.Context) ApiDynamicSecretCreateGkeRequest {
	return ApiDynamicSecretCreateGkeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretCreateOutput
func (a *V2ApiService) DynamicSecretCreateGkeExecute(r ApiDynamicSecretCreateGkeRequest) (*DynamicSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretCreateGke")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-create-gke"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretCreateGoogleWorkspaceRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretCreateGoogleWorkspace *DynamicSecretCreateGoogleWorkspace
    body interface{}
}

func (r ApiDynamicSecretCreateGoogleWorkspaceRequest) DynamicSecretCreateGoogleWorkspace(dynamicSecretCreateGoogleWorkspace DynamicSecretCreateGoogleWorkspace) ApiDynamicSecretCreateGoogleWorkspaceRequest {
	r.dynamicSecretCreateGoogleWorkspace = &dynamicSecretCreateGoogleWorkspace
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretCreateGoogleWorkspaceRequest) Body(body DynamicSecretCreateGoogleWorkspace) ApiDynamicSecretCreateGoogleWorkspaceRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretCreateGoogleWorkspaceRequest) Execute() (*DynamicSecretCreateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretCreateGoogleWorkspaceExecute(r)
}

/*
DynamicSecretCreateGoogleWorkspace Method for DynamicSecretCreateGoogleWorkspace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretCreateGoogleWorkspaceRequest
*/
func (a *V2ApiService) DynamicSecretCreateGoogleWorkspace(ctx context.Context) ApiDynamicSecretCreateGoogleWorkspaceRequest {
	return ApiDynamicSecretCreateGoogleWorkspaceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretCreateOutput
func (a *V2ApiService) DynamicSecretCreateGoogleWorkspaceExecute(r ApiDynamicSecretCreateGoogleWorkspaceRequest) (*DynamicSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretCreateGoogleWorkspace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-create-google-workspace"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretCreateHanaDbRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretCreateHanaDb *DynamicSecretCreateHanaDb
    body interface{}
}

func (r ApiDynamicSecretCreateHanaDbRequest) DynamicSecretCreateHanaDb(dynamicSecretCreateHanaDb DynamicSecretCreateHanaDb) ApiDynamicSecretCreateHanaDbRequest {
	r.dynamicSecretCreateHanaDb = &dynamicSecretCreateHanaDb
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretCreateHanaDbRequest) Body(body DynamicSecretCreateHanaDb) ApiDynamicSecretCreateHanaDbRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretCreateHanaDbRequest) Execute() (*DynamicSecretCreateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretCreateHanaDbExecute(r)
}

/*
DynamicSecretCreateHanaDb Method for DynamicSecretCreateHanaDb

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretCreateHanaDbRequest
*/
func (a *V2ApiService) DynamicSecretCreateHanaDb(ctx context.Context) ApiDynamicSecretCreateHanaDbRequest {
	return ApiDynamicSecretCreateHanaDbRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretCreateOutput
func (a *V2ApiService) DynamicSecretCreateHanaDbExecute(r ApiDynamicSecretCreateHanaDbRequest) (*DynamicSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretCreateHanaDb")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-create-hanadb"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretCreateK8sRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretCreateK8s *DynamicSecretCreateK8s
    body interface{}
}

func (r ApiDynamicSecretCreateK8sRequest) DynamicSecretCreateK8s(dynamicSecretCreateK8s DynamicSecretCreateK8s) ApiDynamicSecretCreateK8sRequest {
	r.dynamicSecretCreateK8s = &dynamicSecretCreateK8s
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretCreateK8sRequest) Body(body DynamicSecretCreateK8s) ApiDynamicSecretCreateK8sRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretCreateK8sRequest) Execute() (*DynamicSecretCreateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretCreateK8sExecute(r)
}

/*
DynamicSecretCreateK8s Method for DynamicSecretCreateK8s

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretCreateK8sRequest
*/
func (a *V2ApiService) DynamicSecretCreateK8s(ctx context.Context) ApiDynamicSecretCreateK8sRequest {
	return ApiDynamicSecretCreateK8sRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretCreateOutput
func (a *V2ApiService) DynamicSecretCreateK8sExecute(r ApiDynamicSecretCreateK8sRequest) (*DynamicSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretCreateK8s")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-create-k8s"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretCreateLdapRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretCreateLdap *DynamicSecretCreateLdap
    body interface{}
}

func (r ApiDynamicSecretCreateLdapRequest) DynamicSecretCreateLdap(dynamicSecretCreateLdap DynamicSecretCreateLdap) ApiDynamicSecretCreateLdapRequest {
	r.dynamicSecretCreateLdap = &dynamicSecretCreateLdap
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretCreateLdapRequest) Body(body DynamicSecretCreateLdap) ApiDynamicSecretCreateLdapRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretCreateLdapRequest) Execute() (*DynamicSecretCreateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretCreateLdapExecute(r)
}

/*
DynamicSecretCreateLdap Method for DynamicSecretCreateLdap

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretCreateLdapRequest
*/
func (a *V2ApiService) DynamicSecretCreateLdap(ctx context.Context) ApiDynamicSecretCreateLdapRequest {
	return ApiDynamicSecretCreateLdapRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretCreateOutput
func (a *V2ApiService) DynamicSecretCreateLdapExecute(r ApiDynamicSecretCreateLdapRequest) (*DynamicSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretCreateLdap")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-create-ldap"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretCreateMongoDbRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretCreateMongoDb *DynamicSecretCreateMongoDb
    body interface{}
}

func (r ApiDynamicSecretCreateMongoDbRequest) DynamicSecretCreateMongoDb(dynamicSecretCreateMongoDb DynamicSecretCreateMongoDb) ApiDynamicSecretCreateMongoDbRequest {
	r.dynamicSecretCreateMongoDb = &dynamicSecretCreateMongoDb
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretCreateMongoDbRequest) Body(body DynamicSecretCreateMongoDb) ApiDynamicSecretCreateMongoDbRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretCreateMongoDbRequest) Execute() (*DynamicSecretCreateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretCreateMongoDbExecute(r)
}

/*
DynamicSecretCreateMongoDb Method for DynamicSecretCreateMongoDb

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretCreateMongoDbRequest
*/
func (a *V2ApiService) DynamicSecretCreateMongoDb(ctx context.Context) ApiDynamicSecretCreateMongoDbRequest {
	return ApiDynamicSecretCreateMongoDbRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretCreateOutput
func (a *V2ApiService) DynamicSecretCreateMongoDbExecute(r ApiDynamicSecretCreateMongoDbRequest) (*DynamicSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretCreateMongoDb")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-create-mongodb"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretCreateMsSqlRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretCreateMsSql *DynamicSecretCreateMsSql
    body interface{}
}

func (r ApiDynamicSecretCreateMsSqlRequest) DynamicSecretCreateMsSql(dynamicSecretCreateMsSql DynamicSecretCreateMsSql) ApiDynamicSecretCreateMsSqlRequest {
	r.dynamicSecretCreateMsSql = &dynamicSecretCreateMsSql
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretCreateMsSqlRequest) Body(body DynamicSecretCreateMsSql) ApiDynamicSecretCreateMsSqlRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretCreateMsSqlRequest) Execute() (*DynamicSecretCreateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretCreateMsSqlExecute(r)
}

/*
DynamicSecretCreateMsSql Method for DynamicSecretCreateMsSql

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretCreateMsSqlRequest
*/
func (a *V2ApiService) DynamicSecretCreateMsSql(ctx context.Context) ApiDynamicSecretCreateMsSqlRequest {
	return ApiDynamicSecretCreateMsSqlRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretCreateOutput
func (a *V2ApiService) DynamicSecretCreateMsSqlExecute(r ApiDynamicSecretCreateMsSqlRequest) (*DynamicSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretCreateMsSql")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-create-mssql"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretCreateMySqlRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretCreateMySql *DynamicSecretCreateMySql
    body interface{}
}

func (r ApiDynamicSecretCreateMySqlRequest) DynamicSecretCreateMySql(dynamicSecretCreateMySql DynamicSecretCreateMySql) ApiDynamicSecretCreateMySqlRequest {
	r.dynamicSecretCreateMySql = &dynamicSecretCreateMySql
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretCreateMySqlRequest) Body(body DynamicSecretCreateMySql) ApiDynamicSecretCreateMySqlRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretCreateMySqlRequest) Execute() (*DynamicSecretCreateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretCreateMySqlExecute(r)
}

/*
DynamicSecretCreateMySql Method for DynamicSecretCreateMySql

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretCreateMySqlRequest
*/
func (a *V2ApiService) DynamicSecretCreateMySql(ctx context.Context) ApiDynamicSecretCreateMySqlRequest {
	return ApiDynamicSecretCreateMySqlRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretCreateOutput
func (a *V2ApiService) DynamicSecretCreateMySqlExecute(r ApiDynamicSecretCreateMySqlRequest) (*DynamicSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretCreateMySql")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-create-mysql"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretCreateOpenAIRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretCreateOpenAI *DynamicSecretCreateOpenAI
    body interface{}
}

func (r ApiDynamicSecretCreateOpenAIRequest) DynamicSecretCreateOpenAI(dynamicSecretCreateOpenAI DynamicSecretCreateOpenAI) ApiDynamicSecretCreateOpenAIRequest {
	r.dynamicSecretCreateOpenAI = &dynamicSecretCreateOpenAI
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretCreateOpenAIRequest) Body(body DynamicSecretCreateOpenAI) ApiDynamicSecretCreateOpenAIRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretCreateOpenAIRequest) Execute() (*DynamicSecretCreateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretCreateOpenAIExecute(r)
}

/*
DynamicSecretCreateOpenAI Method for DynamicSecretCreateOpenAI

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretCreateOpenAIRequest
*/
func (a *V2ApiService) DynamicSecretCreateOpenAI(ctx context.Context) ApiDynamicSecretCreateOpenAIRequest {
	return ApiDynamicSecretCreateOpenAIRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretCreateOutput
func (a *V2ApiService) DynamicSecretCreateOpenAIExecute(r ApiDynamicSecretCreateOpenAIRequest) (*DynamicSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretCreateOpenAI")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-create-openai"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretCreateOracleDbRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretCreateOracleDb *DynamicSecretCreateOracleDb
    body interface{}
}

func (r ApiDynamicSecretCreateOracleDbRequest) DynamicSecretCreateOracleDb(dynamicSecretCreateOracleDb DynamicSecretCreateOracleDb) ApiDynamicSecretCreateOracleDbRequest {
	r.dynamicSecretCreateOracleDb = &dynamicSecretCreateOracleDb
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretCreateOracleDbRequest) Body(body DynamicSecretCreateOracleDb) ApiDynamicSecretCreateOracleDbRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretCreateOracleDbRequest) Execute() (*DynamicSecretCreateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretCreateOracleDbExecute(r)
}

/*
DynamicSecretCreateOracleDb Method for DynamicSecretCreateOracleDb

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretCreateOracleDbRequest
*/
func (a *V2ApiService) DynamicSecretCreateOracleDb(ctx context.Context) ApiDynamicSecretCreateOracleDbRequest {
	return ApiDynamicSecretCreateOracleDbRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretCreateOutput
func (a *V2ApiService) DynamicSecretCreateOracleDbExecute(r ApiDynamicSecretCreateOracleDbRequest) (*DynamicSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretCreateOracleDb")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-create-oracle"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretCreatePingRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretCreatePing *DynamicSecretCreatePing
    body interface{}
}

func (r ApiDynamicSecretCreatePingRequest) DynamicSecretCreatePing(dynamicSecretCreatePing DynamicSecretCreatePing) ApiDynamicSecretCreatePingRequest {
	r.dynamicSecretCreatePing = &dynamicSecretCreatePing
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretCreatePingRequest) Body(body DynamicSecretCreatePing) ApiDynamicSecretCreatePingRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretCreatePingRequest) Execute() (*DynamicSecretCreateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretCreatePingExecute(r)
}

/*
DynamicSecretCreatePing Method for DynamicSecretCreatePing

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretCreatePingRequest
*/
func (a *V2ApiService) DynamicSecretCreatePing(ctx context.Context) ApiDynamicSecretCreatePingRequest {
	return ApiDynamicSecretCreatePingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretCreateOutput
func (a *V2ApiService) DynamicSecretCreatePingExecute(r ApiDynamicSecretCreatePingRequest) (*DynamicSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretCreatePing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-create-ping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretCreatePostgreSqlRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretCreatePostgreSql *DynamicSecretCreatePostgreSql
    body interface{}
}

func (r ApiDynamicSecretCreatePostgreSqlRequest) DynamicSecretCreatePostgreSql(dynamicSecretCreatePostgreSql DynamicSecretCreatePostgreSql) ApiDynamicSecretCreatePostgreSqlRequest {
	r.dynamicSecretCreatePostgreSql = &dynamicSecretCreatePostgreSql
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretCreatePostgreSqlRequest) Body(body DynamicSecretCreatePostgreSql) ApiDynamicSecretCreatePostgreSqlRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretCreatePostgreSqlRequest) Execute() (*DynamicSecretCreateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretCreatePostgreSqlExecute(r)
}

/*
DynamicSecretCreatePostgreSql Method for DynamicSecretCreatePostgreSql

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretCreatePostgreSqlRequest
*/
func (a *V2ApiService) DynamicSecretCreatePostgreSql(ctx context.Context) ApiDynamicSecretCreatePostgreSqlRequest {
	return ApiDynamicSecretCreatePostgreSqlRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretCreateOutput
func (a *V2ApiService) DynamicSecretCreatePostgreSqlExecute(r ApiDynamicSecretCreatePostgreSqlRequest) (*DynamicSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretCreatePostgreSql")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-create-postgresql"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretCreateRabbitMqRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretCreateRabbitMq *DynamicSecretCreateRabbitMq
    body interface{}
}

func (r ApiDynamicSecretCreateRabbitMqRequest) DynamicSecretCreateRabbitMq(dynamicSecretCreateRabbitMq DynamicSecretCreateRabbitMq) ApiDynamicSecretCreateRabbitMqRequest {
	r.dynamicSecretCreateRabbitMq = &dynamicSecretCreateRabbitMq
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretCreateRabbitMqRequest) Body(body DynamicSecretCreateRabbitMq) ApiDynamicSecretCreateRabbitMqRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretCreateRabbitMqRequest) Execute() (*DynamicSecretCreateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretCreateRabbitMqExecute(r)
}

/*
DynamicSecretCreateRabbitMq Method for DynamicSecretCreateRabbitMq

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretCreateRabbitMqRequest
*/
func (a *V2ApiService) DynamicSecretCreateRabbitMq(ctx context.Context) ApiDynamicSecretCreateRabbitMqRequest {
	return ApiDynamicSecretCreateRabbitMqRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretCreateOutput
func (a *V2ApiService) DynamicSecretCreateRabbitMqExecute(r ApiDynamicSecretCreateRabbitMqRequest) (*DynamicSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretCreateRabbitMq")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-create-rabbitmq"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretCreateRdpRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretCreateRdp *DynamicSecretCreateRdp
    body interface{}
}

func (r ApiDynamicSecretCreateRdpRequest) DynamicSecretCreateRdp(dynamicSecretCreateRdp DynamicSecretCreateRdp) ApiDynamicSecretCreateRdpRequest {
	r.dynamicSecretCreateRdp = &dynamicSecretCreateRdp
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretCreateRdpRequest) Body(body DynamicSecretCreateRdp) ApiDynamicSecretCreateRdpRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretCreateRdpRequest) Execute() (*DynamicSecretCreateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretCreateRdpExecute(r)
}

/*
DynamicSecretCreateRdp Method for DynamicSecretCreateRdp

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretCreateRdpRequest
*/
func (a *V2ApiService) DynamicSecretCreateRdp(ctx context.Context) ApiDynamicSecretCreateRdpRequest {
	return ApiDynamicSecretCreateRdpRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretCreateOutput
func (a *V2ApiService) DynamicSecretCreateRdpExecute(r ApiDynamicSecretCreateRdpRequest) (*DynamicSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretCreateRdp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-create-rdp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretCreateRedisRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretCreateRedis *DynamicSecretCreateRedis
    body interface{}
}

func (r ApiDynamicSecretCreateRedisRequest) DynamicSecretCreateRedis(dynamicSecretCreateRedis DynamicSecretCreateRedis) ApiDynamicSecretCreateRedisRequest {
	r.dynamicSecretCreateRedis = &dynamicSecretCreateRedis
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretCreateRedisRequest) Body(body DynamicSecretCreateRedis) ApiDynamicSecretCreateRedisRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretCreateRedisRequest) Execute() (*DynamicSecretCreateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretCreateRedisExecute(r)
}

/*
DynamicSecretCreateRedis Method for DynamicSecretCreateRedis

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretCreateRedisRequest
*/
func (a *V2ApiService) DynamicSecretCreateRedis(ctx context.Context) ApiDynamicSecretCreateRedisRequest {
	return ApiDynamicSecretCreateRedisRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretCreateOutput
func (a *V2ApiService) DynamicSecretCreateRedisExecute(r ApiDynamicSecretCreateRedisRequest) (*DynamicSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretCreateRedis")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-create-redis"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretCreateRedshiftRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretCreateRedshift *DynamicSecretCreateRedshift
    body interface{}
}

func (r ApiDynamicSecretCreateRedshiftRequest) DynamicSecretCreateRedshift(dynamicSecretCreateRedshift DynamicSecretCreateRedshift) ApiDynamicSecretCreateRedshiftRequest {
	r.dynamicSecretCreateRedshift = &dynamicSecretCreateRedshift
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretCreateRedshiftRequest) Body(body DynamicSecretCreateRedshift) ApiDynamicSecretCreateRedshiftRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretCreateRedshiftRequest) Execute() (*DynamicSecretCreateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretCreateRedshiftExecute(r)
}

/*
DynamicSecretCreateRedshift Method for DynamicSecretCreateRedshift

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretCreateRedshiftRequest
*/
func (a *V2ApiService) DynamicSecretCreateRedshift(ctx context.Context) ApiDynamicSecretCreateRedshiftRequest {
	return ApiDynamicSecretCreateRedshiftRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretCreateOutput
func (a *V2ApiService) DynamicSecretCreateRedshiftExecute(r ApiDynamicSecretCreateRedshiftRequest) (*DynamicSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretCreateRedshift")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-create-redshift"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretCreateSnowflakeRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretCreateSnowflake *DynamicSecretCreateSnowflake
    body interface{}
}

func (r ApiDynamicSecretCreateSnowflakeRequest) DynamicSecretCreateSnowflake(dynamicSecretCreateSnowflake DynamicSecretCreateSnowflake) ApiDynamicSecretCreateSnowflakeRequest {
	r.dynamicSecretCreateSnowflake = &dynamicSecretCreateSnowflake
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretCreateSnowflakeRequest) Body(body DynamicSecretCreateSnowflake) ApiDynamicSecretCreateSnowflakeRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretCreateSnowflakeRequest) Execute() (*DynamicSecretCreateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretCreateSnowflakeExecute(r)
}

/*
DynamicSecretCreateSnowflake Method for DynamicSecretCreateSnowflake

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretCreateSnowflakeRequest
*/
func (a *V2ApiService) DynamicSecretCreateSnowflake(ctx context.Context) ApiDynamicSecretCreateSnowflakeRequest {
	return ApiDynamicSecretCreateSnowflakeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretCreateOutput
func (a *V2ApiService) DynamicSecretCreateSnowflakeExecute(r ApiDynamicSecretCreateSnowflakeRequest) (*DynamicSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretCreateSnowflake")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-create-snowflake"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretCreateVenafiRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretCreateVenafi *DynamicSecretCreateVenafi
    body interface{}
}

func (r ApiDynamicSecretCreateVenafiRequest) DynamicSecretCreateVenafi(dynamicSecretCreateVenafi DynamicSecretCreateVenafi) ApiDynamicSecretCreateVenafiRequest {
	r.dynamicSecretCreateVenafi = &dynamicSecretCreateVenafi
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretCreateVenafiRequest) Body(body DynamicSecretCreateVenafi) ApiDynamicSecretCreateVenafiRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretCreateVenafiRequest) Execute() (*DynamicSecretCreateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretCreateVenafiExecute(r)
}

/*
DynamicSecretCreateVenafi Method for DynamicSecretCreateVenafi

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretCreateVenafiRequest
*/
func (a *V2ApiService) DynamicSecretCreateVenafi(ctx context.Context) ApiDynamicSecretCreateVenafiRequest {
	return ApiDynamicSecretCreateVenafiRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretCreateOutput
func (a *V2ApiService) DynamicSecretCreateVenafiExecute(r ApiDynamicSecretCreateVenafiRequest) (*DynamicSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretCreateVenafi")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-create-venafi"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretDeleteRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretDelete *DynamicSecretDelete
    body interface{}
}

func (r ApiDynamicSecretDeleteRequest) DynamicSecretDelete(dynamicSecretDelete DynamicSecretDelete) ApiDynamicSecretDeleteRequest {
	r.dynamicSecretDelete = &dynamicSecretDelete
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretDeleteRequest) Body(body DynamicSecretDelete) ApiDynamicSecretDeleteRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretDeleteRequest) Execute() (*DynamicSecretDeleteOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretDeleteExecute(r)
}

/*
DynamicSecretDelete Method for DynamicSecretDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretDeleteRequest
*/
func (a *V2ApiService) DynamicSecretDelete(ctx context.Context) ApiDynamicSecretDeleteRequest {
	return ApiDynamicSecretDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretDeleteOutput
func (a *V2ApiService) DynamicSecretDeleteExecute(r ApiDynamicSecretDeleteRequest) (*DynamicSecretDeleteOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretDeleteOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretGetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretGet *DynamicSecretGet
    body interface{}
}

func (r ApiDynamicSecretGetRequest) DynamicSecretGet(dynamicSecretGet DynamicSecretGet) ApiDynamicSecretGetRequest {
	r.dynamicSecretGet = &dynamicSecretGet
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretGetRequest) Body(body DynamicSecretGet) ApiDynamicSecretGetRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretGetRequest) Execute() (*DSProducerDetails, *http.Response, error) {
	return r.ApiService.DynamicSecretGetExecute(r)
}

/*
DynamicSecretGet Method for DynamicSecretGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretGetRequest
*/
func (a *V2ApiService) DynamicSecretGet(ctx context.Context) ApiDynamicSecretGetRequest {
	return ApiDynamicSecretGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DSProducerDetails
func (a *V2ApiService) DynamicSecretGetExecute(r ApiDynamicSecretGetRequest) (*DSProducerDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DSProducerDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretGetValueRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretGetValue *DynamicSecretGetValue
    body interface{}
}

func (r ApiDynamicSecretGetValueRequest) DynamicSecretGetValue(dynamicSecretGetValue DynamicSecretGetValue) ApiDynamicSecretGetValueRequest {
	r.dynamicSecretGetValue = &dynamicSecretGetValue
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretGetValueRequest) Body(body DynamicSecretGetValue) ApiDynamicSecretGetValueRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretGetValueRequest) Execute() (map[string]string, *http.Response, error) {
	return r.ApiService.DynamicSecretGetValueExecute(r)
}

/*
DynamicSecretGetValue Method for DynamicSecretGetValue

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretGetValueRequest
*/
func (a *V2ApiService) DynamicSecretGetValue(ctx context.Context) ApiDynamicSecretGetValueRequest {
	return ApiDynamicSecretGetValueRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]string
func (a *V2ApiService) DynamicSecretGetValueExecute(r ApiDynamicSecretGetValueRequest) (map[string]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretGetValue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-get-value"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretListRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretList *DynamicSecretList
    body interface{}
}

func (r ApiDynamicSecretListRequest) DynamicSecretList(dynamicSecretList DynamicSecretList) ApiDynamicSecretListRequest {
	r.dynamicSecretList = &dynamicSecretList
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretListRequest) Body(body DynamicSecretList) ApiDynamicSecretListRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretListRequest) Execute() (*GetProducersListReplyObj, *http.Response, error) {
	return r.ApiService.DynamicSecretListExecute(r)
}

/*
DynamicSecretList Method for DynamicSecretList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretListRequest
*/
func (a *V2ApiService) DynamicSecretList(ctx context.Context) ApiDynamicSecretListRequest {
	return ApiDynamicSecretListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetProducersListReplyObj
func (a *V2ApiService) DynamicSecretListExecute(r ApiDynamicSecretListRequest) (*GetProducersListReplyObj, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetProducersListReplyObj
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretTmpCredsDeleteRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretTmpCredsDelete *DynamicSecretTmpCredsDelete
    body interface{}
}

func (r ApiDynamicSecretTmpCredsDeleteRequest) DynamicSecretTmpCredsDelete(dynamicSecretTmpCredsDelete DynamicSecretTmpCredsDelete) ApiDynamicSecretTmpCredsDeleteRequest {
	r.dynamicSecretTmpCredsDelete = &dynamicSecretTmpCredsDelete
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretTmpCredsDeleteRequest) Body(body DynamicSecretTmpCredsDelete) ApiDynamicSecretTmpCredsDeleteRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretTmpCredsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DynamicSecretTmpCredsDeleteExecute(r)
}

/*
DynamicSecretTmpCredsDelete Method for DynamicSecretTmpCredsDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretTmpCredsDeleteRequest
*/
func (a *V2ApiService) DynamicSecretTmpCredsDelete(ctx context.Context) ApiDynamicSecretTmpCredsDeleteRequest {
	return ApiDynamicSecretTmpCredsDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *V2ApiService) DynamicSecretTmpCredsDeleteExecute(r ApiDynamicSecretTmpCredsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretTmpCredsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-tmp-creds-delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDynamicSecretTmpCredsGetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretTmpCredsGet *DynamicSecretTmpCredsGet
    body interface{}
}

func (r ApiDynamicSecretTmpCredsGetRequest) DynamicSecretTmpCredsGet(dynamicSecretTmpCredsGet DynamicSecretTmpCredsGet) ApiDynamicSecretTmpCredsGetRequest {
	r.dynamicSecretTmpCredsGet = &dynamicSecretTmpCredsGet
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretTmpCredsGetRequest) Body(body DynamicSecretTmpCredsGet) ApiDynamicSecretTmpCredsGetRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretTmpCredsGetRequest) Execute() ([]TmpUserData, *http.Response, error) {
	return r.ApiService.DynamicSecretTmpCredsGetExecute(r)
}

/*
DynamicSecretTmpCredsGet Method for DynamicSecretTmpCredsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretTmpCredsGetRequest
*/
func (a *V2ApiService) DynamicSecretTmpCredsGet(ctx context.Context) ApiDynamicSecretTmpCredsGetRequest {
	return ApiDynamicSecretTmpCredsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []TmpUserData
func (a *V2ApiService) DynamicSecretTmpCredsGetExecute(r ApiDynamicSecretTmpCredsGetRequest) ([]TmpUserData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TmpUserData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretTmpCredsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-tmp-creds-Get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretTmpCredsUpdateRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretTmpCredsUpdate *DynamicSecretTmpCredsUpdate
    body interface{}
}

func (r ApiDynamicSecretTmpCredsUpdateRequest) DynamicSecretTmpCredsUpdate(dynamicSecretTmpCredsUpdate DynamicSecretTmpCredsUpdate) ApiDynamicSecretTmpCredsUpdateRequest {
	r.dynamicSecretTmpCredsUpdate = &dynamicSecretTmpCredsUpdate
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretTmpCredsUpdateRequest) Body(body DynamicSecretTmpCredsUpdate) ApiDynamicSecretTmpCredsUpdateRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretTmpCredsUpdateRequest) Execute() (*http.Response, error) {
	return r.ApiService.DynamicSecretTmpCredsUpdateExecute(r)
}

/*
DynamicSecretTmpCredsUpdate Method for DynamicSecretTmpCredsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretTmpCredsUpdateRequest
*/
func (a *V2ApiService) DynamicSecretTmpCredsUpdate(ctx context.Context) ApiDynamicSecretTmpCredsUpdateRequest {
	return ApiDynamicSecretTmpCredsUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *V2ApiService) DynamicSecretTmpCredsUpdateExecute(r ApiDynamicSecretTmpCredsUpdateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretTmpCredsUpdate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-tmp-creds-update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDynamicSecretUpdateArtifactoryRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretUpdateArtifactory *DynamicSecretUpdateArtifactory
    body interface{}
}

func (r ApiDynamicSecretUpdateArtifactoryRequest) DynamicSecretUpdateArtifactory(dynamicSecretUpdateArtifactory DynamicSecretUpdateArtifactory) ApiDynamicSecretUpdateArtifactoryRequest {
	r.dynamicSecretUpdateArtifactory = &dynamicSecretUpdateArtifactory
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretUpdateArtifactoryRequest) Body(body DynamicSecretUpdateArtifactory) ApiDynamicSecretUpdateArtifactoryRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretUpdateArtifactoryRequest) Execute() (*DynamicSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretUpdateArtifactoryExecute(r)
}

/*
DynamicSecretUpdateArtifactory Method for DynamicSecretUpdateArtifactory

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretUpdateArtifactoryRequest
*/
func (a *V2ApiService) DynamicSecretUpdateArtifactory(ctx context.Context) ApiDynamicSecretUpdateArtifactoryRequest {
	return ApiDynamicSecretUpdateArtifactoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretUpdateOutput
func (a *V2ApiService) DynamicSecretUpdateArtifactoryExecute(r ApiDynamicSecretUpdateArtifactoryRequest) (*DynamicSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretUpdateArtifactory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-update-artifactory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretUpdateAwsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretUpdateAws *DynamicSecretUpdateAws
    body interface{}
}

func (r ApiDynamicSecretUpdateAwsRequest) DynamicSecretUpdateAws(dynamicSecretUpdateAws DynamicSecretUpdateAws) ApiDynamicSecretUpdateAwsRequest {
	r.dynamicSecretUpdateAws = &dynamicSecretUpdateAws
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretUpdateAwsRequest) Body(body DynamicSecretUpdateAws) ApiDynamicSecretUpdateAwsRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretUpdateAwsRequest) Execute() (*DynamicSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretUpdateAwsExecute(r)
}

/*
DynamicSecretUpdateAws Method for DynamicSecretUpdateAws

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretUpdateAwsRequest
*/
func (a *V2ApiService) DynamicSecretUpdateAws(ctx context.Context) ApiDynamicSecretUpdateAwsRequest {
	return ApiDynamicSecretUpdateAwsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretUpdateOutput
func (a *V2ApiService) DynamicSecretUpdateAwsExecute(r ApiDynamicSecretUpdateAwsRequest) (*DynamicSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretUpdateAws")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-update-aws"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretUpdateAzureRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretUpdateAzure *DynamicSecretUpdateAzure
    body interface{}
}

func (r ApiDynamicSecretUpdateAzureRequest) DynamicSecretUpdateAzure(dynamicSecretUpdateAzure DynamicSecretUpdateAzure) ApiDynamicSecretUpdateAzureRequest {
	r.dynamicSecretUpdateAzure = &dynamicSecretUpdateAzure
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretUpdateAzureRequest) Body(body DynamicSecretUpdateAzure) ApiDynamicSecretUpdateAzureRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretUpdateAzureRequest) Execute() (*DynamicSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretUpdateAzureExecute(r)
}

/*
DynamicSecretUpdateAzure Method for DynamicSecretUpdateAzure

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretUpdateAzureRequest
*/
func (a *V2ApiService) DynamicSecretUpdateAzure(ctx context.Context) ApiDynamicSecretUpdateAzureRequest {
	return ApiDynamicSecretUpdateAzureRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretUpdateOutput
func (a *V2ApiService) DynamicSecretUpdateAzureExecute(r ApiDynamicSecretUpdateAzureRequest) (*DynamicSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretUpdateAzure")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-update-azure"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretUpdateCassandraRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretUpdateCassandra *DynamicSecretUpdateCassandra
    body interface{}
}

func (r ApiDynamicSecretUpdateCassandraRequest) DynamicSecretUpdateCassandra(dynamicSecretUpdateCassandra DynamicSecretUpdateCassandra) ApiDynamicSecretUpdateCassandraRequest {
	r.dynamicSecretUpdateCassandra = &dynamicSecretUpdateCassandra
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretUpdateCassandraRequest) Body(body DynamicSecretUpdateCassandra) ApiDynamicSecretUpdateCassandraRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretUpdateCassandraRequest) Execute() (*DynamicSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretUpdateCassandraExecute(r)
}

/*
DynamicSecretUpdateCassandra Method for DynamicSecretUpdateCassandra

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretUpdateCassandraRequest
*/
func (a *V2ApiService) DynamicSecretUpdateCassandra(ctx context.Context) ApiDynamicSecretUpdateCassandraRequest {
	return ApiDynamicSecretUpdateCassandraRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretUpdateOutput
func (a *V2ApiService) DynamicSecretUpdateCassandraExecute(r ApiDynamicSecretUpdateCassandraRequest) (*DynamicSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretUpdateCassandra")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-update-cassandra"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretUpdateCustomRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretUpdateCustom *DynamicSecretUpdateCustom
    body interface{}
}

func (r ApiDynamicSecretUpdateCustomRequest) DynamicSecretUpdateCustom(dynamicSecretUpdateCustom DynamicSecretUpdateCustom) ApiDynamicSecretUpdateCustomRequest {
	r.dynamicSecretUpdateCustom = &dynamicSecretUpdateCustom
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretUpdateCustomRequest) Body(body DynamicSecretUpdateCustom) ApiDynamicSecretUpdateCustomRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretUpdateCustomRequest) Execute() (*DynamicSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretUpdateCustomExecute(r)
}

/*
DynamicSecretUpdateCustom Method for DynamicSecretUpdateCustom

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretUpdateCustomRequest
*/
func (a *V2ApiService) DynamicSecretUpdateCustom(ctx context.Context) ApiDynamicSecretUpdateCustomRequest {
	return ApiDynamicSecretUpdateCustomRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretUpdateOutput
func (a *V2ApiService) DynamicSecretUpdateCustomExecute(r ApiDynamicSecretUpdateCustomRequest) (*DynamicSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretUpdateCustom")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-update-custom"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretUpdateDockerhubRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretUpdateDockerhub *DynamicSecretUpdateDockerhub
    body interface{}
}

func (r ApiDynamicSecretUpdateDockerhubRequest) DynamicSecretUpdateDockerhub(dynamicSecretUpdateDockerhub DynamicSecretUpdateDockerhub) ApiDynamicSecretUpdateDockerhubRequest {
	r.dynamicSecretUpdateDockerhub = &dynamicSecretUpdateDockerhub
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretUpdateDockerhubRequest) Body(body DynamicSecretUpdateDockerhub) ApiDynamicSecretUpdateDockerhubRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretUpdateDockerhubRequest) Execute() (*DynamicSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretUpdateDockerhubExecute(r)
}

/*
DynamicSecretUpdateDockerhub Method for DynamicSecretUpdateDockerhub

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretUpdateDockerhubRequest
*/
func (a *V2ApiService) DynamicSecretUpdateDockerhub(ctx context.Context) ApiDynamicSecretUpdateDockerhubRequest {
	return ApiDynamicSecretUpdateDockerhubRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretUpdateOutput
func (a *V2ApiService) DynamicSecretUpdateDockerhubExecute(r ApiDynamicSecretUpdateDockerhubRequest) (*DynamicSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretUpdateDockerhub")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-update-dockerhub"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretUpdateEksRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretUpdateEks *DynamicSecretUpdateEks
    body interface{}
}

func (r ApiDynamicSecretUpdateEksRequest) DynamicSecretUpdateEks(dynamicSecretUpdateEks DynamicSecretUpdateEks) ApiDynamicSecretUpdateEksRequest {
	r.dynamicSecretUpdateEks = &dynamicSecretUpdateEks
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretUpdateEksRequest) Body(body DynamicSecretUpdateEks) ApiDynamicSecretUpdateEksRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretUpdateEksRequest) Execute() (*DynamicSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretUpdateEksExecute(r)
}

/*
DynamicSecretUpdateEks Method for DynamicSecretUpdateEks

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretUpdateEksRequest
*/
func (a *V2ApiService) DynamicSecretUpdateEks(ctx context.Context) ApiDynamicSecretUpdateEksRequest {
	return ApiDynamicSecretUpdateEksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretUpdateOutput
func (a *V2ApiService) DynamicSecretUpdateEksExecute(r ApiDynamicSecretUpdateEksRequest) (*DynamicSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretUpdateEks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-update-eks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretUpdateGcpRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretUpdateGcp *DynamicSecretUpdateGcp
    body interface{}
}

func (r ApiDynamicSecretUpdateGcpRequest) DynamicSecretUpdateGcp(dynamicSecretUpdateGcp DynamicSecretUpdateGcp) ApiDynamicSecretUpdateGcpRequest {
	r.dynamicSecretUpdateGcp = &dynamicSecretUpdateGcp
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretUpdateGcpRequest) Body(body DynamicSecretUpdateGcp) ApiDynamicSecretUpdateGcpRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretUpdateGcpRequest) Execute() (*DynamicSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretUpdateGcpExecute(r)
}

/*
DynamicSecretUpdateGcp Method for DynamicSecretUpdateGcp

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretUpdateGcpRequest
*/
func (a *V2ApiService) DynamicSecretUpdateGcp(ctx context.Context) ApiDynamicSecretUpdateGcpRequest {
	return ApiDynamicSecretUpdateGcpRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretUpdateOutput
func (a *V2ApiService) DynamicSecretUpdateGcpExecute(r ApiDynamicSecretUpdateGcpRequest) (*DynamicSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretUpdateGcp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-update-gcp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretUpdateGithubRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretUpdateGithub *DynamicSecretUpdateGithub
    body interface{}
}

func (r ApiDynamicSecretUpdateGithubRequest) DynamicSecretUpdateGithub(dynamicSecretUpdateGithub DynamicSecretUpdateGithub) ApiDynamicSecretUpdateGithubRequest {
	r.dynamicSecretUpdateGithub = &dynamicSecretUpdateGithub
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretUpdateGithubRequest) Body(body DynamicSecretUpdateGithub) ApiDynamicSecretUpdateGithubRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretUpdateGithubRequest) Execute() (*DynamicSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretUpdateGithubExecute(r)
}

/*
DynamicSecretUpdateGithub Method for DynamicSecretUpdateGithub

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretUpdateGithubRequest
*/
func (a *V2ApiService) DynamicSecretUpdateGithub(ctx context.Context) ApiDynamicSecretUpdateGithubRequest {
	return ApiDynamicSecretUpdateGithubRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretUpdateOutput
func (a *V2ApiService) DynamicSecretUpdateGithubExecute(r ApiDynamicSecretUpdateGithubRequest) (*DynamicSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretUpdateGithub")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-update-github"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretUpdateGitlabRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretUpdateGitlab *DynamicSecretUpdateGitlab
    body interface{}
}

func (r ApiDynamicSecretUpdateGitlabRequest) DynamicSecretUpdateGitlab(dynamicSecretUpdateGitlab DynamicSecretUpdateGitlab) ApiDynamicSecretUpdateGitlabRequest {
	r.dynamicSecretUpdateGitlab = &dynamicSecretUpdateGitlab
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretUpdateGitlabRequest) Body(body DynamicSecretUpdateGitlab) ApiDynamicSecretUpdateGitlabRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretUpdateGitlabRequest) Execute() (*DynamicSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretUpdateGitlabExecute(r)
}

/*
DynamicSecretUpdateGitlab Method for DynamicSecretUpdateGitlab

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretUpdateGitlabRequest
*/
func (a *V2ApiService) DynamicSecretUpdateGitlab(ctx context.Context) ApiDynamicSecretUpdateGitlabRequest {
	return ApiDynamicSecretUpdateGitlabRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretUpdateOutput
func (a *V2ApiService) DynamicSecretUpdateGitlabExecute(r ApiDynamicSecretUpdateGitlabRequest) (*DynamicSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretUpdateGitlab")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-update-gitlab"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretUpdateGkeRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretUpdateGke *DynamicSecretUpdateGke
    body interface{}
}

func (r ApiDynamicSecretUpdateGkeRequest) DynamicSecretUpdateGke(dynamicSecretUpdateGke DynamicSecretUpdateGke) ApiDynamicSecretUpdateGkeRequest {
	r.dynamicSecretUpdateGke = &dynamicSecretUpdateGke
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretUpdateGkeRequest) Body(body DynamicSecretUpdateGke) ApiDynamicSecretUpdateGkeRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretUpdateGkeRequest) Execute() (*DynamicSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretUpdateGkeExecute(r)
}

/*
DynamicSecretUpdateGke Method for DynamicSecretUpdateGke

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretUpdateGkeRequest
*/
func (a *V2ApiService) DynamicSecretUpdateGke(ctx context.Context) ApiDynamicSecretUpdateGkeRequest {
	return ApiDynamicSecretUpdateGkeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretUpdateOutput
func (a *V2ApiService) DynamicSecretUpdateGkeExecute(r ApiDynamicSecretUpdateGkeRequest) (*DynamicSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretUpdateGke")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-update-gke"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretUpdateGoogleWorkspaceRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretUpdateGoogleWorkspace *DynamicSecretUpdateGoogleWorkspace
    body interface{}
}

func (r ApiDynamicSecretUpdateGoogleWorkspaceRequest) DynamicSecretUpdateGoogleWorkspace(dynamicSecretUpdateGoogleWorkspace DynamicSecretUpdateGoogleWorkspace) ApiDynamicSecretUpdateGoogleWorkspaceRequest {
	r.dynamicSecretUpdateGoogleWorkspace = &dynamicSecretUpdateGoogleWorkspace
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretUpdateGoogleWorkspaceRequest) Body(body DynamicSecretUpdateGoogleWorkspace) ApiDynamicSecretUpdateGoogleWorkspaceRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretUpdateGoogleWorkspaceRequest) Execute() (*DynamicSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretUpdateGoogleWorkspaceExecute(r)
}

/*
DynamicSecretUpdateGoogleWorkspace Method for DynamicSecretUpdateGoogleWorkspace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretUpdateGoogleWorkspaceRequest
*/
func (a *V2ApiService) DynamicSecretUpdateGoogleWorkspace(ctx context.Context) ApiDynamicSecretUpdateGoogleWorkspaceRequest {
	return ApiDynamicSecretUpdateGoogleWorkspaceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretUpdateOutput
func (a *V2ApiService) DynamicSecretUpdateGoogleWorkspaceExecute(r ApiDynamicSecretUpdateGoogleWorkspaceRequest) (*DynamicSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretUpdateGoogleWorkspace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-update-google-workspace"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretUpdateHanaDbRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretUpdateHanaDb *DynamicSecretUpdateHanaDb
    body interface{}
}

func (r ApiDynamicSecretUpdateHanaDbRequest) DynamicSecretUpdateHanaDb(dynamicSecretUpdateHanaDb DynamicSecretUpdateHanaDb) ApiDynamicSecretUpdateHanaDbRequest {
	r.dynamicSecretUpdateHanaDb = &dynamicSecretUpdateHanaDb
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretUpdateHanaDbRequest) Body(body DynamicSecretUpdateHanaDb) ApiDynamicSecretUpdateHanaDbRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretUpdateHanaDbRequest) Execute() (*DynamicSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretUpdateHanaDbExecute(r)
}

/*
DynamicSecretUpdateHanaDb Method for DynamicSecretUpdateHanaDb

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretUpdateHanaDbRequest
*/
func (a *V2ApiService) DynamicSecretUpdateHanaDb(ctx context.Context) ApiDynamicSecretUpdateHanaDbRequest {
	return ApiDynamicSecretUpdateHanaDbRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretUpdateOutput
func (a *V2ApiService) DynamicSecretUpdateHanaDbExecute(r ApiDynamicSecretUpdateHanaDbRequest) (*DynamicSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretUpdateHanaDb")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-update-hana"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretUpdateK8sRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretUpdateK8s *DynamicSecretUpdateK8s
    body interface{}
}

func (r ApiDynamicSecretUpdateK8sRequest) DynamicSecretUpdateK8s(dynamicSecretUpdateK8s DynamicSecretUpdateK8s) ApiDynamicSecretUpdateK8sRequest {
	r.dynamicSecretUpdateK8s = &dynamicSecretUpdateK8s
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretUpdateK8sRequest) Body(body DynamicSecretUpdateK8s) ApiDynamicSecretUpdateK8sRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretUpdateK8sRequest) Execute() (*DynamicSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretUpdateK8sExecute(r)
}

/*
DynamicSecretUpdateK8s Method for DynamicSecretUpdateK8s

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretUpdateK8sRequest
*/
func (a *V2ApiService) DynamicSecretUpdateK8s(ctx context.Context) ApiDynamicSecretUpdateK8sRequest {
	return ApiDynamicSecretUpdateK8sRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretUpdateOutput
func (a *V2ApiService) DynamicSecretUpdateK8sExecute(r ApiDynamicSecretUpdateK8sRequest) (*DynamicSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretUpdateK8s")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-update-k8s"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretUpdateLdapRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretUpdateLdap *DynamicSecretUpdateLdap
    body interface{}
}

func (r ApiDynamicSecretUpdateLdapRequest) DynamicSecretUpdateLdap(dynamicSecretUpdateLdap DynamicSecretUpdateLdap) ApiDynamicSecretUpdateLdapRequest {
	r.dynamicSecretUpdateLdap = &dynamicSecretUpdateLdap
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretUpdateLdapRequest) Body(body DynamicSecretUpdateLdap) ApiDynamicSecretUpdateLdapRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretUpdateLdapRequest) Execute() (*DynamicSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretUpdateLdapExecute(r)
}

/*
DynamicSecretUpdateLdap Method for DynamicSecretUpdateLdap

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretUpdateLdapRequest
*/
func (a *V2ApiService) DynamicSecretUpdateLdap(ctx context.Context) ApiDynamicSecretUpdateLdapRequest {
	return ApiDynamicSecretUpdateLdapRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretUpdateOutput
func (a *V2ApiService) DynamicSecretUpdateLdapExecute(r ApiDynamicSecretUpdateLdapRequest) (*DynamicSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretUpdateLdap")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-update-ldap"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretUpdateMongoDbRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretUpdateMongoDb *DynamicSecretUpdateMongoDb
    body interface{}
}

func (r ApiDynamicSecretUpdateMongoDbRequest) DynamicSecretUpdateMongoDb(dynamicSecretUpdateMongoDb DynamicSecretUpdateMongoDb) ApiDynamicSecretUpdateMongoDbRequest {
	r.dynamicSecretUpdateMongoDb = &dynamicSecretUpdateMongoDb
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretUpdateMongoDbRequest) Body(body DynamicSecretUpdateMongoDb) ApiDynamicSecretUpdateMongoDbRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretUpdateMongoDbRequest) Execute() (*DynamicSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretUpdateMongoDbExecute(r)
}

/*
DynamicSecretUpdateMongoDb Method for DynamicSecretUpdateMongoDb

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretUpdateMongoDbRequest
*/
func (a *V2ApiService) DynamicSecretUpdateMongoDb(ctx context.Context) ApiDynamicSecretUpdateMongoDbRequest {
	return ApiDynamicSecretUpdateMongoDbRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretUpdateOutput
func (a *V2ApiService) DynamicSecretUpdateMongoDbExecute(r ApiDynamicSecretUpdateMongoDbRequest) (*DynamicSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretUpdateMongoDb")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-update-mongo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretUpdateMsSqlRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretUpdateMsSql *DynamicSecretUpdateMsSql
    body interface{}
}

func (r ApiDynamicSecretUpdateMsSqlRequest) DynamicSecretUpdateMsSql(dynamicSecretUpdateMsSql DynamicSecretUpdateMsSql) ApiDynamicSecretUpdateMsSqlRequest {
	r.dynamicSecretUpdateMsSql = &dynamicSecretUpdateMsSql
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretUpdateMsSqlRequest) Body(body DynamicSecretUpdateMsSql) ApiDynamicSecretUpdateMsSqlRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretUpdateMsSqlRequest) Execute() (*DynamicSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretUpdateMsSqlExecute(r)
}

/*
DynamicSecretUpdateMsSql Method for DynamicSecretUpdateMsSql

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretUpdateMsSqlRequest
*/
func (a *V2ApiService) DynamicSecretUpdateMsSql(ctx context.Context) ApiDynamicSecretUpdateMsSqlRequest {
	return ApiDynamicSecretUpdateMsSqlRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretUpdateOutput
func (a *V2ApiService) DynamicSecretUpdateMsSqlExecute(r ApiDynamicSecretUpdateMsSqlRequest) (*DynamicSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretUpdateMsSql")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-update-mssql"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretUpdateMySqlRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretUpdateMySql *DynamicSecretUpdateMySql
    body interface{}
}

func (r ApiDynamicSecretUpdateMySqlRequest) DynamicSecretUpdateMySql(dynamicSecretUpdateMySql DynamicSecretUpdateMySql) ApiDynamicSecretUpdateMySqlRequest {
	r.dynamicSecretUpdateMySql = &dynamicSecretUpdateMySql
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretUpdateMySqlRequest) Body(body DynamicSecretUpdateMySql) ApiDynamicSecretUpdateMySqlRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretUpdateMySqlRequest) Execute() (*DynamicSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretUpdateMySqlExecute(r)
}

/*
DynamicSecretUpdateMySql Method for DynamicSecretUpdateMySql

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretUpdateMySqlRequest
*/
func (a *V2ApiService) DynamicSecretUpdateMySql(ctx context.Context) ApiDynamicSecretUpdateMySqlRequest {
	return ApiDynamicSecretUpdateMySqlRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretUpdateOutput
func (a *V2ApiService) DynamicSecretUpdateMySqlExecute(r ApiDynamicSecretUpdateMySqlRequest) (*DynamicSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretUpdateMySql")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-update-mysql"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretUpdateOpenAIRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretUpdateOpenAI *DynamicSecretUpdateOpenAI
    body interface{}
}

func (r ApiDynamicSecretUpdateOpenAIRequest) DynamicSecretUpdateOpenAI(dynamicSecretUpdateOpenAI DynamicSecretUpdateOpenAI) ApiDynamicSecretUpdateOpenAIRequest {
	r.dynamicSecretUpdateOpenAI = &dynamicSecretUpdateOpenAI
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretUpdateOpenAIRequest) Body(body DynamicSecretUpdateOpenAI) ApiDynamicSecretUpdateOpenAIRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretUpdateOpenAIRequest) Execute() (*DynamicSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretUpdateOpenAIExecute(r)
}

/*
DynamicSecretUpdateOpenAI Method for DynamicSecretUpdateOpenAI

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretUpdateOpenAIRequest
*/
func (a *V2ApiService) DynamicSecretUpdateOpenAI(ctx context.Context) ApiDynamicSecretUpdateOpenAIRequest {
	return ApiDynamicSecretUpdateOpenAIRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretUpdateOutput
func (a *V2ApiService) DynamicSecretUpdateOpenAIExecute(r ApiDynamicSecretUpdateOpenAIRequest) (*DynamicSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretUpdateOpenAI")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-update-openai"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretUpdateOracleDbRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretUpdateOracleDb *DynamicSecretUpdateOracleDb
    body interface{}
}

func (r ApiDynamicSecretUpdateOracleDbRequest) DynamicSecretUpdateOracleDb(dynamicSecretUpdateOracleDb DynamicSecretUpdateOracleDb) ApiDynamicSecretUpdateOracleDbRequest {
	r.dynamicSecretUpdateOracleDb = &dynamicSecretUpdateOracleDb
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretUpdateOracleDbRequest) Body(body DynamicSecretUpdateOracleDb) ApiDynamicSecretUpdateOracleDbRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretUpdateOracleDbRequest) Execute() (*DynamicSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretUpdateOracleDbExecute(r)
}

/*
DynamicSecretUpdateOracleDb Method for DynamicSecretUpdateOracleDb

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretUpdateOracleDbRequest
*/
func (a *V2ApiService) DynamicSecretUpdateOracleDb(ctx context.Context) ApiDynamicSecretUpdateOracleDbRequest {
	return ApiDynamicSecretUpdateOracleDbRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretUpdateOutput
func (a *V2ApiService) DynamicSecretUpdateOracleDbExecute(r ApiDynamicSecretUpdateOracleDbRequest) (*DynamicSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretUpdateOracleDb")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-update-oracle"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretUpdatePingRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretUpdatePing *DynamicSecretUpdatePing
    body interface{}
}

func (r ApiDynamicSecretUpdatePingRequest) DynamicSecretUpdatePing(dynamicSecretUpdatePing DynamicSecretUpdatePing) ApiDynamicSecretUpdatePingRequest {
	r.dynamicSecretUpdatePing = &dynamicSecretUpdatePing
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretUpdatePingRequest) Body(body DynamicSecretUpdatePing) ApiDynamicSecretUpdatePingRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretUpdatePingRequest) Execute() (*DynamicSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretUpdatePingExecute(r)
}

/*
DynamicSecretUpdatePing Method for DynamicSecretUpdatePing

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretUpdatePingRequest
*/
func (a *V2ApiService) DynamicSecretUpdatePing(ctx context.Context) ApiDynamicSecretUpdatePingRequest {
	return ApiDynamicSecretUpdatePingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretUpdateOutput
func (a *V2ApiService) DynamicSecretUpdatePingExecute(r ApiDynamicSecretUpdatePingRequest) (*DynamicSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretUpdatePing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-update-ping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretUpdatePostgreSqlRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretUpdatePostgreSql *DynamicSecretUpdatePostgreSql
    body interface{}
}

func (r ApiDynamicSecretUpdatePostgreSqlRequest) DynamicSecretUpdatePostgreSql(dynamicSecretUpdatePostgreSql DynamicSecretUpdatePostgreSql) ApiDynamicSecretUpdatePostgreSqlRequest {
	r.dynamicSecretUpdatePostgreSql = &dynamicSecretUpdatePostgreSql
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretUpdatePostgreSqlRequest) Body(body DynamicSecretUpdatePostgreSql) ApiDynamicSecretUpdatePostgreSqlRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretUpdatePostgreSqlRequest) Execute() (*DynamicSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretUpdatePostgreSqlExecute(r)
}

/*
DynamicSecretUpdatePostgreSql Method for DynamicSecretUpdatePostgreSql

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretUpdatePostgreSqlRequest
*/
func (a *V2ApiService) DynamicSecretUpdatePostgreSql(ctx context.Context) ApiDynamicSecretUpdatePostgreSqlRequest {
	return ApiDynamicSecretUpdatePostgreSqlRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretUpdateOutput
func (a *V2ApiService) DynamicSecretUpdatePostgreSqlExecute(r ApiDynamicSecretUpdatePostgreSqlRequest) (*DynamicSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretUpdatePostgreSql")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-update-postgresql"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretUpdateRabbitMqRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretUpdateRabbitMq *DynamicSecretUpdateRabbitMq
    body interface{}
}

func (r ApiDynamicSecretUpdateRabbitMqRequest) DynamicSecretUpdateRabbitMq(dynamicSecretUpdateRabbitMq DynamicSecretUpdateRabbitMq) ApiDynamicSecretUpdateRabbitMqRequest {
	r.dynamicSecretUpdateRabbitMq = &dynamicSecretUpdateRabbitMq
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretUpdateRabbitMqRequest) Body(body DynamicSecretUpdateRabbitMq) ApiDynamicSecretUpdateRabbitMqRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretUpdateRabbitMqRequest) Execute() (*DynamicSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretUpdateRabbitMqExecute(r)
}

/*
DynamicSecretUpdateRabbitMq Method for DynamicSecretUpdateRabbitMq

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretUpdateRabbitMqRequest
*/
func (a *V2ApiService) DynamicSecretUpdateRabbitMq(ctx context.Context) ApiDynamicSecretUpdateRabbitMqRequest {
	return ApiDynamicSecretUpdateRabbitMqRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretUpdateOutput
func (a *V2ApiService) DynamicSecretUpdateRabbitMqExecute(r ApiDynamicSecretUpdateRabbitMqRequest) (*DynamicSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretUpdateRabbitMq")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-update-rabbitmq"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretUpdateRdpRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretUpdateRdp *DynamicSecretUpdateRdp
    body interface{}
}

func (r ApiDynamicSecretUpdateRdpRequest) DynamicSecretUpdateRdp(dynamicSecretUpdateRdp DynamicSecretUpdateRdp) ApiDynamicSecretUpdateRdpRequest {
	r.dynamicSecretUpdateRdp = &dynamicSecretUpdateRdp
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretUpdateRdpRequest) Body(body DynamicSecretUpdateRdp) ApiDynamicSecretUpdateRdpRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretUpdateRdpRequest) Execute() (*DynamicSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretUpdateRdpExecute(r)
}

/*
DynamicSecretUpdateRdp Method for DynamicSecretUpdateRdp

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretUpdateRdpRequest
*/
func (a *V2ApiService) DynamicSecretUpdateRdp(ctx context.Context) ApiDynamicSecretUpdateRdpRequest {
	return ApiDynamicSecretUpdateRdpRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretUpdateOutput
func (a *V2ApiService) DynamicSecretUpdateRdpExecute(r ApiDynamicSecretUpdateRdpRequest) (*DynamicSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretUpdateRdp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-update-rdp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretUpdateRedisRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretUpdateRedis *DynamicSecretUpdateRedis
    body interface{}
}

func (r ApiDynamicSecretUpdateRedisRequest) DynamicSecretUpdateRedis(dynamicSecretUpdateRedis DynamicSecretUpdateRedis) ApiDynamicSecretUpdateRedisRequest {
	r.dynamicSecretUpdateRedis = &dynamicSecretUpdateRedis
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretUpdateRedisRequest) Body(body DynamicSecretUpdateRedis) ApiDynamicSecretUpdateRedisRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretUpdateRedisRequest) Execute() (*DynamicSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretUpdateRedisExecute(r)
}

/*
DynamicSecretUpdateRedis Method for DynamicSecretUpdateRedis

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretUpdateRedisRequest
*/
func (a *V2ApiService) DynamicSecretUpdateRedis(ctx context.Context) ApiDynamicSecretUpdateRedisRequest {
	return ApiDynamicSecretUpdateRedisRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretUpdateOutput
func (a *V2ApiService) DynamicSecretUpdateRedisExecute(r ApiDynamicSecretUpdateRedisRequest) (*DynamicSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretUpdateRedis")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-update-redis"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretUpdateRedshiftRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretUpdateRedshift *DynamicSecretUpdateRedshift
    body interface{}
}

func (r ApiDynamicSecretUpdateRedshiftRequest) DynamicSecretUpdateRedshift(dynamicSecretUpdateRedshift DynamicSecretUpdateRedshift) ApiDynamicSecretUpdateRedshiftRequest {
	r.dynamicSecretUpdateRedshift = &dynamicSecretUpdateRedshift
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretUpdateRedshiftRequest) Body(body DynamicSecretUpdateRedshift) ApiDynamicSecretUpdateRedshiftRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretUpdateRedshiftRequest) Execute() (*DynamicSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretUpdateRedshiftExecute(r)
}

/*
DynamicSecretUpdateRedshift Method for DynamicSecretUpdateRedshift

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretUpdateRedshiftRequest
*/
func (a *V2ApiService) DynamicSecretUpdateRedshift(ctx context.Context) ApiDynamicSecretUpdateRedshiftRequest {
	return ApiDynamicSecretUpdateRedshiftRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretUpdateOutput
func (a *V2ApiService) DynamicSecretUpdateRedshiftExecute(r ApiDynamicSecretUpdateRedshiftRequest) (*DynamicSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretUpdateRedshift")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-update-redshift"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretUpdateSnowflakeRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretUpdateSnowflake *DynamicSecretUpdateSnowflake
    body interface{}
}

func (r ApiDynamicSecretUpdateSnowflakeRequest) DynamicSecretUpdateSnowflake(dynamicSecretUpdateSnowflake DynamicSecretUpdateSnowflake) ApiDynamicSecretUpdateSnowflakeRequest {
	r.dynamicSecretUpdateSnowflake = &dynamicSecretUpdateSnowflake
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretUpdateSnowflakeRequest) Body(body DynamicSecretUpdateSnowflake) ApiDynamicSecretUpdateSnowflakeRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretUpdateSnowflakeRequest) Execute() (*DynamicSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretUpdateSnowflakeExecute(r)
}

/*
DynamicSecretUpdateSnowflake Method for DynamicSecretUpdateSnowflake

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretUpdateSnowflakeRequest
*/
func (a *V2ApiService) DynamicSecretUpdateSnowflake(ctx context.Context) ApiDynamicSecretUpdateSnowflakeRequest {
	return ApiDynamicSecretUpdateSnowflakeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretUpdateOutput
func (a *V2ApiService) DynamicSecretUpdateSnowflakeExecute(r ApiDynamicSecretUpdateSnowflakeRequest) (*DynamicSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretUpdateSnowflake")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-update-snowflake"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDynamicSecretUpdateVenafiRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	dynamicSecretUpdateVenafi *DynamicSecretUpdateVenafi
    body interface{}
}

func (r ApiDynamicSecretUpdateVenafiRequest) DynamicSecretUpdateVenafi(dynamicSecretUpdateVenafi DynamicSecretUpdateVenafi) ApiDynamicSecretUpdateVenafiRequest {
	r.dynamicSecretUpdateVenafi = &dynamicSecretUpdateVenafi
	return r
}


    // Body sets the body payload for the API call.
func (r ApiDynamicSecretUpdateVenafiRequest) Body(body DynamicSecretUpdateVenafi) ApiDynamicSecretUpdateVenafiRequest {
    r.body = body
    return r
}

func (r ApiDynamicSecretUpdateVenafiRequest) Execute() (*DynamicSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.DynamicSecretUpdateVenafiExecute(r)
}

/*
DynamicSecretUpdateVenafi Method for DynamicSecretUpdateVenafi

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDynamicSecretUpdateVenafiRequest
*/
func (a *V2ApiService) DynamicSecretUpdateVenafi(ctx context.Context) ApiDynamicSecretUpdateVenafiRequest {
	return ApiDynamicSecretUpdateVenafiRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicSecretUpdateOutput
func (a *V2ApiService) DynamicSecretUpdateVenafiExecute(r ApiDynamicSecretUpdateVenafiRequest) (*DynamicSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.DynamicSecretUpdateVenafi")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dynamic-secret-update-venafi"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEncryptRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	encrypt *Encrypt
    body interface{}
}

func (r ApiEncryptRequest) Encrypt(encrypt Encrypt) ApiEncryptRequest {
	r.encrypt = &encrypt
	return r
}


    // Body sets the body payload for the API call.
func (r ApiEncryptRequest) Body(body Encrypt) ApiEncryptRequest {
    r.body = body
    return r
}

func (r ApiEncryptRequest) Execute() (*EncryptOutput, *http.Response, error) {
	return r.ApiService.EncryptExecute(r)
}

/*
Encrypt Method for Encrypt

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEncryptRequest
*/
func (a *V2ApiService) Encrypt(ctx context.Context) ApiEncryptRequest {
	return ApiEncryptRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EncryptOutput
func (a *V2ApiService) EncryptExecute(r ApiEncryptRequest) (*EncryptOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EncryptOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.Encrypt")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/encrypt"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEncryptBatchRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	batchEncryptionRequestLine *[]BatchEncryptionRequestLine
    body interface{}
}

func (r ApiEncryptBatchRequest) BatchEncryptionRequestLine(batchEncryptionRequestLine []BatchEncryptionRequestLine) ApiEncryptBatchRequest {
	r.batchEncryptionRequestLine = &batchEncryptionRequestLine
	return r
}


    // Body sets the body payload for the API call.
func (r ApiEncryptBatchRequest) Body(body []BatchEncryptionRequestLine) ApiEncryptBatchRequest {
    r.body = body
    return r
}

func (r ApiEncryptBatchRequest) Execute() (*EncryptOutput, *http.Response, error) {
	return r.ApiService.EncryptBatchExecute(r)
}

/*
EncryptBatch Method for EncryptBatch

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEncryptBatchRequest
*/
func (a *V2ApiService) EncryptBatch(ctx context.Context) ApiEncryptBatchRequest {
	return ApiEncryptBatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EncryptOutput
func (a *V2ApiService) EncryptBatchExecute(r ApiEncryptBatchRequest) (*EncryptOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EncryptOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.EncryptBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/encrypt-batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEncryptGPGRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	encryptGPG *EncryptGPG
    body interface{}
}

func (r ApiEncryptGPGRequest) EncryptGPG(encryptGPG EncryptGPG) ApiEncryptGPGRequest {
	r.encryptGPG = &encryptGPG
	return r
}


    // Body sets the body payload for the API call.
func (r ApiEncryptGPGRequest) Body(body EncryptGPG) ApiEncryptGPGRequest {
    r.body = body
    return r
}

func (r ApiEncryptGPGRequest) Execute() (*EncryptGPGOutput, *http.Response, error) {
	return r.ApiService.EncryptGPGExecute(r)
}

/*
EncryptGPG Method for EncryptGPG

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEncryptGPGRequest
*/
func (a *V2ApiService) EncryptGPG(ctx context.Context) ApiEncryptGPGRequest {
	return ApiEncryptGPGRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EncryptGPGOutput
func (a *V2ApiService) EncryptGPGExecute(r ApiEncryptGPGRequest) (*EncryptGPGOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EncryptGPGOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.EncryptGPG")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/encrypt-gpg"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEncryptWithClassicKeyRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	encryptWithClassicKey *EncryptWithClassicKey
    body interface{}
}

func (r ApiEncryptWithClassicKeyRequest) EncryptWithClassicKey(encryptWithClassicKey EncryptWithClassicKey) ApiEncryptWithClassicKeyRequest {
	r.encryptWithClassicKey = &encryptWithClassicKey
	return r
}


    // Body sets the body payload for the API call.
func (r ApiEncryptWithClassicKeyRequest) Body(body EncryptWithClassicKey) ApiEncryptWithClassicKeyRequest {
    r.body = body
    return r
}

func (r ApiEncryptWithClassicKeyRequest) Execute() (*EncryptOutput, *http.Response, error) {
	return r.ApiService.EncryptWithClassicKeyExecute(r)
}

/*
EncryptWithClassicKey Method for EncryptWithClassicKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEncryptWithClassicKeyRequest
*/
func (a *V2ApiService) EncryptWithClassicKey(ctx context.Context) ApiEncryptWithClassicKeyRequest {
	return ApiEncryptWithClassicKeyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EncryptOutput
func (a *V2ApiService) EncryptWithClassicKeyExecute(r ApiEncryptWithClassicKeyRequest) (*EncryptOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EncryptOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.EncryptWithClassicKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/encrypt-with-classic-key"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEsmCreateRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	esmCreate *EsmCreate
    body interface{}
}

func (r ApiEsmCreateRequest) EsmCreate(esmCreate EsmCreate) ApiEsmCreateRequest {
	r.esmCreate = &esmCreate
	return r
}


    // Body sets the body payload for the API call.
func (r ApiEsmCreateRequest) Body(body EsmCreate) ApiEsmCreateRequest {
    r.body = body
    return r
}

func (r ApiEsmCreateRequest) Execute() (*EsmCreateSecretOutput, *http.Response, error) {
	return r.ApiService.EsmCreateExecute(r)
}

/*
EsmCreate Method for EsmCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEsmCreateRequest
*/
func (a *V2ApiService) EsmCreate(ctx context.Context) ApiEsmCreateRequest {
	return ApiEsmCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EsmCreateSecretOutput
func (a *V2ApiService) EsmCreateExecute(r ApiEsmCreateRequest) (*EsmCreateSecretOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EsmCreateSecretOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.EsmCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/esm-create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEsmDeleteRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	esmDelete *EsmDelete
    body interface{}
}

func (r ApiEsmDeleteRequest) EsmDelete(esmDelete EsmDelete) ApiEsmDeleteRequest {
	r.esmDelete = &esmDelete
	return r
}


    // Body sets the body payload for the API call.
func (r ApiEsmDeleteRequest) Body(body EsmDelete) ApiEsmDeleteRequest {
    r.body = body
    return r
}

func (r ApiEsmDeleteRequest) Execute() (*EsmDeleteSecretOutput, *http.Response, error) {
	return r.ApiService.EsmDeleteExecute(r)
}

/*
EsmDelete Method for EsmDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEsmDeleteRequest
*/
func (a *V2ApiService) EsmDelete(ctx context.Context) ApiEsmDeleteRequest {
	return ApiEsmDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EsmDeleteSecretOutput
func (a *V2ApiService) EsmDeleteExecute(r ApiEsmDeleteRequest) (*EsmDeleteSecretOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EsmDeleteSecretOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.EsmDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/esm-delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEsmGetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	esmGet *EsmGet
    body interface{}
}

func (r ApiEsmGetRequest) EsmGet(esmGet EsmGet) ApiEsmGetRequest {
	r.esmGet = &esmGet
	return r
}


    // Body sets the body payload for the API call.
func (r ApiEsmGetRequest) Body(body EsmGet) ApiEsmGetRequest {
    r.body = body
    return r
}

func (r ApiEsmGetRequest) Execute() (*EsmGetSecretOutput, *http.Response, error) {
	return r.ApiService.EsmGetExecute(r)
}

/*
EsmGet Method for EsmGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEsmGetRequest
*/
func (a *V2ApiService) EsmGet(ctx context.Context) ApiEsmGetRequest {
	return ApiEsmGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EsmGetSecretOutput
func (a *V2ApiService) EsmGetExecute(r ApiEsmGetRequest) (*EsmGetSecretOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EsmGetSecretOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.EsmGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/esm-get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEsmListRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	esmList *EsmList
    body interface{}
}

func (r ApiEsmListRequest) EsmList(esmList EsmList) ApiEsmListRequest {
	r.esmList = &esmList
	return r
}


    // Body sets the body payload for the API call.
func (r ApiEsmListRequest) Body(body EsmList) ApiEsmListRequest {
    r.body = body
    return r
}

func (r ApiEsmListRequest) Execute() (*EsmListSecretsOutput, *http.Response, error) {
	return r.ApiService.EsmListExecute(r)
}

/*
EsmList Method for EsmList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEsmListRequest
*/
func (a *V2ApiService) EsmList(ctx context.Context) ApiEsmListRequest {
	return ApiEsmListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EsmListSecretsOutput
func (a *V2ApiService) EsmListExecute(r ApiEsmListRequest) (*EsmListSecretsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EsmListSecretsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.EsmList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/esm-list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEsmUpdateRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	esmUpdate *EsmUpdate
    body interface{}
}

func (r ApiEsmUpdateRequest) EsmUpdate(esmUpdate EsmUpdate) ApiEsmUpdateRequest {
	r.esmUpdate = &esmUpdate
	return r
}


    // Body sets the body payload for the API call.
func (r ApiEsmUpdateRequest) Body(body EsmUpdate) ApiEsmUpdateRequest {
    r.body = body
    return r
}

func (r ApiEsmUpdateRequest) Execute() (*EsmUpdateSecretOutput, *http.Response, error) {
	return r.ApiService.EsmUpdateExecute(r)
}

/*
EsmUpdate Method for EsmUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEsmUpdateRequest
*/
func (a *V2ApiService) EsmUpdate(ctx context.Context) ApiEsmUpdateRequest {
	return ApiEsmUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EsmUpdateSecretOutput
func (a *V2ApiService) EsmUpdateExecute(r ApiEsmUpdateRequest) (*EsmUpdateSecretOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EsmUpdateSecretOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.EsmUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/esm-update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventActionRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	eventAction *EventAction
    body interface{}
}

func (r ApiEventActionRequest) EventAction(eventAction EventAction) ApiEventActionRequest {
	r.eventAction = &eventAction
	return r
}


    // Body sets the body payload for the API call.
func (r ApiEventActionRequest) Body(body EventAction) ApiEventActionRequest {
    r.body = body
    return r
}

func (r ApiEventActionRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.EventActionExecute(r)
}

/*
EventAction Method for EventAction

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEventActionRequest
*/
func (a *V2ApiService) EventAction(ctx context.Context) ApiEventActionRequest {
	return ApiEventActionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) EventActionExecute(r ApiEventActionRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.EventAction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/event-action"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventForwarderCreateEmailRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	eventForwarderCreateEmail *EventForwarderCreateEmail
    body interface{}
}

func (r ApiEventForwarderCreateEmailRequest) EventForwarderCreateEmail(eventForwarderCreateEmail EventForwarderCreateEmail) ApiEventForwarderCreateEmailRequest {
	r.eventForwarderCreateEmail = &eventForwarderCreateEmail
	return r
}


    // Body sets the body payload for the API call.
func (r ApiEventForwarderCreateEmailRequest) Body(body EventForwarderCreateEmail) ApiEventForwarderCreateEmailRequest {
    r.body = body
    return r
}

func (r ApiEventForwarderCreateEmailRequest) Execute() (*EventForwarderCreateUpdateOutput, *http.Response, error) {
	return r.ApiService.EventForwarderCreateEmailExecute(r)
}

/*
EventForwarderCreateEmail Method for EventForwarderCreateEmail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEventForwarderCreateEmailRequest
*/
func (a *V2ApiService) EventForwarderCreateEmail(ctx context.Context) ApiEventForwarderCreateEmailRequest {
	return ApiEventForwarderCreateEmailRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EventForwarderCreateUpdateOutput
func (a *V2ApiService) EventForwarderCreateEmailExecute(r ApiEventForwarderCreateEmailRequest) (*EventForwarderCreateUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EventForwarderCreateUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.EventForwarderCreateEmail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/event-forwarder-create-email"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventForwarderCreateServiceNowRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	eventForwarderCreateServiceNow *EventForwarderCreateServiceNow
    body interface{}
}

func (r ApiEventForwarderCreateServiceNowRequest) EventForwarderCreateServiceNow(eventForwarderCreateServiceNow EventForwarderCreateServiceNow) ApiEventForwarderCreateServiceNowRequest {
	r.eventForwarderCreateServiceNow = &eventForwarderCreateServiceNow
	return r
}


    // Body sets the body payload for the API call.
func (r ApiEventForwarderCreateServiceNowRequest) Body(body EventForwarderCreateServiceNow) ApiEventForwarderCreateServiceNowRequest {
    r.body = body
    return r
}

func (r ApiEventForwarderCreateServiceNowRequest) Execute() (*EventForwarderCreateUpdateOutput, *http.Response, error) {
	return r.ApiService.EventForwarderCreateServiceNowExecute(r)
}

/*
EventForwarderCreateServiceNow Method for EventForwarderCreateServiceNow

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEventForwarderCreateServiceNowRequest
*/
func (a *V2ApiService) EventForwarderCreateServiceNow(ctx context.Context) ApiEventForwarderCreateServiceNowRequest {
	return ApiEventForwarderCreateServiceNowRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EventForwarderCreateUpdateOutput
func (a *V2ApiService) EventForwarderCreateServiceNowExecute(r ApiEventForwarderCreateServiceNowRequest) (*EventForwarderCreateUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EventForwarderCreateUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.EventForwarderCreateServiceNow")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/event-forwarder-create-servicenow"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventForwarderCreateSlackRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	eventForwarderCreateSlack *EventForwarderCreateSlack
    body interface{}
}

func (r ApiEventForwarderCreateSlackRequest) EventForwarderCreateSlack(eventForwarderCreateSlack EventForwarderCreateSlack) ApiEventForwarderCreateSlackRequest {
	r.eventForwarderCreateSlack = &eventForwarderCreateSlack
	return r
}


    // Body sets the body payload for the API call.
func (r ApiEventForwarderCreateSlackRequest) Body(body EventForwarderCreateSlack) ApiEventForwarderCreateSlackRequest {
    r.body = body
    return r
}

func (r ApiEventForwarderCreateSlackRequest) Execute() (*EventForwarderCreateUpdateOutput, *http.Response, error) {
	return r.ApiService.EventForwarderCreateSlackExecute(r)
}

/*
EventForwarderCreateSlack Method for EventForwarderCreateSlack

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEventForwarderCreateSlackRequest
*/
func (a *V2ApiService) EventForwarderCreateSlack(ctx context.Context) ApiEventForwarderCreateSlackRequest {
	return ApiEventForwarderCreateSlackRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EventForwarderCreateUpdateOutput
func (a *V2ApiService) EventForwarderCreateSlackExecute(r ApiEventForwarderCreateSlackRequest) (*EventForwarderCreateUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EventForwarderCreateUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.EventForwarderCreateSlack")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/event-forwarder-create-slack"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventForwarderCreateTeamsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	eventForwarderCreateTeams *EventForwarderCreateTeams
    body interface{}
}

func (r ApiEventForwarderCreateTeamsRequest) EventForwarderCreateTeams(eventForwarderCreateTeams EventForwarderCreateTeams) ApiEventForwarderCreateTeamsRequest {
	r.eventForwarderCreateTeams = &eventForwarderCreateTeams
	return r
}


    // Body sets the body payload for the API call.
func (r ApiEventForwarderCreateTeamsRequest) Body(body EventForwarderCreateTeams) ApiEventForwarderCreateTeamsRequest {
    r.body = body
    return r
}

func (r ApiEventForwarderCreateTeamsRequest) Execute() (*EventForwarderCreateUpdateOutput, *http.Response, error) {
	return r.ApiService.EventForwarderCreateTeamsExecute(r)
}

/*
EventForwarderCreateTeams Method for EventForwarderCreateTeams

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEventForwarderCreateTeamsRequest
*/
func (a *V2ApiService) EventForwarderCreateTeams(ctx context.Context) ApiEventForwarderCreateTeamsRequest {
	return ApiEventForwarderCreateTeamsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EventForwarderCreateUpdateOutput
func (a *V2ApiService) EventForwarderCreateTeamsExecute(r ApiEventForwarderCreateTeamsRequest) (*EventForwarderCreateUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EventForwarderCreateUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.EventForwarderCreateTeams")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/event-forwarder-create-teams"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventForwarderCreateWebhookRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	eventForwarderCreateWebhook *EventForwarderCreateWebhook
    body interface{}
}

func (r ApiEventForwarderCreateWebhookRequest) EventForwarderCreateWebhook(eventForwarderCreateWebhook EventForwarderCreateWebhook) ApiEventForwarderCreateWebhookRequest {
	r.eventForwarderCreateWebhook = &eventForwarderCreateWebhook
	return r
}


    // Body sets the body payload for the API call.
func (r ApiEventForwarderCreateWebhookRequest) Body(body EventForwarderCreateWebhook) ApiEventForwarderCreateWebhookRequest {
    r.body = body
    return r
}

func (r ApiEventForwarderCreateWebhookRequest) Execute() (*EventForwarderCreateUpdateOutput, *http.Response, error) {
	return r.ApiService.EventForwarderCreateWebhookExecute(r)
}

/*
EventForwarderCreateWebhook Method for EventForwarderCreateWebhook

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEventForwarderCreateWebhookRequest
*/
func (a *V2ApiService) EventForwarderCreateWebhook(ctx context.Context) ApiEventForwarderCreateWebhookRequest {
	return ApiEventForwarderCreateWebhookRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EventForwarderCreateUpdateOutput
func (a *V2ApiService) EventForwarderCreateWebhookExecute(r ApiEventForwarderCreateWebhookRequest) (*EventForwarderCreateUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EventForwarderCreateUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.EventForwarderCreateWebhook")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/event-forwarder-create-webhook"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventForwarderDeleteRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	eventForwarderDelete *EventForwarderDelete
    body interface{}
}

func (r ApiEventForwarderDeleteRequest) EventForwarderDelete(eventForwarderDelete EventForwarderDelete) ApiEventForwarderDeleteRequest {
	r.eventForwarderDelete = &eventForwarderDelete
	return r
}


    // Body sets the body payload for the API call.
func (r ApiEventForwarderDeleteRequest) Body(body EventForwarderDelete) ApiEventForwarderDeleteRequest {
    r.body = body
    return r
}

func (r ApiEventForwarderDeleteRequest) Execute() (*EventForwarderDeleteOutput, *http.Response, error) {
	return r.ApiService.EventForwarderDeleteExecute(r)
}

/*
EventForwarderDelete Method for EventForwarderDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEventForwarderDeleteRequest
*/
func (a *V2ApiService) EventForwarderDelete(ctx context.Context) ApiEventForwarderDeleteRequest {
	return ApiEventForwarderDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EventForwarderDeleteOutput
func (a *V2ApiService) EventForwarderDeleteExecute(r ApiEventForwarderDeleteRequest) (*EventForwarderDeleteOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EventForwarderDeleteOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.EventForwarderDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/event-forwarder-delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventForwarderGetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	eventForwarderGet *EventForwarderGet
    body interface{}
}

func (r ApiEventForwarderGetRequest) EventForwarderGet(eventForwarderGet EventForwarderGet) ApiEventForwarderGetRequest {
	r.eventForwarderGet = &eventForwarderGet
	return r
}


    // Body sets the body payload for the API call.
func (r ApiEventForwarderGetRequest) Body(body EventForwarderGet) ApiEventForwarderGetRequest {
    r.body = body
    return r
}

func (r ApiEventForwarderGetRequest) Execute() (*EventForwarderGetOutput, *http.Response, error) {
	return r.ApiService.EventForwarderGetExecute(r)
}

/*
EventForwarderGet Method for EventForwarderGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEventForwarderGetRequest
*/
func (a *V2ApiService) EventForwarderGet(ctx context.Context) ApiEventForwarderGetRequest {
	return ApiEventForwarderGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EventForwarderGetOutput
func (a *V2ApiService) EventForwarderGetExecute(r ApiEventForwarderGetRequest) (*EventForwarderGetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EventForwarderGetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.EventForwarderGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/event-forwarder-get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventForwarderUpdateEmailRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	eventForwarderUpdateEmail *EventForwarderUpdateEmail
    body interface{}
}

func (r ApiEventForwarderUpdateEmailRequest) EventForwarderUpdateEmail(eventForwarderUpdateEmail EventForwarderUpdateEmail) ApiEventForwarderUpdateEmailRequest {
	r.eventForwarderUpdateEmail = &eventForwarderUpdateEmail
	return r
}


    // Body sets the body payload for the API call.
func (r ApiEventForwarderUpdateEmailRequest) Body(body EventForwarderUpdateEmail) ApiEventForwarderUpdateEmailRequest {
    r.body = body
    return r
}

func (r ApiEventForwarderUpdateEmailRequest) Execute() (*EventForwarderCreateUpdateOutput, *http.Response, error) {
	return r.ApiService.EventForwarderUpdateEmailExecute(r)
}

/*
EventForwarderUpdateEmail Method for EventForwarderUpdateEmail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEventForwarderUpdateEmailRequest
*/
func (a *V2ApiService) EventForwarderUpdateEmail(ctx context.Context) ApiEventForwarderUpdateEmailRequest {
	return ApiEventForwarderUpdateEmailRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EventForwarderCreateUpdateOutput
func (a *V2ApiService) EventForwarderUpdateEmailExecute(r ApiEventForwarderUpdateEmailRequest) (*EventForwarderCreateUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EventForwarderCreateUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.EventForwarderUpdateEmail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/event-forwarder-update-email"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventForwarderUpdateServiceNowRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	eventForwarderUpdateServiceNow *EventForwarderUpdateServiceNow
    body interface{}
}

func (r ApiEventForwarderUpdateServiceNowRequest) EventForwarderUpdateServiceNow(eventForwarderUpdateServiceNow EventForwarderUpdateServiceNow) ApiEventForwarderUpdateServiceNowRequest {
	r.eventForwarderUpdateServiceNow = &eventForwarderUpdateServiceNow
	return r
}


    // Body sets the body payload for the API call.
func (r ApiEventForwarderUpdateServiceNowRequest) Body(body EventForwarderUpdateServiceNow) ApiEventForwarderUpdateServiceNowRequest {
    r.body = body
    return r
}

func (r ApiEventForwarderUpdateServiceNowRequest) Execute() (*EventForwarderCreateUpdateOutput, *http.Response, error) {
	return r.ApiService.EventForwarderUpdateServiceNowExecute(r)
}

/*
EventForwarderUpdateServiceNow Method for EventForwarderUpdateServiceNow

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEventForwarderUpdateServiceNowRequest
*/
func (a *V2ApiService) EventForwarderUpdateServiceNow(ctx context.Context) ApiEventForwarderUpdateServiceNowRequest {
	return ApiEventForwarderUpdateServiceNowRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EventForwarderCreateUpdateOutput
func (a *V2ApiService) EventForwarderUpdateServiceNowExecute(r ApiEventForwarderUpdateServiceNowRequest) (*EventForwarderCreateUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EventForwarderCreateUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.EventForwarderUpdateServiceNow")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/event-forwarder-update-servicenow"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventForwarderUpdateSlackRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	eventForwarderUpdateSlack *EventForwarderUpdateSlack
    body interface{}
}

func (r ApiEventForwarderUpdateSlackRequest) EventForwarderUpdateSlack(eventForwarderUpdateSlack EventForwarderUpdateSlack) ApiEventForwarderUpdateSlackRequest {
	r.eventForwarderUpdateSlack = &eventForwarderUpdateSlack
	return r
}


    // Body sets the body payload for the API call.
func (r ApiEventForwarderUpdateSlackRequest) Body(body EventForwarderUpdateSlack) ApiEventForwarderUpdateSlackRequest {
    r.body = body
    return r
}

func (r ApiEventForwarderUpdateSlackRequest) Execute() (*EventForwarderCreateUpdateOutput, *http.Response, error) {
	return r.ApiService.EventForwarderUpdateSlackExecute(r)
}

/*
EventForwarderUpdateSlack Method for EventForwarderUpdateSlack

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEventForwarderUpdateSlackRequest
*/
func (a *V2ApiService) EventForwarderUpdateSlack(ctx context.Context) ApiEventForwarderUpdateSlackRequest {
	return ApiEventForwarderUpdateSlackRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EventForwarderCreateUpdateOutput
func (a *V2ApiService) EventForwarderUpdateSlackExecute(r ApiEventForwarderUpdateSlackRequest) (*EventForwarderCreateUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EventForwarderCreateUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.EventForwarderUpdateSlack")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/event-forwarder-update-slack"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventForwarderUpdateTeamsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	eventForwarderUpdateTeams *EventForwarderUpdateTeams
    body interface{}
}

func (r ApiEventForwarderUpdateTeamsRequest) EventForwarderUpdateTeams(eventForwarderUpdateTeams EventForwarderUpdateTeams) ApiEventForwarderUpdateTeamsRequest {
	r.eventForwarderUpdateTeams = &eventForwarderUpdateTeams
	return r
}


    // Body sets the body payload for the API call.
func (r ApiEventForwarderUpdateTeamsRequest) Body(body EventForwarderUpdateTeams) ApiEventForwarderUpdateTeamsRequest {
    r.body = body
    return r
}

func (r ApiEventForwarderUpdateTeamsRequest) Execute() (*EventForwarderCreateUpdateOutput, *http.Response, error) {
	return r.ApiService.EventForwarderUpdateTeamsExecute(r)
}

/*
EventForwarderUpdateTeams Method for EventForwarderUpdateTeams

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEventForwarderUpdateTeamsRequest
*/
func (a *V2ApiService) EventForwarderUpdateTeams(ctx context.Context) ApiEventForwarderUpdateTeamsRequest {
	return ApiEventForwarderUpdateTeamsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EventForwarderCreateUpdateOutput
func (a *V2ApiService) EventForwarderUpdateTeamsExecute(r ApiEventForwarderUpdateTeamsRequest) (*EventForwarderCreateUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EventForwarderCreateUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.EventForwarderUpdateTeams")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/event-forwarder-update-teams"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventForwarderUpdateWebhookRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	eventForwarderUpdateWebhook *EventForwarderUpdateWebhook
    body interface{}
}

func (r ApiEventForwarderUpdateWebhookRequest) EventForwarderUpdateWebhook(eventForwarderUpdateWebhook EventForwarderUpdateWebhook) ApiEventForwarderUpdateWebhookRequest {
	r.eventForwarderUpdateWebhook = &eventForwarderUpdateWebhook
	return r
}


    // Body sets the body payload for the API call.
func (r ApiEventForwarderUpdateWebhookRequest) Body(body EventForwarderUpdateWebhook) ApiEventForwarderUpdateWebhookRequest {
    r.body = body
    return r
}

func (r ApiEventForwarderUpdateWebhookRequest) Execute() (*EventForwarderCreateUpdateOutput, *http.Response, error) {
	return r.ApiService.EventForwarderUpdateWebhookExecute(r)
}

/*
EventForwarderUpdateWebhook Method for EventForwarderUpdateWebhook

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEventForwarderUpdateWebhookRequest
*/
func (a *V2ApiService) EventForwarderUpdateWebhook(ctx context.Context) ApiEventForwarderUpdateWebhookRequest {
	return ApiEventForwarderUpdateWebhookRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EventForwarderCreateUpdateOutput
func (a *V2ApiService) EventForwarderUpdateWebhookExecute(r ApiEventForwarderUpdateWebhookRequest) (*EventForwarderCreateUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EventForwarderCreateUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.EventForwarderUpdateWebhook")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/event-forwarder-update-webhook"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExportClassicKeyRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	exportClassicKey *ExportClassicKey
    body interface{}
}

func (r ApiExportClassicKeyRequest) ExportClassicKey(exportClassicKey ExportClassicKey) ApiExportClassicKeyRequest {
	r.exportClassicKey = &exportClassicKey
	return r
}


    // Body sets the body payload for the API call.
func (r ApiExportClassicKeyRequest) Body(body ExportClassicKey) ApiExportClassicKeyRequest {
    r.body = body
    return r
}

func (r ApiExportClassicKeyRequest) Execute() (*ExportClassicKeyOutput, *http.Response, error) {
	return r.ApiService.ExportClassicKeyExecute(r)
}

/*
ExportClassicKey Method for ExportClassicKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExportClassicKeyRequest
*/
func (a *V2ApiService) ExportClassicKey(ctx context.Context) ApiExportClassicKeyRequest {
	return ApiExportClassicKeyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExportClassicKeyOutput
func (a *V2ApiService) ExportClassicKeyExecute(r ApiExportClassicKeyRequest) (*ExportClassicKeyOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExportClassicKeyOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.ExportClassicKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/export-classic-key"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFolderCreateRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	folderCreate *FolderCreate
    body interface{}
}

func (r ApiFolderCreateRequest) FolderCreate(folderCreate FolderCreate) ApiFolderCreateRequest {
	r.folderCreate = &folderCreate
	return r
}


    // Body sets the body payload for the API call.
func (r ApiFolderCreateRequest) Body(body FolderCreate) ApiFolderCreateRequest {
    r.body = body
    return r
}

func (r ApiFolderCreateRequest) Execute() (*FolderCreateOutput, *http.Response, error) {
	return r.ApiService.FolderCreateExecute(r)
}

/*
FolderCreate Method for FolderCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFolderCreateRequest
*/
func (a *V2ApiService) FolderCreate(ctx context.Context) ApiFolderCreateRequest {
	return ApiFolderCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FolderCreateOutput
func (a *V2ApiService) FolderCreateExecute(r ApiFolderCreateRequest) (*FolderCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolderCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.FolderCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folder-create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFolderDeleteRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	folderDelete *FolderDelete
    body interface{}
}

func (r ApiFolderDeleteRequest) FolderDelete(folderDelete FolderDelete) ApiFolderDeleteRequest {
	r.folderDelete = &folderDelete
	return r
}


    // Body sets the body payload for the API call.
func (r ApiFolderDeleteRequest) Body(body FolderDelete) ApiFolderDeleteRequest {
    r.body = body
    return r
}

func (r ApiFolderDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.FolderDeleteExecute(r)
}

/*
FolderDelete Method for FolderDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFolderDeleteRequest
*/
func (a *V2ApiService) FolderDelete(ctx context.Context) ApiFolderDeleteRequest {
	return ApiFolderDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) FolderDeleteExecute(r ApiFolderDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.FolderDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folder-delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFolderGetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	folderGet *FolderGet
    body interface{}
}

func (r ApiFolderGetRequest) FolderGet(folderGet FolderGet) ApiFolderGetRequest {
	r.folderGet = &folderGet
	return r
}


    // Body sets the body payload for the API call.
func (r ApiFolderGetRequest) Body(body FolderGet) ApiFolderGetRequest {
    r.body = body
    return r
}

func (r ApiFolderGetRequest) Execute() (*FolderGetOutput, *http.Response, error) {
	return r.ApiService.FolderGetExecute(r)
}

/*
FolderGet Method for FolderGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFolderGetRequest
*/
func (a *V2ApiService) FolderGet(ctx context.Context) ApiFolderGetRequest {
	return ApiFolderGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FolderGetOutput
func (a *V2ApiService) FolderGetExecute(r ApiFolderGetRequest) (*FolderGetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolderGetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.FolderGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folder-get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFolderUpdateRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	folderUpdate *FolderUpdate
    body interface{}
}

func (r ApiFolderUpdateRequest) FolderUpdate(folderUpdate FolderUpdate) ApiFolderUpdateRequest {
	r.folderUpdate = &folderUpdate
	return r
}


    // Body sets the body payload for the API call.
func (r ApiFolderUpdateRequest) Body(body FolderUpdate) ApiFolderUpdateRequest {
    r.body = body
    return r
}

func (r ApiFolderUpdateRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.FolderUpdateExecute(r)
}

/*
FolderUpdate Method for FolderUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFolderUpdateRequest
*/
func (a *V2ApiService) FolderUpdate(ctx context.Context) ApiFolderUpdateRequest {
	return ApiFolderUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) FolderUpdateExecute(r ApiFolderUpdateRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.FolderUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folder-update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayCreateAllowedAccessRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayCreateAllowedAccess *GatewayCreateAllowedAccess
    body interface{}
}

func (r ApiGatewayCreateAllowedAccessRequest) GatewayCreateAllowedAccess(gatewayCreateAllowedAccess GatewayCreateAllowedAccess) ApiGatewayCreateAllowedAccessRequest {
	r.gatewayCreateAllowedAccess = &gatewayCreateAllowedAccess
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayCreateAllowedAccessRequest) Body(body GatewayCreateAllowedAccess) ApiGatewayCreateAllowedAccessRequest {
    r.body = body
    return r
}

func (r ApiGatewayCreateAllowedAccessRequest) Execute() (*AllowedAccess, *http.Response, error) {
	return r.ApiService.GatewayCreateAllowedAccessExecute(r)
}

/*
GatewayCreateAllowedAccess Method for GatewayCreateAllowedAccess

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayCreateAllowedAccessRequest
*/
func (a *V2ApiService) GatewayCreateAllowedAccess(ctx context.Context) ApiGatewayCreateAllowedAccessRequest {
	return ApiGatewayCreateAllowedAccessRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AllowedAccess
func (a *V2ApiService) GatewayCreateAllowedAccessExecute(r ApiGatewayCreateAllowedAccessRequest) (*AllowedAccess, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AllowedAccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayCreateAllowedAccess")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-create-allowed-access"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayCreateK8SAuthConfigRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayCreateK8SAuthConfig *GatewayCreateK8SAuthConfig
    body interface{}
}

func (r ApiGatewayCreateK8SAuthConfigRequest) GatewayCreateK8SAuthConfig(gatewayCreateK8SAuthConfig GatewayCreateK8SAuthConfig) ApiGatewayCreateK8SAuthConfigRequest {
	r.gatewayCreateK8SAuthConfig = &gatewayCreateK8SAuthConfig
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayCreateK8SAuthConfigRequest) Body(body GatewayCreateK8SAuthConfig) ApiGatewayCreateK8SAuthConfigRequest {
    r.body = body
    return r
}

func (r ApiGatewayCreateK8SAuthConfigRequest) Execute() (*GatewayCreateK8SAuthConfigOutput, *http.Response, error) {
	return r.ApiService.GatewayCreateK8SAuthConfigExecute(r)
}

/*
GatewayCreateK8SAuthConfig Method for GatewayCreateK8SAuthConfig

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayCreateK8SAuthConfigRequest
*/
func (a *V2ApiService) GatewayCreateK8SAuthConfig(ctx context.Context) ApiGatewayCreateK8SAuthConfigRequest {
	return ApiGatewayCreateK8SAuthConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayCreateK8SAuthConfigOutput
func (a *V2ApiService) GatewayCreateK8SAuthConfigExecute(r ApiGatewayCreateK8SAuthConfigRequest) (*GatewayCreateK8SAuthConfigOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayCreateK8SAuthConfigOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayCreateK8SAuthConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-create-k8s-auth-config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayCreateMigrationRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayCreateMigration *GatewayCreateMigration
    body interface{}
}

func (r ApiGatewayCreateMigrationRequest) GatewayCreateMigration(gatewayCreateMigration GatewayCreateMigration) ApiGatewayCreateMigrationRequest {
	r.gatewayCreateMigration = &gatewayCreateMigration
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayCreateMigrationRequest) Body(body GatewayCreateMigration) ApiGatewayCreateMigrationRequest {
    r.body = body
    return r
}

func (r ApiGatewayCreateMigrationRequest) Execute() (*GatewayMigrationCreateOutput, *http.Response, error) {
	return r.ApiService.GatewayCreateMigrationExecute(r)
}

/*
GatewayCreateMigration Method for GatewayCreateMigration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayCreateMigrationRequest
*/
func (a *V2ApiService) GatewayCreateMigration(ctx context.Context) ApiGatewayCreateMigrationRequest {
	return ApiGatewayCreateMigrationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayMigrationCreateOutput
func (a *V2ApiService) GatewayCreateMigrationExecute(r ApiGatewayCreateMigrationRequest) (*GatewayMigrationCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayMigrationCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayCreateMigration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-create-migration"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayCreateProducerArtifactoryRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayCreateProducerArtifactory *GatewayCreateProducerArtifactory
    body interface{}
}

func (r ApiGatewayCreateProducerArtifactoryRequest) GatewayCreateProducerArtifactory(gatewayCreateProducerArtifactory GatewayCreateProducerArtifactory) ApiGatewayCreateProducerArtifactoryRequest {
	r.gatewayCreateProducerArtifactory = &gatewayCreateProducerArtifactory
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayCreateProducerArtifactoryRequest) Body(body GatewayCreateProducerArtifactory) ApiGatewayCreateProducerArtifactoryRequest {
    r.body = body
    return r
}

func (r ApiGatewayCreateProducerArtifactoryRequest) Execute() (*GatewayCreateProducerArtifactoryOutput, *http.Response, error) {
	return r.ApiService.GatewayCreateProducerArtifactoryExecute(r)
}

/*
GatewayCreateProducerArtifactory Method for GatewayCreateProducerArtifactory

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayCreateProducerArtifactoryRequest
*/
func (a *V2ApiService) GatewayCreateProducerArtifactory(ctx context.Context) ApiGatewayCreateProducerArtifactoryRequest {
	return ApiGatewayCreateProducerArtifactoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayCreateProducerArtifactoryOutput
func (a *V2ApiService) GatewayCreateProducerArtifactoryExecute(r ApiGatewayCreateProducerArtifactoryRequest) (*GatewayCreateProducerArtifactoryOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayCreateProducerArtifactoryOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayCreateProducerArtifactory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-create-producer-artifactory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayCreateProducerAwsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayCreateProducerAws *GatewayCreateProducerAws
    body interface{}
}

func (r ApiGatewayCreateProducerAwsRequest) GatewayCreateProducerAws(gatewayCreateProducerAws GatewayCreateProducerAws) ApiGatewayCreateProducerAwsRequest {
	r.gatewayCreateProducerAws = &gatewayCreateProducerAws
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayCreateProducerAwsRequest) Body(body GatewayCreateProducerAws) ApiGatewayCreateProducerAwsRequest {
    r.body = body
    return r
}

func (r ApiGatewayCreateProducerAwsRequest) Execute() (*GatewayCreateProducerAwsOutput, *http.Response, error) {
	return r.ApiService.GatewayCreateProducerAwsExecute(r)
}

/*
GatewayCreateProducerAws Method for GatewayCreateProducerAws

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayCreateProducerAwsRequest
*/
func (a *V2ApiService) GatewayCreateProducerAws(ctx context.Context) ApiGatewayCreateProducerAwsRequest {
	return ApiGatewayCreateProducerAwsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayCreateProducerAwsOutput
func (a *V2ApiService) GatewayCreateProducerAwsExecute(r ApiGatewayCreateProducerAwsRequest) (*GatewayCreateProducerAwsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayCreateProducerAwsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayCreateProducerAws")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-create-producer-aws"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayCreateProducerAzureRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayCreateProducerAzure *GatewayCreateProducerAzure
    body interface{}
}

func (r ApiGatewayCreateProducerAzureRequest) GatewayCreateProducerAzure(gatewayCreateProducerAzure GatewayCreateProducerAzure) ApiGatewayCreateProducerAzureRequest {
	r.gatewayCreateProducerAzure = &gatewayCreateProducerAzure
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayCreateProducerAzureRequest) Body(body GatewayCreateProducerAzure) ApiGatewayCreateProducerAzureRequest {
    r.body = body
    return r
}

func (r ApiGatewayCreateProducerAzureRequest) Execute() (*GatewayCreateProducerAzureOutput, *http.Response, error) {
	return r.ApiService.GatewayCreateProducerAzureExecute(r)
}

/*
GatewayCreateProducerAzure Method for GatewayCreateProducerAzure

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayCreateProducerAzureRequest
*/
func (a *V2ApiService) GatewayCreateProducerAzure(ctx context.Context) ApiGatewayCreateProducerAzureRequest {
	return ApiGatewayCreateProducerAzureRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayCreateProducerAzureOutput
func (a *V2ApiService) GatewayCreateProducerAzureExecute(r ApiGatewayCreateProducerAzureRequest) (*GatewayCreateProducerAzureOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayCreateProducerAzureOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayCreateProducerAzure")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-create-producer-azure"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayCreateProducerCassandraRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayCreateProducerCassandra *GatewayCreateProducerCassandra
    body interface{}
}

func (r ApiGatewayCreateProducerCassandraRequest) GatewayCreateProducerCassandra(gatewayCreateProducerCassandra GatewayCreateProducerCassandra) ApiGatewayCreateProducerCassandraRequest {
	r.gatewayCreateProducerCassandra = &gatewayCreateProducerCassandra
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayCreateProducerCassandraRequest) Body(body GatewayCreateProducerCassandra) ApiGatewayCreateProducerCassandraRequest {
    r.body = body
    return r
}

func (r ApiGatewayCreateProducerCassandraRequest) Execute() (*GatewayCreateProducerCassandraOutput, *http.Response, error) {
	return r.ApiService.GatewayCreateProducerCassandraExecute(r)
}

/*
GatewayCreateProducerCassandra Method for GatewayCreateProducerCassandra

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayCreateProducerCassandraRequest
*/
func (a *V2ApiService) GatewayCreateProducerCassandra(ctx context.Context) ApiGatewayCreateProducerCassandraRequest {
	return ApiGatewayCreateProducerCassandraRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayCreateProducerCassandraOutput
func (a *V2ApiService) GatewayCreateProducerCassandraExecute(r ApiGatewayCreateProducerCassandraRequest) (*GatewayCreateProducerCassandraOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayCreateProducerCassandraOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayCreateProducerCassandra")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-create-producer-cassandra"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayCreateProducerChefRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayCreateProducerChef *GatewayCreateProducerChef
    body interface{}
}

func (r ApiGatewayCreateProducerChefRequest) GatewayCreateProducerChef(gatewayCreateProducerChef GatewayCreateProducerChef) ApiGatewayCreateProducerChefRequest {
	r.gatewayCreateProducerChef = &gatewayCreateProducerChef
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayCreateProducerChefRequest) Body(body GatewayCreateProducerChef) ApiGatewayCreateProducerChefRequest {
    r.body = body
    return r
}

func (r ApiGatewayCreateProducerChefRequest) Execute() (*GatewayCreateProducerChefOutput, *http.Response, error) {
	return r.ApiService.GatewayCreateProducerChefExecute(r)
}

/*
GatewayCreateProducerChef Method for GatewayCreateProducerChef

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayCreateProducerChefRequest
*/
func (a *V2ApiService) GatewayCreateProducerChef(ctx context.Context) ApiGatewayCreateProducerChefRequest {
	return ApiGatewayCreateProducerChefRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayCreateProducerChefOutput
func (a *V2ApiService) GatewayCreateProducerChefExecute(r ApiGatewayCreateProducerChefRequest) (*GatewayCreateProducerChefOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayCreateProducerChefOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayCreateProducerChef")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-create-producer-chef"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayCreateProducerCustomRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayCreateProducerCustom *GatewayCreateProducerCustom
    body interface{}
}

func (r ApiGatewayCreateProducerCustomRequest) GatewayCreateProducerCustom(gatewayCreateProducerCustom GatewayCreateProducerCustom) ApiGatewayCreateProducerCustomRequest {
	r.gatewayCreateProducerCustom = &gatewayCreateProducerCustom
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayCreateProducerCustomRequest) Body(body GatewayCreateProducerCustom) ApiGatewayCreateProducerCustomRequest {
    r.body = body
    return r
}

func (r ApiGatewayCreateProducerCustomRequest) Execute() (*GatewayCreateProducerCustomOutput, *http.Response, error) {
	return r.ApiService.GatewayCreateProducerCustomExecute(r)
}

/*
GatewayCreateProducerCustom Method for GatewayCreateProducerCustom

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayCreateProducerCustomRequest
*/
func (a *V2ApiService) GatewayCreateProducerCustom(ctx context.Context) ApiGatewayCreateProducerCustomRequest {
	return ApiGatewayCreateProducerCustomRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayCreateProducerCustomOutput
func (a *V2ApiService) GatewayCreateProducerCustomExecute(r ApiGatewayCreateProducerCustomRequest) (*GatewayCreateProducerCustomOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayCreateProducerCustomOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayCreateProducerCustom")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-create-producer-custom"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayCreateProducerDockerhubRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayCreateProducerDockerhub *GatewayCreateProducerDockerhub
    body interface{}
}

func (r ApiGatewayCreateProducerDockerhubRequest) GatewayCreateProducerDockerhub(gatewayCreateProducerDockerhub GatewayCreateProducerDockerhub) ApiGatewayCreateProducerDockerhubRequest {
	r.gatewayCreateProducerDockerhub = &gatewayCreateProducerDockerhub
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayCreateProducerDockerhubRequest) Body(body GatewayCreateProducerDockerhub) ApiGatewayCreateProducerDockerhubRequest {
    r.body = body
    return r
}

func (r ApiGatewayCreateProducerDockerhubRequest) Execute() (*GatewayCreateProducerDockerhubOutput, *http.Response, error) {
	return r.ApiService.GatewayCreateProducerDockerhubExecute(r)
}

/*
GatewayCreateProducerDockerhub Method for GatewayCreateProducerDockerhub

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayCreateProducerDockerhubRequest
*/
func (a *V2ApiService) GatewayCreateProducerDockerhub(ctx context.Context) ApiGatewayCreateProducerDockerhubRequest {
	return ApiGatewayCreateProducerDockerhubRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayCreateProducerDockerhubOutput
func (a *V2ApiService) GatewayCreateProducerDockerhubExecute(r ApiGatewayCreateProducerDockerhubRequest) (*GatewayCreateProducerDockerhubOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayCreateProducerDockerhubOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayCreateProducerDockerhub")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-create-producer-dockerhub"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayCreateProducerEksRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayCreateProducerEks *GatewayCreateProducerEks
    body interface{}
}

func (r ApiGatewayCreateProducerEksRequest) GatewayCreateProducerEks(gatewayCreateProducerEks GatewayCreateProducerEks) ApiGatewayCreateProducerEksRequest {
	r.gatewayCreateProducerEks = &gatewayCreateProducerEks
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayCreateProducerEksRequest) Body(body GatewayCreateProducerEks) ApiGatewayCreateProducerEksRequest {
    r.body = body
    return r
}

func (r ApiGatewayCreateProducerEksRequest) Execute() (*GatewayCreateProducerEksOutput, *http.Response, error) {
	return r.ApiService.GatewayCreateProducerEksExecute(r)
}

/*
GatewayCreateProducerEks Method for GatewayCreateProducerEks

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayCreateProducerEksRequest
*/
func (a *V2ApiService) GatewayCreateProducerEks(ctx context.Context) ApiGatewayCreateProducerEksRequest {
	return ApiGatewayCreateProducerEksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayCreateProducerEksOutput
func (a *V2ApiService) GatewayCreateProducerEksExecute(r ApiGatewayCreateProducerEksRequest) (*GatewayCreateProducerEksOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayCreateProducerEksOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayCreateProducerEks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-create-producer-eks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayCreateProducerGcpRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayCreateProducerGcp *GatewayCreateProducerGcp
    body interface{}
}

func (r ApiGatewayCreateProducerGcpRequest) GatewayCreateProducerGcp(gatewayCreateProducerGcp GatewayCreateProducerGcp) ApiGatewayCreateProducerGcpRequest {
	r.gatewayCreateProducerGcp = &gatewayCreateProducerGcp
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayCreateProducerGcpRequest) Body(body GatewayCreateProducerGcp) ApiGatewayCreateProducerGcpRequest {
    r.body = body
    return r
}

func (r ApiGatewayCreateProducerGcpRequest) Execute() (*GatewayCreateProducerGcpOutput, *http.Response, error) {
	return r.ApiService.GatewayCreateProducerGcpExecute(r)
}

/*
GatewayCreateProducerGcp Method for GatewayCreateProducerGcp

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayCreateProducerGcpRequest
*/
func (a *V2ApiService) GatewayCreateProducerGcp(ctx context.Context) ApiGatewayCreateProducerGcpRequest {
	return ApiGatewayCreateProducerGcpRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayCreateProducerGcpOutput
func (a *V2ApiService) GatewayCreateProducerGcpExecute(r ApiGatewayCreateProducerGcpRequest) (*GatewayCreateProducerGcpOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayCreateProducerGcpOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayCreateProducerGcp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-create-producer-gcp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayCreateProducerGithubRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayCreateProducerGithub *GatewayCreateProducerGithub
    body interface{}
}

func (r ApiGatewayCreateProducerGithubRequest) GatewayCreateProducerGithub(gatewayCreateProducerGithub GatewayCreateProducerGithub) ApiGatewayCreateProducerGithubRequest {
	r.gatewayCreateProducerGithub = &gatewayCreateProducerGithub
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayCreateProducerGithubRequest) Body(body GatewayCreateProducerGithub) ApiGatewayCreateProducerGithubRequest {
    r.body = body
    return r
}

func (r ApiGatewayCreateProducerGithubRequest) Execute() (*GatewayCreateProducerGithubOutput, *http.Response, error) {
	return r.ApiService.GatewayCreateProducerGithubExecute(r)
}

/*
GatewayCreateProducerGithub Method for GatewayCreateProducerGithub

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayCreateProducerGithubRequest
*/
func (a *V2ApiService) GatewayCreateProducerGithub(ctx context.Context) ApiGatewayCreateProducerGithubRequest {
	return ApiGatewayCreateProducerGithubRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayCreateProducerGithubOutput
func (a *V2ApiService) GatewayCreateProducerGithubExecute(r ApiGatewayCreateProducerGithubRequest) (*GatewayCreateProducerGithubOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayCreateProducerGithubOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayCreateProducerGithub")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-create-producer-github"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayCreateProducerGkeRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayCreateProducerGke *GatewayCreateProducerGke
    body interface{}
}

func (r ApiGatewayCreateProducerGkeRequest) GatewayCreateProducerGke(gatewayCreateProducerGke GatewayCreateProducerGke) ApiGatewayCreateProducerGkeRequest {
	r.gatewayCreateProducerGke = &gatewayCreateProducerGke
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayCreateProducerGkeRequest) Body(body GatewayCreateProducerGke) ApiGatewayCreateProducerGkeRequest {
    r.body = body
    return r
}

func (r ApiGatewayCreateProducerGkeRequest) Execute() (*GatewayCreateProducerGkeOutput, *http.Response, error) {
	return r.ApiService.GatewayCreateProducerGkeExecute(r)
}

/*
GatewayCreateProducerGke Method for GatewayCreateProducerGke

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayCreateProducerGkeRequest
*/
func (a *V2ApiService) GatewayCreateProducerGke(ctx context.Context) ApiGatewayCreateProducerGkeRequest {
	return ApiGatewayCreateProducerGkeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayCreateProducerGkeOutput
func (a *V2ApiService) GatewayCreateProducerGkeExecute(r ApiGatewayCreateProducerGkeRequest) (*GatewayCreateProducerGkeOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayCreateProducerGkeOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayCreateProducerGke")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-create-producer-gke"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayCreateProducerHanaDbRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayCreateProducerHanaDb *GatewayCreateProducerHanaDb
    body interface{}
}

func (r ApiGatewayCreateProducerHanaDbRequest) GatewayCreateProducerHanaDb(gatewayCreateProducerHanaDb GatewayCreateProducerHanaDb) ApiGatewayCreateProducerHanaDbRequest {
	r.gatewayCreateProducerHanaDb = &gatewayCreateProducerHanaDb
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayCreateProducerHanaDbRequest) Body(body GatewayCreateProducerHanaDb) ApiGatewayCreateProducerHanaDbRequest {
    r.body = body
    return r
}

func (r ApiGatewayCreateProducerHanaDbRequest) Execute() (*GatewayCreateProducerHanaDbOutput, *http.Response, error) {
	return r.ApiService.GatewayCreateProducerHanaDbExecute(r)
}

/*
GatewayCreateProducerHanaDb Method for GatewayCreateProducerHanaDb

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayCreateProducerHanaDbRequest
*/
func (a *V2ApiService) GatewayCreateProducerHanaDb(ctx context.Context) ApiGatewayCreateProducerHanaDbRequest {
	return ApiGatewayCreateProducerHanaDbRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayCreateProducerHanaDbOutput
func (a *V2ApiService) GatewayCreateProducerHanaDbExecute(r ApiGatewayCreateProducerHanaDbRequest) (*GatewayCreateProducerHanaDbOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayCreateProducerHanaDbOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayCreateProducerHanaDb")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-create-producer-hanadb"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayCreateProducerLdapRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayCreateProducerLdap *GatewayCreateProducerLdap
    body interface{}
}

func (r ApiGatewayCreateProducerLdapRequest) GatewayCreateProducerLdap(gatewayCreateProducerLdap GatewayCreateProducerLdap) ApiGatewayCreateProducerLdapRequest {
	r.gatewayCreateProducerLdap = &gatewayCreateProducerLdap
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayCreateProducerLdapRequest) Body(body GatewayCreateProducerLdap) ApiGatewayCreateProducerLdapRequest {
    r.body = body
    return r
}

func (r ApiGatewayCreateProducerLdapRequest) Execute() (*GatewayCreateProducerLdapOutput, *http.Response, error) {
	return r.ApiService.GatewayCreateProducerLdapExecute(r)
}

/*
GatewayCreateProducerLdap Method for GatewayCreateProducerLdap

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayCreateProducerLdapRequest
*/
func (a *V2ApiService) GatewayCreateProducerLdap(ctx context.Context) ApiGatewayCreateProducerLdapRequest {
	return ApiGatewayCreateProducerLdapRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayCreateProducerLdapOutput
func (a *V2ApiService) GatewayCreateProducerLdapExecute(r ApiGatewayCreateProducerLdapRequest) (*GatewayCreateProducerLdapOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayCreateProducerLdapOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayCreateProducerLdap")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-create-producer-ldap"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayCreateProducerMSSQLRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayCreateProducerMSSQL *GatewayCreateProducerMSSQL
    body interface{}
}

func (r ApiGatewayCreateProducerMSSQLRequest) GatewayCreateProducerMSSQL(gatewayCreateProducerMSSQL GatewayCreateProducerMSSQL) ApiGatewayCreateProducerMSSQLRequest {
	r.gatewayCreateProducerMSSQL = &gatewayCreateProducerMSSQL
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayCreateProducerMSSQLRequest) Body(body GatewayCreateProducerMSSQL) ApiGatewayCreateProducerMSSQLRequest {
    r.body = body
    return r
}

func (r ApiGatewayCreateProducerMSSQLRequest) Execute() (*GatewayCreateProducerMSSQLOutput, *http.Response, error) {
	return r.ApiService.GatewayCreateProducerMSSQLExecute(r)
}

/*
GatewayCreateProducerMSSQL Method for GatewayCreateProducerMSSQL

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayCreateProducerMSSQLRequest
*/
func (a *V2ApiService) GatewayCreateProducerMSSQL(ctx context.Context) ApiGatewayCreateProducerMSSQLRequest {
	return ApiGatewayCreateProducerMSSQLRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayCreateProducerMSSQLOutput
func (a *V2ApiService) GatewayCreateProducerMSSQLExecute(r ApiGatewayCreateProducerMSSQLRequest) (*GatewayCreateProducerMSSQLOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayCreateProducerMSSQLOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayCreateProducerMSSQL")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-create-producer-mssql"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayCreateProducerMongoRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayCreateProducerMongo *GatewayCreateProducerMongo
    body interface{}
}

func (r ApiGatewayCreateProducerMongoRequest) GatewayCreateProducerMongo(gatewayCreateProducerMongo GatewayCreateProducerMongo) ApiGatewayCreateProducerMongoRequest {
	r.gatewayCreateProducerMongo = &gatewayCreateProducerMongo
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayCreateProducerMongoRequest) Body(body GatewayCreateProducerMongo) ApiGatewayCreateProducerMongoRequest {
    r.body = body
    return r
}

func (r ApiGatewayCreateProducerMongoRequest) Execute() (*GatewayCreateProducerMongoOutput, *http.Response, error) {
	return r.ApiService.GatewayCreateProducerMongoExecute(r)
}

/*
GatewayCreateProducerMongo Method for GatewayCreateProducerMongo

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayCreateProducerMongoRequest
*/
func (a *V2ApiService) GatewayCreateProducerMongo(ctx context.Context) ApiGatewayCreateProducerMongoRequest {
	return ApiGatewayCreateProducerMongoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayCreateProducerMongoOutput
func (a *V2ApiService) GatewayCreateProducerMongoExecute(r ApiGatewayCreateProducerMongoRequest) (*GatewayCreateProducerMongoOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayCreateProducerMongoOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayCreateProducerMongo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-create-producer-mongo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayCreateProducerMySQLRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayCreateProducerMySQL *GatewayCreateProducerMySQL
    body interface{}
}

func (r ApiGatewayCreateProducerMySQLRequest) GatewayCreateProducerMySQL(gatewayCreateProducerMySQL GatewayCreateProducerMySQL) ApiGatewayCreateProducerMySQLRequest {
	r.gatewayCreateProducerMySQL = &gatewayCreateProducerMySQL
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayCreateProducerMySQLRequest) Body(body GatewayCreateProducerMySQL) ApiGatewayCreateProducerMySQLRequest {
    r.body = body
    return r
}

func (r ApiGatewayCreateProducerMySQLRequest) Execute() (*GatewayCreateProducerMySQLOutput, *http.Response, error) {
	return r.ApiService.GatewayCreateProducerMySQLExecute(r)
}

/*
GatewayCreateProducerMySQL Method for GatewayCreateProducerMySQL

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayCreateProducerMySQLRequest
*/
func (a *V2ApiService) GatewayCreateProducerMySQL(ctx context.Context) ApiGatewayCreateProducerMySQLRequest {
	return ApiGatewayCreateProducerMySQLRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayCreateProducerMySQLOutput
func (a *V2ApiService) GatewayCreateProducerMySQLExecute(r ApiGatewayCreateProducerMySQLRequest) (*GatewayCreateProducerMySQLOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayCreateProducerMySQLOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayCreateProducerMySQL")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-create-producer-mysql"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayCreateProducerNativeK8SRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayCreateProducerNativeK8S *GatewayCreateProducerNativeK8S
    body interface{}
}

func (r ApiGatewayCreateProducerNativeK8SRequest) GatewayCreateProducerNativeK8S(gatewayCreateProducerNativeK8S GatewayCreateProducerNativeK8S) ApiGatewayCreateProducerNativeK8SRequest {
	r.gatewayCreateProducerNativeK8S = &gatewayCreateProducerNativeK8S
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayCreateProducerNativeK8SRequest) Body(body GatewayCreateProducerNativeK8S) ApiGatewayCreateProducerNativeK8SRequest {
    r.body = body
    return r
}

func (r ApiGatewayCreateProducerNativeK8SRequest) Execute() (*GatewayCreateProducerNativeK8SOutput, *http.Response, error) {
	return r.ApiService.GatewayCreateProducerNativeK8SExecute(r)
}

/*
GatewayCreateProducerNativeK8S Method for GatewayCreateProducerNativeK8S

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayCreateProducerNativeK8SRequest
*/
func (a *V2ApiService) GatewayCreateProducerNativeK8S(ctx context.Context) ApiGatewayCreateProducerNativeK8SRequest {
	return ApiGatewayCreateProducerNativeK8SRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayCreateProducerNativeK8SOutput
func (a *V2ApiService) GatewayCreateProducerNativeK8SExecute(r ApiGatewayCreateProducerNativeK8SRequest) (*GatewayCreateProducerNativeK8SOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayCreateProducerNativeK8SOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayCreateProducerNativeK8S")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-create-producer-k8s"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayCreateProducerOracleDbRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayCreateProducerOracleDb *GatewayCreateProducerOracleDb
    body interface{}
}

func (r ApiGatewayCreateProducerOracleDbRequest) GatewayCreateProducerOracleDb(gatewayCreateProducerOracleDb GatewayCreateProducerOracleDb) ApiGatewayCreateProducerOracleDbRequest {
	r.gatewayCreateProducerOracleDb = &gatewayCreateProducerOracleDb
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayCreateProducerOracleDbRequest) Body(body GatewayCreateProducerOracleDb) ApiGatewayCreateProducerOracleDbRequest {
    r.body = body
    return r
}

func (r ApiGatewayCreateProducerOracleDbRequest) Execute() (*GatewayCreateProducerOracleDbOutput, *http.Response, error) {
	return r.ApiService.GatewayCreateProducerOracleDbExecute(r)
}

/*
GatewayCreateProducerOracleDb Method for GatewayCreateProducerOracleDb

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayCreateProducerOracleDbRequest
*/
func (a *V2ApiService) GatewayCreateProducerOracleDb(ctx context.Context) ApiGatewayCreateProducerOracleDbRequest {
	return ApiGatewayCreateProducerOracleDbRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayCreateProducerOracleDbOutput
func (a *V2ApiService) GatewayCreateProducerOracleDbExecute(r ApiGatewayCreateProducerOracleDbRequest) (*GatewayCreateProducerOracleDbOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayCreateProducerOracleDbOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayCreateProducerOracleDb")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-create-producer-oracle"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayCreateProducerPingRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayCreateProducerPing *GatewayCreateProducerPing
    body interface{}
}

func (r ApiGatewayCreateProducerPingRequest) GatewayCreateProducerPing(gatewayCreateProducerPing GatewayCreateProducerPing) ApiGatewayCreateProducerPingRequest {
	r.gatewayCreateProducerPing = &gatewayCreateProducerPing
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayCreateProducerPingRequest) Body(body GatewayCreateProducerPing) ApiGatewayCreateProducerPingRequest {
    r.body = body
    return r
}

func (r ApiGatewayCreateProducerPingRequest) Execute() (*GatewayCreateProducerPingOutput, *http.Response, error) {
	return r.ApiService.GatewayCreateProducerPingExecute(r)
}

/*
GatewayCreateProducerPing Method for GatewayCreateProducerPing

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayCreateProducerPingRequest
*/
func (a *V2ApiService) GatewayCreateProducerPing(ctx context.Context) ApiGatewayCreateProducerPingRequest {
	return ApiGatewayCreateProducerPingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayCreateProducerPingOutput
func (a *V2ApiService) GatewayCreateProducerPingExecute(r ApiGatewayCreateProducerPingRequest) (*GatewayCreateProducerPingOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayCreateProducerPingOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayCreateProducerPing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-create-producer-ping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayCreateProducerPostgreSQLRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayCreateProducerPostgreSQL *GatewayCreateProducerPostgreSQL
    body interface{}
}

func (r ApiGatewayCreateProducerPostgreSQLRequest) GatewayCreateProducerPostgreSQL(gatewayCreateProducerPostgreSQL GatewayCreateProducerPostgreSQL) ApiGatewayCreateProducerPostgreSQLRequest {
	r.gatewayCreateProducerPostgreSQL = &gatewayCreateProducerPostgreSQL
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayCreateProducerPostgreSQLRequest) Body(body GatewayCreateProducerPostgreSQL) ApiGatewayCreateProducerPostgreSQLRequest {
    r.body = body
    return r
}

func (r ApiGatewayCreateProducerPostgreSQLRequest) Execute() (*GatewayCreateProducerPostgreSQLOutput, *http.Response, error) {
	return r.ApiService.GatewayCreateProducerPostgreSQLExecute(r)
}

/*
GatewayCreateProducerPostgreSQL Method for GatewayCreateProducerPostgreSQL

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayCreateProducerPostgreSQLRequest
*/
func (a *V2ApiService) GatewayCreateProducerPostgreSQL(ctx context.Context) ApiGatewayCreateProducerPostgreSQLRequest {
	return ApiGatewayCreateProducerPostgreSQLRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayCreateProducerPostgreSQLOutput
func (a *V2ApiService) GatewayCreateProducerPostgreSQLExecute(r ApiGatewayCreateProducerPostgreSQLRequest) (*GatewayCreateProducerPostgreSQLOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayCreateProducerPostgreSQLOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayCreateProducerPostgreSQL")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-create-producer-postgresql"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayCreateProducerRabbitMQRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayCreateProducerRabbitMQ *GatewayCreateProducerRabbitMQ
    body interface{}
}

func (r ApiGatewayCreateProducerRabbitMQRequest) GatewayCreateProducerRabbitMQ(gatewayCreateProducerRabbitMQ GatewayCreateProducerRabbitMQ) ApiGatewayCreateProducerRabbitMQRequest {
	r.gatewayCreateProducerRabbitMQ = &gatewayCreateProducerRabbitMQ
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayCreateProducerRabbitMQRequest) Body(body GatewayCreateProducerRabbitMQ) ApiGatewayCreateProducerRabbitMQRequest {
    r.body = body
    return r
}

func (r ApiGatewayCreateProducerRabbitMQRequest) Execute() (*GatewayCreateProducerRabbitMQOutput, *http.Response, error) {
	return r.ApiService.GatewayCreateProducerRabbitMQExecute(r)
}

/*
GatewayCreateProducerRabbitMQ Method for GatewayCreateProducerRabbitMQ

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayCreateProducerRabbitMQRequest
*/
func (a *V2ApiService) GatewayCreateProducerRabbitMQ(ctx context.Context) ApiGatewayCreateProducerRabbitMQRequest {
	return ApiGatewayCreateProducerRabbitMQRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayCreateProducerRabbitMQOutput
func (a *V2ApiService) GatewayCreateProducerRabbitMQExecute(r ApiGatewayCreateProducerRabbitMQRequest) (*GatewayCreateProducerRabbitMQOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayCreateProducerRabbitMQOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayCreateProducerRabbitMQ")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-create-producer-rabbitmq"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayCreateProducerRdpRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayCreateProducerRdp *GatewayCreateProducerRdp
    body interface{}
}

func (r ApiGatewayCreateProducerRdpRequest) GatewayCreateProducerRdp(gatewayCreateProducerRdp GatewayCreateProducerRdp) ApiGatewayCreateProducerRdpRequest {
	r.gatewayCreateProducerRdp = &gatewayCreateProducerRdp
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayCreateProducerRdpRequest) Body(body GatewayCreateProducerRdp) ApiGatewayCreateProducerRdpRequest {
    r.body = body
    return r
}

func (r ApiGatewayCreateProducerRdpRequest) Execute() (*GatewayCreateProducerRdpOutput, *http.Response, error) {
	return r.ApiService.GatewayCreateProducerRdpExecute(r)
}

/*
GatewayCreateProducerRdp Method for GatewayCreateProducerRdp

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayCreateProducerRdpRequest
*/
func (a *V2ApiService) GatewayCreateProducerRdp(ctx context.Context) ApiGatewayCreateProducerRdpRequest {
	return ApiGatewayCreateProducerRdpRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayCreateProducerRdpOutput
func (a *V2ApiService) GatewayCreateProducerRdpExecute(r ApiGatewayCreateProducerRdpRequest) (*GatewayCreateProducerRdpOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayCreateProducerRdpOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayCreateProducerRdp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-create-producer-rdp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayCreateProducerRedisRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayCreateProducerRedis *GatewayCreateProducerRedis
    body interface{}
}

func (r ApiGatewayCreateProducerRedisRequest) GatewayCreateProducerRedis(gatewayCreateProducerRedis GatewayCreateProducerRedis) ApiGatewayCreateProducerRedisRequest {
	r.gatewayCreateProducerRedis = &gatewayCreateProducerRedis
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayCreateProducerRedisRequest) Body(body GatewayCreateProducerRedis) ApiGatewayCreateProducerRedisRequest {
    r.body = body
    return r
}

func (r ApiGatewayCreateProducerRedisRequest) Execute() (*GatewayCreateProducerRedisOutput, *http.Response, error) {
	return r.ApiService.GatewayCreateProducerRedisExecute(r)
}

/*
GatewayCreateProducerRedis Method for GatewayCreateProducerRedis

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayCreateProducerRedisRequest
*/
func (a *V2ApiService) GatewayCreateProducerRedis(ctx context.Context) ApiGatewayCreateProducerRedisRequest {
	return ApiGatewayCreateProducerRedisRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayCreateProducerRedisOutput
func (a *V2ApiService) GatewayCreateProducerRedisExecute(r ApiGatewayCreateProducerRedisRequest) (*GatewayCreateProducerRedisOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayCreateProducerRedisOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayCreateProducerRedis")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-create-producer-Redis"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayCreateProducerRedshiftRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayCreateProducerRedshift *GatewayCreateProducerRedshift
    body interface{}
}

func (r ApiGatewayCreateProducerRedshiftRequest) GatewayCreateProducerRedshift(gatewayCreateProducerRedshift GatewayCreateProducerRedshift) ApiGatewayCreateProducerRedshiftRequest {
	r.gatewayCreateProducerRedshift = &gatewayCreateProducerRedshift
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayCreateProducerRedshiftRequest) Body(body GatewayCreateProducerRedshift) ApiGatewayCreateProducerRedshiftRequest {
    r.body = body
    return r
}

func (r ApiGatewayCreateProducerRedshiftRequest) Execute() (*GatewayCreateProducerRedshiftOutput, *http.Response, error) {
	return r.ApiService.GatewayCreateProducerRedshiftExecute(r)
}

/*
GatewayCreateProducerRedshift Method for GatewayCreateProducerRedshift

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayCreateProducerRedshiftRequest
*/
func (a *V2ApiService) GatewayCreateProducerRedshift(ctx context.Context) ApiGatewayCreateProducerRedshiftRequest {
	return ApiGatewayCreateProducerRedshiftRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayCreateProducerRedshiftOutput
func (a *V2ApiService) GatewayCreateProducerRedshiftExecute(r ApiGatewayCreateProducerRedshiftRequest) (*GatewayCreateProducerRedshiftOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayCreateProducerRedshiftOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayCreateProducerRedshift")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-create-producer-redshift"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayCreateProducerSnowflakeRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayCreateProducerSnowflake *GatewayCreateProducerSnowflake
    body interface{}
}

func (r ApiGatewayCreateProducerSnowflakeRequest) GatewayCreateProducerSnowflake(gatewayCreateProducerSnowflake GatewayCreateProducerSnowflake) ApiGatewayCreateProducerSnowflakeRequest {
	r.gatewayCreateProducerSnowflake = &gatewayCreateProducerSnowflake
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayCreateProducerSnowflakeRequest) Body(body GatewayCreateProducerSnowflake) ApiGatewayCreateProducerSnowflakeRequest {
    r.body = body
    return r
}

func (r ApiGatewayCreateProducerSnowflakeRequest) Execute() (*GatewayCreateProducerSnowflakeOutput, *http.Response, error) {
	return r.ApiService.GatewayCreateProducerSnowflakeExecute(r)
}

/*
GatewayCreateProducerSnowflake Method for GatewayCreateProducerSnowflake

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayCreateProducerSnowflakeRequest
*/
func (a *V2ApiService) GatewayCreateProducerSnowflake(ctx context.Context) ApiGatewayCreateProducerSnowflakeRequest {
	return ApiGatewayCreateProducerSnowflakeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayCreateProducerSnowflakeOutput
func (a *V2ApiService) GatewayCreateProducerSnowflakeExecute(r ApiGatewayCreateProducerSnowflakeRequest) (*GatewayCreateProducerSnowflakeOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayCreateProducerSnowflakeOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayCreateProducerSnowflake")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-create-producer-snowflake"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayCreateProducerVenafiRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayCreateProducerVenafi *GatewayCreateProducerVenafi
    body interface{}
}

func (r ApiGatewayCreateProducerVenafiRequest) GatewayCreateProducerVenafi(gatewayCreateProducerVenafi GatewayCreateProducerVenafi) ApiGatewayCreateProducerVenafiRequest {
	r.gatewayCreateProducerVenafi = &gatewayCreateProducerVenafi
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayCreateProducerVenafiRequest) Body(body GatewayCreateProducerVenafi) ApiGatewayCreateProducerVenafiRequest {
    r.body = body
    return r
}

func (r ApiGatewayCreateProducerVenafiRequest) Execute() (*GatewayCreateProducerVenafiOutput, *http.Response, error) {
	return r.ApiService.GatewayCreateProducerVenafiExecute(r)
}

/*
GatewayCreateProducerVenafi Method for GatewayCreateProducerVenafi

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayCreateProducerVenafiRequest
*/
func (a *V2ApiService) GatewayCreateProducerVenafi(ctx context.Context) ApiGatewayCreateProducerVenafiRequest {
	return ApiGatewayCreateProducerVenafiRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayCreateProducerVenafiOutput
func (a *V2ApiService) GatewayCreateProducerVenafiExecute(r ApiGatewayCreateProducerVenafiRequest) (*GatewayCreateProducerVenafiOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayCreateProducerVenafiOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayCreateProducerVenafi")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-create-producer-certificate-automation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayDeleteAllowedAccessRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayDeleteAllowedAccess *GatewayDeleteAllowedAccess
    body interface{}
}

func (r ApiGatewayDeleteAllowedAccessRequest) GatewayDeleteAllowedAccess(gatewayDeleteAllowedAccess GatewayDeleteAllowedAccess) ApiGatewayDeleteAllowedAccessRequest {
	r.gatewayDeleteAllowedAccess = &gatewayDeleteAllowedAccess
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayDeleteAllowedAccessRequest) Body(body GatewayDeleteAllowedAccess) ApiGatewayDeleteAllowedAccessRequest {
    r.body = body
    return r
}

func (r ApiGatewayDeleteAllowedAccessRequest) Execute() (*GatewayDeleteAllowedAccessOutput, *http.Response, error) {
	return r.ApiService.GatewayDeleteAllowedAccessExecute(r)
}

/*
GatewayDeleteAllowedAccess Method for GatewayDeleteAllowedAccess

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayDeleteAllowedAccessRequest
*/
func (a *V2ApiService) GatewayDeleteAllowedAccess(ctx context.Context) ApiGatewayDeleteAllowedAccessRequest {
	return ApiGatewayDeleteAllowedAccessRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayDeleteAllowedAccessOutput
func (a *V2ApiService) GatewayDeleteAllowedAccessExecute(r ApiGatewayDeleteAllowedAccessRequest) (*GatewayDeleteAllowedAccessOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayDeleteAllowedAccessOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayDeleteAllowedAccess")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-delete-allowed-access"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayDeleteK8SAuthConfigRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayDeleteK8SAuthConfig *GatewayDeleteK8SAuthConfig
    body interface{}
}

func (r ApiGatewayDeleteK8SAuthConfigRequest) GatewayDeleteK8SAuthConfig(gatewayDeleteK8SAuthConfig GatewayDeleteK8SAuthConfig) ApiGatewayDeleteK8SAuthConfigRequest {
	r.gatewayDeleteK8SAuthConfig = &gatewayDeleteK8SAuthConfig
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayDeleteK8SAuthConfigRequest) Body(body GatewayDeleteK8SAuthConfig) ApiGatewayDeleteK8SAuthConfigRequest {
    r.body = body
    return r
}

func (r ApiGatewayDeleteK8SAuthConfigRequest) Execute() (*GatewayDeleteK8SAuthConfigOutput, *http.Response, error) {
	return r.ApiService.GatewayDeleteK8SAuthConfigExecute(r)
}

/*
GatewayDeleteK8SAuthConfig Method for GatewayDeleteK8SAuthConfig

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayDeleteK8SAuthConfigRequest
*/
func (a *V2ApiService) GatewayDeleteK8SAuthConfig(ctx context.Context) ApiGatewayDeleteK8SAuthConfigRequest {
	return ApiGatewayDeleteK8SAuthConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayDeleteK8SAuthConfigOutput
func (a *V2ApiService) GatewayDeleteK8SAuthConfigExecute(r ApiGatewayDeleteK8SAuthConfigRequest) (*GatewayDeleteK8SAuthConfigOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayDeleteK8SAuthConfigOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayDeleteK8SAuthConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-delete-k8s-auth-config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayDeleteMigrationRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayDeleteMigration *GatewayDeleteMigration
    body interface{}
}

func (r ApiGatewayDeleteMigrationRequest) GatewayDeleteMigration(gatewayDeleteMigration GatewayDeleteMigration) ApiGatewayDeleteMigrationRequest {
	r.gatewayDeleteMigration = &gatewayDeleteMigration
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayDeleteMigrationRequest) Body(body GatewayDeleteMigration) ApiGatewayDeleteMigrationRequest {
    r.body = body
    return r
}

func (r ApiGatewayDeleteMigrationRequest) Execute() (*GatewayMigrationDeleteOutput, *http.Response, error) {
	return r.ApiService.GatewayDeleteMigrationExecute(r)
}

/*
GatewayDeleteMigration Method for GatewayDeleteMigration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayDeleteMigrationRequest
*/
func (a *V2ApiService) GatewayDeleteMigration(ctx context.Context) ApiGatewayDeleteMigrationRequest {
	return ApiGatewayDeleteMigrationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayMigrationDeleteOutput
func (a *V2ApiService) GatewayDeleteMigrationExecute(r ApiGatewayDeleteMigrationRequest) (*GatewayMigrationDeleteOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayMigrationDeleteOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayDeleteMigration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-delete-migration"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayDeleteProducerRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayDeleteProducer *GatewayDeleteProducer
    body interface{}
}

func (r ApiGatewayDeleteProducerRequest) GatewayDeleteProducer(gatewayDeleteProducer GatewayDeleteProducer) ApiGatewayDeleteProducerRequest {
	r.gatewayDeleteProducer = &gatewayDeleteProducer
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayDeleteProducerRequest) Body(body GatewayDeleteProducer) ApiGatewayDeleteProducerRequest {
    r.body = body
    return r
}

func (r ApiGatewayDeleteProducerRequest) Execute() (*GatewayDeleteProducerOutput, *http.Response, error) {
	return r.ApiService.GatewayDeleteProducerExecute(r)
}

/*
GatewayDeleteProducer Method for GatewayDeleteProducer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayDeleteProducerRequest
*/
func (a *V2ApiService) GatewayDeleteProducer(ctx context.Context) ApiGatewayDeleteProducerRequest {
	return ApiGatewayDeleteProducerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayDeleteProducerOutput
func (a *V2ApiService) GatewayDeleteProducerExecute(r ApiGatewayDeleteProducerRequest) (*GatewayDeleteProducerOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayDeleteProducerOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayDeleteProducer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-delete-producer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayDownloadCustomerFragmentsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayDownloadCustomerFragments *GatewayDownloadCustomerFragments
    body interface{}
}

func (r ApiGatewayDownloadCustomerFragmentsRequest) GatewayDownloadCustomerFragments(gatewayDownloadCustomerFragments GatewayDownloadCustomerFragments) ApiGatewayDownloadCustomerFragmentsRequest {
	r.gatewayDownloadCustomerFragments = &gatewayDownloadCustomerFragments
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayDownloadCustomerFragmentsRequest) Body(body GatewayDownloadCustomerFragments) ApiGatewayDownloadCustomerFragmentsRequest {
    r.body = body
    return r
}

func (r ApiGatewayDownloadCustomerFragmentsRequest) Execute() (*GatewayDownloadCustomerFragmentsOutput, *http.Response, error) {
	return r.ApiService.GatewayDownloadCustomerFragmentsExecute(r)
}

/*
GatewayDownloadCustomerFragments Method for GatewayDownloadCustomerFragments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayDownloadCustomerFragmentsRequest
*/
func (a *V2ApiService) GatewayDownloadCustomerFragments(ctx context.Context) ApiGatewayDownloadCustomerFragmentsRequest {
	return ApiGatewayDownloadCustomerFragmentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayDownloadCustomerFragmentsOutput
func (a *V2ApiService) GatewayDownloadCustomerFragmentsExecute(r ApiGatewayDownloadCustomerFragmentsRequest) (*GatewayDownloadCustomerFragmentsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayDownloadCustomerFragmentsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayDownloadCustomerFragments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-download-customer-fragments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayGetAllowedAccessRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayGetAllowedAccess *GatewayGetAllowedAccess
    body interface{}
}

func (r ApiGatewayGetAllowedAccessRequest) GatewayGetAllowedAccess(gatewayGetAllowedAccess GatewayGetAllowedAccess) ApiGatewayGetAllowedAccessRequest {
	r.gatewayGetAllowedAccess = &gatewayGetAllowedAccess
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayGetAllowedAccessRequest) Body(body GatewayGetAllowedAccess) ApiGatewayGetAllowedAccessRequest {
    r.body = body
    return r
}

func (r ApiGatewayGetAllowedAccessRequest) Execute() (*AllowedAccess, *http.Response, error) {
	return r.ApiService.GatewayGetAllowedAccessExecute(r)
}

/*
GatewayGetAllowedAccess Method for GatewayGetAllowedAccess

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayGetAllowedAccessRequest
*/
func (a *V2ApiService) GatewayGetAllowedAccess(ctx context.Context) ApiGatewayGetAllowedAccessRequest {
	return ApiGatewayGetAllowedAccessRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AllowedAccess
func (a *V2ApiService) GatewayGetAllowedAccessExecute(r ApiGatewayGetAllowedAccessRequest) (*AllowedAccess, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AllowedAccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayGetAllowedAccess")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-get-allowed-access"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayGetCacheRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayGetCache *GatewayGetCache
    body interface{}
}

func (r ApiGatewayGetCacheRequest) GatewayGetCache(gatewayGetCache GatewayGetCache) ApiGatewayGetCacheRequest {
	r.gatewayGetCache = &gatewayGetCache
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayGetCacheRequest) Body(body GatewayGetCache) ApiGatewayGetCacheRequest {
    r.body = body
    return r
}

func (r ApiGatewayGetCacheRequest) Execute() (*CacheConfigPart, *http.Response, error) {
	return r.ApiService.GatewayGetCacheExecute(r)
}

/*
GatewayGetCache Method for GatewayGetCache

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayGetCacheRequest
*/
func (a *V2ApiService) GatewayGetCache(ctx context.Context) ApiGatewayGetCacheRequest {
	return ApiGatewayGetCacheRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CacheConfigPart
func (a *V2ApiService) GatewayGetCacheExecute(r ApiGatewayGetCacheRequest) (*CacheConfigPart, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CacheConfigPart
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayGetCache")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-get-cache"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayGetConfigRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayGetConfig *GatewayGetConfig
    body interface{}
}

func (r ApiGatewayGetConfigRequest) GatewayGetConfig(gatewayGetConfig GatewayGetConfig) ApiGatewayGetConfigRequest {
	r.gatewayGetConfig = &gatewayGetConfig
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayGetConfigRequest) Body(body GatewayGetConfig) ApiGatewayGetConfigRequest {
    r.body = body
    return r
}

func (r ApiGatewayGetConfigRequest) Execute() (*AkeylessGatewayConfig, *http.Response, error) {
	return r.ApiService.GatewayGetConfigExecute(r)
}

/*
GatewayGetConfig Method for GatewayGetConfig

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayGetConfigRequest
*/
func (a *V2ApiService) GatewayGetConfig(ctx context.Context) ApiGatewayGetConfigRequest {
	return ApiGatewayGetConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AkeylessGatewayConfig
func (a *V2ApiService) GatewayGetConfigExecute(r ApiGatewayGetConfigRequest) (*AkeylessGatewayConfig, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AkeylessGatewayConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayGetConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-get-config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayGetDefaultsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayGetDefaults *GatewayGetDefaults
    body interface{}
}

func (r ApiGatewayGetDefaultsRequest) GatewayGetDefaults(gatewayGetDefaults GatewayGetDefaults) ApiGatewayGetDefaultsRequest {
	r.gatewayGetDefaults = &gatewayGetDefaults
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayGetDefaultsRequest) Body(body GatewayGetDefaults) ApiGatewayGetDefaultsRequest {
    r.body = body
    return r
}

func (r ApiGatewayGetDefaultsRequest) Execute() (*GatewayGetDefaultsOutput, *http.Response, error) {
	return r.ApiService.GatewayGetDefaultsExecute(r)
}

/*
GatewayGetDefaults Method for GatewayGetDefaults

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayGetDefaultsRequest
*/
func (a *V2ApiService) GatewayGetDefaults(ctx context.Context) ApiGatewayGetDefaultsRequest {
	return ApiGatewayGetDefaultsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayGetDefaultsOutput
func (a *V2ApiService) GatewayGetDefaultsExecute(r ApiGatewayGetDefaultsRequest) (*GatewayGetDefaultsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayGetDefaultsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayGetDefaults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-get-defaults"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayGetK8SAuthConfigRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayGetK8SAuthConfig *GatewayGetK8SAuthConfig
    body interface{}
}

func (r ApiGatewayGetK8SAuthConfigRequest) GatewayGetK8SAuthConfig(gatewayGetK8SAuthConfig GatewayGetK8SAuthConfig) ApiGatewayGetK8SAuthConfigRequest {
	r.gatewayGetK8SAuthConfig = &gatewayGetK8SAuthConfig
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayGetK8SAuthConfigRequest) Body(body GatewayGetK8SAuthConfig) ApiGatewayGetK8SAuthConfigRequest {
    r.body = body
    return r
}

func (r ApiGatewayGetK8SAuthConfigRequest) Execute() (*GatewayGetK8SAuthConfigOutput, *http.Response, error) {
	return r.ApiService.GatewayGetK8SAuthConfigExecute(r)
}

/*
GatewayGetK8SAuthConfig Method for GatewayGetK8SAuthConfig

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayGetK8SAuthConfigRequest
*/
func (a *V2ApiService) GatewayGetK8SAuthConfig(ctx context.Context) ApiGatewayGetK8SAuthConfigRequest {
	return ApiGatewayGetK8SAuthConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayGetK8SAuthConfigOutput
func (a *V2ApiService) GatewayGetK8SAuthConfigExecute(r ApiGatewayGetK8SAuthConfigRequest) (*GatewayGetK8SAuthConfigOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayGetK8SAuthConfigOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayGetK8SAuthConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-get-k8s-auth-config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayGetLdapAuthConfigRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayGetLdapAuthConfig *GatewayGetLdapAuthConfig
    body interface{}
}

func (r ApiGatewayGetLdapAuthConfigRequest) GatewayGetLdapAuthConfig(gatewayGetLdapAuthConfig GatewayGetLdapAuthConfig) ApiGatewayGetLdapAuthConfigRequest {
	r.gatewayGetLdapAuthConfig = &gatewayGetLdapAuthConfig
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayGetLdapAuthConfigRequest) Body(body GatewayGetLdapAuthConfig) ApiGatewayGetLdapAuthConfigRequest {
    r.body = body
    return r
}

func (r ApiGatewayGetLdapAuthConfigRequest) Execute() (*GatewayGetLdapAuthConfigOutput, *http.Response, error) {
	return r.ApiService.GatewayGetLdapAuthConfigExecute(r)
}

/*
GatewayGetLdapAuthConfig Method for GatewayGetLdapAuthConfig

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayGetLdapAuthConfigRequest
*/
func (a *V2ApiService) GatewayGetLdapAuthConfig(ctx context.Context) ApiGatewayGetLdapAuthConfigRequest {
	return ApiGatewayGetLdapAuthConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayGetLdapAuthConfigOutput
func (a *V2ApiService) GatewayGetLdapAuthConfigExecute(r ApiGatewayGetLdapAuthConfigRequest) (*GatewayGetLdapAuthConfigOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayGetLdapAuthConfigOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayGetLdapAuthConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-get-ldap-auth-config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayGetLogForwardingRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayGetLogForwarding *GatewayGetLogForwarding
    body interface{}
}

func (r ApiGatewayGetLogForwardingRequest) GatewayGetLogForwarding(gatewayGetLogForwarding GatewayGetLogForwarding) ApiGatewayGetLogForwardingRequest {
	r.gatewayGetLogForwarding = &gatewayGetLogForwarding
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayGetLogForwardingRequest) Body(body GatewayGetLogForwarding) ApiGatewayGetLogForwardingRequest {
    r.body = body
    return r
}

func (r ApiGatewayGetLogForwardingRequest) Execute() (*LogForwardingConfigPart, *http.Response, error) {
	return r.ApiService.GatewayGetLogForwardingExecute(r)
}

/*
GatewayGetLogForwarding Method for GatewayGetLogForwarding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayGetLogForwardingRequest
*/
func (a *V2ApiService) GatewayGetLogForwarding(ctx context.Context) ApiGatewayGetLogForwardingRequest {
	return ApiGatewayGetLogForwardingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LogForwardingConfigPart
func (a *V2ApiService) GatewayGetLogForwardingExecute(r ApiGatewayGetLogForwardingRequest) (*LogForwardingConfigPart, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LogForwardingConfigPart
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayGetLogForwarding")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-get-log-forwarding"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayGetMigrationRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayGetMigration *GatewayGetMigration
    body interface{}
}

func (r ApiGatewayGetMigrationRequest) GatewayGetMigration(gatewayGetMigration GatewayGetMigration) ApiGatewayGetMigrationRequest {
	r.gatewayGetMigration = &gatewayGetMigration
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayGetMigrationRequest) Body(body GatewayGetMigration) ApiGatewayGetMigrationRequest {
    r.body = body
    return r
}

func (r ApiGatewayGetMigrationRequest) Execute() (*GatewayMigrationGetOutput, *http.Response, error) {
	return r.ApiService.GatewayGetMigrationExecute(r)
}

/*
GatewayGetMigration Method for GatewayGetMigration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayGetMigrationRequest
*/
func (a *V2ApiService) GatewayGetMigration(ctx context.Context) ApiGatewayGetMigrationRequest {
	return ApiGatewayGetMigrationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayMigrationGetOutput
func (a *V2ApiService) GatewayGetMigrationExecute(r ApiGatewayGetMigrationRequest) (*GatewayMigrationGetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayMigrationGetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayGetMigration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-get-migration"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayGetProducerRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayGetProducer *GatewayGetProducer
    body interface{}
}

func (r ApiGatewayGetProducerRequest) GatewayGetProducer(gatewayGetProducer GatewayGetProducer) ApiGatewayGetProducerRequest {
	r.gatewayGetProducer = &gatewayGetProducer
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayGetProducerRequest) Body(body GatewayGetProducer) ApiGatewayGetProducerRequest {
    r.body = body
    return r
}

func (r ApiGatewayGetProducerRequest) Execute() (*DSProducerDetails, *http.Response, error) {
	return r.ApiService.GatewayGetProducerExecute(r)
}

/*
GatewayGetProducer Method for GatewayGetProducer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayGetProducerRequest
*/
func (a *V2ApiService) GatewayGetProducer(ctx context.Context) ApiGatewayGetProducerRequest {
	return ApiGatewayGetProducerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DSProducerDetails
func (a *V2ApiService) GatewayGetProducerExecute(r ApiGatewayGetProducerRequest) (*DSProducerDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DSProducerDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayGetProducer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-get-producer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayGetRemoteAccessRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayGetRemoteAccess *GatewayGetRemoteAccess
    body interface{}
}

func (r ApiGatewayGetRemoteAccessRequest) GatewayGetRemoteAccess(gatewayGetRemoteAccess GatewayGetRemoteAccess) ApiGatewayGetRemoteAccessRequest {
	r.gatewayGetRemoteAccess = &gatewayGetRemoteAccess
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayGetRemoteAccessRequest) Body(body GatewayGetRemoteAccess) ApiGatewayGetRemoteAccessRequest {
    r.body = body
    return r
}

func (r ApiGatewayGetRemoteAccessRequest) Execute() (*BastionConfigReplyObj, *http.Response, error) {
	return r.ApiService.GatewayGetRemoteAccessExecute(r)
}

/*
GatewayGetRemoteAccess Method for GatewayGetRemoteAccess

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayGetRemoteAccessRequest
*/
func (a *V2ApiService) GatewayGetRemoteAccess(ctx context.Context) ApiGatewayGetRemoteAccessRequest {
	return ApiGatewayGetRemoteAccessRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BastionConfigReplyObj
func (a *V2ApiService) GatewayGetRemoteAccessExecute(r ApiGatewayGetRemoteAccessRequest) (*BastionConfigReplyObj, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BastionConfigReplyObj
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayGetRemoteAccess")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-get-remote-access"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayGetTmpUsersRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayGetTmpUsers *GatewayGetTmpUsers
    body interface{}
}

func (r ApiGatewayGetTmpUsersRequest) GatewayGetTmpUsers(gatewayGetTmpUsers GatewayGetTmpUsers) ApiGatewayGetTmpUsersRequest {
	r.gatewayGetTmpUsers = &gatewayGetTmpUsers
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayGetTmpUsersRequest) Body(body GatewayGetTmpUsers) ApiGatewayGetTmpUsersRequest {
    r.body = body
    return r
}

func (r ApiGatewayGetTmpUsersRequest) Execute() ([]TmpUserData, *http.Response, error) {
	return r.ApiService.GatewayGetTmpUsersExecute(r)
}

/*
GatewayGetTmpUsers Method for GatewayGetTmpUsers

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayGetTmpUsersRequest
*/
func (a *V2ApiService) GatewayGetTmpUsers(ctx context.Context) ApiGatewayGetTmpUsersRequest {
	return ApiGatewayGetTmpUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []TmpUserData
func (a *V2ApiService) GatewayGetTmpUsersExecute(r ApiGatewayGetTmpUsersRequest) ([]TmpUserData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TmpUserData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayGetTmpUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-get-producer-tmp-creds"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayListCustomerFragmentsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayListCustomerFragments *GatewayListCustomerFragments
    body interface{}
}

func (r ApiGatewayListCustomerFragmentsRequest) GatewayListCustomerFragments(gatewayListCustomerFragments GatewayListCustomerFragments) ApiGatewayListCustomerFragmentsRequest {
	r.gatewayListCustomerFragments = &gatewayListCustomerFragments
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayListCustomerFragmentsRequest) Body(body GatewayListCustomerFragments) ApiGatewayListCustomerFragmentsRequest {
    r.body = body
    return r
}

func (r ApiGatewayListCustomerFragmentsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GatewayListCustomerFragmentsExecute(r)
}

/*
GatewayListCustomerFragments Method for GatewayListCustomerFragments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayListCustomerFragmentsRequest
*/
func (a *V2ApiService) GatewayListCustomerFragments(ctx context.Context) ApiGatewayListCustomerFragmentsRequest {
	return ApiGatewayListCustomerFragmentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) GatewayListCustomerFragmentsExecute(r ApiGatewayListCustomerFragmentsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayListCustomerFragments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-list-customer-fragments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayListMigrationRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayListMigration *GatewayListMigration
    body interface{}
}

func (r ApiGatewayListMigrationRequest) GatewayListMigration(gatewayListMigration GatewayListMigration) ApiGatewayListMigrationRequest {
	r.gatewayListMigration = &gatewayListMigration
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayListMigrationRequest) Body(body GatewayListMigration) ApiGatewayListMigrationRequest {
    r.body = body
    return r
}

func (r ApiGatewayListMigrationRequest) Execute() (*GatewayMigrationListOutput, *http.Response, error) {
	return r.ApiService.GatewayListMigrationExecute(r)
}

/*
GatewayListMigration Method for GatewayListMigration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayListMigrationRequest
*/
func (a *V2ApiService) GatewayListMigration(ctx context.Context) ApiGatewayListMigrationRequest {
	return ApiGatewayListMigrationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayMigrationListOutput
func (a *V2ApiService) GatewayListMigrationExecute(r ApiGatewayListMigrationRequest) (*GatewayMigrationListOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayMigrationListOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayListMigration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-list-migration"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayListProducersRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayListProducers *GatewayListProducers
    body interface{}
}

func (r ApiGatewayListProducersRequest) GatewayListProducers(gatewayListProducers GatewayListProducers) ApiGatewayListProducersRequest {
	r.gatewayListProducers = &gatewayListProducers
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayListProducersRequest) Body(body GatewayListProducers) ApiGatewayListProducersRequest {
    r.body = body
    return r
}

func (r ApiGatewayListProducersRequest) Execute() (*GetProducersListReplyObj, *http.Response, error) {
	return r.ApiService.GatewayListProducersExecute(r)
}

/*
GatewayListProducers Method for GatewayListProducers

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayListProducersRequest
*/
func (a *V2ApiService) GatewayListProducers(ctx context.Context) ApiGatewayListProducersRequest {
	return ApiGatewayListProducersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetProducersListReplyObj
func (a *V2ApiService) GatewayListProducersExecute(r ApiGatewayListProducersRequest) (*GetProducersListReplyObj, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetProducersListReplyObj
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayListProducers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-list-producers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayListRotatedSecretsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayListRotatedSecrets *GatewayListRotatedSecrets
    body interface{}
}

func (r ApiGatewayListRotatedSecretsRequest) GatewayListRotatedSecrets(gatewayListRotatedSecrets GatewayListRotatedSecrets) ApiGatewayListRotatedSecretsRequest {
	r.gatewayListRotatedSecrets = &gatewayListRotatedSecrets
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayListRotatedSecretsRequest) Body(body GatewayListRotatedSecrets) ApiGatewayListRotatedSecretsRequest {
    r.body = body
    return r
}

func (r ApiGatewayListRotatedSecretsRequest) Execute() (*ListItemsOutput, *http.Response, error) {
	return r.ApiService.GatewayListRotatedSecretsExecute(r)
}

/*
GatewayListRotatedSecrets Method for GatewayListRotatedSecrets

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayListRotatedSecretsRequest
*/
func (a *V2ApiService) GatewayListRotatedSecrets(ctx context.Context) ApiGatewayListRotatedSecretsRequest {
	return ApiGatewayListRotatedSecretsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListItemsOutput
func (a *V2ApiService) GatewayListRotatedSecretsExecute(r ApiGatewayListRotatedSecretsRequest) (*ListItemsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListItemsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayListRotatedSecrets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-list-rotated-secrets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayMigratePersonalItemsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayMigratePersonalItems *GatewayMigratePersonalItems
    body interface{}
}

func (r ApiGatewayMigratePersonalItemsRequest) GatewayMigratePersonalItems(gatewayMigratePersonalItems GatewayMigratePersonalItems) ApiGatewayMigratePersonalItemsRequest {
	r.gatewayMigratePersonalItems = &gatewayMigratePersonalItems
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayMigratePersonalItemsRequest) Body(body GatewayMigratePersonalItems) ApiGatewayMigratePersonalItemsRequest {
    r.body = body
    return r
}

func (r ApiGatewayMigratePersonalItemsRequest) Execute() (*GatewayMigratePersonalItemsOutput, *http.Response, error) {
	return r.ApiService.GatewayMigratePersonalItemsExecute(r)
}

/*
GatewayMigratePersonalItems Method for GatewayMigratePersonalItems

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayMigratePersonalItemsRequest
*/
func (a *V2ApiService) GatewayMigratePersonalItems(ctx context.Context) ApiGatewayMigratePersonalItemsRequest {
	return ApiGatewayMigratePersonalItemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayMigratePersonalItemsOutput
func (a *V2ApiService) GatewayMigratePersonalItemsExecute(r ApiGatewayMigratePersonalItemsRequest) (*GatewayMigratePersonalItemsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayMigratePersonalItemsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayMigratePersonalItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-migrate-personal-items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayRevokeTmpUsersRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayRevokeTmpUsers *GatewayRevokeTmpUsers
    body interface{}
}

func (r ApiGatewayRevokeTmpUsersRequest) GatewayRevokeTmpUsers(gatewayRevokeTmpUsers GatewayRevokeTmpUsers) ApiGatewayRevokeTmpUsersRequest {
	r.gatewayRevokeTmpUsers = &gatewayRevokeTmpUsers
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayRevokeTmpUsersRequest) Body(body GatewayRevokeTmpUsers) ApiGatewayRevokeTmpUsersRequest {
    r.body = body
    return r
}

func (r ApiGatewayRevokeTmpUsersRequest) Execute() (*http.Response, error) {
	return r.ApiService.GatewayRevokeTmpUsersExecute(r)
}

/*
GatewayRevokeTmpUsers Method for GatewayRevokeTmpUsers

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayRevokeTmpUsersRequest
*/
func (a *V2ApiService) GatewayRevokeTmpUsers(ctx context.Context) ApiGatewayRevokeTmpUsersRequest {
	return ApiGatewayRevokeTmpUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *V2ApiService) GatewayRevokeTmpUsersExecute(r ApiGatewayRevokeTmpUsersRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayRevokeTmpUsers")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-revoke-producer-tmp-creds"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGatewayStartProducerRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayStartProducer *GatewayStartProducer
    body interface{}
}

func (r ApiGatewayStartProducerRequest) GatewayStartProducer(gatewayStartProducer GatewayStartProducer) ApiGatewayStartProducerRequest {
	r.gatewayStartProducer = &gatewayStartProducer
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayStartProducerRequest) Body(body GatewayStartProducer) ApiGatewayStartProducerRequest {
    r.body = body
    return r
}

func (r ApiGatewayStartProducerRequest) Execute() (*GatewayStartProducerOutput, *http.Response, error) {
	return r.ApiService.GatewayStartProducerExecute(r)
}

/*
GatewayStartProducer Method for GatewayStartProducer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayStartProducerRequest
*/
func (a *V2ApiService) GatewayStartProducer(ctx context.Context) ApiGatewayStartProducerRequest {
	return ApiGatewayStartProducerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayStartProducerOutput
func (a *V2ApiService) GatewayStartProducerExecute(r ApiGatewayStartProducerRequest) (*GatewayStartProducerOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayStartProducerOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayStartProducer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-start-producer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayStatusMigrationRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayStatusMigration *GatewayStatusMigration
    body interface{}
}

func (r ApiGatewayStatusMigrationRequest) GatewayStatusMigration(gatewayStatusMigration GatewayStatusMigration) ApiGatewayStatusMigrationRequest {
	r.gatewayStatusMigration = &gatewayStatusMigration
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayStatusMigrationRequest) Body(body GatewayStatusMigration) ApiGatewayStatusMigrationRequest {
    r.body = body
    return r
}

func (r ApiGatewayStatusMigrationRequest) Execute() (*MigrationStatusReplyObj, *http.Response, error) {
	return r.ApiService.GatewayStatusMigrationExecute(r)
}

/*
GatewayStatusMigration Method for GatewayStatusMigration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayStatusMigrationRequest
*/
func (a *V2ApiService) GatewayStatusMigration(ctx context.Context) ApiGatewayStatusMigrationRequest {
	return ApiGatewayStatusMigrationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MigrationStatusReplyObj
func (a *V2ApiService) GatewayStatusMigrationExecute(r ApiGatewayStatusMigrationRequest) (*MigrationStatusReplyObj, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MigrationStatusReplyObj
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayStatusMigration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-migration-status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayStopProducerRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayStopProducer *GatewayStopProducer
    body interface{}
}

func (r ApiGatewayStopProducerRequest) GatewayStopProducer(gatewayStopProducer GatewayStopProducer) ApiGatewayStopProducerRequest {
	r.gatewayStopProducer = &gatewayStopProducer
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayStopProducerRequest) Body(body GatewayStopProducer) ApiGatewayStopProducerRequest {
    r.body = body
    return r
}

func (r ApiGatewayStopProducerRequest) Execute() (*GatewayStopProducerOutput, *http.Response, error) {
	return r.ApiService.GatewayStopProducerExecute(r)
}

/*
GatewayStopProducer Method for GatewayStopProducer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayStopProducerRequest
*/
func (a *V2ApiService) GatewayStopProducer(ctx context.Context) ApiGatewayStopProducerRequest {
	return ApiGatewayStopProducerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayStopProducerOutput
func (a *V2ApiService) GatewayStopProducerExecute(r ApiGatewayStopProducerRequest) (*GatewayStopProducerOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayStopProducerOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayStopProducer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-stop-producer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewaySyncMigrationRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewaySyncMigration *GatewaySyncMigration
    body interface{}
}

func (r ApiGatewaySyncMigrationRequest) GatewaySyncMigration(gatewaySyncMigration GatewaySyncMigration) ApiGatewaySyncMigrationRequest {
	r.gatewaySyncMigration = &gatewaySyncMigration
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewaySyncMigrationRequest) Body(body GatewaySyncMigration) ApiGatewaySyncMigrationRequest {
    r.body = body
    return r
}

func (r ApiGatewaySyncMigrationRequest) Execute() (*GatewayMigrationSyncOutput, *http.Response, error) {
	return r.ApiService.GatewaySyncMigrationExecute(r)
}

/*
GatewaySyncMigration Method for GatewaySyncMigration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewaySyncMigrationRequest
*/
func (a *V2ApiService) GatewaySyncMigration(ctx context.Context) ApiGatewaySyncMigrationRequest {
	return ApiGatewaySyncMigrationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayMigrationSyncOutput
func (a *V2ApiService) GatewaySyncMigrationExecute(r ApiGatewaySyncMigrationRequest) (*GatewayMigrationSyncOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayMigrationSyncOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewaySyncMigration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-sync-migration"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateAllowedAccessRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateAllowedAccess *GatewayUpdateAllowedAccess
    body interface{}
}

func (r ApiGatewayUpdateAllowedAccessRequest) GatewayUpdateAllowedAccess(gatewayUpdateAllowedAccess GatewayUpdateAllowedAccess) ApiGatewayUpdateAllowedAccessRequest {
	r.gatewayUpdateAllowedAccess = &gatewayUpdateAllowedAccess
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateAllowedAccessRequest) Body(body GatewayUpdateAllowedAccess) ApiGatewayUpdateAllowedAccessRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateAllowedAccessRequest) Execute() (*AllowedAccess, *http.Response, error) {
	return r.ApiService.GatewayUpdateAllowedAccessExecute(r)
}

/*
GatewayUpdateAllowedAccess Method for GatewayUpdateAllowedAccess

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateAllowedAccessRequest
*/
func (a *V2ApiService) GatewayUpdateAllowedAccess(ctx context.Context) ApiGatewayUpdateAllowedAccessRequest {
	return ApiGatewayUpdateAllowedAccessRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AllowedAccess
func (a *V2ApiService) GatewayUpdateAllowedAccessExecute(r ApiGatewayUpdateAllowedAccessRequest) (*AllowedAccess, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AllowedAccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateAllowedAccess")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-allowed-access"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateCacheRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateCache *GatewayUpdateCache
    body interface{}
}

func (r ApiGatewayUpdateCacheRequest) GatewayUpdateCache(gatewayUpdateCache GatewayUpdateCache) ApiGatewayUpdateCacheRequest {
	r.gatewayUpdateCache = &gatewayUpdateCache
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateCacheRequest) Body(body GatewayUpdateCache) ApiGatewayUpdateCacheRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateCacheRequest) Execute() (*GatewayUpdateOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateCacheExecute(r)
}

/*
GatewayUpdateCache Method for GatewayUpdateCache

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateCacheRequest
*/
func (a *V2ApiService) GatewayUpdateCache(ctx context.Context) ApiGatewayUpdateCacheRequest {
	return ApiGatewayUpdateCacheRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateOutput
func (a *V2ApiService) GatewayUpdateCacheExecute(r ApiGatewayUpdateCacheRequest) (*GatewayUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateCache")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-cache"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateDefaultsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateDefaults *GatewayUpdateDefaults
    body interface{}
}

func (r ApiGatewayUpdateDefaultsRequest) GatewayUpdateDefaults(gatewayUpdateDefaults GatewayUpdateDefaults) ApiGatewayUpdateDefaultsRequest {
	r.gatewayUpdateDefaults = &gatewayUpdateDefaults
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateDefaultsRequest) Body(body GatewayUpdateDefaults) ApiGatewayUpdateDefaultsRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateDefaultsRequest) Execute() (*GatewayUpdateOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateDefaultsExecute(r)
}

/*
GatewayUpdateDefaults Method for GatewayUpdateDefaults

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateDefaultsRequest
*/
func (a *V2ApiService) GatewayUpdateDefaults(ctx context.Context) ApiGatewayUpdateDefaultsRequest {
	return ApiGatewayUpdateDefaultsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateOutput
func (a *V2ApiService) GatewayUpdateDefaultsExecute(r ApiGatewayUpdateDefaultsRequest) (*GatewayUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateDefaults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-defaults"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateItemRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateItem *GatewayUpdateItem
    body interface{}
}

func (r ApiGatewayUpdateItemRequest) GatewayUpdateItem(gatewayUpdateItem GatewayUpdateItem) ApiGatewayUpdateItemRequest {
	r.gatewayUpdateItem = &gatewayUpdateItem
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateItemRequest) Body(body GatewayUpdateItem) ApiGatewayUpdateItemRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateItemRequest) Execute() (*GatewayUpdateItemOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateItemExecute(r)
}

/*
GatewayUpdateItem Method for GatewayUpdateItem

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateItemRequest
*/
func (a *V2ApiService) GatewayUpdateItem(ctx context.Context) ApiGatewayUpdateItemRequest {
	return ApiGatewayUpdateItemRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateItemOutput
func (a *V2ApiService) GatewayUpdateItemExecute(r ApiGatewayUpdateItemRequest) (*GatewayUpdateItemOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateItemOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-item"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateK8SAuthConfigRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateK8SAuthConfig *GatewayUpdateK8SAuthConfig
    body interface{}
}

func (r ApiGatewayUpdateK8SAuthConfigRequest) GatewayUpdateK8SAuthConfig(gatewayUpdateK8SAuthConfig GatewayUpdateK8SAuthConfig) ApiGatewayUpdateK8SAuthConfigRequest {
	r.gatewayUpdateK8SAuthConfig = &gatewayUpdateK8SAuthConfig
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateK8SAuthConfigRequest) Body(body GatewayUpdateK8SAuthConfig) ApiGatewayUpdateK8SAuthConfigRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateK8SAuthConfigRequest) Execute() (*GatewayUpdateK8SAuthConfigOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateK8SAuthConfigExecute(r)
}

/*
GatewayUpdateK8SAuthConfig Method for GatewayUpdateK8SAuthConfig

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateK8SAuthConfigRequest
*/
func (a *V2ApiService) GatewayUpdateK8SAuthConfig(ctx context.Context) ApiGatewayUpdateK8SAuthConfigRequest {
	return ApiGatewayUpdateK8SAuthConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateK8SAuthConfigOutput
func (a *V2ApiService) GatewayUpdateK8SAuthConfigExecute(r ApiGatewayUpdateK8SAuthConfigRequest) (*GatewayUpdateK8SAuthConfigOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateK8SAuthConfigOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateK8SAuthConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-k8s-auth-config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateLdapAuthConfigRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateLdapAuthConfig *GatewayUpdateLdapAuthConfig
    body interface{}
}

func (r ApiGatewayUpdateLdapAuthConfigRequest) GatewayUpdateLdapAuthConfig(gatewayUpdateLdapAuthConfig GatewayUpdateLdapAuthConfig) ApiGatewayUpdateLdapAuthConfigRequest {
	r.gatewayUpdateLdapAuthConfig = &gatewayUpdateLdapAuthConfig
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateLdapAuthConfigRequest) Body(body GatewayUpdateLdapAuthConfig) ApiGatewayUpdateLdapAuthConfigRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateLdapAuthConfigRequest) Execute() (*GatewayUpdateLdapAuthConfigOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateLdapAuthConfigExecute(r)
}

/*
GatewayUpdateLdapAuthConfig Method for GatewayUpdateLdapAuthConfig

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateLdapAuthConfigRequest
*/
func (a *V2ApiService) GatewayUpdateLdapAuthConfig(ctx context.Context) ApiGatewayUpdateLdapAuthConfigRequest {
	return ApiGatewayUpdateLdapAuthConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateLdapAuthConfigOutput
func (a *V2ApiService) GatewayUpdateLdapAuthConfigExecute(r ApiGatewayUpdateLdapAuthConfigRequest) (*GatewayUpdateLdapAuthConfigOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateLdapAuthConfigOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateLdapAuthConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-ldap-auth-config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateLogForwardingAwsS3Request struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateLogForwardingAwsS3 *GatewayUpdateLogForwardingAwsS3
    body interface{}
}

func (r ApiGatewayUpdateLogForwardingAwsS3Request) GatewayUpdateLogForwardingAwsS3(gatewayUpdateLogForwardingAwsS3 GatewayUpdateLogForwardingAwsS3) ApiGatewayUpdateLogForwardingAwsS3Request {
	r.gatewayUpdateLogForwardingAwsS3 = &gatewayUpdateLogForwardingAwsS3
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateLogForwardingAwsS3Request) Body(body GatewayUpdateLogForwardingAwsS3) ApiGatewayUpdateLogForwardingAwsS3Request {
    r.body = body
    return r
}

func (r ApiGatewayUpdateLogForwardingAwsS3Request) Execute() (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateLogForwardingAwsS3Execute(r)
}

/*
GatewayUpdateLogForwardingAwsS3 Method for GatewayUpdateLogForwardingAwsS3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateLogForwardingAwsS3Request
*/
func (a *V2ApiService) GatewayUpdateLogForwardingAwsS3(ctx context.Context) ApiGatewayUpdateLogForwardingAwsS3Request {
	return ApiGatewayUpdateLogForwardingAwsS3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateLogForwardingOutput
func (a *V2ApiService) GatewayUpdateLogForwardingAwsS3Execute(r ApiGatewayUpdateLogForwardingAwsS3Request) (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateLogForwardingOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateLogForwardingAwsS3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-log-forwarding-aws-s3"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateLogForwardingAzureAnalyticsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateLogForwardingAzureAnalytics *GatewayUpdateLogForwardingAzureAnalytics
    body interface{}
}

func (r ApiGatewayUpdateLogForwardingAzureAnalyticsRequest) GatewayUpdateLogForwardingAzureAnalytics(gatewayUpdateLogForwardingAzureAnalytics GatewayUpdateLogForwardingAzureAnalytics) ApiGatewayUpdateLogForwardingAzureAnalyticsRequest {
	r.gatewayUpdateLogForwardingAzureAnalytics = &gatewayUpdateLogForwardingAzureAnalytics
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateLogForwardingAzureAnalyticsRequest) Body(body GatewayUpdateLogForwardingAzureAnalytics) ApiGatewayUpdateLogForwardingAzureAnalyticsRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateLogForwardingAzureAnalyticsRequest) Execute() (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateLogForwardingAzureAnalyticsExecute(r)
}

/*
GatewayUpdateLogForwardingAzureAnalytics Method for GatewayUpdateLogForwardingAzureAnalytics

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateLogForwardingAzureAnalyticsRequest
*/
func (a *V2ApiService) GatewayUpdateLogForwardingAzureAnalytics(ctx context.Context) ApiGatewayUpdateLogForwardingAzureAnalyticsRequest {
	return ApiGatewayUpdateLogForwardingAzureAnalyticsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateLogForwardingOutput
func (a *V2ApiService) GatewayUpdateLogForwardingAzureAnalyticsExecute(r ApiGatewayUpdateLogForwardingAzureAnalyticsRequest) (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateLogForwardingOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateLogForwardingAzureAnalytics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-log-forwarding-azure-analytics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateLogForwardingDatadogRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateLogForwardingDatadog *GatewayUpdateLogForwardingDatadog
    body interface{}
}

func (r ApiGatewayUpdateLogForwardingDatadogRequest) GatewayUpdateLogForwardingDatadog(gatewayUpdateLogForwardingDatadog GatewayUpdateLogForwardingDatadog) ApiGatewayUpdateLogForwardingDatadogRequest {
	r.gatewayUpdateLogForwardingDatadog = &gatewayUpdateLogForwardingDatadog
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateLogForwardingDatadogRequest) Body(body GatewayUpdateLogForwardingDatadog) ApiGatewayUpdateLogForwardingDatadogRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateLogForwardingDatadogRequest) Execute() (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateLogForwardingDatadogExecute(r)
}

/*
GatewayUpdateLogForwardingDatadog Method for GatewayUpdateLogForwardingDatadog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateLogForwardingDatadogRequest
*/
func (a *V2ApiService) GatewayUpdateLogForwardingDatadog(ctx context.Context) ApiGatewayUpdateLogForwardingDatadogRequest {
	return ApiGatewayUpdateLogForwardingDatadogRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateLogForwardingOutput
func (a *V2ApiService) GatewayUpdateLogForwardingDatadogExecute(r ApiGatewayUpdateLogForwardingDatadogRequest) (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateLogForwardingOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateLogForwardingDatadog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-log-forwarding-datadog"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateLogForwardingElasticsearchRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateLogForwardingElasticsearch *GatewayUpdateLogForwardingElasticsearch
    body interface{}
}

func (r ApiGatewayUpdateLogForwardingElasticsearchRequest) GatewayUpdateLogForwardingElasticsearch(gatewayUpdateLogForwardingElasticsearch GatewayUpdateLogForwardingElasticsearch) ApiGatewayUpdateLogForwardingElasticsearchRequest {
	r.gatewayUpdateLogForwardingElasticsearch = &gatewayUpdateLogForwardingElasticsearch
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateLogForwardingElasticsearchRequest) Body(body GatewayUpdateLogForwardingElasticsearch) ApiGatewayUpdateLogForwardingElasticsearchRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateLogForwardingElasticsearchRequest) Execute() (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateLogForwardingElasticsearchExecute(r)
}

/*
GatewayUpdateLogForwardingElasticsearch Method for GatewayUpdateLogForwardingElasticsearch

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateLogForwardingElasticsearchRequest
*/
func (a *V2ApiService) GatewayUpdateLogForwardingElasticsearch(ctx context.Context) ApiGatewayUpdateLogForwardingElasticsearchRequest {
	return ApiGatewayUpdateLogForwardingElasticsearchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateLogForwardingOutput
func (a *V2ApiService) GatewayUpdateLogForwardingElasticsearchExecute(r ApiGatewayUpdateLogForwardingElasticsearchRequest) (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateLogForwardingOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateLogForwardingElasticsearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-log-forwarding-elasticsearch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateLogForwardingGoogleChronicleRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateLogForwardingGoogleChronicle *GatewayUpdateLogForwardingGoogleChronicle
    body interface{}
}

func (r ApiGatewayUpdateLogForwardingGoogleChronicleRequest) GatewayUpdateLogForwardingGoogleChronicle(gatewayUpdateLogForwardingGoogleChronicle GatewayUpdateLogForwardingGoogleChronicle) ApiGatewayUpdateLogForwardingGoogleChronicleRequest {
	r.gatewayUpdateLogForwardingGoogleChronicle = &gatewayUpdateLogForwardingGoogleChronicle
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateLogForwardingGoogleChronicleRequest) Body(body GatewayUpdateLogForwardingGoogleChronicle) ApiGatewayUpdateLogForwardingGoogleChronicleRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateLogForwardingGoogleChronicleRequest) Execute() (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateLogForwardingGoogleChronicleExecute(r)
}

/*
GatewayUpdateLogForwardingGoogleChronicle Method for GatewayUpdateLogForwardingGoogleChronicle

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateLogForwardingGoogleChronicleRequest
*/
func (a *V2ApiService) GatewayUpdateLogForwardingGoogleChronicle(ctx context.Context) ApiGatewayUpdateLogForwardingGoogleChronicleRequest {
	return ApiGatewayUpdateLogForwardingGoogleChronicleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateLogForwardingOutput
func (a *V2ApiService) GatewayUpdateLogForwardingGoogleChronicleExecute(r ApiGatewayUpdateLogForwardingGoogleChronicleRequest) (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateLogForwardingOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateLogForwardingGoogleChronicle")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-log-forwarding-google-chronicle"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateLogForwardingLogstashRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateLogForwardingLogstash *GatewayUpdateLogForwardingLogstash
    body interface{}
}

func (r ApiGatewayUpdateLogForwardingLogstashRequest) GatewayUpdateLogForwardingLogstash(gatewayUpdateLogForwardingLogstash GatewayUpdateLogForwardingLogstash) ApiGatewayUpdateLogForwardingLogstashRequest {
	r.gatewayUpdateLogForwardingLogstash = &gatewayUpdateLogForwardingLogstash
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateLogForwardingLogstashRequest) Body(body GatewayUpdateLogForwardingLogstash) ApiGatewayUpdateLogForwardingLogstashRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateLogForwardingLogstashRequest) Execute() (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateLogForwardingLogstashExecute(r)
}

/*
GatewayUpdateLogForwardingLogstash Method for GatewayUpdateLogForwardingLogstash

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateLogForwardingLogstashRequest
*/
func (a *V2ApiService) GatewayUpdateLogForwardingLogstash(ctx context.Context) ApiGatewayUpdateLogForwardingLogstashRequest {
	return ApiGatewayUpdateLogForwardingLogstashRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateLogForwardingOutput
func (a *V2ApiService) GatewayUpdateLogForwardingLogstashExecute(r ApiGatewayUpdateLogForwardingLogstashRequest) (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateLogForwardingOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateLogForwardingLogstash")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-log-forwarding-logstash"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateLogForwardingLogzIoRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateLogForwardingLogzIo *GatewayUpdateLogForwardingLogzIo
    body interface{}
}

func (r ApiGatewayUpdateLogForwardingLogzIoRequest) GatewayUpdateLogForwardingLogzIo(gatewayUpdateLogForwardingLogzIo GatewayUpdateLogForwardingLogzIo) ApiGatewayUpdateLogForwardingLogzIoRequest {
	r.gatewayUpdateLogForwardingLogzIo = &gatewayUpdateLogForwardingLogzIo
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateLogForwardingLogzIoRequest) Body(body GatewayUpdateLogForwardingLogzIo) ApiGatewayUpdateLogForwardingLogzIoRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateLogForwardingLogzIoRequest) Execute() (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateLogForwardingLogzIoExecute(r)
}

/*
GatewayUpdateLogForwardingLogzIo Method for GatewayUpdateLogForwardingLogzIo

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateLogForwardingLogzIoRequest
*/
func (a *V2ApiService) GatewayUpdateLogForwardingLogzIo(ctx context.Context) ApiGatewayUpdateLogForwardingLogzIoRequest {
	return ApiGatewayUpdateLogForwardingLogzIoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateLogForwardingOutput
func (a *V2ApiService) GatewayUpdateLogForwardingLogzIoExecute(r ApiGatewayUpdateLogForwardingLogzIoRequest) (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateLogForwardingOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateLogForwardingLogzIo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-log-forwarding-logz-io"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateLogForwardingSplunkRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateLogForwardingSplunk *GatewayUpdateLogForwardingSplunk
    body interface{}
}

func (r ApiGatewayUpdateLogForwardingSplunkRequest) GatewayUpdateLogForwardingSplunk(gatewayUpdateLogForwardingSplunk GatewayUpdateLogForwardingSplunk) ApiGatewayUpdateLogForwardingSplunkRequest {
	r.gatewayUpdateLogForwardingSplunk = &gatewayUpdateLogForwardingSplunk
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateLogForwardingSplunkRequest) Body(body GatewayUpdateLogForwardingSplunk) ApiGatewayUpdateLogForwardingSplunkRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateLogForwardingSplunkRequest) Execute() (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateLogForwardingSplunkExecute(r)
}

/*
GatewayUpdateLogForwardingSplunk Method for GatewayUpdateLogForwardingSplunk

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateLogForwardingSplunkRequest
*/
func (a *V2ApiService) GatewayUpdateLogForwardingSplunk(ctx context.Context) ApiGatewayUpdateLogForwardingSplunkRequest {
	return ApiGatewayUpdateLogForwardingSplunkRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateLogForwardingOutput
func (a *V2ApiService) GatewayUpdateLogForwardingSplunkExecute(r ApiGatewayUpdateLogForwardingSplunkRequest) (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateLogForwardingOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateLogForwardingSplunk")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-log-forwarding-splunk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateLogForwardingStdoutRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateLogForwardingStdout *GatewayUpdateLogForwardingStdout
    body interface{}
}

func (r ApiGatewayUpdateLogForwardingStdoutRequest) GatewayUpdateLogForwardingStdout(gatewayUpdateLogForwardingStdout GatewayUpdateLogForwardingStdout) ApiGatewayUpdateLogForwardingStdoutRequest {
	r.gatewayUpdateLogForwardingStdout = &gatewayUpdateLogForwardingStdout
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateLogForwardingStdoutRequest) Body(body GatewayUpdateLogForwardingStdout) ApiGatewayUpdateLogForwardingStdoutRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateLogForwardingStdoutRequest) Execute() (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateLogForwardingStdoutExecute(r)
}

/*
GatewayUpdateLogForwardingStdout Method for GatewayUpdateLogForwardingStdout

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateLogForwardingStdoutRequest
*/
func (a *V2ApiService) GatewayUpdateLogForwardingStdout(ctx context.Context) ApiGatewayUpdateLogForwardingStdoutRequest {
	return ApiGatewayUpdateLogForwardingStdoutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateLogForwardingOutput
func (a *V2ApiService) GatewayUpdateLogForwardingStdoutExecute(r ApiGatewayUpdateLogForwardingStdoutRequest) (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateLogForwardingOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateLogForwardingStdout")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-log-forwarding-stdout"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateLogForwardingSumologicRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateLogForwardingSumologic *GatewayUpdateLogForwardingSumologic
    body interface{}
}

func (r ApiGatewayUpdateLogForwardingSumologicRequest) GatewayUpdateLogForwardingSumologic(gatewayUpdateLogForwardingSumologic GatewayUpdateLogForwardingSumologic) ApiGatewayUpdateLogForwardingSumologicRequest {
	r.gatewayUpdateLogForwardingSumologic = &gatewayUpdateLogForwardingSumologic
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateLogForwardingSumologicRequest) Body(body GatewayUpdateLogForwardingSumologic) ApiGatewayUpdateLogForwardingSumologicRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateLogForwardingSumologicRequest) Execute() (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateLogForwardingSumologicExecute(r)
}

/*
GatewayUpdateLogForwardingSumologic Method for GatewayUpdateLogForwardingSumologic

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateLogForwardingSumologicRequest
*/
func (a *V2ApiService) GatewayUpdateLogForwardingSumologic(ctx context.Context) ApiGatewayUpdateLogForwardingSumologicRequest {
	return ApiGatewayUpdateLogForwardingSumologicRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateLogForwardingOutput
func (a *V2ApiService) GatewayUpdateLogForwardingSumologicExecute(r ApiGatewayUpdateLogForwardingSumologicRequest) (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateLogForwardingOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateLogForwardingSumologic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-log-forwarding-sumologic"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateLogForwardingSyslogRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateLogForwardingSyslog *GatewayUpdateLogForwardingSyslog
    body interface{}
}

func (r ApiGatewayUpdateLogForwardingSyslogRequest) GatewayUpdateLogForwardingSyslog(gatewayUpdateLogForwardingSyslog GatewayUpdateLogForwardingSyslog) ApiGatewayUpdateLogForwardingSyslogRequest {
	r.gatewayUpdateLogForwardingSyslog = &gatewayUpdateLogForwardingSyslog
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateLogForwardingSyslogRequest) Body(body GatewayUpdateLogForwardingSyslog) ApiGatewayUpdateLogForwardingSyslogRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateLogForwardingSyslogRequest) Execute() (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateLogForwardingSyslogExecute(r)
}

/*
GatewayUpdateLogForwardingSyslog Method for GatewayUpdateLogForwardingSyslog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateLogForwardingSyslogRequest
*/
func (a *V2ApiService) GatewayUpdateLogForwardingSyslog(ctx context.Context) ApiGatewayUpdateLogForwardingSyslogRequest {
	return ApiGatewayUpdateLogForwardingSyslogRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateLogForwardingOutput
func (a *V2ApiService) GatewayUpdateLogForwardingSyslogExecute(r ApiGatewayUpdateLogForwardingSyslogRequest) (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateLogForwardingOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateLogForwardingSyslog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-log-forwarding-syslog"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateMigrationRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateMigration *GatewayUpdateMigration
    body interface{}
}

func (r ApiGatewayUpdateMigrationRequest) GatewayUpdateMigration(gatewayUpdateMigration GatewayUpdateMigration) ApiGatewayUpdateMigrationRequest {
	r.gatewayUpdateMigration = &gatewayUpdateMigration
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateMigrationRequest) Body(body GatewayUpdateMigration) ApiGatewayUpdateMigrationRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateMigrationRequest) Execute() (*GatewayMigrationUpdateOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateMigrationExecute(r)
}

/*
GatewayUpdateMigration Method for GatewayUpdateMigration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateMigrationRequest
*/
func (a *V2ApiService) GatewayUpdateMigration(ctx context.Context) ApiGatewayUpdateMigrationRequest {
	return ApiGatewayUpdateMigrationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayMigrationUpdateOutput
func (a *V2ApiService) GatewayUpdateMigrationExecute(r ApiGatewayUpdateMigrationRequest) (*GatewayMigrationUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayMigrationUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateMigration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-migration"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateProducerArtifactoryRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateProducerArtifactory *GatewayUpdateProducerArtifactory
    body interface{}
}

func (r ApiGatewayUpdateProducerArtifactoryRequest) GatewayUpdateProducerArtifactory(gatewayUpdateProducerArtifactory GatewayUpdateProducerArtifactory) ApiGatewayUpdateProducerArtifactoryRequest {
	r.gatewayUpdateProducerArtifactory = &gatewayUpdateProducerArtifactory
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateProducerArtifactoryRequest) Body(body GatewayUpdateProducerArtifactory) ApiGatewayUpdateProducerArtifactoryRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateProducerArtifactoryRequest) Execute() (*GatewayUpdateProducerArtifactoryOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateProducerArtifactoryExecute(r)
}

/*
GatewayUpdateProducerArtifactory Method for GatewayUpdateProducerArtifactory

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateProducerArtifactoryRequest
*/
func (a *V2ApiService) GatewayUpdateProducerArtifactory(ctx context.Context) ApiGatewayUpdateProducerArtifactoryRequest {
	return ApiGatewayUpdateProducerArtifactoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateProducerArtifactoryOutput
func (a *V2ApiService) GatewayUpdateProducerArtifactoryExecute(r ApiGatewayUpdateProducerArtifactoryRequest) (*GatewayUpdateProducerArtifactoryOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateProducerArtifactoryOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateProducerArtifactory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-producer-artifactory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateProducerAwsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateProducerAws *GatewayUpdateProducerAws
    body interface{}
}

func (r ApiGatewayUpdateProducerAwsRequest) GatewayUpdateProducerAws(gatewayUpdateProducerAws GatewayUpdateProducerAws) ApiGatewayUpdateProducerAwsRequest {
	r.gatewayUpdateProducerAws = &gatewayUpdateProducerAws
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateProducerAwsRequest) Body(body GatewayUpdateProducerAws) ApiGatewayUpdateProducerAwsRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateProducerAwsRequest) Execute() (*GatewayUpdateProducerAwsOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateProducerAwsExecute(r)
}

/*
GatewayUpdateProducerAws Method for GatewayUpdateProducerAws

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateProducerAwsRequest
*/
func (a *V2ApiService) GatewayUpdateProducerAws(ctx context.Context) ApiGatewayUpdateProducerAwsRequest {
	return ApiGatewayUpdateProducerAwsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateProducerAwsOutput
func (a *V2ApiService) GatewayUpdateProducerAwsExecute(r ApiGatewayUpdateProducerAwsRequest) (*GatewayUpdateProducerAwsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateProducerAwsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateProducerAws")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-producer-aws"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateProducerAzureRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateProducerAzure *GatewayUpdateProducerAzure
    body interface{}
}

func (r ApiGatewayUpdateProducerAzureRequest) GatewayUpdateProducerAzure(gatewayUpdateProducerAzure GatewayUpdateProducerAzure) ApiGatewayUpdateProducerAzureRequest {
	r.gatewayUpdateProducerAzure = &gatewayUpdateProducerAzure
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateProducerAzureRequest) Body(body GatewayUpdateProducerAzure) ApiGatewayUpdateProducerAzureRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateProducerAzureRequest) Execute() (*GatewayUpdateProducerAzureOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateProducerAzureExecute(r)
}

/*
GatewayUpdateProducerAzure Method for GatewayUpdateProducerAzure

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateProducerAzureRequest
*/
func (a *V2ApiService) GatewayUpdateProducerAzure(ctx context.Context) ApiGatewayUpdateProducerAzureRequest {
	return ApiGatewayUpdateProducerAzureRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateProducerAzureOutput
func (a *V2ApiService) GatewayUpdateProducerAzureExecute(r ApiGatewayUpdateProducerAzureRequest) (*GatewayUpdateProducerAzureOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateProducerAzureOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateProducerAzure")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-producer-azure"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateProducerCassandraRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateProducerCassandra *GatewayUpdateProducerCassandra
    body interface{}
}

func (r ApiGatewayUpdateProducerCassandraRequest) GatewayUpdateProducerCassandra(gatewayUpdateProducerCassandra GatewayUpdateProducerCassandra) ApiGatewayUpdateProducerCassandraRequest {
	r.gatewayUpdateProducerCassandra = &gatewayUpdateProducerCassandra
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateProducerCassandraRequest) Body(body GatewayUpdateProducerCassandra) ApiGatewayUpdateProducerCassandraRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateProducerCassandraRequest) Execute() (*GatewayUpdateProducerCassandraOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateProducerCassandraExecute(r)
}

/*
GatewayUpdateProducerCassandra Method for GatewayUpdateProducerCassandra

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateProducerCassandraRequest
*/
func (a *V2ApiService) GatewayUpdateProducerCassandra(ctx context.Context) ApiGatewayUpdateProducerCassandraRequest {
	return ApiGatewayUpdateProducerCassandraRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateProducerCassandraOutput
func (a *V2ApiService) GatewayUpdateProducerCassandraExecute(r ApiGatewayUpdateProducerCassandraRequest) (*GatewayUpdateProducerCassandraOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateProducerCassandraOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateProducerCassandra")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-producer-cassandra"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateProducerChefRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateProducerChef *GatewayUpdateProducerChef
    body interface{}
}

func (r ApiGatewayUpdateProducerChefRequest) GatewayUpdateProducerChef(gatewayUpdateProducerChef GatewayUpdateProducerChef) ApiGatewayUpdateProducerChefRequest {
	r.gatewayUpdateProducerChef = &gatewayUpdateProducerChef
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateProducerChefRequest) Body(body GatewayUpdateProducerChef) ApiGatewayUpdateProducerChefRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateProducerChefRequest) Execute() (*GatewayUpdateProducerChefOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateProducerChefExecute(r)
}

/*
GatewayUpdateProducerChef Method for GatewayUpdateProducerChef

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateProducerChefRequest
*/
func (a *V2ApiService) GatewayUpdateProducerChef(ctx context.Context) ApiGatewayUpdateProducerChefRequest {
	return ApiGatewayUpdateProducerChefRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateProducerChefOutput
func (a *V2ApiService) GatewayUpdateProducerChefExecute(r ApiGatewayUpdateProducerChefRequest) (*GatewayUpdateProducerChefOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateProducerChefOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateProducerChef")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-producer-chef"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateProducerCustomRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateProducerCustom *GatewayUpdateProducerCustom
    body interface{}
}

func (r ApiGatewayUpdateProducerCustomRequest) GatewayUpdateProducerCustom(gatewayUpdateProducerCustom GatewayUpdateProducerCustom) ApiGatewayUpdateProducerCustomRequest {
	r.gatewayUpdateProducerCustom = &gatewayUpdateProducerCustom
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateProducerCustomRequest) Body(body GatewayUpdateProducerCustom) ApiGatewayUpdateProducerCustomRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateProducerCustomRequest) Execute() (*GatewayUpdateProducerCustomOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateProducerCustomExecute(r)
}

/*
GatewayUpdateProducerCustom Method for GatewayUpdateProducerCustom

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateProducerCustomRequest
*/
func (a *V2ApiService) GatewayUpdateProducerCustom(ctx context.Context) ApiGatewayUpdateProducerCustomRequest {
	return ApiGatewayUpdateProducerCustomRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateProducerCustomOutput
func (a *V2ApiService) GatewayUpdateProducerCustomExecute(r ApiGatewayUpdateProducerCustomRequest) (*GatewayUpdateProducerCustomOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateProducerCustomOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateProducerCustom")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-producer-custom"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateProducerDockerhubRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateProducerDockerhub *GatewayUpdateProducerDockerhub
    body interface{}
}

func (r ApiGatewayUpdateProducerDockerhubRequest) GatewayUpdateProducerDockerhub(gatewayUpdateProducerDockerhub GatewayUpdateProducerDockerhub) ApiGatewayUpdateProducerDockerhubRequest {
	r.gatewayUpdateProducerDockerhub = &gatewayUpdateProducerDockerhub
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateProducerDockerhubRequest) Body(body GatewayUpdateProducerDockerhub) ApiGatewayUpdateProducerDockerhubRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateProducerDockerhubRequest) Execute() (*GatewayUpdateProducerDockerhubOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateProducerDockerhubExecute(r)
}

/*
GatewayUpdateProducerDockerhub Method for GatewayUpdateProducerDockerhub

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateProducerDockerhubRequest
*/
func (a *V2ApiService) GatewayUpdateProducerDockerhub(ctx context.Context) ApiGatewayUpdateProducerDockerhubRequest {
	return ApiGatewayUpdateProducerDockerhubRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateProducerDockerhubOutput
func (a *V2ApiService) GatewayUpdateProducerDockerhubExecute(r ApiGatewayUpdateProducerDockerhubRequest) (*GatewayUpdateProducerDockerhubOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateProducerDockerhubOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateProducerDockerhub")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-producer-dockerhub"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateProducerEksRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateProducerEks *GatewayUpdateProducerEks
    body interface{}
}

func (r ApiGatewayUpdateProducerEksRequest) GatewayUpdateProducerEks(gatewayUpdateProducerEks GatewayUpdateProducerEks) ApiGatewayUpdateProducerEksRequest {
	r.gatewayUpdateProducerEks = &gatewayUpdateProducerEks
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateProducerEksRequest) Body(body GatewayUpdateProducerEks) ApiGatewayUpdateProducerEksRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateProducerEksRequest) Execute() (*GatewayUpdateProducerEksOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateProducerEksExecute(r)
}

/*
GatewayUpdateProducerEks Method for GatewayUpdateProducerEks

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateProducerEksRequest
*/
func (a *V2ApiService) GatewayUpdateProducerEks(ctx context.Context) ApiGatewayUpdateProducerEksRequest {
	return ApiGatewayUpdateProducerEksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateProducerEksOutput
func (a *V2ApiService) GatewayUpdateProducerEksExecute(r ApiGatewayUpdateProducerEksRequest) (*GatewayUpdateProducerEksOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateProducerEksOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateProducerEks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-producer-eks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateProducerGcpRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateProducerGcp *GatewayUpdateProducerGcp
    body interface{}
}

func (r ApiGatewayUpdateProducerGcpRequest) GatewayUpdateProducerGcp(gatewayUpdateProducerGcp GatewayUpdateProducerGcp) ApiGatewayUpdateProducerGcpRequest {
	r.gatewayUpdateProducerGcp = &gatewayUpdateProducerGcp
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateProducerGcpRequest) Body(body GatewayUpdateProducerGcp) ApiGatewayUpdateProducerGcpRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateProducerGcpRequest) Execute() (*GatewayUpdateProducerGcpOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateProducerGcpExecute(r)
}

/*
GatewayUpdateProducerGcp Method for GatewayUpdateProducerGcp

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateProducerGcpRequest
*/
func (a *V2ApiService) GatewayUpdateProducerGcp(ctx context.Context) ApiGatewayUpdateProducerGcpRequest {
	return ApiGatewayUpdateProducerGcpRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateProducerGcpOutput
func (a *V2ApiService) GatewayUpdateProducerGcpExecute(r ApiGatewayUpdateProducerGcpRequest) (*GatewayUpdateProducerGcpOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateProducerGcpOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateProducerGcp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-producer-gcp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateProducerGithubRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateProducerGithub *GatewayUpdateProducerGithub
    body interface{}
}

func (r ApiGatewayUpdateProducerGithubRequest) GatewayUpdateProducerGithub(gatewayUpdateProducerGithub GatewayUpdateProducerGithub) ApiGatewayUpdateProducerGithubRequest {
	r.gatewayUpdateProducerGithub = &gatewayUpdateProducerGithub
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateProducerGithubRequest) Body(body GatewayUpdateProducerGithub) ApiGatewayUpdateProducerGithubRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateProducerGithubRequest) Execute() (*GatewayUpdateProducerGithubOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateProducerGithubExecute(r)
}

/*
GatewayUpdateProducerGithub Method for GatewayUpdateProducerGithub

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateProducerGithubRequest
*/
func (a *V2ApiService) GatewayUpdateProducerGithub(ctx context.Context) ApiGatewayUpdateProducerGithubRequest {
	return ApiGatewayUpdateProducerGithubRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateProducerGithubOutput
func (a *V2ApiService) GatewayUpdateProducerGithubExecute(r ApiGatewayUpdateProducerGithubRequest) (*GatewayUpdateProducerGithubOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateProducerGithubOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateProducerGithub")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-producer-github"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateProducerGkeRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateProducerGke *GatewayUpdateProducerGke
    body interface{}
}

func (r ApiGatewayUpdateProducerGkeRequest) GatewayUpdateProducerGke(gatewayUpdateProducerGke GatewayUpdateProducerGke) ApiGatewayUpdateProducerGkeRequest {
	r.gatewayUpdateProducerGke = &gatewayUpdateProducerGke
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateProducerGkeRequest) Body(body GatewayUpdateProducerGke) ApiGatewayUpdateProducerGkeRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateProducerGkeRequest) Execute() (*GatewayUpdateProducerGkeOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateProducerGkeExecute(r)
}

/*
GatewayUpdateProducerGke Method for GatewayUpdateProducerGke

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateProducerGkeRequest
*/
func (a *V2ApiService) GatewayUpdateProducerGke(ctx context.Context) ApiGatewayUpdateProducerGkeRequest {
	return ApiGatewayUpdateProducerGkeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateProducerGkeOutput
func (a *V2ApiService) GatewayUpdateProducerGkeExecute(r ApiGatewayUpdateProducerGkeRequest) (*GatewayUpdateProducerGkeOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateProducerGkeOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateProducerGke")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-producer-gke"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateProducerHanaDbRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateProducerHanaDb *GatewayUpdateProducerHanaDb
    body interface{}
}

func (r ApiGatewayUpdateProducerHanaDbRequest) GatewayUpdateProducerHanaDb(gatewayUpdateProducerHanaDb GatewayUpdateProducerHanaDb) ApiGatewayUpdateProducerHanaDbRequest {
	r.gatewayUpdateProducerHanaDb = &gatewayUpdateProducerHanaDb
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateProducerHanaDbRequest) Body(body GatewayUpdateProducerHanaDb) ApiGatewayUpdateProducerHanaDbRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateProducerHanaDbRequest) Execute() (*GatewayUpdateProducerHanaDbOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateProducerHanaDbExecute(r)
}

/*
GatewayUpdateProducerHanaDb Method for GatewayUpdateProducerHanaDb

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateProducerHanaDbRequest
*/
func (a *V2ApiService) GatewayUpdateProducerHanaDb(ctx context.Context) ApiGatewayUpdateProducerHanaDbRequest {
	return ApiGatewayUpdateProducerHanaDbRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateProducerHanaDbOutput
func (a *V2ApiService) GatewayUpdateProducerHanaDbExecute(r ApiGatewayUpdateProducerHanaDbRequest) (*GatewayUpdateProducerHanaDbOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateProducerHanaDbOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateProducerHanaDb")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-producer-hana"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateProducerLdapRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateProducerLdap *GatewayUpdateProducerLdap
    body interface{}
}

func (r ApiGatewayUpdateProducerLdapRequest) GatewayUpdateProducerLdap(gatewayUpdateProducerLdap GatewayUpdateProducerLdap) ApiGatewayUpdateProducerLdapRequest {
	r.gatewayUpdateProducerLdap = &gatewayUpdateProducerLdap
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateProducerLdapRequest) Body(body GatewayUpdateProducerLdap) ApiGatewayUpdateProducerLdapRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateProducerLdapRequest) Execute() (*GatewayUpdateProducerLdapOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateProducerLdapExecute(r)
}

/*
GatewayUpdateProducerLdap Method for GatewayUpdateProducerLdap

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateProducerLdapRequest
*/
func (a *V2ApiService) GatewayUpdateProducerLdap(ctx context.Context) ApiGatewayUpdateProducerLdapRequest {
	return ApiGatewayUpdateProducerLdapRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateProducerLdapOutput
func (a *V2ApiService) GatewayUpdateProducerLdapExecute(r ApiGatewayUpdateProducerLdapRequest) (*GatewayUpdateProducerLdapOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateProducerLdapOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateProducerLdap")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-producer-ldap"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateProducerMSSQLRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateProducerMSSQL *GatewayUpdateProducerMSSQL
    body interface{}
}

func (r ApiGatewayUpdateProducerMSSQLRequest) GatewayUpdateProducerMSSQL(gatewayUpdateProducerMSSQL GatewayUpdateProducerMSSQL) ApiGatewayUpdateProducerMSSQLRequest {
	r.gatewayUpdateProducerMSSQL = &gatewayUpdateProducerMSSQL
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateProducerMSSQLRequest) Body(body GatewayUpdateProducerMSSQL) ApiGatewayUpdateProducerMSSQLRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateProducerMSSQLRequest) Execute() (*GatewayUpdateProducerMSSQLOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateProducerMSSQLExecute(r)
}

/*
GatewayUpdateProducerMSSQL Method for GatewayUpdateProducerMSSQL

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateProducerMSSQLRequest
*/
func (a *V2ApiService) GatewayUpdateProducerMSSQL(ctx context.Context) ApiGatewayUpdateProducerMSSQLRequest {
	return ApiGatewayUpdateProducerMSSQLRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateProducerMSSQLOutput
func (a *V2ApiService) GatewayUpdateProducerMSSQLExecute(r ApiGatewayUpdateProducerMSSQLRequest) (*GatewayUpdateProducerMSSQLOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateProducerMSSQLOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateProducerMSSQL")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-producer-mssql"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateProducerMongoRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateProducerMongo *GatewayUpdateProducerMongo
    body interface{}
}

func (r ApiGatewayUpdateProducerMongoRequest) GatewayUpdateProducerMongo(gatewayUpdateProducerMongo GatewayUpdateProducerMongo) ApiGatewayUpdateProducerMongoRequest {
	r.gatewayUpdateProducerMongo = &gatewayUpdateProducerMongo
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateProducerMongoRequest) Body(body GatewayUpdateProducerMongo) ApiGatewayUpdateProducerMongoRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateProducerMongoRequest) Execute() (*GatewayUpdateProducerMongoOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateProducerMongoExecute(r)
}

/*
GatewayUpdateProducerMongo Method for GatewayUpdateProducerMongo

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateProducerMongoRequest
*/
func (a *V2ApiService) GatewayUpdateProducerMongo(ctx context.Context) ApiGatewayUpdateProducerMongoRequest {
	return ApiGatewayUpdateProducerMongoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateProducerMongoOutput
func (a *V2ApiService) GatewayUpdateProducerMongoExecute(r ApiGatewayUpdateProducerMongoRequest) (*GatewayUpdateProducerMongoOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateProducerMongoOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateProducerMongo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-producer-mongo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateProducerMySQLRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateProducerMySQL *GatewayUpdateProducerMySQL
    body interface{}
}

func (r ApiGatewayUpdateProducerMySQLRequest) GatewayUpdateProducerMySQL(gatewayUpdateProducerMySQL GatewayUpdateProducerMySQL) ApiGatewayUpdateProducerMySQLRequest {
	r.gatewayUpdateProducerMySQL = &gatewayUpdateProducerMySQL
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateProducerMySQLRequest) Body(body GatewayUpdateProducerMySQL) ApiGatewayUpdateProducerMySQLRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateProducerMySQLRequest) Execute() (*GatewayUpdateProducerMySQLOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateProducerMySQLExecute(r)
}

/*
GatewayUpdateProducerMySQL Method for GatewayUpdateProducerMySQL

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateProducerMySQLRequest
*/
func (a *V2ApiService) GatewayUpdateProducerMySQL(ctx context.Context) ApiGatewayUpdateProducerMySQLRequest {
	return ApiGatewayUpdateProducerMySQLRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateProducerMySQLOutput
func (a *V2ApiService) GatewayUpdateProducerMySQLExecute(r ApiGatewayUpdateProducerMySQLRequest) (*GatewayUpdateProducerMySQLOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateProducerMySQLOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateProducerMySQL")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-producer-mysql"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateProducerNativeK8SRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateProducerNativeK8S *GatewayUpdateProducerNativeK8S
    body interface{}
}

func (r ApiGatewayUpdateProducerNativeK8SRequest) GatewayUpdateProducerNativeK8S(gatewayUpdateProducerNativeK8S GatewayUpdateProducerNativeK8S) ApiGatewayUpdateProducerNativeK8SRequest {
	r.gatewayUpdateProducerNativeK8S = &gatewayUpdateProducerNativeK8S
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateProducerNativeK8SRequest) Body(body GatewayUpdateProducerNativeK8S) ApiGatewayUpdateProducerNativeK8SRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateProducerNativeK8SRequest) Execute() (*GatewayUpdateProducerNativeK8SOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateProducerNativeK8SExecute(r)
}

/*
GatewayUpdateProducerNativeK8S Method for GatewayUpdateProducerNativeK8S

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateProducerNativeK8SRequest
*/
func (a *V2ApiService) GatewayUpdateProducerNativeK8S(ctx context.Context) ApiGatewayUpdateProducerNativeK8SRequest {
	return ApiGatewayUpdateProducerNativeK8SRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateProducerNativeK8SOutput
func (a *V2ApiService) GatewayUpdateProducerNativeK8SExecute(r ApiGatewayUpdateProducerNativeK8SRequest) (*GatewayUpdateProducerNativeK8SOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateProducerNativeK8SOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateProducerNativeK8S")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-producer-k8s"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateProducerOracleDbRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateProducerOracleDb *GatewayUpdateProducerOracleDb
    body interface{}
}

func (r ApiGatewayUpdateProducerOracleDbRequest) GatewayUpdateProducerOracleDb(gatewayUpdateProducerOracleDb GatewayUpdateProducerOracleDb) ApiGatewayUpdateProducerOracleDbRequest {
	r.gatewayUpdateProducerOracleDb = &gatewayUpdateProducerOracleDb
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateProducerOracleDbRequest) Body(body GatewayUpdateProducerOracleDb) ApiGatewayUpdateProducerOracleDbRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateProducerOracleDbRequest) Execute() (*GatewayUpdateProducerOracleDbOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateProducerOracleDbExecute(r)
}

/*
GatewayUpdateProducerOracleDb Method for GatewayUpdateProducerOracleDb

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateProducerOracleDbRequest
*/
func (a *V2ApiService) GatewayUpdateProducerOracleDb(ctx context.Context) ApiGatewayUpdateProducerOracleDbRequest {
	return ApiGatewayUpdateProducerOracleDbRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateProducerOracleDbOutput
func (a *V2ApiService) GatewayUpdateProducerOracleDbExecute(r ApiGatewayUpdateProducerOracleDbRequest) (*GatewayUpdateProducerOracleDbOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateProducerOracleDbOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateProducerOracleDb")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-producer-oracle"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateProducerPingRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateProducerPing *GatewayUpdateProducerPing
    body interface{}
}

func (r ApiGatewayUpdateProducerPingRequest) GatewayUpdateProducerPing(gatewayUpdateProducerPing GatewayUpdateProducerPing) ApiGatewayUpdateProducerPingRequest {
	r.gatewayUpdateProducerPing = &gatewayUpdateProducerPing
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateProducerPingRequest) Body(body GatewayUpdateProducerPing) ApiGatewayUpdateProducerPingRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateProducerPingRequest) Execute() (*GatewayUpdateProducerPingOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateProducerPingExecute(r)
}

/*
GatewayUpdateProducerPing Method for GatewayUpdateProducerPing

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateProducerPingRequest
*/
func (a *V2ApiService) GatewayUpdateProducerPing(ctx context.Context) ApiGatewayUpdateProducerPingRequest {
	return ApiGatewayUpdateProducerPingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateProducerPingOutput
func (a *V2ApiService) GatewayUpdateProducerPingExecute(r ApiGatewayUpdateProducerPingRequest) (*GatewayUpdateProducerPingOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateProducerPingOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateProducerPing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-producer-ping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateProducerPostgreSQLRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateProducerPostgreSQL *GatewayUpdateProducerPostgreSQL
    body interface{}
}

func (r ApiGatewayUpdateProducerPostgreSQLRequest) GatewayUpdateProducerPostgreSQL(gatewayUpdateProducerPostgreSQL GatewayUpdateProducerPostgreSQL) ApiGatewayUpdateProducerPostgreSQLRequest {
	r.gatewayUpdateProducerPostgreSQL = &gatewayUpdateProducerPostgreSQL
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateProducerPostgreSQLRequest) Body(body GatewayUpdateProducerPostgreSQL) ApiGatewayUpdateProducerPostgreSQLRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateProducerPostgreSQLRequest) Execute() (*GatewayUpdateProducerPostgreSQLOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateProducerPostgreSQLExecute(r)
}

/*
GatewayUpdateProducerPostgreSQL Method for GatewayUpdateProducerPostgreSQL

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateProducerPostgreSQLRequest
*/
func (a *V2ApiService) GatewayUpdateProducerPostgreSQL(ctx context.Context) ApiGatewayUpdateProducerPostgreSQLRequest {
	return ApiGatewayUpdateProducerPostgreSQLRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateProducerPostgreSQLOutput
func (a *V2ApiService) GatewayUpdateProducerPostgreSQLExecute(r ApiGatewayUpdateProducerPostgreSQLRequest) (*GatewayUpdateProducerPostgreSQLOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateProducerPostgreSQLOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateProducerPostgreSQL")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-producer-postgresql"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateProducerRabbitMQRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateProducerRabbitMQ *GatewayUpdateProducerRabbitMQ
    body interface{}
}

func (r ApiGatewayUpdateProducerRabbitMQRequest) GatewayUpdateProducerRabbitMQ(gatewayUpdateProducerRabbitMQ GatewayUpdateProducerRabbitMQ) ApiGatewayUpdateProducerRabbitMQRequest {
	r.gatewayUpdateProducerRabbitMQ = &gatewayUpdateProducerRabbitMQ
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateProducerRabbitMQRequest) Body(body GatewayUpdateProducerRabbitMQ) ApiGatewayUpdateProducerRabbitMQRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateProducerRabbitMQRequest) Execute() (*GatewayUpdateProducerRabbitMQOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateProducerRabbitMQExecute(r)
}

/*
GatewayUpdateProducerRabbitMQ Method for GatewayUpdateProducerRabbitMQ

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateProducerRabbitMQRequest
*/
func (a *V2ApiService) GatewayUpdateProducerRabbitMQ(ctx context.Context) ApiGatewayUpdateProducerRabbitMQRequest {
	return ApiGatewayUpdateProducerRabbitMQRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateProducerRabbitMQOutput
func (a *V2ApiService) GatewayUpdateProducerRabbitMQExecute(r ApiGatewayUpdateProducerRabbitMQRequest) (*GatewayUpdateProducerRabbitMQOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateProducerRabbitMQOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateProducerRabbitMQ")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-producer-rabbitmq"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateProducerRdpRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateProducerRdp *GatewayUpdateProducerRdp
    body interface{}
}

func (r ApiGatewayUpdateProducerRdpRequest) GatewayUpdateProducerRdp(gatewayUpdateProducerRdp GatewayUpdateProducerRdp) ApiGatewayUpdateProducerRdpRequest {
	r.gatewayUpdateProducerRdp = &gatewayUpdateProducerRdp
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateProducerRdpRequest) Body(body GatewayUpdateProducerRdp) ApiGatewayUpdateProducerRdpRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateProducerRdpRequest) Execute() (*GatewayUpdateProducerRdpOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateProducerRdpExecute(r)
}

/*
GatewayUpdateProducerRdp Method for GatewayUpdateProducerRdp

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateProducerRdpRequest
*/
func (a *V2ApiService) GatewayUpdateProducerRdp(ctx context.Context) ApiGatewayUpdateProducerRdpRequest {
	return ApiGatewayUpdateProducerRdpRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateProducerRdpOutput
func (a *V2ApiService) GatewayUpdateProducerRdpExecute(r ApiGatewayUpdateProducerRdpRequest) (*GatewayUpdateProducerRdpOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateProducerRdpOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateProducerRdp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-producer-rdp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateProducerRedisRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateProducerRedis *GatewayUpdateProducerRedis
    body interface{}
}

func (r ApiGatewayUpdateProducerRedisRequest) GatewayUpdateProducerRedis(gatewayUpdateProducerRedis GatewayUpdateProducerRedis) ApiGatewayUpdateProducerRedisRequest {
	r.gatewayUpdateProducerRedis = &gatewayUpdateProducerRedis
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateProducerRedisRequest) Body(body GatewayUpdateProducerRedis) ApiGatewayUpdateProducerRedisRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateProducerRedisRequest) Execute() (*GatewayUpdateProducerRedisOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateProducerRedisExecute(r)
}

/*
GatewayUpdateProducerRedis Method for GatewayUpdateProducerRedis

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateProducerRedisRequest
*/
func (a *V2ApiService) GatewayUpdateProducerRedis(ctx context.Context) ApiGatewayUpdateProducerRedisRequest {
	return ApiGatewayUpdateProducerRedisRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateProducerRedisOutput
func (a *V2ApiService) GatewayUpdateProducerRedisExecute(r ApiGatewayUpdateProducerRedisRequest) (*GatewayUpdateProducerRedisOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateProducerRedisOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateProducerRedis")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-producer-redis"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateProducerRedshiftRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateProducerRedshift *GatewayUpdateProducerRedshift
    body interface{}
}

func (r ApiGatewayUpdateProducerRedshiftRequest) GatewayUpdateProducerRedshift(gatewayUpdateProducerRedshift GatewayUpdateProducerRedshift) ApiGatewayUpdateProducerRedshiftRequest {
	r.gatewayUpdateProducerRedshift = &gatewayUpdateProducerRedshift
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateProducerRedshiftRequest) Body(body GatewayUpdateProducerRedshift) ApiGatewayUpdateProducerRedshiftRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateProducerRedshiftRequest) Execute() (*GatewayUpdateProducerRedshiftOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateProducerRedshiftExecute(r)
}

/*
GatewayUpdateProducerRedshift Method for GatewayUpdateProducerRedshift

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateProducerRedshiftRequest
*/
func (a *V2ApiService) GatewayUpdateProducerRedshift(ctx context.Context) ApiGatewayUpdateProducerRedshiftRequest {
	return ApiGatewayUpdateProducerRedshiftRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateProducerRedshiftOutput
func (a *V2ApiService) GatewayUpdateProducerRedshiftExecute(r ApiGatewayUpdateProducerRedshiftRequest) (*GatewayUpdateProducerRedshiftOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateProducerRedshiftOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateProducerRedshift")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-producer-redshift"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateProducerSnowflakeRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateProducerSnowflake *GatewayUpdateProducerSnowflake
    body interface{}
}

func (r ApiGatewayUpdateProducerSnowflakeRequest) GatewayUpdateProducerSnowflake(gatewayUpdateProducerSnowflake GatewayUpdateProducerSnowflake) ApiGatewayUpdateProducerSnowflakeRequest {
	r.gatewayUpdateProducerSnowflake = &gatewayUpdateProducerSnowflake
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateProducerSnowflakeRequest) Body(body GatewayUpdateProducerSnowflake) ApiGatewayUpdateProducerSnowflakeRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateProducerSnowflakeRequest) Execute() (*GatewayUpdateProducerSnowflakeOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateProducerSnowflakeExecute(r)
}

/*
GatewayUpdateProducerSnowflake Method for GatewayUpdateProducerSnowflake

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateProducerSnowflakeRequest
*/
func (a *V2ApiService) GatewayUpdateProducerSnowflake(ctx context.Context) ApiGatewayUpdateProducerSnowflakeRequest {
	return ApiGatewayUpdateProducerSnowflakeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateProducerSnowflakeOutput
func (a *V2ApiService) GatewayUpdateProducerSnowflakeExecute(r ApiGatewayUpdateProducerSnowflakeRequest) (*GatewayUpdateProducerSnowflakeOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateProducerSnowflakeOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateProducerSnowflake")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-producer-snowflake"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateProducerVenafiRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateProducerVenafi *GatewayUpdateProducerVenafi
    body interface{}
}

func (r ApiGatewayUpdateProducerVenafiRequest) GatewayUpdateProducerVenafi(gatewayUpdateProducerVenafi GatewayUpdateProducerVenafi) ApiGatewayUpdateProducerVenafiRequest {
	r.gatewayUpdateProducerVenafi = &gatewayUpdateProducerVenafi
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateProducerVenafiRequest) Body(body GatewayUpdateProducerVenafi) ApiGatewayUpdateProducerVenafiRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateProducerVenafiRequest) Execute() (*GatewayUpdateProducerVenafiOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateProducerVenafiExecute(r)
}

/*
GatewayUpdateProducerVenafi Method for GatewayUpdateProducerVenafi

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateProducerVenafiRequest
*/
func (a *V2ApiService) GatewayUpdateProducerVenafi(ctx context.Context) ApiGatewayUpdateProducerVenafiRequest {
	return ApiGatewayUpdateProducerVenafiRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateProducerVenafiOutput
func (a *V2ApiService) GatewayUpdateProducerVenafiExecute(r ApiGatewayUpdateProducerVenafiRequest) (*GatewayUpdateProducerVenafiOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateProducerVenafiOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateProducerVenafi")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-producer-certificate-automation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateRemoteAccessRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateRemoteAccess *GatewayUpdateRemoteAccess
    body interface{}
}

func (r ApiGatewayUpdateRemoteAccessRequest) GatewayUpdateRemoteAccess(gatewayUpdateRemoteAccess GatewayUpdateRemoteAccess) ApiGatewayUpdateRemoteAccessRequest {
	r.gatewayUpdateRemoteAccess = &gatewayUpdateRemoteAccess
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateRemoteAccessRequest) Body(body GatewayUpdateRemoteAccess) ApiGatewayUpdateRemoteAccessRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateRemoteAccessRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GatewayUpdateRemoteAccessExecute(r)
}

/*
GatewayUpdateRemoteAccess Method for GatewayUpdateRemoteAccess

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateRemoteAccessRequest
*/
func (a *V2ApiService) GatewayUpdateRemoteAccess(ctx context.Context) ApiGatewayUpdateRemoteAccessRequest {
	return ApiGatewayUpdateRemoteAccessRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) GatewayUpdateRemoteAccessExecute(r ApiGatewayUpdateRemoteAccessRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateRemoteAccess")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-remote-access"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateRemoteAccessDesktopAppRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateRemoteAccessDesktopApp *GatewayUpdateRemoteAccessDesktopApp
    body interface{}
}

func (r ApiGatewayUpdateRemoteAccessDesktopAppRequest) GatewayUpdateRemoteAccessDesktopApp(gatewayUpdateRemoteAccessDesktopApp GatewayUpdateRemoteAccessDesktopApp) ApiGatewayUpdateRemoteAccessDesktopAppRequest {
	r.gatewayUpdateRemoteAccessDesktopApp = &gatewayUpdateRemoteAccessDesktopApp
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateRemoteAccessDesktopAppRequest) Body(body GatewayUpdateRemoteAccessDesktopApp) ApiGatewayUpdateRemoteAccessDesktopAppRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateRemoteAccessDesktopAppRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GatewayUpdateRemoteAccessDesktopAppExecute(r)
}

/*
GatewayUpdateRemoteAccessDesktopApp Method for GatewayUpdateRemoteAccessDesktopApp

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateRemoteAccessDesktopAppRequest
*/
func (a *V2ApiService) GatewayUpdateRemoteAccessDesktopApp(ctx context.Context) ApiGatewayUpdateRemoteAccessDesktopAppRequest {
	return ApiGatewayUpdateRemoteAccessDesktopAppRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) GatewayUpdateRemoteAccessDesktopAppExecute(r ApiGatewayUpdateRemoteAccessDesktopAppRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateRemoteAccessDesktopApp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-remote-access-desktop-app"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateRemoteAccessRdpRecordingsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateRemoteAccessRdpRecordings *GatewayUpdateRemoteAccessRdpRecordings
    body interface{}
}

func (r ApiGatewayUpdateRemoteAccessRdpRecordingsRequest) GatewayUpdateRemoteAccessRdpRecordings(gatewayUpdateRemoteAccessRdpRecordings GatewayUpdateRemoteAccessRdpRecordings) ApiGatewayUpdateRemoteAccessRdpRecordingsRequest {
	r.gatewayUpdateRemoteAccessRdpRecordings = &gatewayUpdateRemoteAccessRdpRecordings
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateRemoteAccessRdpRecordingsRequest) Body(body GatewayUpdateRemoteAccessRdpRecordings) ApiGatewayUpdateRemoteAccessRdpRecordingsRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateRemoteAccessRdpRecordingsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GatewayUpdateRemoteAccessRdpRecordingsExecute(r)
}

/*
GatewayUpdateRemoteAccessRdpRecordings Method for GatewayUpdateRemoteAccessRdpRecordings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateRemoteAccessRdpRecordingsRequest
*/
func (a *V2ApiService) GatewayUpdateRemoteAccessRdpRecordings(ctx context.Context) ApiGatewayUpdateRemoteAccessRdpRecordingsRequest {
	return ApiGatewayUpdateRemoteAccessRdpRecordingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) GatewayUpdateRemoteAccessRdpRecordingsExecute(r ApiGatewayUpdateRemoteAccessRdpRecordingsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateRemoteAccessRdpRecordings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-remote-access-rdp-recording"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateTlsCertRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateTlsCert *GatewayUpdateTlsCert
    body interface{}
}

func (r ApiGatewayUpdateTlsCertRequest) GatewayUpdateTlsCert(gatewayUpdateTlsCert GatewayUpdateTlsCert) ApiGatewayUpdateTlsCertRequest {
	r.gatewayUpdateTlsCert = &gatewayUpdateTlsCert
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateTlsCertRequest) Body(body GatewayUpdateTlsCert) ApiGatewayUpdateTlsCertRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateTlsCertRequest) Execute() (*GatewayUpdateTlsCertOutput, *http.Response, error) {
	return r.ApiService.GatewayUpdateTlsCertExecute(r)
}

/*
GatewayUpdateTlsCert Method for GatewayUpdateTlsCert

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateTlsCertRequest
*/
func (a *V2ApiService) GatewayUpdateTlsCert(ctx context.Context) ApiGatewayUpdateTlsCertRequest {
	return ApiGatewayUpdateTlsCertRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateTlsCertOutput
func (a *V2ApiService) GatewayUpdateTlsCertExecute(r ApiGatewayUpdateTlsCertRequest) (*GatewayUpdateTlsCertOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateTlsCertOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateTlsCert")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-tls-cert"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatewayUpdateTmpUsersRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gatewayUpdateTmpUsers *GatewayUpdateTmpUsers
    body interface{}
}

func (r ApiGatewayUpdateTmpUsersRequest) GatewayUpdateTmpUsers(gatewayUpdateTmpUsers GatewayUpdateTmpUsers) ApiGatewayUpdateTmpUsersRequest {
	r.gatewayUpdateTmpUsers = &gatewayUpdateTmpUsers
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGatewayUpdateTmpUsersRequest) Body(body GatewayUpdateTmpUsers) ApiGatewayUpdateTmpUsersRequest {
    r.body = body
    return r
}

func (r ApiGatewayUpdateTmpUsersRequest) Execute() (*http.Response, error) {
	return r.ApiService.GatewayUpdateTmpUsersExecute(r)
}

/*
GatewayUpdateTmpUsers Method for GatewayUpdateTmpUsers

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatewayUpdateTmpUsersRequest
*/
func (a *V2ApiService) GatewayUpdateTmpUsers(ctx context.Context) ApiGatewayUpdateTmpUsersRequest {
	return ApiGatewayUpdateTmpUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *V2ApiService) GatewayUpdateTmpUsersExecute(r ApiGatewayUpdateTmpUsersRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GatewayUpdateTmpUsers")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-producer-tmp-creds"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGenerateAcmeEabRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	generateAcmeEab *GenerateAcmeEab
    body interface{}
}

func (r ApiGenerateAcmeEabRequest) GenerateAcmeEab(generateAcmeEab GenerateAcmeEab) ApiGenerateAcmeEabRequest {
	r.generateAcmeEab = &generateAcmeEab
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGenerateAcmeEabRequest) Body(body GenerateAcmeEab) ApiGenerateAcmeEabRequest {
    r.body = body
    return r
}

func (r ApiGenerateAcmeEabRequest) Execute() (*GenerateAcmeEabOutput, *http.Response, error) {
	return r.ApiService.GenerateAcmeEabExecute(r)
}

/*
GenerateAcmeEab Method for GenerateAcmeEab

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGenerateAcmeEabRequest
*/
func (a *V2ApiService) GenerateAcmeEab(ctx context.Context) ApiGenerateAcmeEabRequest {
	return ApiGenerateAcmeEabRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GenerateAcmeEabOutput
func (a *V2ApiService) GenerateAcmeEabExecute(r ApiGenerateAcmeEabRequest) (*GenerateAcmeEabOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GenerateAcmeEabOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GenerateAcmeEab")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/generate-acme-eab"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGenerateCARequest struct {
	ctx context.Context
	ApiService *V2ApiService
	generateCA *GenerateCA
    body interface{}
}

func (r ApiGenerateCARequest) GenerateCA(generateCA GenerateCA) ApiGenerateCARequest {
	r.generateCA = &generateCA
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGenerateCARequest) Body(body GenerateCA) ApiGenerateCARequest {
    r.body = body
    return r
}

func (r ApiGenerateCARequest) Execute() (*GenerateCAOutput, *http.Response, error) {
	return r.ApiService.GenerateCAExecute(r)
}

/*
GenerateCA Method for GenerateCA

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGenerateCARequest
*/
func (a *V2ApiService) GenerateCA(ctx context.Context) ApiGenerateCARequest {
	return ApiGenerateCARequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GenerateCAOutput
func (a *V2ApiService) GenerateCAExecute(r ApiGenerateCARequest) (*GenerateCAOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GenerateCAOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GenerateCA")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/generate-ca"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGenerateCsrRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	generateCsr *GenerateCsr
    body interface{}
}

func (r ApiGenerateCsrRequest) GenerateCsr(generateCsr GenerateCsr) ApiGenerateCsrRequest {
	r.generateCsr = &generateCsr
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGenerateCsrRequest) Body(body GenerateCsr) ApiGenerateCsrRequest {
    r.body = body
    return r
}

func (r ApiGenerateCsrRequest) Execute() (*GenerateCsrOutput, *http.Response, error) {
	return r.ApiService.GenerateCsrExecute(r)
}

/*
GenerateCsr Method for GenerateCsr

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGenerateCsrRequest
*/
func (a *V2ApiService) GenerateCsr(ctx context.Context) ApiGenerateCsrRequest {
	return ApiGenerateCsrRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GenerateCsrOutput
func (a *V2ApiService) GenerateCsrExecute(r ApiGenerateCsrRequest) (*GenerateCsrOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GenerateCsrOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GenerateCsr")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/generate-csr"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountLogoRequest struct {
	ctx context.Context
	ApiService *V2ApiService
    body interface{}
}



func (r ApiGetAccountLogoRequest) Execute() (map[string]string, *http.Response, error) {
	return r.ApiService.GetAccountLogoExecute(r)
}

/*
GetAccountLogo Method for GetAccountLogo

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountLogoRequest
*/
func (a *V2ApiService) GetAccountLogo(ctx context.Context) ApiGetAccountLogoRequest {
	return ApiGetAccountLogoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]string
func (a *V2ApiService) GetAccountLogoExecute(r ApiGetAccountLogoRequest) (map[string]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GetAccountLogo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/get-account-logo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountSettingsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	getAccountSettings *GetAccountSettings
    body interface{}
}

func (r ApiGetAccountSettingsRequest) GetAccountSettings(getAccountSettings GetAccountSettings) ApiGetAccountSettingsRequest {
	r.getAccountSettings = &getAccountSettings
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGetAccountSettingsRequest) Body(body GetAccountSettings) ApiGetAccountSettingsRequest {
    r.body = body
    return r
}

func (r ApiGetAccountSettingsRequest) Execute() (*GetAccountSettingsCommandOutput, *http.Response, error) {
	return r.ApiService.GetAccountSettingsExecute(r)
}

/*
GetAccountSettings Method for GetAccountSettings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountSettingsRequest
*/
func (a *V2ApiService) GetAccountSettings(ctx context.Context) ApiGetAccountSettingsRequest {
	return ApiGetAccountSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccountSettingsCommandOutput
func (a *V2ApiService) GetAccountSettingsExecute(r ApiGetAccountSettingsRequest) (*GetAccountSettingsCommandOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountSettingsCommandOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GetAccountSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/get-account-settings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAnalyticsDataRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	getAnalyticsData *GetAnalyticsData
    body interface{}
}

func (r ApiGetAnalyticsDataRequest) GetAnalyticsData(getAnalyticsData GetAnalyticsData) ApiGetAnalyticsDataRequest {
	r.getAnalyticsData = &getAnalyticsData
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGetAnalyticsDataRequest) Body(body GetAnalyticsData) ApiGetAnalyticsDataRequest {
    r.body = body
    return r
}

func (r ApiGetAnalyticsDataRequest) Execute() (*AllAnalyticsData, *http.Response, error) {
	return r.ApiService.GetAnalyticsDataExecute(r)
}

/*
GetAnalyticsData Method for GetAnalyticsData

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAnalyticsDataRequest
*/
func (a *V2ApiService) GetAnalyticsData(ctx context.Context) ApiGetAnalyticsDataRequest {
	return ApiGetAnalyticsDataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AllAnalyticsData
func (a *V2ApiService) GetAnalyticsDataExecute(r ApiGetAnalyticsDataRequest) (*AllAnalyticsData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AllAnalyticsData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GetAnalyticsData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/get-analytics-data"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAuthMethodRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	getAuthMethod *GetAuthMethod
    body interface{}
}

func (r ApiGetAuthMethodRequest) GetAuthMethod(getAuthMethod GetAuthMethod) ApiGetAuthMethodRequest {
	r.getAuthMethod = &getAuthMethod
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGetAuthMethodRequest) Body(body GetAuthMethod) ApiGetAuthMethodRequest {
    r.body = body
    return r
}

func (r ApiGetAuthMethodRequest) Execute() (*AuthMethod, *http.Response, error) {
	return r.ApiService.GetAuthMethodExecute(r)
}

/*
GetAuthMethod Method for GetAuthMethod

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAuthMethodRequest
*/
func (a *V2ApiService) GetAuthMethod(ctx context.Context) ApiGetAuthMethodRequest {
	return ApiGetAuthMethodRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthMethod
func (a *V2ApiService) GetAuthMethodExecute(r ApiGetAuthMethodRequest) (*AuthMethod, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthMethod
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GetAuthMethod")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/get-auth-method"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCertChallengeRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	getCertChallenge *GetCertChallenge
    body interface{}
}

func (r ApiGetCertChallengeRequest) GetCertChallenge(getCertChallenge GetCertChallenge) ApiGetCertChallengeRequest {
	r.getCertChallenge = &getCertChallenge
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGetCertChallengeRequest) Body(body GetCertChallenge) ApiGetCertChallengeRequest {
    r.body = body
    return r
}

func (r ApiGetCertChallengeRequest) Execute() (*GetCertChallengeOutput, *http.Response, error) {
	return r.ApiService.GetCertChallengeExecute(r)
}

/*
GetCertChallenge Method for GetCertChallenge

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCertChallengeRequest
*/
func (a *V2ApiService) GetCertChallenge(ctx context.Context) ApiGetCertChallengeRequest {
	return ApiGetCertChallengeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCertChallengeOutput
func (a *V2ApiService) GetCertChallengeExecute(r ApiGetCertChallengeRequest) (*GetCertChallengeOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCertChallengeOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GetCertChallenge")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/get-cert-challenge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCertificateValueRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	getCertificateValue *GetCertificateValue
    body interface{}
}

func (r ApiGetCertificateValueRequest) GetCertificateValue(getCertificateValue GetCertificateValue) ApiGetCertificateValueRequest {
	r.getCertificateValue = &getCertificateValue
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGetCertificateValueRequest) Body(body GetCertificateValue) ApiGetCertificateValueRequest {
    r.body = body
    return r
}

func (r ApiGetCertificateValueRequest) Execute() (*GetCertificateValueOutput, *http.Response, error) {
	return r.ApiService.GetCertificateValueExecute(r)
}

/*
GetCertificateValue Method for GetCertificateValue

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCertificateValueRequest
*/
func (a *V2ApiService) GetCertificateValue(ctx context.Context) ApiGetCertificateValueRequest {
	return ApiGetCertificateValueRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCertificateValueOutput
func (a *V2ApiService) GetCertificateValueExecute(r ApiGetCertificateValueRequest) (*GetCertificateValueOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCertificateValueOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GetCertificateValue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/get-certificate-value"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDynamicSecretValueRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	getDynamicSecretValue *GetDynamicSecretValue
    body interface{}
}

func (r ApiGetDynamicSecretValueRequest) GetDynamicSecretValue(getDynamicSecretValue GetDynamicSecretValue) ApiGetDynamicSecretValueRequest {
	r.getDynamicSecretValue = &getDynamicSecretValue
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGetDynamicSecretValueRequest) Body(body GetDynamicSecretValue) ApiGetDynamicSecretValueRequest {
    r.body = body
    return r
}

func (r ApiGetDynamicSecretValueRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDynamicSecretValueExecute(r)
}

/*
GetDynamicSecretValue Method for GetDynamicSecretValue

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDynamicSecretValueRequest
*/
func (a *V2ApiService) GetDynamicSecretValue(ctx context.Context) ApiGetDynamicSecretValueRequest {
	return ApiGetDynamicSecretValueRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) GetDynamicSecretValueExecute(r ApiGetDynamicSecretValueRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GetDynamicSecretValue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/get-dynamic-secret-value"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEventForwarderRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	getEventForwarder *GetEventForwarder
    body interface{}
}

func (r ApiGetEventForwarderRequest) GetEventForwarder(getEventForwarder GetEventForwarder) ApiGetEventForwarderRequest {
	r.getEventForwarder = &getEventForwarder
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGetEventForwarderRequest) Body(body GetEventForwarder) ApiGetEventForwarderRequest {
    r.body = body
    return r
}

func (r ApiGetEventForwarderRequest) Execute() (*GetEventForwarderOutput, *http.Response, error) {
	return r.ApiService.GetEventForwarderExecute(r)
}

/*
GetEventForwarder Method for GetEventForwarder

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEventForwarderRequest
*/
func (a *V2ApiService) GetEventForwarder(ctx context.Context) ApiGetEventForwarderRequest {
	return ApiGetEventForwarderRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetEventForwarderOutput
func (a *V2ApiService) GetEventForwarderExecute(r ApiGetEventForwarderRequest) (*GetEventForwarderOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetEventForwarderOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GetEventForwarder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/get-event-forwarder"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGroupRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	getGroup *GetGroup
    body interface{}
}

func (r ApiGetGroupRequest) GetGroup(getGroup GetGroup) ApiGetGroupRequest {
	r.getGroup = &getGroup
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGetGroupRequest) Body(body GetGroup) ApiGetGroupRequest {
    r.body = body
    return r
}

func (r ApiGetGroupRequest) Execute() (*GetGroupOutput, *http.Response, error) {
	return r.ApiService.GetGroupExecute(r)
}

/*
GetGroup Method for GetGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetGroupRequest
*/
func (a *V2ApiService) GetGroup(ctx context.Context) ApiGetGroupRequest {
	return ApiGetGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetGroupOutput
func (a *V2ApiService) GetGroupExecute(r ApiGetGroupRequest) (*GetGroupOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetGroupOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GetGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/get-group"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetKubeExecCredsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	getKubeExecCreds *GetKubeExecCreds
    body interface{}
}

func (r ApiGetKubeExecCredsRequest) GetKubeExecCreds(getKubeExecCreds GetKubeExecCreds) ApiGetKubeExecCredsRequest {
	r.getKubeExecCreds = &getKubeExecCreds
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGetKubeExecCredsRequest) Body(body GetKubeExecCreds) ApiGetKubeExecCredsRequest {
    r.body = body
    return r
}

func (r ApiGetKubeExecCredsRequest) Execute() (*GetKubeExecCredsOutput, *http.Response, error) {
	return r.ApiService.GetKubeExecCredsExecute(r)
}

/*
GetKubeExecCreds Method for GetKubeExecCreds

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetKubeExecCredsRequest
*/
func (a *V2ApiService) GetKubeExecCreds(ctx context.Context) ApiGetKubeExecCredsRequest {
	return ApiGetKubeExecCredsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetKubeExecCredsOutput
func (a *V2ApiService) GetKubeExecCredsExecute(r ApiGetKubeExecCredsRequest) (*GetKubeExecCredsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetKubeExecCredsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GetKubeExecCreds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/get-kube-exec-creds"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLastUserEventStatusRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	getLastUserEventStatus *GetLastUserEventStatus
    body interface{}
}

func (r ApiGetLastUserEventStatusRequest) GetLastUserEventStatus(getLastUserEventStatus GetLastUserEventStatus) ApiGetLastUserEventStatusRequest {
	r.getLastUserEventStatus = &getLastUserEventStatus
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGetLastUserEventStatusRequest) Body(body GetLastUserEventStatus) ApiGetLastUserEventStatusRequest {
    r.body = body
    return r
}

func (r ApiGetLastUserEventStatusRequest) Execute() (*GetUserEventStatusOutput, *http.Response, error) {
	return r.ApiService.GetLastUserEventStatusExecute(r)
}

/*
GetLastUserEventStatus Method for GetLastUserEventStatus

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLastUserEventStatusRequest
*/
func (a *V2ApiService) GetLastUserEventStatus(ctx context.Context) ApiGetLastUserEventStatusRequest {
	return ApiGetLastUserEventStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetUserEventStatusOutput
func (a *V2ApiService) GetLastUserEventStatusExecute(r ApiGetLastUserEventStatusRequest) (*GetUserEventStatusOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetUserEventStatusOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GetLastUserEventStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user-event-last-status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPKICertificateRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	getPKICertificate *GetPKICertificate
    body interface{}
}

func (r ApiGetPKICertificateRequest) GetPKICertificate(getPKICertificate GetPKICertificate) ApiGetPKICertificateRequest {
	r.getPKICertificate = &getPKICertificate
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGetPKICertificateRequest) Body(body GetPKICertificate) ApiGetPKICertificateRequest {
    r.body = body
    return r
}

func (r ApiGetPKICertificateRequest) Execute() (*GetPKICertificateOutput, *http.Response, error) {
	return r.ApiService.GetPKICertificateExecute(r)
}

/*
GetPKICertificate Method for GetPKICertificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPKICertificateRequest
*/
func (a *V2ApiService) GetPKICertificate(ctx context.Context) ApiGetPKICertificateRequest {
	return ApiGetPKICertificateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetPKICertificateOutput
func (a *V2ApiService) GetPKICertificateExecute(r ApiGetPKICertificateRequest) (*GetPKICertificateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPKICertificateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GetPKICertificate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/get-pki-certificate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRSAPublicRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	getRSAPublic *GetRSAPublic
    body interface{}
}

func (r ApiGetRSAPublicRequest) GetRSAPublic(getRSAPublic GetRSAPublic) ApiGetRSAPublicRequest {
	r.getRSAPublic = &getRSAPublic
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGetRSAPublicRequest) Body(body GetRSAPublic) ApiGetRSAPublicRequest {
    r.body = body
    return r
}

func (r ApiGetRSAPublicRequest) Execute() (*GetRSAPublicOutput, *http.Response, error) {
	return r.ApiService.GetRSAPublicExecute(r)
}

/*
GetRSAPublic Method for GetRSAPublic

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRSAPublicRequest
*/
func (a *V2ApiService) GetRSAPublic(ctx context.Context) ApiGetRSAPublicRequest {
	return ApiGetRSAPublicRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetRSAPublicOutput
func (a *V2ApiService) GetRSAPublicExecute(r ApiGetRSAPublicRequest) (*GetRSAPublicOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRSAPublicOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GetRSAPublic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/get-rsa-public"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoleRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	getRole *GetRole
    body interface{}
}

func (r ApiGetRoleRequest) GetRole(getRole GetRole) ApiGetRoleRequest {
	r.getRole = &getRole
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGetRoleRequest) Body(body GetRole) ApiGetRoleRequest {
    r.body = body
    return r
}

func (r ApiGetRoleRequest) Execute() (*Role, *http.Response, error) {
	return r.ApiService.GetRoleExecute(r)
}

/*
GetRole Method for GetRole

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRoleRequest
*/
func (a *V2ApiService) GetRole(ctx context.Context) ApiGetRoleRequest {
	return ApiGetRoleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Role
func (a *V2ApiService) GetRoleExecute(r ApiGetRoleRequest) (*Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GetRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/get-role"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRotatedSecretValueRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	getRotatedSecretValue *GetRotatedSecretValue
    body interface{}
}

func (r ApiGetRotatedSecretValueRequest) GetRotatedSecretValue(getRotatedSecretValue GetRotatedSecretValue) ApiGetRotatedSecretValueRequest {
	r.getRotatedSecretValue = &getRotatedSecretValue
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGetRotatedSecretValueRequest) Body(body GetRotatedSecretValue) ApiGetRotatedSecretValueRequest {
    r.body = body
    return r
}

func (r ApiGetRotatedSecretValueRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetRotatedSecretValueExecute(r)
}

/*
GetRotatedSecretValue Method for GetRotatedSecretValue

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRotatedSecretValueRequest
*/
func (a *V2ApiService) GetRotatedSecretValue(ctx context.Context) ApiGetRotatedSecretValueRequest {
	return ApiGetRotatedSecretValueRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) GetRotatedSecretValueExecute(r ApiGetRotatedSecretValueRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GetRotatedSecretValue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/get-rotated-secret-value"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSSHCertificateRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	getSSHCertificate *GetSSHCertificate
    body interface{}
}

func (r ApiGetSSHCertificateRequest) GetSSHCertificate(getSSHCertificate GetSSHCertificate) ApiGetSSHCertificateRequest {
	r.getSSHCertificate = &getSSHCertificate
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGetSSHCertificateRequest) Body(body GetSSHCertificate) ApiGetSSHCertificateRequest {
    r.body = body
    return r
}

func (r ApiGetSSHCertificateRequest) Execute() (*GetSSHCertificateOutput, *http.Response, error) {
	return r.ApiService.GetSSHCertificateExecute(r)
}

/*
GetSSHCertificate Method for GetSSHCertificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSSHCertificateRequest
*/
func (a *V2ApiService) GetSSHCertificate(ctx context.Context) ApiGetSSHCertificateRequest {
	return ApiGetSSHCertificateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSSHCertificateOutput
func (a *V2ApiService) GetSSHCertificateExecute(r ApiGetSSHCertificateRequest) (*GetSSHCertificateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSSHCertificateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GetSSHCertificate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/get-ssh-certificate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSecretValueRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	getSecretValue *GetSecretValue
    body interface{}
}

func (r ApiGetSecretValueRequest) GetSecretValue(getSecretValue GetSecretValue) ApiGetSecretValueRequest {
	r.getSecretValue = &getSecretValue
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGetSecretValueRequest) Body(body GetSecretValue) ApiGetSecretValueRequest {
    r.body = body
    return r
}

func (r ApiGetSecretValueRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetSecretValueExecute(r)
}

/*
GetSecretValue Method for GetSecretValue

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSecretValueRequest
*/
func (a *V2ApiService) GetSecretValue(ctx context.Context) ApiGetSecretValueRequest {
	return ApiGetSecretValueRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) GetSecretValueExecute(r ApiGetSecretValueRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GetSecretValue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/get-secret-value"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTagsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	getTags *GetTags
    body interface{}
}

func (r ApiGetTagsRequest) GetTags(getTags GetTags) ApiGetTagsRequest {
	r.getTags = &getTags
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGetTagsRequest) Body(body GetTags) ApiGetTagsRequest {
    r.body = body
    return r
}

func (r ApiGetTagsRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.GetTagsExecute(r)
}

/*
GetTags Method for GetTags

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTagsRequest
*/
func (a *V2ApiService) GetTags(ctx context.Context) ApiGetTagsRequest {
	return ApiGetTagsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []string
func (a *V2ApiService) GetTagsExecute(r ApiGetTagsRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GetTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/get-tags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	getTarget *GetTarget
    body interface{}
}

func (r ApiGetTargetRequest) GetTarget(getTarget GetTarget) ApiGetTargetRequest {
	r.getTarget = &getTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGetTargetRequest) Body(body GetTarget) ApiGetTargetRequest {
    r.body = body
    return r
}

func (r ApiGetTargetRequest) Execute() (*Target, *http.Response, error) {
	return r.ApiService.GetTargetExecute(r)
}

/*
GetTarget Method for GetTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTargetRequest
*/
func (a *V2ApiService) GetTarget(ctx context.Context) ApiGetTargetRequest {
	return ApiGetTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Target
func (a *V2ApiService) GetTargetExecute(r ApiGetTargetRequest) (*Target, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Target
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GetTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/get-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTargetDetailsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	getTargetDetails *GetTargetDetails
    body interface{}
}

func (r ApiGetTargetDetailsRequest) GetTargetDetails(getTargetDetails GetTargetDetails) ApiGetTargetDetailsRequest {
	r.getTargetDetails = &getTargetDetails
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGetTargetDetailsRequest) Body(body GetTargetDetails) ApiGetTargetDetailsRequest {
    r.body = body
    return r
}

func (r ApiGetTargetDetailsRequest) Execute() (*GetTargetDetailsOutput, *http.Response, error) {
	return r.ApiService.GetTargetDetailsExecute(r)
}

/*
GetTargetDetails Method for GetTargetDetails

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTargetDetailsRequest
*/
func (a *V2ApiService) GetTargetDetails(ctx context.Context) ApiGetTargetDetailsRequest {
	return ApiGetTargetDetailsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTargetDetailsOutput
func (a *V2ApiService) GetTargetDetailsExecute(r ApiGetTargetDetailsRequest) (*GetTargetDetailsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTargetDetailsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GetTargetDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/get-target-details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGwUpdateRemoteAccessSessionLogsAwsS3Request struct {
	ctx context.Context
	ApiService *V2ApiService
	gwUpdateRemoteAccessSessionLogsAwsS3 *GwUpdateRemoteAccessSessionLogsAwsS3
    body interface{}
}

func (r ApiGwUpdateRemoteAccessSessionLogsAwsS3Request) GwUpdateRemoteAccessSessionLogsAwsS3(gwUpdateRemoteAccessSessionLogsAwsS3 GwUpdateRemoteAccessSessionLogsAwsS3) ApiGwUpdateRemoteAccessSessionLogsAwsS3Request {
	r.gwUpdateRemoteAccessSessionLogsAwsS3 = &gwUpdateRemoteAccessSessionLogsAwsS3
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGwUpdateRemoteAccessSessionLogsAwsS3Request) Body(body GwUpdateRemoteAccessSessionLogsAwsS3) ApiGwUpdateRemoteAccessSessionLogsAwsS3Request {
    r.body = body
    return r
}

func (r ApiGwUpdateRemoteAccessSessionLogsAwsS3Request) Execute() (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	return r.ApiService.GwUpdateRemoteAccessSessionLogsAwsS3Execute(r)
}

/*
GwUpdateRemoteAccessSessionLogsAwsS3 Method for GwUpdateRemoteAccessSessionLogsAwsS3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGwUpdateRemoteAccessSessionLogsAwsS3Request
*/
func (a *V2ApiService) GwUpdateRemoteAccessSessionLogsAwsS3(ctx context.Context) ApiGwUpdateRemoteAccessSessionLogsAwsS3Request {
	return ApiGwUpdateRemoteAccessSessionLogsAwsS3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateLogForwardingOutput
func (a *V2ApiService) GwUpdateRemoteAccessSessionLogsAwsS3Execute(r ApiGwUpdateRemoteAccessSessionLogsAwsS3Request) (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateLogForwardingOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GwUpdateRemoteAccessSessionLogsAwsS3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-remote-access-session-forwarding-aws-s3"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGwUpdateRemoteAccessSessionLogsAzureAnalyticsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gwUpdateRemoteAccessSessionLogsAzureAnalytics *GwUpdateRemoteAccessSessionLogsAzureAnalytics
    body interface{}
}

func (r ApiGwUpdateRemoteAccessSessionLogsAzureAnalyticsRequest) GwUpdateRemoteAccessSessionLogsAzureAnalytics(gwUpdateRemoteAccessSessionLogsAzureAnalytics GwUpdateRemoteAccessSessionLogsAzureAnalytics) ApiGwUpdateRemoteAccessSessionLogsAzureAnalyticsRequest {
	r.gwUpdateRemoteAccessSessionLogsAzureAnalytics = &gwUpdateRemoteAccessSessionLogsAzureAnalytics
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGwUpdateRemoteAccessSessionLogsAzureAnalyticsRequest) Body(body GwUpdateRemoteAccessSessionLogsAzureAnalytics) ApiGwUpdateRemoteAccessSessionLogsAzureAnalyticsRequest {
    r.body = body
    return r
}

func (r ApiGwUpdateRemoteAccessSessionLogsAzureAnalyticsRequest) Execute() (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	return r.ApiService.GwUpdateRemoteAccessSessionLogsAzureAnalyticsExecute(r)
}

/*
GwUpdateRemoteAccessSessionLogsAzureAnalytics Method for GwUpdateRemoteAccessSessionLogsAzureAnalytics

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGwUpdateRemoteAccessSessionLogsAzureAnalyticsRequest
*/
func (a *V2ApiService) GwUpdateRemoteAccessSessionLogsAzureAnalytics(ctx context.Context) ApiGwUpdateRemoteAccessSessionLogsAzureAnalyticsRequest {
	return ApiGwUpdateRemoteAccessSessionLogsAzureAnalyticsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateLogForwardingOutput
func (a *V2ApiService) GwUpdateRemoteAccessSessionLogsAzureAnalyticsExecute(r ApiGwUpdateRemoteAccessSessionLogsAzureAnalyticsRequest) (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateLogForwardingOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GwUpdateRemoteAccessSessionLogsAzureAnalytics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-remote-access-session-forwarding-azure-analytics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGwUpdateRemoteAccessSessionLogsDatadogRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gwUpdateRemoteAccessSessionLogsDatadog *GwUpdateRemoteAccessSessionLogsDatadog
    body interface{}
}

func (r ApiGwUpdateRemoteAccessSessionLogsDatadogRequest) GwUpdateRemoteAccessSessionLogsDatadog(gwUpdateRemoteAccessSessionLogsDatadog GwUpdateRemoteAccessSessionLogsDatadog) ApiGwUpdateRemoteAccessSessionLogsDatadogRequest {
	r.gwUpdateRemoteAccessSessionLogsDatadog = &gwUpdateRemoteAccessSessionLogsDatadog
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGwUpdateRemoteAccessSessionLogsDatadogRequest) Body(body GwUpdateRemoteAccessSessionLogsDatadog) ApiGwUpdateRemoteAccessSessionLogsDatadogRequest {
    r.body = body
    return r
}

func (r ApiGwUpdateRemoteAccessSessionLogsDatadogRequest) Execute() (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	return r.ApiService.GwUpdateRemoteAccessSessionLogsDatadogExecute(r)
}

/*
GwUpdateRemoteAccessSessionLogsDatadog Method for GwUpdateRemoteAccessSessionLogsDatadog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGwUpdateRemoteAccessSessionLogsDatadogRequest
*/
func (a *V2ApiService) GwUpdateRemoteAccessSessionLogsDatadog(ctx context.Context) ApiGwUpdateRemoteAccessSessionLogsDatadogRequest {
	return ApiGwUpdateRemoteAccessSessionLogsDatadogRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateLogForwardingOutput
func (a *V2ApiService) GwUpdateRemoteAccessSessionLogsDatadogExecute(r ApiGwUpdateRemoteAccessSessionLogsDatadogRequest) (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateLogForwardingOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GwUpdateRemoteAccessSessionLogsDatadog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-remote-access-session-forwarding-datadog"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGwUpdateRemoteAccessSessionLogsElasticsearchRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gwUpdateRemoteAccessSessionLogsElasticsearch *GwUpdateRemoteAccessSessionLogsElasticsearch
    body interface{}
}

func (r ApiGwUpdateRemoteAccessSessionLogsElasticsearchRequest) GwUpdateRemoteAccessSessionLogsElasticsearch(gwUpdateRemoteAccessSessionLogsElasticsearch GwUpdateRemoteAccessSessionLogsElasticsearch) ApiGwUpdateRemoteAccessSessionLogsElasticsearchRequest {
	r.gwUpdateRemoteAccessSessionLogsElasticsearch = &gwUpdateRemoteAccessSessionLogsElasticsearch
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGwUpdateRemoteAccessSessionLogsElasticsearchRequest) Body(body GwUpdateRemoteAccessSessionLogsElasticsearch) ApiGwUpdateRemoteAccessSessionLogsElasticsearchRequest {
    r.body = body
    return r
}

func (r ApiGwUpdateRemoteAccessSessionLogsElasticsearchRequest) Execute() (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	return r.ApiService.GwUpdateRemoteAccessSessionLogsElasticsearchExecute(r)
}

/*
GwUpdateRemoteAccessSessionLogsElasticsearch Method for GwUpdateRemoteAccessSessionLogsElasticsearch

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGwUpdateRemoteAccessSessionLogsElasticsearchRequest
*/
func (a *V2ApiService) GwUpdateRemoteAccessSessionLogsElasticsearch(ctx context.Context) ApiGwUpdateRemoteAccessSessionLogsElasticsearchRequest {
	return ApiGwUpdateRemoteAccessSessionLogsElasticsearchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateLogForwardingOutput
func (a *V2ApiService) GwUpdateRemoteAccessSessionLogsElasticsearchExecute(r ApiGwUpdateRemoteAccessSessionLogsElasticsearchRequest) (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateLogForwardingOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GwUpdateRemoteAccessSessionLogsElasticsearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-remote-access-session-forwarding-elasticsearch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGwUpdateRemoteAccessSessionLogsGoogleChronicleRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gwUpdateRemoteAccessSessionLogsGoogleChronicle *GwUpdateRemoteAccessSessionLogsGoogleChronicle
    body interface{}
}

func (r ApiGwUpdateRemoteAccessSessionLogsGoogleChronicleRequest) GwUpdateRemoteAccessSessionLogsGoogleChronicle(gwUpdateRemoteAccessSessionLogsGoogleChronicle GwUpdateRemoteAccessSessionLogsGoogleChronicle) ApiGwUpdateRemoteAccessSessionLogsGoogleChronicleRequest {
	r.gwUpdateRemoteAccessSessionLogsGoogleChronicle = &gwUpdateRemoteAccessSessionLogsGoogleChronicle
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGwUpdateRemoteAccessSessionLogsGoogleChronicleRequest) Body(body GwUpdateRemoteAccessSessionLogsGoogleChronicle) ApiGwUpdateRemoteAccessSessionLogsGoogleChronicleRequest {
    r.body = body
    return r
}

func (r ApiGwUpdateRemoteAccessSessionLogsGoogleChronicleRequest) Execute() (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	return r.ApiService.GwUpdateRemoteAccessSessionLogsGoogleChronicleExecute(r)
}

/*
GwUpdateRemoteAccessSessionLogsGoogleChronicle Method for GwUpdateRemoteAccessSessionLogsGoogleChronicle

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGwUpdateRemoteAccessSessionLogsGoogleChronicleRequest
*/
func (a *V2ApiService) GwUpdateRemoteAccessSessionLogsGoogleChronicle(ctx context.Context) ApiGwUpdateRemoteAccessSessionLogsGoogleChronicleRequest {
	return ApiGwUpdateRemoteAccessSessionLogsGoogleChronicleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateLogForwardingOutput
func (a *V2ApiService) GwUpdateRemoteAccessSessionLogsGoogleChronicleExecute(r ApiGwUpdateRemoteAccessSessionLogsGoogleChronicleRequest) (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateLogForwardingOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GwUpdateRemoteAccessSessionLogsGoogleChronicle")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-remote-access-session-forwarding-google-chronicle"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGwUpdateRemoteAccessSessionLogsLogstashRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gwUpdateRemoteAccessSessionLogsLogstash *GwUpdateRemoteAccessSessionLogsLogstash
    body interface{}
}

func (r ApiGwUpdateRemoteAccessSessionLogsLogstashRequest) GwUpdateRemoteAccessSessionLogsLogstash(gwUpdateRemoteAccessSessionLogsLogstash GwUpdateRemoteAccessSessionLogsLogstash) ApiGwUpdateRemoteAccessSessionLogsLogstashRequest {
	r.gwUpdateRemoteAccessSessionLogsLogstash = &gwUpdateRemoteAccessSessionLogsLogstash
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGwUpdateRemoteAccessSessionLogsLogstashRequest) Body(body GwUpdateRemoteAccessSessionLogsLogstash) ApiGwUpdateRemoteAccessSessionLogsLogstashRequest {
    r.body = body
    return r
}

func (r ApiGwUpdateRemoteAccessSessionLogsLogstashRequest) Execute() (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	return r.ApiService.GwUpdateRemoteAccessSessionLogsLogstashExecute(r)
}

/*
GwUpdateRemoteAccessSessionLogsLogstash Method for GwUpdateRemoteAccessSessionLogsLogstash

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGwUpdateRemoteAccessSessionLogsLogstashRequest
*/
func (a *V2ApiService) GwUpdateRemoteAccessSessionLogsLogstash(ctx context.Context) ApiGwUpdateRemoteAccessSessionLogsLogstashRequest {
	return ApiGwUpdateRemoteAccessSessionLogsLogstashRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateLogForwardingOutput
func (a *V2ApiService) GwUpdateRemoteAccessSessionLogsLogstashExecute(r ApiGwUpdateRemoteAccessSessionLogsLogstashRequest) (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateLogForwardingOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GwUpdateRemoteAccessSessionLogsLogstash")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-remote-access-session-forwarding-logstash"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGwUpdateRemoteAccessSessionLogsLogzIoRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gwUpdateRemoteAccessSessionLogsLogzIo *GwUpdateRemoteAccessSessionLogsLogzIo
    body interface{}
}

func (r ApiGwUpdateRemoteAccessSessionLogsLogzIoRequest) GwUpdateRemoteAccessSessionLogsLogzIo(gwUpdateRemoteAccessSessionLogsLogzIo GwUpdateRemoteAccessSessionLogsLogzIo) ApiGwUpdateRemoteAccessSessionLogsLogzIoRequest {
	r.gwUpdateRemoteAccessSessionLogsLogzIo = &gwUpdateRemoteAccessSessionLogsLogzIo
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGwUpdateRemoteAccessSessionLogsLogzIoRequest) Body(body GwUpdateRemoteAccessSessionLogsLogzIo) ApiGwUpdateRemoteAccessSessionLogsLogzIoRequest {
    r.body = body
    return r
}

func (r ApiGwUpdateRemoteAccessSessionLogsLogzIoRequest) Execute() (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	return r.ApiService.GwUpdateRemoteAccessSessionLogsLogzIoExecute(r)
}

/*
GwUpdateRemoteAccessSessionLogsLogzIo Method for GwUpdateRemoteAccessSessionLogsLogzIo

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGwUpdateRemoteAccessSessionLogsLogzIoRequest
*/
func (a *V2ApiService) GwUpdateRemoteAccessSessionLogsLogzIo(ctx context.Context) ApiGwUpdateRemoteAccessSessionLogsLogzIoRequest {
	return ApiGwUpdateRemoteAccessSessionLogsLogzIoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateLogForwardingOutput
func (a *V2ApiService) GwUpdateRemoteAccessSessionLogsLogzIoExecute(r ApiGwUpdateRemoteAccessSessionLogsLogzIoRequest) (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateLogForwardingOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GwUpdateRemoteAccessSessionLogsLogzIo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-remote-access-session-forwarding-logz-io"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGwUpdateRemoteAccessSessionLogsSplunkRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gwUpdateRemoteAccessSessionLogsSplunk *GwUpdateRemoteAccessSessionLogsSplunk
    body interface{}
}

func (r ApiGwUpdateRemoteAccessSessionLogsSplunkRequest) GwUpdateRemoteAccessSessionLogsSplunk(gwUpdateRemoteAccessSessionLogsSplunk GwUpdateRemoteAccessSessionLogsSplunk) ApiGwUpdateRemoteAccessSessionLogsSplunkRequest {
	r.gwUpdateRemoteAccessSessionLogsSplunk = &gwUpdateRemoteAccessSessionLogsSplunk
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGwUpdateRemoteAccessSessionLogsSplunkRequest) Body(body GwUpdateRemoteAccessSessionLogsSplunk) ApiGwUpdateRemoteAccessSessionLogsSplunkRequest {
    r.body = body
    return r
}

func (r ApiGwUpdateRemoteAccessSessionLogsSplunkRequest) Execute() (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	return r.ApiService.GwUpdateRemoteAccessSessionLogsSplunkExecute(r)
}

/*
GwUpdateRemoteAccessSessionLogsSplunk Method for GwUpdateRemoteAccessSessionLogsSplunk

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGwUpdateRemoteAccessSessionLogsSplunkRequest
*/
func (a *V2ApiService) GwUpdateRemoteAccessSessionLogsSplunk(ctx context.Context) ApiGwUpdateRemoteAccessSessionLogsSplunkRequest {
	return ApiGwUpdateRemoteAccessSessionLogsSplunkRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateLogForwardingOutput
func (a *V2ApiService) GwUpdateRemoteAccessSessionLogsSplunkExecute(r ApiGwUpdateRemoteAccessSessionLogsSplunkRequest) (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateLogForwardingOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GwUpdateRemoteAccessSessionLogsSplunk")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-remote-access-session-forwarding-splunk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGwUpdateRemoteAccessSessionLogsStdoutRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gwUpdateRemoteAccessSessionLogsStdout *GwUpdateRemoteAccessSessionLogsStdout
    body interface{}
}

func (r ApiGwUpdateRemoteAccessSessionLogsStdoutRequest) GwUpdateRemoteAccessSessionLogsStdout(gwUpdateRemoteAccessSessionLogsStdout GwUpdateRemoteAccessSessionLogsStdout) ApiGwUpdateRemoteAccessSessionLogsStdoutRequest {
	r.gwUpdateRemoteAccessSessionLogsStdout = &gwUpdateRemoteAccessSessionLogsStdout
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGwUpdateRemoteAccessSessionLogsStdoutRequest) Body(body GwUpdateRemoteAccessSessionLogsStdout) ApiGwUpdateRemoteAccessSessionLogsStdoutRequest {
    r.body = body
    return r
}

func (r ApiGwUpdateRemoteAccessSessionLogsStdoutRequest) Execute() (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	return r.ApiService.GwUpdateRemoteAccessSessionLogsStdoutExecute(r)
}

/*
GwUpdateRemoteAccessSessionLogsStdout Method for GwUpdateRemoteAccessSessionLogsStdout

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGwUpdateRemoteAccessSessionLogsStdoutRequest
*/
func (a *V2ApiService) GwUpdateRemoteAccessSessionLogsStdout(ctx context.Context) ApiGwUpdateRemoteAccessSessionLogsStdoutRequest {
	return ApiGwUpdateRemoteAccessSessionLogsStdoutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateLogForwardingOutput
func (a *V2ApiService) GwUpdateRemoteAccessSessionLogsStdoutExecute(r ApiGwUpdateRemoteAccessSessionLogsStdoutRequest) (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateLogForwardingOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GwUpdateRemoteAccessSessionLogsStdout")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-remote-access-session-forwarding-stdout"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGwUpdateRemoteAccessSessionLogsSumologicRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gwUpdateRemoteAccessSessionLogsSumologic *GwUpdateRemoteAccessSessionLogsSumologic
    body interface{}
}

func (r ApiGwUpdateRemoteAccessSessionLogsSumologicRequest) GwUpdateRemoteAccessSessionLogsSumologic(gwUpdateRemoteAccessSessionLogsSumologic GwUpdateRemoteAccessSessionLogsSumologic) ApiGwUpdateRemoteAccessSessionLogsSumologicRequest {
	r.gwUpdateRemoteAccessSessionLogsSumologic = &gwUpdateRemoteAccessSessionLogsSumologic
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGwUpdateRemoteAccessSessionLogsSumologicRequest) Body(body GwUpdateRemoteAccessSessionLogsSumologic) ApiGwUpdateRemoteAccessSessionLogsSumologicRequest {
    r.body = body
    return r
}

func (r ApiGwUpdateRemoteAccessSessionLogsSumologicRequest) Execute() (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	return r.ApiService.GwUpdateRemoteAccessSessionLogsSumologicExecute(r)
}

/*
GwUpdateRemoteAccessSessionLogsSumologic Method for GwUpdateRemoteAccessSessionLogsSumologic

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGwUpdateRemoteAccessSessionLogsSumologicRequest
*/
func (a *V2ApiService) GwUpdateRemoteAccessSessionLogsSumologic(ctx context.Context) ApiGwUpdateRemoteAccessSessionLogsSumologicRequest {
	return ApiGwUpdateRemoteAccessSessionLogsSumologicRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateLogForwardingOutput
func (a *V2ApiService) GwUpdateRemoteAccessSessionLogsSumologicExecute(r ApiGwUpdateRemoteAccessSessionLogsSumologicRequest) (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateLogForwardingOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GwUpdateRemoteAccessSessionLogsSumologic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-remote-access-session-forwarding-sumologic"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGwUpdateRemoteAccessSessionLogsSyslogRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	gwUpdateRemoteAccessSessionLogsSyslog *GwUpdateRemoteAccessSessionLogsSyslog
    body interface{}
}

func (r ApiGwUpdateRemoteAccessSessionLogsSyslogRequest) GwUpdateRemoteAccessSessionLogsSyslog(gwUpdateRemoteAccessSessionLogsSyslog GwUpdateRemoteAccessSessionLogsSyslog) ApiGwUpdateRemoteAccessSessionLogsSyslogRequest {
	r.gwUpdateRemoteAccessSessionLogsSyslog = &gwUpdateRemoteAccessSessionLogsSyslog
	return r
}


    // Body sets the body payload for the API call.
func (r ApiGwUpdateRemoteAccessSessionLogsSyslogRequest) Body(body GwUpdateRemoteAccessSessionLogsSyslog) ApiGwUpdateRemoteAccessSessionLogsSyslogRequest {
    r.body = body
    return r
}

func (r ApiGwUpdateRemoteAccessSessionLogsSyslogRequest) Execute() (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	return r.ApiService.GwUpdateRemoteAccessSessionLogsSyslogExecute(r)
}

/*
GwUpdateRemoteAccessSessionLogsSyslog Method for GwUpdateRemoteAccessSessionLogsSyslog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGwUpdateRemoteAccessSessionLogsSyslogRequest
*/
func (a *V2ApiService) GwUpdateRemoteAccessSessionLogsSyslog(ctx context.Context) ApiGwUpdateRemoteAccessSessionLogsSyslogRequest {
	return ApiGwUpdateRemoteAccessSessionLogsSyslogRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewayUpdateLogForwardingOutput
func (a *V2ApiService) GwUpdateRemoteAccessSessionLogsSyslogExecute(r ApiGwUpdateRemoteAccessSessionLogsSyslogRequest) (*GatewayUpdateLogForwardingOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayUpdateLogForwardingOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.GwUpdateRemoteAccessSessionLogsSyslog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-update-remote-access-session-forwarding-syslog"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHmacRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	hmac *Hmac
    body interface{}
}

func (r ApiHmacRequest) Hmac(hmac Hmac) ApiHmacRequest {
	r.hmac = &hmac
	return r
}


    // Body sets the body payload for the API call.
func (r ApiHmacRequest) Body(body Hmac) ApiHmacRequest {
    r.body = body
    return r
}

func (r ApiHmacRequest) Execute() (*HmacOutput, *http.Response, error) {
	return r.ApiService.HmacExecute(r)
}

/*
Hmac Method for Hmac

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiHmacRequest
*/
func (a *V2ApiService) Hmac(ctx context.Context) ApiHmacRequest {
	return ApiHmacRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HmacOutput
func (a *V2ApiService) HmacExecute(r ApiHmacRequest) (*HmacOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HmacOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.Hmac")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hmac"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiImportPasswordsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	importPasswords *ImportPasswords
    body interface{}
}

func (r ApiImportPasswordsRequest) ImportPasswords(importPasswords ImportPasswords) ApiImportPasswordsRequest {
	r.importPasswords = &importPasswords
	return r
}


    // Body sets the body payload for the API call.
func (r ApiImportPasswordsRequest) Body(body ImportPasswords) ApiImportPasswordsRequest {
    r.body = body
    return r
}

func (r ApiImportPasswordsRequest) Execute() (*ImportPasswordsOutput, *http.Response, error) {
	return r.ApiService.ImportPasswordsExecute(r)
}

/*
ImportPasswords Method for ImportPasswords

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiImportPasswordsRequest
*/
func (a *V2ApiService) ImportPasswords(ctx context.Context) ApiImportPasswordsRequest {
	return ApiImportPasswordsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ImportPasswordsOutput
func (a *V2ApiService) ImportPasswordsExecute(r ApiImportPasswordsRequest) (*ImportPasswordsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ImportPasswordsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.ImportPasswords")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/import-passwords"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKmipClientDeleteRuleRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	kmipClientDeleteRule *KmipClientDeleteRule
    body interface{}
}

func (r ApiKmipClientDeleteRuleRequest) KmipClientDeleteRule(kmipClientDeleteRule KmipClientDeleteRule) ApiKmipClientDeleteRuleRequest {
	r.kmipClientDeleteRule = &kmipClientDeleteRule
	return r
}


    // Body sets the body payload for the API call.
func (r ApiKmipClientDeleteRuleRequest) Body(body KmipClientDeleteRule) ApiKmipClientDeleteRuleRequest {
    r.body = body
    return r
}

func (r ApiKmipClientDeleteRuleRequest) Execute() (*KMIPClientUpdateResponse, *http.Response, error) {
	return r.ApiService.KmipClientDeleteRuleExecute(r)
}

/*
KmipClientDeleteRule Method for KmipClientDeleteRule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiKmipClientDeleteRuleRequest
*/
func (a *V2ApiService) KmipClientDeleteRule(ctx context.Context) ApiKmipClientDeleteRuleRequest {
	return ApiKmipClientDeleteRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KMIPClientUpdateResponse
func (a *V2ApiService) KmipClientDeleteRuleExecute(r ApiKmipClientDeleteRuleRequest) (*KMIPClientUpdateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KMIPClientUpdateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.KmipClientDeleteRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kmip-client-delete-rule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKmipClientSetRuleRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	kmipClientSetRule *KmipClientSetRule
    body interface{}
}

func (r ApiKmipClientSetRuleRequest) KmipClientSetRule(kmipClientSetRule KmipClientSetRule) ApiKmipClientSetRuleRequest {
	r.kmipClientSetRule = &kmipClientSetRule
	return r
}


    // Body sets the body payload for the API call.
func (r ApiKmipClientSetRuleRequest) Body(body KmipClientSetRule) ApiKmipClientSetRuleRequest {
    r.body = body
    return r
}

func (r ApiKmipClientSetRuleRequest) Execute() (*KMIPClientUpdateResponse, *http.Response, error) {
	return r.ApiService.KmipClientSetRuleExecute(r)
}

/*
KmipClientSetRule Method for KmipClientSetRule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiKmipClientSetRuleRequest
*/
func (a *V2ApiService) KmipClientSetRule(ctx context.Context) ApiKmipClientSetRuleRequest {
	return ApiKmipClientSetRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KMIPClientUpdateResponse
func (a *V2ApiService) KmipClientSetRuleExecute(r ApiKmipClientSetRuleRequest) (*KMIPClientUpdateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KMIPClientUpdateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.KmipClientSetRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kmip-client-set-rule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKmipCreateClientRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	kmipCreateClient *KmipCreateClient
    body interface{}
}

func (r ApiKmipCreateClientRequest) KmipCreateClient(kmipCreateClient KmipCreateClient) ApiKmipCreateClientRequest {
	r.kmipCreateClient = &kmipCreateClient
	return r
}


    // Body sets the body payload for the API call.
func (r ApiKmipCreateClientRequest) Body(body KmipCreateClient) ApiKmipCreateClientRequest {
    r.body = body
    return r
}

func (r ApiKmipCreateClientRequest) Execute() (*KmipCreateClientOutput, *http.Response, error) {
	return r.ApiService.KmipCreateClientExecute(r)
}

/*
KmipCreateClient Method for KmipCreateClient

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiKmipCreateClientRequest
*/
func (a *V2ApiService) KmipCreateClient(ctx context.Context) ApiKmipCreateClientRequest {
	return ApiKmipCreateClientRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KmipCreateClientOutput
func (a *V2ApiService) KmipCreateClientExecute(r ApiKmipCreateClientRequest) (*KmipCreateClientOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KmipCreateClientOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.KmipCreateClient")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kmip-create-client"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKmipDeleteClientRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	kmipDeleteClient *KmipDeleteClient
    body interface{}
}

func (r ApiKmipDeleteClientRequest) KmipDeleteClient(kmipDeleteClient KmipDeleteClient) ApiKmipDeleteClientRequest {
	r.kmipDeleteClient = &kmipDeleteClient
	return r
}


    // Body sets the body payload for the API call.
func (r ApiKmipDeleteClientRequest) Body(body KmipDeleteClient) ApiKmipDeleteClientRequest {
    r.body = body
    return r
}

func (r ApiKmipDeleteClientRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.KmipDeleteClientExecute(r)
}

/*
KmipDeleteClient Method for KmipDeleteClient

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiKmipDeleteClientRequest
*/
func (a *V2ApiService) KmipDeleteClient(ctx context.Context) ApiKmipDeleteClientRequest {
	return ApiKmipDeleteClientRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) KmipDeleteClientExecute(r ApiKmipDeleteClientRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.KmipDeleteClient")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kmip-delete-client"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKmipDeleteServerRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	kmipDeleteServer *KmipDeleteServer
    body interface{}
}

func (r ApiKmipDeleteServerRequest) KmipDeleteServer(kmipDeleteServer KmipDeleteServer) ApiKmipDeleteServerRequest {
	r.kmipDeleteServer = &kmipDeleteServer
	return r
}


    // Body sets the body payload for the API call.
func (r ApiKmipDeleteServerRequest) Body(body KmipDeleteServer) ApiKmipDeleteServerRequest {
    r.body = body
    return r
}

func (r ApiKmipDeleteServerRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.KmipDeleteServerExecute(r)
}

/*
KmipDeleteServer Method for KmipDeleteServer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiKmipDeleteServerRequest
*/
func (a *V2ApiService) KmipDeleteServer(ctx context.Context) ApiKmipDeleteServerRequest {
	return ApiKmipDeleteServerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) KmipDeleteServerExecute(r ApiKmipDeleteServerRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.KmipDeleteServer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kmip-delete-environment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKmipDescribeClientRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	kmipDescribeClient *KmipDescribeClient
    body interface{}
}

func (r ApiKmipDescribeClientRequest) KmipDescribeClient(kmipDescribeClient KmipDescribeClient) ApiKmipDescribeClientRequest {
	r.kmipDescribeClient = &kmipDescribeClient
	return r
}


    // Body sets the body payload for the API call.
func (r ApiKmipDescribeClientRequest) Body(body KmipDescribeClient) ApiKmipDescribeClientRequest {
    r.body = body
    return r
}

func (r ApiKmipDescribeClientRequest) Execute() (*KMIPClientGetResponse, *http.Response, error) {
	return r.ApiService.KmipDescribeClientExecute(r)
}

/*
KmipDescribeClient Method for KmipDescribeClient

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiKmipDescribeClientRequest
*/
func (a *V2ApiService) KmipDescribeClient(ctx context.Context) ApiKmipDescribeClientRequest {
	return ApiKmipDescribeClientRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KMIPClientGetResponse
func (a *V2ApiService) KmipDescribeClientExecute(r ApiKmipDescribeClientRequest) (*KMIPClientGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KMIPClientGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.KmipDescribeClient")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kmip-get-client"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKmipDescribeServerRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	kmipDescribeServer *KmipDescribeServer
    body interface{}
}

func (r ApiKmipDescribeServerRequest) KmipDescribeServer(kmipDescribeServer KmipDescribeServer) ApiKmipDescribeServerRequest {
	r.kmipDescribeServer = &kmipDescribeServer
	return r
}


    // Body sets the body payload for the API call.
func (r ApiKmipDescribeServerRequest) Body(body KmipDescribeServer) ApiKmipDescribeServerRequest {
    r.body = body
    return r
}

func (r ApiKmipDescribeServerRequest) Execute() (*KmipDescribeServerOutput, *http.Response, error) {
	return r.ApiService.KmipDescribeServerExecute(r)
}

/*
KmipDescribeServer Method for KmipDescribeServer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiKmipDescribeServerRequest
*/
func (a *V2ApiService) KmipDescribeServer(ctx context.Context) ApiKmipDescribeServerRequest {
	return ApiKmipDescribeServerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KmipDescribeServerOutput
func (a *V2ApiService) KmipDescribeServerExecute(r ApiKmipDescribeServerRequest) (*KmipDescribeServerOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KmipDescribeServerOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.KmipDescribeServer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kmip-get-environment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKmipListClientsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	kmipListClients *KmipListClients
    body interface{}
}

func (r ApiKmipListClientsRequest) KmipListClients(kmipListClients KmipListClients) ApiKmipListClientsRequest {
	r.kmipListClients = &kmipListClients
	return r
}


    // Body sets the body payload for the API call.
func (r ApiKmipListClientsRequest) Body(body KmipListClients) ApiKmipListClientsRequest {
    r.body = body
    return r
}

func (r ApiKmipListClientsRequest) Execute() (*KMIPClientListResponse, *http.Response, error) {
	return r.ApiService.KmipListClientsExecute(r)
}

/*
KmipListClients Method for KmipListClients

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiKmipListClientsRequest
*/
func (a *V2ApiService) KmipListClients(ctx context.Context) ApiKmipListClientsRequest {
	return ApiKmipListClientsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KMIPClientListResponse
func (a *V2ApiService) KmipListClientsExecute(r ApiKmipListClientsRequest) (*KMIPClientListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KMIPClientListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.KmipListClients")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kmip-list-clients"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKmipMoveServerRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	kmipMoveServer *KmipMoveServer
    body interface{}
}

func (r ApiKmipMoveServerRequest) KmipMoveServer(kmipMoveServer KmipMoveServer) ApiKmipMoveServerRequest {
	r.kmipMoveServer = &kmipMoveServer
	return r
}


    // Body sets the body payload for the API call.
func (r ApiKmipMoveServerRequest) Body(body KmipMoveServer) ApiKmipMoveServerRequest {
    r.body = body
    return r
}

func (r ApiKmipMoveServerRequest) Execute() (*KmipMoveServerOutput, *http.Response, error) {
	return r.ApiService.KmipMoveServerExecute(r)
}

/*
KmipMoveServer Method for KmipMoveServer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiKmipMoveServerRequest
*/
func (a *V2ApiService) KmipMoveServer(ctx context.Context) ApiKmipMoveServerRequest {
	return ApiKmipMoveServerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KmipMoveServerOutput
func (a *V2ApiService) KmipMoveServerExecute(r ApiKmipMoveServerRequest) (*KmipMoveServerOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KmipMoveServerOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.KmipMoveServer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kmip-move-environment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKmipRenewClientCertificateRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	kmipRenewClientCertificate *KmipRenewClientCertificate
    body interface{}
}

func (r ApiKmipRenewClientCertificateRequest) KmipRenewClientCertificate(kmipRenewClientCertificate KmipRenewClientCertificate) ApiKmipRenewClientCertificateRequest {
	r.kmipRenewClientCertificate = &kmipRenewClientCertificate
	return r
}


    // Body sets the body payload for the API call.
func (r ApiKmipRenewClientCertificateRequest) Body(body KmipRenewClientCertificate) ApiKmipRenewClientCertificateRequest {
    r.body = body
    return r
}

func (r ApiKmipRenewClientCertificateRequest) Execute() (*KmipRenewClientCertificateOutput, *http.Response, error) {
	return r.ApiService.KmipRenewClientCertificateExecute(r)
}

/*
KmipRenewClientCertificate Method for KmipRenewClientCertificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiKmipRenewClientCertificateRequest
*/
func (a *V2ApiService) KmipRenewClientCertificate(ctx context.Context) ApiKmipRenewClientCertificateRequest {
	return ApiKmipRenewClientCertificateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KmipRenewClientCertificateOutput
func (a *V2ApiService) KmipRenewClientCertificateExecute(r ApiKmipRenewClientCertificateRequest) (*KmipRenewClientCertificateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KmipRenewClientCertificateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.KmipRenewClientCertificate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kmip-renew-client"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKmipRenewServerCertificateRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	kmipRenewServerCertificate *KmipRenewServerCertificate
    body interface{}
}

func (r ApiKmipRenewServerCertificateRequest) KmipRenewServerCertificate(kmipRenewServerCertificate KmipRenewServerCertificate) ApiKmipRenewServerCertificateRequest {
	r.kmipRenewServerCertificate = &kmipRenewServerCertificate
	return r
}


    // Body sets the body payload for the API call.
func (r ApiKmipRenewServerCertificateRequest) Body(body KmipRenewServerCertificate) ApiKmipRenewServerCertificateRequest {
    r.body = body
    return r
}

func (r ApiKmipRenewServerCertificateRequest) Execute() (*KmipRenewServerCertificateOutput, *http.Response, error) {
	return r.ApiService.KmipRenewServerCertificateExecute(r)
}

/*
KmipRenewServerCertificate Method for KmipRenewServerCertificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiKmipRenewServerCertificateRequest
*/
func (a *V2ApiService) KmipRenewServerCertificate(ctx context.Context) ApiKmipRenewServerCertificateRequest {
	return ApiKmipRenewServerCertificateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KmipRenewServerCertificateOutput
func (a *V2ApiService) KmipRenewServerCertificateExecute(r ApiKmipRenewServerCertificateRequest) (*KmipRenewServerCertificateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KmipRenewServerCertificateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.KmipRenewServerCertificate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kmip-renew-environment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKmipServerSetupRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	kmipServerSetup *KmipServerSetup
    body interface{}
}

func (r ApiKmipServerSetupRequest) KmipServerSetup(kmipServerSetup KmipServerSetup) ApiKmipServerSetupRequest {
	r.kmipServerSetup = &kmipServerSetup
	return r
}


    // Body sets the body payload for the API call.
func (r ApiKmipServerSetupRequest) Body(body KmipServerSetup) ApiKmipServerSetupRequest {
    r.body = body
    return r
}

func (r ApiKmipServerSetupRequest) Execute() (*KMIPEnvironmentCreateResponse, *http.Response, error) {
	return r.ApiService.KmipServerSetupExecute(r)
}

/*
KmipServerSetup Method for KmipServerSetup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiKmipServerSetupRequest
*/
func (a *V2ApiService) KmipServerSetup(ctx context.Context) ApiKmipServerSetupRequest {
	return ApiKmipServerSetupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KMIPEnvironmentCreateResponse
func (a *V2ApiService) KmipServerSetupExecute(r ApiKmipServerSetupRequest) (*KMIPEnvironmentCreateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KMIPEnvironmentCreateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.KmipServerSetup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kmip-create-environment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKmipSetServerStateRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	kmipSetServerState *KmipSetServerState
    body interface{}
}

func (r ApiKmipSetServerStateRequest) KmipSetServerState(kmipSetServerState KmipSetServerState) ApiKmipSetServerStateRequest {
	r.kmipSetServerState = &kmipSetServerState
	return r
}


    // Body sets the body payload for the API call.
func (r ApiKmipSetServerStateRequest) Body(body KmipSetServerState) ApiKmipSetServerStateRequest {
    r.body = body
    return r
}

func (r ApiKmipSetServerStateRequest) Execute() (*KmipSetServerStateOutput, *http.Response, error) {
	return r.ApiService.KmipSetServerStateExecute(r)
}

/*
KmipSetServerState Method for KmipSetServerState

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiKmipSetServerStateRequest
*/
func (a *V2ApiService) KmipSetServerState(ctx context.Context) ApiKmipSetServerStateRequest {
	return ApiKmipSetServerStateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KmipSetServerStateOutput
func (a *V2ApiService) KmipSetServerStateExecute(r ApiKmipSetServerStateRequest) (*KmipSetServerStateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KmipSetServerStateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.KmipSetServerState")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kmip-set-environment-state"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKubeconfigGenerateRequest struct {
	ctx context.Context
	ApiService *V2ApiService
    body interface{}
}



func (r ApiKubeconfigGenerateRequest) Execute() (*KubeconfigGenerateOutput, *http.Response, error) {
	return r.ApiService.KubeconfigGenerateExecute(r)
}

/*
KubeconfigGenerate Method for KubeconfigGenerate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiKubeconfigGenerateRequest
*/
func (a *V2ApiService) KubeconfigGenerate(ctx context.Context) ApiKubeconfigGenerateRequest {
	return ApiKubeconfigGenerateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KubeconfigGenerateOutput
func (a *V2ApiService) KubeconfigGenerateExecute(r ApiKubeconfigGenerateRequest) (*KubeconfigGenerateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KubeconfigGenerateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.KubeconfigGenerate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kubeconfig-generate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAcmeAccountsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	listAcmeAccounts *ListAcmeAccounts
    body interface{}
}

func (r ApiListAcmeAccountsRequest) ListAcmeAccounts(listAcmeAccounts ListAcmeAccounts) ApiListAcmeAccountsRequest {
	r.listAcmeAccounts = &listAcmeAccounts
	return r
}


    // Body sets the body payload for the API call.
func (r ApiListAcmeAccountsRequest) Body(body ListAcmeAccounts) ApiListAcmeAccountsRequest {
    r.body = body
    return r
}

func (r ApiListAcmeAccountsRequest) Execute() (*ListAcmeAccountsOutput, *http.Response, error) {
	return r.ApiService.ListAcmeAccountsExecute(r)
}

/*
ListAcmeAccounts Method for ListAcmeAccounts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListAcmeAccountsRequest
*/
func (a *V2ApiService) ListAcmeAccounts(ctx context.Context) ApiListAcmeAccountsRequest {
	return ApiListAcmeAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListAcmeAccountsOutput
func (a *V2ApiService) ListAcmeAccountsExecute(r ApiListAcmeAccountsRequest) (*ListAcmeAccountsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAcmeAccountsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.ListAcmeAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/list-acme-accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAuthMethodsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	listAuthMethods *ListAuthMethods
    body interface{}
}

func (r ApiListAuthMethodsRequest) ListAuthMethods(listAuthMethods ListAuthMethods) ApiListAuthMethodsRequest {
	r.listAuthMethods = &listAuthMethods
	return r
}


    // Body sets the body payload for the API call.
func (r ApiListAuthMethodsRequest) Body(body ListAuthMethods) ApiListAuthMethodsRequest {
    r.body = body
    return r
}

func (r ApiListAuthMethodsRequest) Execute() (*ListAuthMethodsOutput, *http.Response, error) {
	return r.ApiService.ListAuthMethodsExecute(r)
}

/*
ListAuthMethods Method for ListAuthMethods

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListAuthMethodsRequest
*/
func (a *V2ApiService) ListAuthMethods(ctx context.Context) ApiListAuthMethodsRequest {
	return ApiListAuthMethodsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListAuthMethodsOutput
func (a *V2ApiService) ListAuthMethodsExecute(r ApiListAuthMethodsRequest) (*ListAuthMethodsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAuthMethodsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.ListAuthMethods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/list-auth-methods"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListGatewaysRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	listGateways *ListGateways
    body interface{}
}

func (r ApiListGatewaysRequest) ListGateways(listGateways ListGateways) ApiListGatewaysRequest {
	r.listGateways = &listGateways
	return r
}


    // Body sets the body payload for the API call.
func (r ApiListGatewaysRequest) Body(body ListGateways) ApiListGatewaysRequest {
    r.body = body
    return r
}

func (r ApiListGatewaysRequest) Execute() (*GatewaysListResponse, *http.Response, error) {
	return r.ApiService.ListGatewaysExecute(r)
}

/*
ListGateways Method for ListGateways

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListGatewaysRequest
*/
func (a *V2ApiService) ListGateways(ctx context.Context) ApiListGatewaysRequest {
	return ApiListGatewaysRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GatewaysListResponse
func (a *V2ApiService) ListGatewaysExecute(r ApiListGatewaysRequest) (*GatewaysListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewaysListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.ListGateways")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/list-gateways"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListGroupsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	listGroups *ListGroups
    body interface{}
}

func (r ApiListGroupsRequest) ListGroups(listGroups ListGroups) ApiListGroupsRequest {
	r.listGroups = &listGroups
	return r
}


    // Body sets the body payload for the API call.
func (r ApiListGroupsRequest) Body(body ListGroups) ApiListGroupsRequest {
    r.body = body
    return r
}

func (r ApiListGroupsRequest) Execute() (*ListGroupsOutput, *http.Response, error) {
	return r.ApiService.ListGroupsExecute(r)
}

/*
ListGroups Method for ListGroups

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListGroupsRequest
*/
func (a *V2ApiService) ListGroups(ctx context.Context) ApiListGroupsRequest {
	return ApiListGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListGroupsOutput
func (a *V2ApiService) ListGroupsExecute(r ApiListGroupsRequest) (*ListGroupsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListGroupsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.ListGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/list-group"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListItemsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	listItems *ListItems
    body interface{}
}

func (r ApiListItemsRequest) ListItems(listItems ListItems) ApiListItemsRequest {
	r.listItems = &listItems
	return r
}


    // Body sets the body payload for the API call.
func (r ApiListItemsRequest) Body(body ListItems) ApiListItemsRequest {
    r.body = body
    return r
}

func (r ApiListItemsRequest) Execute() (*ListItemsInPathOutput, *http.Response, error) {
	return r.ApiService.ListItemsExecute(r)
}

/*
ListItems Method for ListItems

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListItemsRequest
*/
func (a *V2ApiService) ListItems(ctx context.Context) ApiListItemsRequest {
	return ApiListItemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListItemsInPathOutput
func (a *V2ApiService) ListItemsExecute(r ApiListItemsRequest) (*ListItemsInPathOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListItemsInPathOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.ListItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/list-items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListRolesRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	listRoles *ListRoles
    body interface{}
}

func (r ApiListRolesRequest) ListRoles(listRoles ListRoles) ApiListRolesRequest {
	r.listRoles = &listRoles
	return r
}


    // Body sets the body payload for the API call.
func (r ApiListRolesRequest) Body(body ListRoles) ApiListRolesRequest {
    r.body = body
    return r
}

func (r ApiListRolesRequest) Execute() (*ListRolesOutput, *http.Response, error) {
	return r.ApiService.ListRolesExecute(r)
}

/*
ListRoles Method for ListRoles

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListRolesRequest
*/
func (a *V2ApiService) ListRoles(ctx context.Context) ApiListRolesRequest {
	return ApiListRolesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListRolesOutput
func (a *V2ApiService) ListRolesExecute(r ApiListRolesRequest) (*ListRolesOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListRolesOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.ListRoles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/list-roles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSRABastionsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	listSRABastions *ListSRABastions
    body interface{}
}

func (r ApiListSRABastionsRequest) ListSRABastions(listSRABastions ListSRABastions) ApiListSRABastionsRequest {
	r.listSRABastions = &listSRABastions
	return r
}


    // Body sets the body payload for the API call.
func (r ApiListSRABastionsRequest) Body(body ListSRABastions) ApiListSRABastionsRequest {
    r.body = body
    return r
}

func (r ApiListSRABastionsRequest) Execute() (*BastionsList, *http.Response, error) {
	return r.ApiService.ListSRABastionsExecute(r)
}

/*
ListSRABastions Method for ListSRABastions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListSRABastionsRequest
*/
func (a *V2ApiService) ListSRABastions(ctx context.Context) ApiListSRABastionsRequest {
	return ApiListSRABastionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BastionsList
func (a *V2ApiService) ListSRABastionsExecute(r ApiListSRABastionsRequest) (*BastionsList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BastionsList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.ListSRABastions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/list-sra-bastions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSRASessionsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	listSRASessions *ListSRASessions
    body interface{}
}

func (r ApiListSRASessionsRequest) ListSRASessions(listSRASessions ListSRASessions) ApiListSRASessionsRequest {
	r.listSRASessions = &listSRASessions
	return r
}


    // Body sets the body payload for the API call.
func (r ApiListSRASessionsRequest) Body(body ListSRASessions) ApiListSRASessionsRequest {
    r.body = body
    return r
}

func (r ApiListSRASessionsRequest) Execute() (*ListSraSessionsOutput, *http.Response, error) {
	return r.ApiService.ListSRASessionsExecute(r)
}

/*
ListSRASessions Method for ListSRASessions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListSRASessionsRequest
*/
func (a *V2ApiService) ListSRASessions(ctx context.Context) ApiListSRASessionsRequest {
	return ApiListSRASessionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListSraSessionsOutput
func (a *V2ApiService) ListSRASessionsExecute(r ApiListSRASessionsRequest) (*ListSraSessionsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListSraSessionsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.ListSRASessions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/list-sra-sessions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSharedItemsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	listSharedItems *ListSharedItems
    body interface{}
}

func (r ApiListSharedItemsRequest) ListSharedItems(listSharedItems ListSharedItems) ApiListSharedItemsRequest {
	r.listSharedItems = &listSharedItems
	return r
}


    // Body sets the body payload for the API call.
func (r ApiListSharedItemsRequest) Body(body ListSharedItems) ApiListSharedItemsRequest {
    r.body = body
    return r
}

func (r ApiListSharedItemsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ListSharedItemsExecute(r)
}

/*
ListSharedItems Method for ListSharedItems

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListSharedItemsRequest
*/
func (a *V2ApiService) ListSharedItems(ctx context.Context) ApiListSharedItemsRequest {
	return ApiListSharedItemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *V2ApiService) ListSharedItemsExecute(r ApiListSharedItemsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.ListSharedItems")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/list-shared-items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListTargetsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	listTargets *ListTargets
    body interface{}
}

func (r ApiListTargetsRequest) ListTargets(listTargets ListTargets) ApiListTargetsRequest {
	r.listTargets = &listTargets
	return r
}


    // Body sets the body payload for the API call.
func (r ApiListTargetsRequest) Body(body ListTargets) ApiListTargetsRequest {
    r.body = body
    return r
}

func (r ApiListTargetsRequest) Execute() (*ListTargetsOutput, *http.Response, error) {
	return r.ApiService.ListTargetsExecute(r)
}

/*
ListTargets Method for ListTargets

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListTargetsRequest
*/
func (a *V2ApiService) ListTargets(ctx context.Context) ApiListTargetsRequest {
	return ApiListTargetsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListTargetsOutput
func (a *V2ApiService) ListTargetsExecute(r ApiListTargetsRequest) (*ListTargetsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListTargetsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.ListTargets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/list-targets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoveObjectsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	moveObjects *MoveObjects
    body interface{}
}

func (r ApiMoveObjectsRequest) MoveObjects(moveObjects MoveObjects) ApiMoveObjectsRequest {
	r.moveObjects = &moveObjects
	return r
}


    // Body sets the body payload for the API call.
func (r ApiMoveObjectsRequest) Body(body MoveObjects) ApiMoveObjectsRequest {
    r.body = body
    return r
}

func (r ApiMoveObjectsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.MoveObjectsExecute(r)
}

/*
MoveObjects Method for MoveObjects

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMoveObjectsRequest
*/
func (a *V2ApiService) MoveObjects(ctx context.Context) ApiMoveObjectsRequest {
	return ApiMoveObjectsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) MoveObjectsExecute(r ApiMoveObjectsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.MoveObjects")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/move-objects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProvisionCertificateRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	provisionCertificate *ProvisionCertificate
    body interface{}
}

func (r ApiProvisionCertificateRequest) ProvisionCertificate(provisionCertificate ProvisionCertificate) ApiProvisionCertificateRequest {
	r.provisionCertificate = &provisionCertificate
	return r
}


    // Body sets the body payload for the API call.
func (r ApiProvisionCertificateRequest) Body(body ProvisionCertificate) ApiProvisionCertificateRequest {
    r.body = body
    return r
}

func (r ApiProvisionCertificateRequest) Execute() (*ProvisionCertificateOutput, *http.Response, error) {
	return r.ApiService.ProvisionCertificateExecute(r)
}

/*
ProvisionCertificate Method for ProvisionCertificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProvisionCertificateRequest
*/
func (a *V2ApiService) ProvisionCertificate(ctx context.Context) ApiProvisionCertificateRequest {
	return ApiProvisionCertificateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProvisionCertificateOutput
func (a *V2ApiService) ProvisionCertificateExecute(r ApiProvisionCertificateRequest) (*ProvisionCertificateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProvisionCertificateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.ProvisionCertificate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provision-certificate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRawCredsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rawCreds *RawCreds
    body interface{}
}

func (r ApiRawCredsRequest) RawCreds(rawCreds RawCreds) ApiRawCredsRequest {
	r.rawCreds = &rawCreds
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRawCredsRequest) Body(body RawCreds) ApiRawCredsRequest {
    r.body = body
    return r
}

func (r ApiRawCredsRequest) Execute() (*SystemAccessCredentialsReplyObj, *http.Response, error) {
	return r.ApiService.RawCredsExecute(r)
}

/*
RawCreds Method for RawCreds

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRawCredsRequest
*/
func (a *V2ApiService) RawCreds(ctx context.Context) ApiRawCredsRequest {
	return ApiRawCredsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SystemAccessCredentialsReplyObj
func (a *V2ApiService) RawCredsExecute(r ApiRawCredsRequest) (*SystemAccessCredentialsReplyObj, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SystemAccessCredentialsReplyObj
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RawCreds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/raw-creds"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRefreshKeyRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	refreshKey *RefreshKey
    body interface{}
}

func (r ApiRefreshKeyRequest) RefreshKey(refreshKey RefreshKey) ApiRefreshKeyRequest {
	r.refreshKey = &refreshKey
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRefreshKeyRequest) Body(body RefreshKey) ApiRefreshKeyRequest {
    r.body = body
    return r
}

func (r ApiRefreshKeyRequest) Execute() (*RefreshKeyOutput, *http.Response, error) {
	return r.ApiService.RefreshKeyExecute(r)
}

/*
RefreshKey Method for RefreshKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRefreshKeyRequest
*/
func (a *V2ApiService) RefreshKey(ctx context.Context) ApiRefreshKeyRequest {
	return ApiRefreshKeyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RefreshKeyOutput
func (a *V2ApiService) RefreshKeyExecute(r ApiRefreshKeyRequest) (*RefreshKeyOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RefreshKeyOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RefreshKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/refresh-key"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRenewCertificateRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	renewCertificate *RenewCertificate
    body interface{}
}

func (r ApiRenewCertificateRequest) RenewCertificate(renewCertificate RenewCertificate) ApiRenewCertificateRequest {
	r.renewCertificate = &renewCertificate
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRenewCertificateRequest) Body(body RenewCertificate) ApiRenewCertificateRequest {
    r.body = body
    return r
}

func (r ApiRenewCertificateRequest) Execute() (*RenewCertificateOutput, *http.Response, error) {
	return r.ApiService.RenewCertificateExecute(r)
}

/*
RenewCertificate Method for RenewCertificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRenewCertificateRequest
*/
func (a *V2ApiService) RenewCertificate(ctx context.Context) ApiRenewCertificateRequest {
	return ApiRenewCertificateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RenewCertificateOutput
func (a *V2ApiService) RenewCertificateExecute(r ApiRenewCertificateRequest) (*RenewCertificateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RenewCertificateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RenewCertificate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/renew-certificate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRequestAccessRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	requestAccess *RequestAccess
    body interface{}
}

func (r ApiRequestAccessRequest) RequestAccess(requestAccess RequestAccess) ApiRequestAccessRequest {
	r.requestAccess = &requestAccess
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRequestAccessRequest) Body(body RequestAccess) ApiRequestAccessRequest {
    r.body = body
    return r
}

func (r ApiRequestAccessRequest) Execute() (*RequestAccessOutput, *http.Response, error) {
	return r.ApiService.RequestAccessExecute(r)
}

/*
RequestAccess Method for RequestAccess

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRequestAccessRequest
*/
func (a *V2ApiService) RequestAccess(ctx context.Context) ApiRequestAccessRequest {
	return ApiRequestAccessRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RequestAccessOutput
func (a *V2ApiService) RequestAccessExecute(r ApiRequestAccessRequest) (*RequestAccessOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RequestAccessOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RequestAccess")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/request-access"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResetAccessKeyRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	resetAccessKey *ResetAccessKey
    body interface{}
}

func (r ApiResetAccessKeyRequest) ResetAccessKey(resetAccessKey ResetAccessKey) ApiResetAccessKeyRequest {
	r.resetAccessKey = &resetAccessKey
	return r
}


    // Body sets the body payload for the API call.
func (r ApiResetAccessKeyRequest) Body(body ResetAccessKey) ApiResetAccessKeyRequest {
    r.body = body
    return r
}

func (r ApiResetAccessKeyRequest) Execute() (*ResetAuthMethodAccessKeyOutput, *http.Response, error) {
	return r.ApiService.ResetAccessKeyExecute(r)
}

/*
ResetAccessKey Method for ResetAccessKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiResetAccessKeyRequest
*/
func (a *V2ApiService) ResetAccessKey(ctx context.Context) ApiResetAccessKeyRequest {
	return ApiResetAccessKeyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResetAuthMethodAccessKeyOutput
func (a *V2ApiService) ResetAccessKeyExecute(r ApiResetAccessKeyRequest) (*ResetAuthMethodAccessKeyOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResetAuthMethodAccessKeyOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.ResetAccessKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/reset-access-key"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReverseRBACRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	reverseRBAC *ReverseRBAC
    body interface{}
}

func (r ApiReverseRBACRequest) ReverseRBAC(reverseRBAC ReverseRBAC) ApiReverseRBACRequest {
	r.reverseRBAC = &reverseRBAC
	return r
}


    // Body sets the body payload for the API call.
func (r ApiReverseRBACRequest) Body(body ReverseRBAC) ApiReverseRBACRequest {
    r.body = body
    return r
}

func (r ApiReverseRBACRequest) Execute() (*ReverseRBACOutput, *http.Response, error) {
	return r.ApiService.ReverseRBACExecute(r)
}

/*
ReverseRBAC Method for ReverseRBAC

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReverseRBACRequest
*/
func (a *V2ApiService) ReverseRBAC(ctx context.Context) ApiReverseRBACRequest {
	return ApiReverseRBACRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReverseRBACOutput
func (a *V2ApiService) ReverseRBACExecute(r ApiReverseRBACRequest) (*ReverseRBACOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReverseRBACOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.ReverseRBAC")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/reverse-rbac"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRevokeCertificateRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	revokeCertificate *RevokeCertificate
    body interface{}
}

func (r ApiRevokeCertificateRequest) RevokeCertificate(revokeCertificate RevokeCertificate) ApiRevokeCertificateRequest {
	r.revokeCertificate = &revokeCertificate
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRevokeCertificateRequest) Body(body RevokeCertificate) ApiRevokeCertificateRequest {
    r.body = body
    return r
}

func (r ApiRevokeCertificateRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.RevokeCertificateExecute(r)
}

/*
RevokeCertificate Method for RevokeCertificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRevokeCertificateRequest
*/
func (a *V2ApiService) RevokeCertificate(ctx context.Context) ApiRevokeCertificateRequest {
	return ApiRevokeCertificateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) RevokeCertificateExecute(r ApiRevokeCertificateRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RevokeCertificate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revoke-certificate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRevokeCredsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
    body interface{}
}



func (r ApiRevokeCredsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.RevokeCredsExecute(r)
}

/*
RevokeCreds Method for RevokeCreds

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRevokeCredsRequest
*/
func (a *V2ApiService) RevokeCreds(ctx context.Context) ApiRevokeCredsRequest {
	return ApiRevokeCredsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) RevokeCredsExecute(r ApiRevokeCredsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RevokeCreds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revoke-creds"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRollbackSecretRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rollbackSecret *RollbackSecret
    body interface{}
}

func (r ApiRollbackSecretRequest) RollbackSecret(rollbackSecret RollbackSecret) ApiRollbackSecretRequest {
	r.rollbackSecret = &rollbackSecret
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRollbackSecretRequest) Body(body RollbackSecret) ApiRollbackSecretRequest {
    r.body = body
    return r
}

func (r ApiRollbackSecretRequest) Execute() (*RollbackSecretOutput, *http.Response, error) {
	return r.ApiService.RollbackSecretExecute(r)
}

/*
RollbackSecret Method for RollbackSecret

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRollbackSecretRequest
*/
func (a *V2ApiService) RollbackSecret(ctx context.Context) ApiRollbackSecretRequest {
	return ApiRollbackSecretRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RollbackSecretOutput
func (a *V2ApiService) RollbackSecretExecute(r ApiRollbackSecretRequest) (*RollbackSecretOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RollbackSecretOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RollbackSecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rollback-secret"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotateKeyRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotateKey *RotateKey
    body interface{}
}

func (r ApiRotateKeyRequest) RotateKey(rotateKey RotateKey) ApiRotateKeyRequest {
	r.rotateKey = &rotateKey
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotateKeyRequest) Body(body RotateKey) ApiRotateKeyRequest {
    r.body = body
    return r
}

func (r ApiRotateKeyRequest) Execute() (*RotateKeyOutput, *http.Response, error) {
	return r.ApiService.RotateKeyExecute(r)
}

/*
RotateKey Method for RotateKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotateKeyRequest
*/
func (a *V2ApiService) RotateKey(ctx context.Context) ApiRotateKeyRequest {
	return ApiRotateKeyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotateKeyOutput
func (a *V2ApiService) RotateKeyExecute(r ApiRotateKeyRequest) (*RotateKeyOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotateKeyOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotateKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotate-key"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotateOidcClientSecretRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotateOidcClientSecret *RotateOidcClientSecret
    body interface{}
}

func (r ApiRotateOidcClientSecretRequest) RotateOidcClientSecret(rotateOidcClientSecret RotateOidcClientSecret) ApiRotateOidcClientSecretRequest {
	r.rotateOidcClientSecret = &rotateOidcClientSecret
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotateOidcClientSecretRequest) Body(body RotateOidcClientSecret) ApiRotateOidcClientSecretRequest {
    r.body = body
    return r
}

func (r ApiRotateOidcClientSecretRequest) Execute() (*RotateOidcClientOutput, *http.Response, error) {
	return r.ApiService.RotateOidcClientSecretExecute(r)
}

/*
RotateOidcClientSecret Method for RotateOidcClientSecret

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotateOidcClientSecretRequest
*/
func (a *V2ApiService) RotateOidcClientSecret(ctx context.Context) ApiRotateOidcClientSecretRequest {
	return ApiRotateOidcClientSecretRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotateOidcClientOutput
func (a *V2ApiService) RotateOidcClientSecretExecute(r ApiRotateOidcClientSecretRequest) (*RotateOidcClientOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotateOidcClientOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotateOidcClientSecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotate-oidc-client-secret"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotateSecretRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotateSecret *RotateSecret
    body interface{}
}

func (r ApiRotateSecretRequest) RotateSecret(rotateSecret RotateSecret) ApiRotateSecretRequest {
	r.rotateSecret = &rotateSecret
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotateSecretRequest) Body(body RotateSecret) ApiRotateSecretRequest {
    r.body = body
    return r
}

func (r ApiRotateSecretRequest) Execute() (*RotatedSecretOutput, *http.Response, error) {
	return r.ApiService.RotateSecretExecute(r)
}

/*
RotateSecret Method for RotateSecret

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotateSecretRequest
*/
func (a *V2ApiService) RotateSecret(ctx context.Context) ApiRotateSecretRequest {
	return ApiRotateSecretRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretOutput
func (a *V2ApiService) RotateSecretExecute(r ApiRotateSecretRequest) (*RotatedSecretOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotateSecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateway-rotate-secret"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretCreateAwsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretCreateAws *RotatedSecretCreateAws
    body interface{}
}

func (r ApiRotatedSecretCreateAwsRequest) RotatedSecretCreateAws(rotatedSecretCreateAws RotatedSecretCreateAws) ApiRotatedSecretCreateAwsRequest {
	r.rotatedSecretCreateAws = &rotatedSecretCreateAws
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretCreateAwsRequest) Body(body RotatedSecretCreateAws) ApiRotatedSecretCreateAwsRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretCreateAwsRequest) Execute() (*RotatedSecretCreateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretCreateAwsExecute(r)
}

/*
RotatedSecretCreateAws Method for RotatedSecretCreateAws

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretCreateAwsRequest
*/
func (a *V2ApiService) RotatedSecretCreateAws(ctx context.Context) ApiRotatedSecretCreateAwsRequest {
	return ApiRotatedSecretCreateAwsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretCreateOutput
func (a *V2ApiService) RotatedSecretCreateAwsExecute(r ApiRotatedSecretCreateAwsRequest) (*RotatedSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretCreateAws")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-create-aws"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretCreateAzureRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretCreateAzure *RotatedSecretCreateAzure
    body interface{}
}

func (r ApiRotatedSecretCreateAzureRequest) RotatedSecretCreateAzure(rotatedSecretCreateAzure RotatedSecretCreateAzure) ApiRotatedSecretCreateAzureRequest {
	r.rotatedSecretCreateAzure = &rotatedSecretCreateAzure
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretCreateAzureRequest) Body(body RotatedSecretCreateAzure) ApiRotatedSecretCreateAzureRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretCreateAzureRequest) Execute() (*RotatedSecretCreateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretCreateAzureExecute(r)
}

/*
RotatedSecretCreateAzure Method for RotatedSecretCreateAzure

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretCreateAzureRequest
*/
func (a *V2ApiService) RotatedSecretCreateAzure(ctx context.Context) ApiRotatedSecretCreateAzureRequest {
	return ApiRotatedSecretCreateAzureRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretCreateOutput
func (a *V2ApiService) RotatedSecretCreateAzureExecute(r ApiRotatedSecretCreateAzureRequest) (*RotatedSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretCreateAzure")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-create-azure"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretCreateCassandraRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretCreateCassandra *RotatedSecretCreateCassandra
    body interface{}
}

func (r ApiRotatedSecretCreateCassandraRequest) RotatedSecretCreateCassandra(rotatedSecretCreateCassandra RotatedSecretCreateCassandra) ApiRotatedSecretCreateCassandraRequest {
	r.rotatedSecretCreateCassandra = &rotatedSecretCreateCassandra
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretCreateCassandraRequest) Body(body RotatedSecretCreateCassandra) ApiRotatedSecretCreateCassandraRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretCreateCassandraRequest) Execute() (*RotatedSecretCreateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretCreateCassandraExecute(r)
}

/*
RotatedSecretCreateCassandra Method for RotatedSecretCreateCassandra

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretCreateCassandraRequest
*/
func (a *V2ApiService) RotatedSecretCreateCassandra(ctx context.Context) ApiRotatedSecretCreateCassandraRequest {
	return ApiRotatedSecretCreateCassandraRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretCreateOutput
func (a *V2ApiService) RotatedSecretCreateCassandraExecute(r ApiRotatedSecretCreateCassandraRequest) (*RotatedSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretCreateCassandra")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-create-cassandra"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretCreateCustomRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretCreateCustom *RotatedSecretCreateCustom
    body interface{}
}

func (r ApiRotatedSecretCreateCustomRequest) RotatedSecretCreateCustom(rotatedSecretCreateCustom RotatedSecretCreateCustom) ApiRotatedSecretCreateCustomRequest {
	r.rotatedSecretCreateCustom = &rotatedSecretCreateCustom
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretCreateCustomRequest) Body(body RotatedSecretCreateCustom) ApiRotatedSecretCreateCustomRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretCreateCustomRequest) Execute() (*RotatedSecretCreateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretCreateCustomExecute(r)
}

/*
RotatedSecretCreateCustom Method for RotatedSecretCreateCustom

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretCreateCustomRequest
*/
func (a *V2ApiService) RotatedSecretCreateCustom(ctx context.Context) ApiRotatedSecretCreateCustomRequest {
	return ApiRotatedSecretCreateCustomRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretCreateOutput
func (a *V2ApiService) RotatedSecretCreateCustomExecute(r ApiRotatedSecretCreateCustomRequest) (*RotatedSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretCreateCustom")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-create-custom"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretCreateDockerhubRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretCreateDockerhub *RotatedSecretCreateDockerhub
    body interface{}
}

func (r ApiRotatedSecretCreateDockerhubRequest) RotatedSecretCreateDockerhub(rotatedSecretCreateDockerhub RotatedSecretCreateDockerhub) ApiRotatedSecretCreateDockerhubRequest {
	r.rotatedSecretCreateDockerhub = &rotatedSecretCreateDockerhub
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretCreateDockerhubRequest) Body(body RotatedSecretCreateDockerhub) ApiRotatedSecretCreateDockerhubRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretCreateDockerhubRequest) Execute() (*RotatedSecretCreateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretCreateDockerhubExecute(r)
}

/*
RotatedSecretCreateDockerhub Method for RotatedSecretCreateDockerhub

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretCreateDockerhubRequest
*/
func (a *V2ApiService) RotatedSecretCreateDockerhub(ctx context.Context) ApiRotatedSecretCreateDockerhubRequest {
	return ApiRotatedSecretCreateDockerhubRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretCreateOutput
func (a *V2ApiService) RotatedSecretCreateDockerhubExecute(r ApiRotatedSecretCreateDockerhubRequest) (*RotatedSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretCreateDockerhub")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-create-dockerhub"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretCreateGcpRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretCreateGcp *RotatedSecretCreateGcp
    body interface{}
}

func (r ApiRotatedSecretCreateGcpRequest) RotatedSecretCreateGcp(rotatedSecretCreateGcp RotatedSecretCreateGcp) ApiRotatedSecretCreateGcpRequest {
	r.rotatedSecretCreateGcp = &rotatedSecretCreateGcp
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretCreateGcpRequest) Body(body RotatedSecretCreateGcp) ApiRotatedSecretCreateGcpRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretCreateGcpRequest) Execute() (*RotatedSecretCreateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretCreateGcpExecute(r)
}

/*
RotatedSecretCreateGcp Method for RotatedSecretCreateGcp

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretCreateGcpRequest
*/
func (a *V2ApiService) RotatedSecretCreateGcp(ctx context.Context) ApiRotatedSecretCreateGcpRequest {
	return ApiRotatedSecretCreateGcpRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretCreateOutput
func (a *V2ApiService) RotatedSecretCreateGcpExecute(r ApiRotatedSecretCreateGcpRequest) (*RotatedSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretCreateGcp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-create-gcp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretCreateHanadbRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretCreateHanadb *RotatedSecretCreateHanadb
    body interface{}
}

func (r ApiRotatedSecretCreateHanadbRequest) RotatedSecretCreateHanadb(rotatedSecretCreateHanadb RotatedSecretCreateHanadb) ApiRotatedSecretCreateHanadbRequest {
	r.rotatedSecretCreateHanadb = &rotatedSecretCreateHanadb
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretCreateHanadbRequest) Body(body RotatedSecretCreateHanadb) ApiRotatedSecretCreateHanadbRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretCreateHanadbRequest) Execute() (*RotatedSecretCreateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretCreateHanadbExecute(r)
}

/*
RotatedSecretCreateHanadb Method for RotatedSecretCreateHanadb

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretCreateHanadbRequest
*/
func (a *V2ApiService) RotatedSecretCreateHanadb(ctx context.Context) ApiRotatedSecretCreateHanadbRequest {
	return ApiRotatedSecretCreateHanadbRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretCreateOutput
func (a *V2ApiService) RotatedSecretCreateHanadbExecute(r ApiRotatedSecretCreateHanadbRequest) (*RotatedSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretCreateHanadb")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-create-hanadb"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretCreateLdapRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretCreateLdap *RotatedSecretCreateLdap
    body interface{}
}

func (r ApiRotatedSecretCreateLdapRequest) RotatedSecretCreateLdap(rotatedSecretCreateLdap RotatedSecretCreateLdap) ApiRotatedSecretCreateLdapRequest {
	r.rotatedSecretCreateLdap = &rotatedSecretCreateLdap
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretCreateLdapRequest) Body(body RotatedSecretCreateLdap) ApiRotatedSecretCreateLdapRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretCreateLdapRequest) Execute() (*RotatedSecretCreateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretCreateLdapExecute(r)
}

/*
RotatedSecretCreateLdap Method for RotatedSecretCreateLdap

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretCreateLdapRequest
*/
func (a *V2ApiService) RotatedSecretCreateLdap(ctx context.Context) ApiRotatedSecretCreateLdapRequest {
	return ApiRotatedSecretCreateLdapRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretCreateOutput
func (a *V2ApiService) RotatedSecretCreateLdapExecute(r ApiRotatedSecretCreateLdapRequest) (*RotatedSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretCreateLdap")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-create-ldap"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretCreateMongodbRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretCreateMongodb *RotatedSecretCreateMongodb
    body interface{}
}

func (r ApiRotatedSecretCreateMongodbRequest) RotatedSecretCreateMongodb(rotatedSecretCreateMongodb RotatedSecretCreateMongodb) ApiRotatedSecretCreateMongodbRequest {
	r.rotatedSecretCreateMongodb = &rotatedSecretCreateMongodb
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretCreateMongodbRequest) Body(body RotatedSecretCreateMongodb) ApiRotatedSecretCreateMongodbRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretCreateMongodbRequest) Execute() (*RotatedSecretCreateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretCreateMongodbExecute(r)
}

/*
RotatedSecretCreateMongodb Method for RotatedSecretCreateMongodb

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretCreateMongodbRequest
*/
func (a *V2ApiService) RotatedSecretCreateMongodb(ctx context.Context) ApiRotatedSecretCreateMongodbRequest {
	return ApiRotatedSecretCreateMongodbRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretCreateOutput
func (a *V2ApiService) RotatedSecretCreateMongodbExecute(r ApiRotatedSecretCreateMongodbRequest) (*RotatedSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretCreateMongodb")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-create-mongodb"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretCreateMssqlRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretCreateMssql *RotatedSecretCreateMssql
    body interface{}
}

func (r ApiRotatedSecretCreateMssqlRequest) RotatedSecretCreateMssql(rotatedSecretCreateMssql RotatedSecretCreateMssql) ApiRotatedSecretCreateMssqlRequest {
	r.rotatedSecretCreateMssql = &rotatedSecretCreateMssql
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretCreateMssqlRequest) Body(body RotatedSecretCreateMssql) ApiRotatedSecretCreateMssqlRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretCreateMssqlRequest) Execute() (*RotatedSecretCreateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretCreateMssqlExecute(r)
}

/*
RotatedSecretCreateMssql Method for RotatedSecretCreateMssql

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretCreateMssqlRequest
*/
func (a *V2ApiService) RotatedSecretCreateMssql(ctx context.Context) ApiRotatedSecretCreateMssqlRequest {
	return ApiRotatedSecretCreateMssqlRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretCreateOutput
func (a *V2ApiService) RotatedSecretCreateMssqlExecute(r ApiRotatedSecretCreateMssqlRequest) (*RotatedSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretCreateMssql")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-create-mssql"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretCreateMysqlRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretCreateMysql *RotatedSecretCreateMysql
    body interface{}
}

func (r ApiRotatedSecretCreateMysqlRequest) RotatedSecretCreateMysql(rotatedSecretCreateMysql RotatedSecretCreateMysql) ApiRotatedSecretCreateMysqlRequest {
	r.rotatedSecretCreateMysql = &rotatedSecretCreateMysql
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretCreateMysqlRequest) Body(body RotatedSecretCreateMysql) ApiRotatedSecretCreateMysqlRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretCreateMysqlRequest) Execute() (*RotatedSecretCreateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretCreateMysqlExecute(r)
}

/*
RotatedSecretCreateMysql Method for RotatedSecretCreateMysql

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretCreateMysqlRequest
*/
func (a *V2ApiService) RotatedSecretCreateMysql(ctx context.Context) ApiRotatedSecretCreateMysqlRequest {
	return ApiRotatedSecretCreateMysqlRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretCreateOutput
func (a *V2ApiService) RotatedSecretCreateMysqlExecute(r ApiRotatedSecretCreateMysqlRequest) (*RotatedSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretCreateMysql")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-create-mysql"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretCreateOracledbRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretCreateOracledb *RotatedSecretCreateOracledb
    body interface{}
}

func (r ApiRotatedSecretCreateOracledbRequest) RotatedSecretCreateOracledb(rotatedSecretCreateOracledb RotatedSecretCreateOracledb) ApiRotatedSecretCreateOracledbRequest {
	r.rotatedSecretCreateOracledb = &rotatedSecretCreateOracledb
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretCreateOracledbRequest) Body(body RotatedSecretCreateOracledb) ApiRotatedSecretCreateOracledbRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretCreateOracledbRequest) Execute() (*RotatedSecretCreateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretCreateOracledbExecute(r)
}

/*
RotatedSecretCreateOracledb Method for RotatedSecretCreateOracledb

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretCreateOracledbRequest
*/
func (a *V2ApiService) RotatedSecretCreateOracledb(ctx context.Context) ApiRotatedSecretCreateOracledbRequest {
	return ApiRotatedSecretCreateOracledbRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretCreateOutput
func (a *V2ApiService) RotatedSecretCreateOracledbExecute(r ApiRotatedSecretCreateOracledbRequest) (*RotatedSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretCreateOracledb")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-create-oracledb"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretCreatePostgresqlRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretCreatePostgresql *RotatedSecretCreatePostgresql
    body interface{}
}

func (r ApiRotatedSecretCreatePostgresqlRequest) RotatedSecretCreatePostgresql(rotatedSecretCreatePostgresql RotatedSecretCreatePostgresql) ApiRotatedSecretCreatePostgresqlRequest {
	r.rotatedSecretCreatePostgresql = &rotatedSecretCreatePostgresql
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretCreatePostgresqlRequest) Body(body RotatedSecretCreatePostgresql) ApiRotatedSecretCreatePostgresqlRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretCreatePostgresqlRequest) Execute() (*RotatedSecretCreateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretCreatePostgresqlExecute(r)
}

/*
RotatedSecretCreatePostgresql Method for RotatedSecretCreatePostgresql

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretCreatePostgresqlRequest
*/
func (a *V2ApiService) RotatedSecretCreatePostgresql(ctx context.Context) ApiRotatedSecretCreatePostgresqlRequest {
	return ApiRotatedSecretCreatePostgresqlRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretCreateOutput
func (a *V2ApiService) RotatedSecretCreatePostgresqlExecute(r ApiRotatedSecretCreatePostgresqlRequest) (*RotatedSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretCreatePostgresql")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-create-postgresql"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretCreateRedisRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretCreateRedis *RotatedSecretCreateRedis
    body interface{}
}

func (r ApiRotatedSecretCreateRedisRequest) RotatedSecretCreateRedis(rotatedSecretCreateRedis RotatedSecretCreateRedis) ApiRotatedSecretCreateRedisRequest {
	r.rotatedSecretCreateRedis = &rotatedSecretCreateRedis
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretCreateRedisRequest) Body(body RotatedSecretCreateRedis) ApiRotatedSecretCreateRedisRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretCreateRedisRequest) Execute() (*RotatedSecretCreateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretCreateRedisExecute(r)
}

/*
RotatedSecretCreateRedis Method for RotatedSecretCreateRedis

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretCreateRedisRequest
*/
func (a *V2ApiService) RotatedSecretCreateRedis(ctx context.Context) ApiRotatedSecretCreateRedisRequest {
	return ApiRotatedSecretCreateRedisRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretCreateOutput
func (a *V2ApiService) RotatedSecretCreateRedisExecute(r ApiRotatedSecretCreateRedisRequest) (*RotatedSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretCreateRedis")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-create-redis"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretCreateRedshiftRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretCreateRedshift *RotatedSecretCreateRedshift
    body interface{}
}

func (r ApiRotatedSecretCreateRedshiftRequest) RotatedSecretCreateRedshift(rotatedSecretCreateRedshift RotatedSecretCreateRedshift) ApiRotatedSecretCreateRedshiftRequest {
	r.rotatedSecretCreateRedshift = &rotatedSecretCreateRedshift
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretCreateRedshiftRequest) Body(body RotatedSecretCreateRedshift) ApiRotatedSecretCreateRedshiftRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretCreateRedshiftRequest) Execute() (*RotatedSecretCreateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretCreateRedshiftExecute(r)
}

/*
RotatedSecretCreateRedshift Method for RotatedSecretCreateRedshift

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretCreateRedshiftRequest
*/
func (a *V2ApiService) RotatedSecretCreateRedshift(ctx context.Context) ApiRotatedSecretCreateRedshiftRequest {
	return ApiRotatedSecretCreateRedshiftRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretCreateOutput
func (a *V2ApiService) RotatedSecretCreateRedshiftExecute(r ApiRotatedSecretCreateRedshiftRequest) (*RotatedSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretCreateRedshift")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-create-redshift"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretCreateSnowflakeRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretCreateSnowflake *RotatedSecretCreateSnowflake
    body interface{}
}

func (r ApiRotatedSecretCreateSnowflakeRequest) RotatedSecretCreateSnowflake(rotatedSecretCreateSnowflake RotatedSecretCreateSnowflake) ApiRotatedSecretCreateSnowflakeRequest {
	r.rotatedSecretCreateSnowflake = &rotatedSecretCreateSnowflake
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretCreateSnowflakeRequest) Body(body RotatedSecretCreateSnowflake) ApiRotatedSecretCreateSnowflakeRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretCreateSnowflakeRequest) Execute() (*RotatedSecretCreateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretCreateSnowflakeExecute(r)
}

/*
RotatedSecretCreateSnowflake Method for RotatedSecretCreateSnowflake

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretCreateSnowflakeRequest
*/
func (a *V2ApiService) RotatedSecretCreateSnowflake(ctx context.Context) ApiRotatedSecretCreateSnowflakeRequest {
	return ApiRotatedSecretCreateSnowflakeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretCreateOutput
func (a *V2ApiService) RotatedSecretCreateSnowflakeExecute(r ApiRotatedSecretCreateSnowflakeRequest) (*RotatedSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretCreateSnowflake")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-create-snowflake"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretCreateSshRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretCreateSsh *RotatedSecretCreateSsh
    body interface{}
}

func (r ApiRotatedSecretCreateSshRequest) RotatedSecretCreateSsh(rotatedSecretCreateSsh RotatedSecretCreateSsh) ApiRotatedSecretCreateSshRequest {
	r.rotatedSecretCreateSsh = &rotatedSecretCreateSsh
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretCreateSshRequest) Body(body RotatedSecretCreateSsh) ApiRotatedSecretCreateSshRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretCreateSshRequest) Execute() (*RotatedSecretCreateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretCreateSshExecute(r)
}

/*
RotatedSecretCreateSsh Method for RotatedSecretCreateSsh

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretCreateSshRequest
*/
func (a *V2ApiService) RotatedSecretCreateSsh(ctx context.Context) ApiRotatedSecretCreateSshRequest {
	return ApiRotatedSecretCreateSshRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretCreateOutput
func (a *V2ApiService) RotatedSecretCreateSshExecute(r ApiRotatedSecretCreateSshRequest) (*RotatedSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretCreateSsh")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-create-ssh"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretCreateWindowsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretCreateWindows *RotatedSecretCreateWindows
    body interface{}
}

func (r ApiRotatedSecretCreateWindowsRequest) RotatedSecretCreateWindows(rotatedSecretCreateWindows RotatedSecretCreateWindows) ApiRotatedSecretCreateWindowsRequest {
	r.rotatedSecretCreateWindows = &rotatedSecretCreateWindows
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretCreateWindowsRequest) Body(body RotatedSecretCreateWindows) ApiRotatedSecretCreateWindowsRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretCreateWindowsRequest) Execute() (*RotatedSecretCreateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretCreateWindowsExecute(r)
}

/*
RotatedSecretCreateWindows Method for RotatedSecretCreateWindows

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretCreateWindowsRequest
*/
func (a *V2ApiService) RotatedSecretCreateWindows(ctx context.Context) ApiRotatedSecretCreateWindowsRequest {
	return ApiRotatedSecretCreateWindowsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretCreateOutput
func (a *V2ApiService) RotatedSecretCreateWindowsExecute(r ApiRotatedSecretCreateWindowsRequest) (*RotatedSecretCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretCreateWindows")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-create-windows"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretDeleteRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretDelete *RotatedSecretDelete
    body interface{}
}

func (r ApiRotatedSecretDeleteRequest) RotatedSecretDelete(rotatedSecretDelete RotatedSecretDelete) ApiRotatedSecretDeleteRequest {
	r.rotatedSecretDelete = &rotatedSecretDelete
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretDeleteRequest) Body(body RotatedSecretDelete) ApiRotatedSecretDeleteRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretDeleteRequest) Execute() (*DeleteItemOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretDeleteExecute(r)
}

/*
RotatedSecretDelete Method for RotatedSecretDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretDeleteRequest
*/
func (a *V2ApiService) RotatedSecretDelete(ctx context.Context) ApiRotatedSecretDeleteRequest {
	return ApiRotatedSecretDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeleteItemOutput
func (a *V2ApiService) RotatedSecretDeleteExecute(r ApiRotatedSecretDeleteRequest) (*DeleteItemOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteItemOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretDeleteSyncRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretDeleteSync *RotatedSecretDeleteSync
    body interface{}
}

func (r ApiRotatedSecretDeleteSyncRequest) RotatedSecretDeleteSync(rotatedSecretDeleteSync RotatedSecretDeleteSync) ApiRotatedSecretDeleteSyncRequest {
	r.rotatedSecretDeleteSync = &rotatedSecretDeleteSync
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretDeleteSyncRequest) Body(body RotatedSecretDeleteSync) ApiRotatedSecretDeleteSyncRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretDeleteSyncRequest) Execute() (*RotatedSecretDeleteSyncOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretDeleteSyncExecute(r)
}

/*
RotatedSecretDeleteSync Method for RotatedSecretDeleteSync

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretDeleteSyncRequest
*/
func (a *V2ApiService) RotatedSecretDeleteSync(ctx context.Context) ApiRotatedSecretDeleteSyncRequest {
	return ApiRotatedSecretDeleteSyncRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretDeleteSyncOutput
func (a *V2ApiService) RotatedSecretDeleteSyncExecute(r ApiRotatedSecretDeleteSyncRequest) (*RotatedSecretDeleteSyncOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretDeleteSyncOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretDeleteSync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-delete-sync"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretGetValueRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretGetValue *RotatedSecretGetValue
    body interface{}
}

func (r ApiRotatedSecretGetValueRequest) RotatedSecretGetValue(rotatedSecretGetValue RotatedSecretGetValue) ApiRotatedSecretGetValueRequest {
	r.rotatedSecretGetValue = &rotatedSecretGetValue
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretGetValueRequest) Body(body RotatedSecretGetValue) ApiRotatedSecretGetValueRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretGetValueRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.RotatedSecretGetValueExecute(r)
}

/*
RotatedSecretGetValue Method for RotatedSecretGetValue

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretGetValueRequest
*/
func (a *V2ApiService) RotatedSecretGetValue(ctx context.Context) ApiRotatedSecretGetValueRequest {
	return ApiRotatedSecretGetValueRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) RotatedSecretGetValueExecute(r ApiRotatedSecretGetValueRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretGetValue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-get-value"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretListRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretList *RotatedSecretList
    body interface{}
}

func (r ApiRotatedSecretListRequest) RotatedSecretList(rotatedSecretList RotatedSecretList) ApiRotatedSecretListRequest {
	r.rotatedSecretList = &rotatedSecretList
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretListRequest) Body(body RotatedSecretList) ApiRotatedSecretListRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretListRequest) Execute() (*GetProducersListReplyObj, *http.Response, error) {
	return r.ApiService.RotatedSecretListExecute(r)
}

/*
RotatedSecretList Method for RotatedSecretList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretListRequest
*/
func (a *V2ApiService) RotatedSecretList(ctx context.Context) ApiRotatedSecretListRequest {
	return ApiRotatedSecretListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetProducersListReplyObj
func (a *V2ApiService) RotatedSecretListExecute(r ApiRotatedSecretListRequest) (*GetProducersListReplyObj, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetProducersListReplyObj
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretSyncRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretSync *RotatedSecretSync
    body interface{}
}

func (r ApiRotatedSecretSyncRequest) RotatedSecretSync(rotatedSecretSync RotatedSecretSync) ApiRotatedSecretSyncRequest {
	r.rotatedSecretSync = &rotatedSecretSync
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretSyncRequest) Body(body RotatedSecretSync) ApiRotatedSecretSyncRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretSyncRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.RotatedSecretSyncExecute(r)
}

/*
RotatedSecretSync Method for RotatedSecretSync

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretSyncRequest
*/
func (a *V2ApiService) RotatedSecretSync(ctx context.Context) ApiRotatedSecretSyncRequest {
	return ApiRotatedSecretSyncRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) RotatedSecretSyncExecute(r ApiRotatedSecretSyncRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretSync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-sync"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretUpdateAwsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretUpdateAws *RotatedSecretUpdateAws
    body interface{}
}

func (r ApiRotatedSecretUpdateAwsRequest) RotatedSecretUpdateAws(rotatedSecretUpdateAws RotatedSecretUpdateAws) ApiRotatedSecretUpdateAwsRequest {
	r.rotatedSecretUpdateAws = &rotatedSecretUpdateAws
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretUpdateAwsRequest) Body(body RotatedSecretUpdateAws) ApiRotatedSecretUpdateAwsRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretUpdateAwsRequest) Execute() (*RotatedSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretUpdateAwsExecute(r)
}

/*
RotatedSecretUpdateAws Method for RotatedSecretUpdateAws

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretUpdateAwsRequest
*/
func (a *V2ApiService) RotatedSecretUpdateAws(ctx context.Context) ApiRotatedSecretUpdateAwsRequest {
	return ApiRotatedSecretUpdateAwsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretUpdateOutput
func (a *V2ApiService) RotatedSecretUpdateAwsExecute(r ApiRotatedSecretUpdateAwsRequest) (*RotatedSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretUpdateAws")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-update-aws"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretUpdateAzureRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretUpdateAzure *RotatedSecretUpdateAzure
    body interface{}
}

func (r ApiRotatedSecretUpdateAzureRequest) RotatedSecretUpdateAzure(rotatedSecretUpdateAzure RotatedSecretUpdateAzure) ApiRotatedSecretUpdateAzureRequest {
	r.rotatedSecretUpdateAzure = &rotatedSecretUpdateAzure
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretUpdateAzureRequest) Body(body RotatedSecretUpdateAzure) ApiRotatedSecretUpdateAzureRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretUpdateAzureRequest) Execute() (*RotatedSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretUpdateAzureExecute(r)
}

/*
RotatedSecretUpdateAzure Method for RotatedSecretUpdateAzure

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretUpdateAzureRequest
*/
func (a *V2ApiService) RotatedSecretUpdateAzure(ctx context.Context) ApiRotatedSecretUpdateAzureRequest {
	return ApiRotatedSecretUpdateAzureRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretUpdateOutput
func (a *V2ApiService) RotatedSecretUpdateAzureExecute(r ApiRotatedSecretUpdateAzureRequest) (*RotatedSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretUpdateAzure")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-update-azure"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretUpdateCassandraRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretUpdateCassandra *RotatedSecretUpdateCassandra
    body interface{}
}

func (r ApiRotatedSecretUpdateCassandraRequest) RotatedSecretUpdateCassandra(rotatedSecretUpdateCassandra RotatedSecretUpdateCassandra) ApiRotatedSecretUpdateCassandraRequest {
	r.rotatedSecretUpdateCassandra = &rotatedSecretUpdateCassandra
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretUpdateCassandraRequest) Body(body RotatedSecretUpdateCassandra) ApiRotatedSecretUpdateCassandraRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretUpdateCassandraRequest) Execute() (*RotatedSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretUpdateCassandraExecute(r)
}

/*
RotatedSecretUpdateCassandra Method for RotatedSecretUpdateCassandra

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretUpdateCassandraRequest
*/
func (a *V2ApiService) RotatedSecretUpdateCassandra(ctx context.Context) ApiRotatedSecretUpdateCassandraRequest {
	return ApiRotatedSecretUpdateCassandraRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretUpdateOutput
func (a *V2ApiService) RotatedSecretUpdateCassandraExecute(r ApiRotatedSecretUpdateCassandraRequest) (*RotatedSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretUpdateCassandra")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-update-cassandra"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretUpdateCustomRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretUpdateCustom *RotatedSecretUpdateCustom
    body interface{}
}

func (r ApiRotatedSecretUpdateCustomRequest) RotatedSecretUpdateCustom(rotatedSecretUpdateCustom RotatedSecretUpdateCustom) ApiRotatedSecretUpdateCustomRequest {
	r.rotatedSecretUpdateCustom = &rotatedSecretUpdateCustom
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretUpdateCustomRequest) Body(body RotatedSecretUpdateCustom) ApiRotatedSecretUpdateCustomRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretUpdateCustomRequest) Execute() (*RotatedSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretUpdateCustomExecute(r)
}

/*
RotatedSecretUpdateCustom Method for RotatedSecretUpdateCustom

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretUpdateCustomRequest
*/
func (a *V2ApiService) RotatedSecretUpdateCustom(ctx context.Context) ApiRotatedSecretUpdateCustomRequest {
	return ApiRotatedSecretUpdateCustomRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretUpdateOutput
func (a *V2ApiService) RotatedSecretUpdateCustomExecute(r ApiRotatedSecretUpdateCustomRequest) (*RotatedSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretUpdateCustom")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-update-custom"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretUpdateDockerhubRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretUpdateDockerhub *RotatedSecretUpdateDockerhub
    body interface{}
}

func (r ApiRotatedSecretUpdateDockerhubRequest) RotatedSecretUpdateDockerhub(rotatedSecretUpdateDockerhub RotatedSecretUpdateDockerhub) ApiRotatedSecretUpdateDockerhubRequest {
	r.rotatedSecretUpdateDockerhub = &rotatedSecretUpdateDockerhub
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretUpdateDockerhubRequest) Body(body RotatedSecretUpdateDockerhub) ApiRotatedSecretUpdateDockerhubRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretUpdateDockerhubRequest) Execute() (*RotatedSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretUpdateDockerhubExecute(r)
}

/*
RotatedSecretUpdateDockerhub Method for RotatedSecretUpdateDockerhub

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretUpdateDockerhubRequest
*/
func (a *V2ApiService) RotatedSecretUpdateDockerhub(ctx context.Context) ApiRotatedSecretUpdateDockerhubRequest {
	return ApiRotatedSecretUpdateDockerhubRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretUpdateOutput
func (a *V2ApiService) RotatedSecretUpdateDockerhubExecute(r ApiRotatedSecretUpdateDockerhubRequest) (*RotatedSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretUpdateDockerhub")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-update-dockerhub"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretUpdateGcpRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretUpdateGcp *RotatedSecretUpdateGcp
    body interface{}
}

func (r ApiRotatedSecretUpdateGcpRequest) RotatedSecretUpdateGcp(rotatedSecretUpdateGcp RotatedSecretUpdateGcp) ApiRotatedSecretUpdateGcpRequest {
	r.rotatedSecretUpdateGcp = &rotatedSecretUpdateGcp
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretUpdateGcpRequest) Body(body RotatedSecretUpdateGcp) ApiRotatedSecretUpdateGcpRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretUpdateGcpRequest) Execute() (*RotatedSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretUpdateGcpExecute(r)
}

/*
RotatedSecretUpdateGcp Method for RotatedSecretUpdateGcp

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretUpdateGcpRequest
*/
func (a *V2ApiService) RotatedSecretUpdateGcp(ctx context.Context) ApiRotatedSecretUpdateGcpRequest {
	return ApiRotatedSecretUpdateGcpRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretUpdateOutput
func (a *V2ApiService) RotatedSecretUpdateGcpExecute(r ApiRotatedSecretUpdateGcpRequest) (*RotatedSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretUpdateGcp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-update-gcp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretUpdateHanadbRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretUpdateHanadb *RotatedSecretUpdateHanadb
    body interface{}
}

func (r ApiRotatedSecretUpdateHanadbRequest) RotatedSecretUpdateHanadb(rotatedSecretUpdateHanadb RotatedSecretUpdateHanadb) ApiRotatedSecretUpdateHanadbRequest {
	r.rotatedSecretUpdateHanadb = &rotatedSecretUpdateHanadb
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretUpdateHanadbRequest) Body(body RotatedSecretUpdateHanadb) ApiRotatedSecretUpdateHanadbRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretUpdateHanadbRequest) Execute() (*RotatedSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretUpdateHanadbExecute(r)
}

/*
RotatedSecretUpdateHanadb Method for RotatedSecretUpdateHanadb

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretUpdateHanadbRequest
*/
func (a *V2ApiService) RotatedSecretUpdateHanadb(ctx context.Context) ApiRotatedSecretUpdateHanadbRequest {
	return ApiRotatedSecretUpdateHanadbRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretUpdateOutput
func (a *V2ApiService) RotatedSecretUpdateHanadbExecute(r ApiRotatedSecretUpdateHanadbRequest) (*RotatedSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretUpdateHanadb")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-update-hanadb"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretUpdateLdapRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretUpdateLdap *RotatedSecretUpdateLdap
    body interface{}
}

func (r ApiRotatedSecretUpdateLdapRequest) RotatedSecretUpdateLdap(rotatedSecretUpdateLdap RotatedSecretUpdateLdap) ApiRotatedSecretUpdateLdapRequest {
	r.rotatedSecretUpdateLdap = &rotatedSecretUpdateLdap
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretUpdateLdapRequest) Body(body RotatedSecretUpdateLdap) ApiRotatedSecretUpdateLdapRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretUpdateLdapRequest) Execute() (*RotatedSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretUpdateLdapExecute(r)
}

/*
RotatedSecretUpdateLdap Method for RotatedSecretUpdateLdap

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretUpdateLdapRequest
*/
func (a *V2ApiService) RotatedSecretUpdateLdap(ctx context.Context) ApiRotatedSecretUpdateLdapRequest {
	return ApiRotatedSecretUpdateLdapRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretUpdateOutput
func (a *V2ApiService) RotatedSecretUpdateLdapExecute(r ApiRotatedSecretUpdateLdapRequest) (*RotatedSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretUpdateLdap")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-update-ldap"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretUpdateMongodbRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretUpdateMongodb *RotatedSecretUpdateMongodb
    body interface{}
}

func (r ApiRotatedSecretUpdateMongodbRequest) RotatedSecretUpdateMongodb(rotatedSecretUpdateMongodb RotatedSecretUpdateMongodb) ApiRotatedSecretUpdateMongodbRequest {
	r.rotatedSecretUpdateMongodb = &rotatedSecretUpdateMongodb
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretUpdateMongodbRequest) Body(body RotatedSecretUpdateMongodb) ApiRotatedSecretUpdateMongodbRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretUpdateMongodbRequest) Execute() (*RotatedSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretUpdateMongodbExecute(r)
}

/*
RotatedSecretUpdateMongodb Method for RotatedSecretUpdateMongodb

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretUpdateMongodbRequest
*/
func (a *V2ApiService) RotatedSecretUpdateMongodb(ctx context.Context) ApiRotatedSecretUpdateMongodbRequest {
	return ApiRotatedSecretUpdateMongodbRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretUpdateOutput
func (a *V2ApiService) RotatedSecretUpdateMongodbExecute(r ApiRotatedSecretUpdateMongodbRequest) (*RotatedSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretUpdateMongodb")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-update-mongodb"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretUpdateMssqlRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretUpdateMssql *RotatedSecretUpdateMssql
    body interface{}
}

func (r ApiRotatedSecretUpdateMssqlRequest) RotatedSecretUpdateMssql(rotatedSecretUpdateMssql RotatedSecretUpdateMssql) ApiRotatedSecretUpdateMssqlRequest {
	r.rotatedSecretUpdateMssql = &rotatedSecretUpdateMssql
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretUpdateMssqlRequest) Body(body RotatedSecretUpdateMssql) ApiRotatedSecretUpdateMssqlRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretUpdateMssqlRequest) Execute() (*RotatedSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretUpdateMssqlExecute(r)
}

/*
RotatedSecretUpdateMssql Method for RotatedSecretUpdateMssql

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretUpdateMssqlRequest
*/
func (a *V2ApiService) RotatedSecretUpdateMssql(ctx context.Context) ApiRotatedSecretUpdateMssqlRequest {
	return ApiRotatedSecretUpdateMssqlRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretUpdateOutput
func (a *V2ApiService) RotatedSecretUpdateMssqlExecute(r ApiRotatedSecretUpdateMssqlRequest) (*RotatedSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretUpdateMssql")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-update-mssql"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretUpdateMysqlRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretUpdateMysql *RotatedSecretUpdateMysql
    body interface{}
}

func (r ApiRotatedSecretUpdateMysqlRequest) RotatedSecretUpdateMysql(rotatedSecretUpdateMysql RotatedSecretUpdateMysql) ApiRotatedSecretUpdateMysqlRequest {
	r.rotatedSecretUpdateMysql = &rotatedSecretUpdateMysql
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretUpdateMysqlRequest) Body(body RotatedSecretUpdateMysql) ApiRotatedSecretUpdateMysqlRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretUpdateMysqlRequest) Execute() (*RotatedSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretUpdateMysqlExecute(r)
}

/*
RotatedSecretUpdateMysql Method for RotatedSecretUpdateMysql

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretUpdateMysqlRequest
*/
func (a *V2ApiService) RotatedSecretUpdateMysql(ctx context.Context) ApiRotatedSecretUpdateMysqlRequest {
	return ApiRotatedSecretUpdateMysqlRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretUpdateOutput
func (a *V2ApiService) RotatedSecretUpdateMysqlExecute(r ApiRotatedSecretUpdateMysqlRequest) (*RotatedSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretUpdateMysql")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-update-mysql"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretUpdateOracledbRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretUpdateOracledb *RotatedSecretUpdateOracledb
    body interface{}
}

func (r ApiRotatedSecretUpdateOracledbRequest) RotatedSecretUpdateOracledb(rotatedSecretUpdateOracledb RotatedSecretUpdateOracledb) ApiRotatedSecretUpdateOracledbRequest {
	r.rotatedSecretUpdateOracledb = &rotatedSecretUpdateOracledb
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretUpdateOracledbRequest) Body(body RotatedSecretUpdateOracledb) ApiRotatedSecretUpdateOracledbRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretUpdateOracledbRequest) Execute() (*RotatedSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretUpdateOracledbExecute(r)
}

/*
RotatedSecretUpdateOracledb Method for RotatedSecretUpdateOracledb

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretUpdateOracledbRequest
*/
func (a *V2ApiService) RotatedSecretUpdateOracledb(ctx context.Context) ApiRotatedSecretUpdateOracledbRequest {
	return ApiRotatedSecretUpdateOracledbRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretUpdateOutput
func (a *V2ApiService) RotatedSecretUpdateOracledbExecute(r ApiRotatedSecretUpdateOracledbRequest) (*RotatedSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretUpdateOracledb")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-update-oracledb"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretUpdatePostgresqlRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretUpdatePostgresql *RotatedSecretUpdatePostgresql
    body interface{}
}

func (r ApiRotatedSecretUpdatePostgresqlRequest) RotatedSecretUpdatePostgresql(rotatedSecretUpdatePostgresql RotatedSecretUpdatePostgresql) ApiRotatedSecretUpdatePostgresqlRequest {
	r.rotatedSecretUpdatePostgresql = &rotatedSecretUpdatePostgresql
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretUpdatePostgresqlRequest) Body(body RotatedSecretUpdatePostgresql) ApiRotatedSecretUpdatePostgresqlRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretUpdatePostgresqlRequest) Execute() (*RotatedSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretUpdatePostgresqlExecute(r)
}

/*
RotatedSecretUpdatePostgresql Method for RotatedSecretUpdatePostgresql

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretUpdatePostgresqlRequest
*/
func (a *V2ApiService) RotatedSecretUpdatePostgresql(ctx context.Context) ApiRotatedSecretUpdatePostgresqlRequest {
	return ApiRotatedSecretUpdatePostgresqlRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretUpdateOutput
func (a *V2ApiService) RotatedSecretUpdatePostgresqlExecute(r ApiRotatedSecretUpdatePostgresqlRequest) (*RotatedSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretUpdatePostgresql")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-update-postgresql"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretUpdateRedisRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretUpdateRedis *RotatedSecretUpdateRedis
    body interface{}
}

func (r ApiRotatedSecretUpdateRedisRequest) RotatedSecretUpdateRedis(rotatedSecretUpdateRedis RotatedSecretUpdateRedis) ApiRotatedSecretUpdateRedisRequest {
	r.rotatedSecretUpdateRedis = &rotatedSecretUpdateRedis
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretUpdateRedisRequest) Body(body RotatedSecretUpdateRedis) ApiRotatedSecretUpdateRedisRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretUpdateRedisRequest) Execute() (*RotatedSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretUpdateRedisExecute(r)
}

/*
RotatedSecretUpdateRedis Method for RotatedSecretUpdateRedis

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretUpdateRedisRequest
*/
func (a *V2ApiService) RotatedSecretUpdateRedis(ctx context.Context) ApiRotatedSecretUpdateRedisRequest {
	return ApiRotatedSecretUpdateRedisRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretUpdateOutput
func (a *V2ApiService) RotatedSecretUpdateRedisExecute(r ApiRotatedSecretUpdateRedisRequest) (*RotatedSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretUpdateRedis")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-update-redis"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretUpdateRedshiftRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretUpdateRedshift *RotatedSecretUpdateRedshift
    body interface{}
}

func (r ApiRotatedSecretUpdateRedshiftRequest) RotatedSecretUpdateRedshift(rotatedSecretUpdateRedshift RotatedSecretUpdateRedshift) ApiRotatedSecretUpdateRedshiftRequest {
	r.rotatedSecretUpdateRedshift = &rotatedSecretUpdateRedshift
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretUpdateRedshiftRequest) Body(body RotatedSecretUpdateRedshift) ApiRotatedSecretUpdateRedshiftRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretUpdateRedshiftRequest) Execute() (*RotatedSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretUpdateRedshiftExecute(r)
}

/*
RotatedSecretUpdateRedshift Method for RotatedSecretUpdateRedshift

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretUpdateRedshiftRequest
*/
func (a *V2ApiService) RotatedSecretUpdateRedshift(ctx context.Context) ApiRotatedSecretUpdateRedshiftRequest {
	return ApiRotatedSecretUpdateRedshiftRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretUpdateOutput
func (a *V2ApiService) RotatedSecretUpdateRedshiftExecute(r ApiRotatedSecretUpdateRedshiftRequest) (*RotatedSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretUpdateRedshift")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-update-redshift"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretUpdateSnowflakeRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretUpdateSnowflake *RotatedSecretUpdateSnowflake
    body interface{}
}

func (r ApiRotatedSecretUpdateSnowflakeRequest) RotatedSecretUpdateSnowflake(rotatedSecretUpdateSnowflake RotatedSecretUpdateSnowflake) ApiRotatedSecretUpdateSnowflakeRequest {
	r.rotatedSecretUpdateSnowflake = &rotatedSecretUpdateSnowflake
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretUpdateSnowflakeRequest) Body(body RotatedSecretUpdateSnowflake) ApiRotatedSecretUpdateSnowflakeRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretUpdateSnowflakeRequest) Execute() (*RotatedSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretUpdateSnowflakeExecute(r)
}

/*
RotatedSecretUpdateSnowflake Method for RotatedSecretUpdateSnowflake

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretUpdateSnowflakeRequest
*/
func (a *V2ApiService) RotatedSecretUpdateSnowflake(ctx context.Context) ApiRotatedSecretUpdateSnowflakeRequest {
	return ApiRotatedSecretUpdateSnowflakeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretUpdateOutput
func (a *V2ApiService) RotatedSecretUpdateSnowflakeExecute(r ApiRotatedSecretUpdateSnowflakeRequest) (*RotatedSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretUpdateSnowflake")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-update-snowflake"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretUpdateSshRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretUpdateSsh *RotatedSecretUpdateSsh
    body interface{}
}

func (r ApiRotatedSecretUpdateSshRequest) RotatedSecretUpdateSsh(rotatedSecretUpdateSsh RotatedSecretUpdateSsh) ApiRotatedSecretUpdateSshRequest {
	r.rotatedSecretUpdateSsh = &rotatedSecretUpdateSsh
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretUpdateSshRequest) Body(body RotatedSecretUpdateSsh) ApiRotatedSecretUpdateSshRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretUpdateSshRequest) Execute() (*RotatedSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretUpdateSshExecute(r)
}

/*
RotatedSecretUpdateSsh Method for RotatedSecretUpdateSsh

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretUpdateSshRequest
*/
func (a *V2ApiService) RotatedSecretUpdateSsh(ctx context.Context) ApiRotatedSecretUpdateSshRequest {
	return ApiRotatedSecretUpdateSshRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretUpdateOutput
func (a *V2ApiService) RotatedSecretUpdateSshExecute(r ApiRotatedSecretUpdateSshRequest) (*RotatedSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretUpdateSsh")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-update-ssh"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotatedSecretUpdateWindowsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	rotatedSecretUpdateWindows *RotatedSecretUpdateWindows
    body interface{}
}

func (r ApiRotatedSecretUpdateWindowsRequest) RotatedSecretUpdateWindows(rotatedSecretUpdateWindows RotatedSecretUpdateWindows) ApiRotatedSecretUpdateWindowsRequest {
	r.rotatedSecretUpdateWindows = &rotatedSecretUpdateWindows
	return r
}


    // Body sets the body payload for the API call.
func (r ApiRotatedSecretUpdateWindowsRequest) Body(body RotatedSecretUpdateWindows) ApiRotatedSecretUpdateWindowsRequest {
    r.body = body
    return r
}

func (r ApiRotatedSecretUpdateWindowsRequest) Execute() (*RotatedSecretUpdateOutput, *http.Response, error) {
	return r.ApiService.RotatedSecretUpdateWindowsExecute(r)
}

/*
RotatedSecretUpdateWindows Method for RotatedSecretUpdateWindows

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRotatedSecretUpdateWindowsRequest
*/
func (a *V2ApiService) RotatedSecretUpdateWindows(ctx context.Context) ApiRotatedSecretUpdateWindowsRequest {
	return ApiRotatedSecretUpdateWindowsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotatedSecretUpdateOutput
func (a *V2ApiService) RotatedSecretUpdateWindowsExecute(r ApiRotatedSecretUpdateWindowsRequest) (*RotatedSecretUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotatedSecretUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.RotatedSecretUpdateWindows")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotated-secret-update-windows"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetItemStateRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	setItemState *SetItemState
    body interface{}
}

func (r ApiSetItemStateRequest) SetItemState(setItemState SetItemState) ApiSetItemStateRequest {
	r.setItemState = &setItemState
	return r
}


    // Body sets the body payload for the API call.
func (r ApiSetItemStateRequest) Body(body SetItemState) ApiSetItemStateRequest {
    r.body = body
    return r
}

func (r ApiSetItemStateRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SetItemStateExecute(r)
}

/*
SetItemState Method for SetItemState

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetItemStateRequest
*/
func (a *V2ApiService) SetItemState(ctx context.Context) ApiSetItemStateRequest {
	return ApiSetItemStateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) SetItemStateExecute(r ApiSetItemStateRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.SetItemState")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/set-item-state"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetRoleRuleRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	setRoleRule *SetRoleRule
    body interface{}
}

func (r ApiSetRoleRuleRequest) SetRoleRule(setRoleRule SetRoleRule) ApiSetRoleRuleRequest {
	r.setRoleRule = &setRoleRule
	return r
}


    // Body sets the body payload for the API call.
func (r ApiSetRoleRuleRequest) Body(body SetRoleRule) ApiSetRoleRuleRequest {
    r.body = body
    return r
}

func (r ApiSetRoleRuleRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SetRoleRuleExecute(r)
}

/*
SetRoleRule Method for SetRoleRule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetRoleRuleRequest
*/
func (a *V2ApiService) SetRoleRule(ctx context.Context) ApiSetRoleRuleRequest {
	return ApiSetRoleRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) SetRoleRuleExecute(r ApiSetRoleRuleRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.SetRoleRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/set-role-rule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShareItemRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	shareItem *ShareItem
    body interface{}
}

func (r ApiShareItemRequest) ShareItem(shareItem ShareItem) ApiShareItemRequest {
	r.shareItem = &shareItem
	return r
}


    // Body sets the body payload for the API call.
func (r ApiShareItemRequest) Body(body ShareItem) ApiShareItemRequest {
    r.body = body
    return r
}

func (r ApiShareItemRequest) Execute() (*ShareItemOutput, *http.Response, error) {
	return r.ApiService.ShareItemExecute(r)
}

/*
ShareItem Method for ShareItem

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiShareItemRequest
*/
func (a *V2ApiService) ShareItem(ctx context.Context) ApiShareItemRequest {
	return ApiShareItemRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ShareItemOutput
func (a *V2ApiService) ShareItemExecute(r ApiShareItemRequest) (*ShareItemOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShareItemOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.ShareItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/share-item"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSignDataWithClassicKeyRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	signDataWithClassicKey *SignDataWithClassicKey
    body interface{}
}

func (r ApiSignDataWithClassicKeyRequest) SignDataWithClassicKey(signDataWithClassicKey SignDataWithClassicKey) ApiSignDataWithClassicKeyRequest {
	r.signDataWithClassicKey = &signDataWithClassicKey
	return r
}


    // Body sets the body payload for the API call.
func (r ApiSignDataWithClassicKeyRequest) Body(body SignDataWithClassicKey) ApiSignDataWithClassicKeyRequest {
    r.body = body
    return r
}

func (r ApiSignDataWithClassicKeyRequest) Execute() (*SignOutput, *http.Response, error) {
	return r.ApiService.SignDataWithClassicKeyExecute(r)
}

/*
SignDataWithClassicKey Method for SignDataWithClassicKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSignDataWithClassicKeyRequest
*/
func (a *V2ApiService) SignDataWithClassicKey(ctx context.Context) ApiSignDataWithClassicKeyRequest {
	return ApiSignDataWithClassicKeyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SignOutput
func (a *V2ApiService) SignDataWithClassicKeyExecute(r ApiSignDataWithClassicKeyRequest) (*SignOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SignOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.SignDataWithClassicKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sign-data-with-classic-key"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSignEcDsaRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	signEcDsa *SignEcDsa
    body interface{}
}

func (r ApiSignEcDsaRequest) SignEcDsa(signEcDsa SignEcDsa) ApiSignEcDsaRequest {
	r.signEcDsa = &signEcDsa
	return r
}


    // Body sets the body payload for the API call.
func (r ApiSignEcDsaRequest) Body(body SignEcDsa) ApiSignEcDsaRequest {
    r.body = body
    return r
}

func (r ApiSignEcDsaRequest) Execute() (*SignEcDsaOutput, *http.Response, error) {
	return r.ApiService.SignEcDsaExecute(r)
}

/*
SignEcDsa Method for SignEcDsa

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSignEcDsaRequest
*/
func (a *V2ApiService) SignEcDsa(ctx context.Context) ApiSignEcDsaRequest {
	return ApiSignEcDsaRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SignEcDsaOutput
func (a *V2ApiService) SignEcDsaExecute(r ApiSignEcDsaRequest) (*SignEcDsaOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SignEcDsaOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.SignEcDsa")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sign-ecdsa"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSignGPGRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	signGPG *SignGPG
    body interface{}
}

func (r ApiSignGPGRequest) SignGPG(signGPG SignGPG) ApiSignGPGRequest {
	r.signGPG = &signGPG
	return r
}


    // Body sets the body payload for the API call.
func (r ApiSignGPGRequest) Body(body SignGPG) ApiSignGPGRequest {
    r.body = body
    return r
}

func (r ApiSignGPGRequest) Execute() (*SignGPGOutput, *http.Response, error) {
	return r.ApiService.SignGPGExecute(r)
}

/*
SignGPG Method for SignGPG

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSignGPGRequest
*/
func (a *V2ApiService) SignGPG(ctx context.Context) ApiSignGPGRequest {
	return ApiSignGPGRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SignGPGOutput
func (a *V2ApiService) SignGPGExecute(r ApiSignGPGRequest) (*SignGPGOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SignGPGOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.SignGPG")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sign-gpg"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSignJWTWithClassicKeyRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	signJWTWithClassicKey *SignJWTWithClassicKey
    body interface{}
}

func (r ApiSignJWTWithClassicKeyRequest) SignJWTWithClassicKey(signJWTWithClassicKey SignJWTWithClassicKey) ApiSignJWTWithClassicKeyRequest {
	r.signJWTWithClassicKey = &signJWTWithClassicKey
	return r
}


    // Body sets the body payload for the API call.
func (r ApiSignJWTWithClassicKeyRequest) Body(body SignJWTWithClassicKey) ApiSignJWTWithClassicKeyRequest {
    r.body = body
    return r
}

func (r ApiSignJWTWithClassicKeyRequest) Execute() (*SignJWTOutput, *http.Response, error) {
	return r.ApiService.SignJWTWithClassicKeyExecute(r)
}

/*
SignJWTWithClassicKey Method for SignJWTWithClassicKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSignJWTWithClassicKeyRequest
*/
func (a *V2ApiService) SignJWTWithClassicKey(ctx context.Context) ApiSignJWTWithClassicKeyRequest {
	return ApiSignJWTWithClassicKeyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SignJWTOutput
func (a *V2ApiService) SignJWTWithClassicKeyExecute(r ApiSignJWTWithClassicKeyRequest) (*SignJWTOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SignJWTOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.SignJWTWithClassicKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sign-jwt-with-classic-key"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSignPKCS1Request struct {
	ctx context.Context
	ApiService *V2ApiService
	signPKCS1 *SignPKCS1
    body interface{}
}

func (r ApiSignPKCS1Request) SignPKCS1(signPKCS1 SignPKCS1) ApiSignPKCS1Request {
	r.signPKCS1 = &signPKCS1
	return r
}


    // Body sets the body payload for the API call.
func (r ApiSignPKCS1Request) Body(body SignPKCS1) ApiSignPKCS1Request {
    r.body = body
    return r
}

func (r ApiSignPKCS1Request) Execute() (*SignPKCS1Output, *http.Response, error) {
	return r.ApiService.SignPKCS1Execute(r)
}

/*
SignPKCS1 Method for SignPKCS1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSignPKCS1Request
*/
func (a *V2ApiService) SignPKCS1(ctx context.Context) ApiSignPKCS1Request {
	return ApiSignPKCS1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SignPKCS1Output
func (a *V2ApiService) SignPKCS1Execute(r ApiSignPKCS1Request) (*SignPKCS1Output, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SignPKCS1Output
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.SignPKCS1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sign-pkcs1"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSignPKICertWithClassicKeyRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	signPKICertWithClassicKey *SignPKICertWithClassicKey
    body interface{}
}

func (r ApiSignPKICertWithClassicKeyRequest) SignPKICertWithClassicKey(signPKICertWithClassicKey SignPKICertWithClassicKey) ApiSignPKICertWithClassicKeyRequest {
	r.signPKICertWithClassicKey = &signPKICertWithClassicKey
	return r
}


    // Body sets the body payload for the API call.
func (r ApiSignPKICertWithClassicKeyRequest) Body(body SignPKICertWithClassicKey) ApiSignPKICertWithClassicKeyRequest {
    r.body = body
    return r
}

func (r ApiSignPKICertWithClassicKeyRequest) Execute() (*SignPKICertOutput, *http.Response, error) {
	return r.ApiService.SignPKICertWithClassicKeyExecute(r)
}

/*
SignPKICertWithClassicKey Method for SignPKICertWithClassicKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSignPKICertWithClassicKeyRequest
*/
func (a *V2ApiService) SignPKICertWithClassicKey(ctx context.Context) ApiSignPKICertWithClassicKeyRequest {
	return ApiSignPKICertWithClassicKeyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SignPKICertOutput
func (a *V2ApiService) SignPKICertWithClassicKeyExecute(r ApiSignPKICertWithClassicKeyRequest) (*SignPKICertOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SignPKICertOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.SignPKICertWithClassicKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sign-pki-cert-with-classic-key"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSignRsaSsaPssRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	signRsaSsaPss *SignRsaSsaPss
    body interface{}
}

func (r ApiSignRsaSsaPssRequest) SignRsaSsaPss(signRsaSsaPss SignRsaSsaPss) ApiSignRsaSsaPssRequest {
	r.signRsaSsaPss = &signRsaSsaPss
	return r
}


    // Body sets the body payload for the API call.
func (r ApiSignRsaSsaPssRequest) Body(body SignRsaSsaPss) ApiSignRsaSsaPssRequest {
    r.body = body
    return r
}

func (r ApiSignRsaSsaPssRequest) Execute() (*SignRsaSsaPssOutput, *http.Response, error) {
	return r.ApiService.SignRsaSsaPssExecute(r)
}

/*
SignRsaSsaPss Method for SignRsaSsaPss

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSignRsaSsaPssRequest
*/
func (a *V2ApiService) SignRsaSsaPss(ctx context.Context) ApiSignRsaSsaPssRequest {
	return ApiSignRsaSsaPssRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SignRsaSsaPssOutput
func (a *V2ApiService) SignRsaSsaPssExecute(r ApiSignRsaSsaPssRequest) (*SignRsaSsaPssOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SignRsaSsaPssOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.SignRsaSsaPss")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sign-rsassa-pss"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStaticCredsAuthRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	staticCredsAuth *StaticCredsAuth
    body interface{}
}

func (r ApiStaticCredsAuthRequest) StaticCredsAuth(staticCredsAuth StaticCredsAuth) ApiStaticCredsAuthRequest {
	r.staticCredsAuth = &staticCredsAuth
	return r
}


    // Body sets the body payload for the API call.
func (r ApiStaticCredsAuthRequest) Body(body StaticCredsAuth) ApiStaticCredsAuthRequest {
    r.body = body
    return r
}

func (r ApiStaticCredsAuthRequest) Execute() (*StaticCredsAuthOutput, *http.Response, error) {
	return r.ApiService.StaticCredsAuthExecute(r)
}

/*
StaticCredsAuth Method for StaticCredsAuth

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiStaticCredsAuthRequest
*/
func (a *V2ApiService) StaticCredsAuth(ctx context.Context) ApiStaticCredsAuthRequest {
	return ApiStaticCredsAuthRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StaticCredsAuthOutput
func (a *V2ApiService) StaticCredsAuthExecute(r ApiStaticCredsAuthRequest) (*StaticCredsAuthOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StaticCredsAuthOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.StaticCredsAuth")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/static-creds-auth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStaticSecretDeleteSyncRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	staticSecretDeleteSync *StaticSecretDeleteSync
    body interface{}
}

func (r ApiStaticSecretDeleteSyncRequest) StaticSecretDeleteSync(staticSecretDeleteSync StaticSecretDeleteSync) ApiStaticSecretDeleteSyncRequest {
	r.staticSecretDeleteSync = &staticSecretDeleteSync
	return r
}


    // Body sets the body payload for the API call.
func (r ApiStaticSecretDeleteSyncRequest) Body(body StaticSecretDeleteSync) ApiStaticSecretDeleteSyncRequest {
    r.body = body
    return r
}

func (r ApiStaticSecretDeleteSyncRequest) Execute() (*StaticSecretDeleteSyncOutput, *http.Response, error) {
	return r.ApiService.StaticSecretDeleteSyncExecute(r)
}

/*
StaticSecretDeleteSync Method for StaticSecretDeleteSync

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiStaticSecretDeleteSyncRequest
*/
func (a *V2ApiService) StaticSecretDeleteSync(ctx context.Context) ApiStaticSecretDeleteSyncRequest {
	return ApiStaticSecretDeleteSyncRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StaticSecretDeleteSyncOutput
func (a *V2ApiService) StaticSecretDeleteSyncExecute(r ApiStaticSecretDeleteSyncRequest) (*StaticSecretDeleteSyncOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StaticSecretDeleteSyncOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.StaticSecretDeleteSync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/static-secret-delete-sync"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStaticSecretSyncRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	staticSecretSync *StaticSecretSync
    body interface{}
}

func (r ApiStaticSecretSyncRequest) StaticSecretSync(staticSecretSync StaticSecretSync) ApiStaticSecretSyncRequest {
	r.staticSecretSync = &staticSecretSync
	return r
}


    // Body sets the body payload for the API call.
func (r ApiStaticSecretSyncRequest) Body(body StaticSecretSync) ApiStaticSecretSyncRequest {
    r.body = body
    return r
}

func (r ApiStaticSecretSyncRequest) Execute() (*SecretSyncOutput, *http.Response, error) {
	return r.ApiService.StaticSecretSyncExecute(r)
}

/*
StaticSecretSync Method for StaticSecretSync

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiStaticSecretSyncRequest
*/
func (a *V2ApiService) StaticSecretSync(ctx context.Context) ApiStaticSecretSyncRequest {
	return ApiStaticSecretSyncRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SecretSyncOutput
func (a *V2ApiService) StaticSecretSyncExecute(r ApiStaticSecretSyncRequest) (*SecretSyncOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SecretSyncOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.StaticSecretSync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/static-secret-sync"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetCreateArtifactoryRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetCreateArtifactory *TargetCreateArtifactory
    body interface{}
}

func (r ApiTargetCreateArtifactoryRequest) TargetCreateArtifactory(targetCreateArtifactory TargetCreateArtifactory) ApiTargetCreateArtifactoryRequest {
	r.targetCreateArtifactory = &targetCreateArtifactory
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetCreateArtifactoryRequest) Body(body TargetCreateArtifactory) ApiTargetCreateArtifactoryRequest {
    r.body = body
    return r
}

func (r ApiTargetCreateArtifactoryRequest) Execute() (*TargetCreateOutput, *http.Response, error) {
	return r.ApiService.TargetCreateArtifactoryExecute(r)
}

/*
TargetCreateArtifactory Method for TargetCreateArtifactory

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetCreateArtifactoryRequest
*/
func (a *V2ApiService) TargetCreateArtifactory(ctx context.Context) ApiTargetCreateArtifactoryRequest {
	return ApiTargetCreateArtifactoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetCreateOutput
func (a *V2ApiService) TargetCreateArtifactoryExecute(r ApiTargetCreateArtifactoryRequest) (*TargetCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetCreateArtifactory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-create-artifactory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetCreateAwsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetCreateAws *TargetCreateAws
    body interface{}
}

func (r ApiTargetCreateAwsRequest) TargetCreateAws(targetCreateAws TargetCreateAws) ApiTargetCreateAwsRequest {
	r.targetCreateAws = &targetCreateAws
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetCreateAwsRequest) Body(body TargetCreateAws) ApiTargetCreateAwsRequest {
    r.body = body
    return r
}

func (r ApiTargetCreateAwsRequest) Execute() (*TargetCreateOutput, *http.Response, error) {
	return r.ApiService.TargetCreateAwsExecute(r)
}

/*
TargetCreateAws Method for TargetCreateAws

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetCreateAwsRequest
*/
func (a *V2ApiService) TargetCreateAws(ctx context.Context) ApiTargetCreateAwsRequest {
	return ApiTargetCreateAwsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetCreateOutput
func (a *V2ApiService) TargetCreateAwsExecute(r ApiTargetCreateAwsRequest) (*TargetCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetCreateAws")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-create-aws"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetCreateAzureRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetCreateAzure *TargetCreateAzure
    body interface{}
}

func (r ApiTargetCreateAzureRequest) TargetCreateAzure(targetCreateAzure TargetCreateAzure) ApiTargetCreateAzureRequest {
	r.targetCreateAzure = &targetCreateAzure
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetCreateAzureRequest) Body(body TargetCreateAzure) ApiTargetCreateAzureRequest {
    r.body = body
    return r
}

func (r ApiTargetCreateAzureRequest) Execute() (*TargetCreateOutput, *http.Response, error) {
	return r.ApiService.TargetCreateAzureExecute(r)
}

/*
TargetCreateAzure Method for TargetCreateAzure

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetCreateAzureRequest
*/
func (a *V2ApiService) TargetCreateAzure(ctx context.Context) ApiTargetCreateAzureRequest {
	return ApiTargetCreateAzureRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetCreateOutput
func (a *V2ApiService) TargetCreateAzureExecute(r ApiTargetCreateAzureRequest) (*TargetCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetCreateAzure")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-create-azure"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetCreateDBRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetCreateDB *TargetCreateDB
    body interface{}
}

func (r ApiTargetCreateDBRequest) TargetCreateDB(targetCreateDB TargetCreateDB) ApiTargetCreateDBRequest {
	r.targetCreateDB = &targetCreateDB
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetCreateDBRequest) Body(body TargetCreateDB) ApiTargetCreateDBRequest {
    r.body = body
    return r
}

func (r ApiTargetCreateDBRequest) Execute() (*TargetCreateOutput, *http.Response, error) {
	return r.ApiService.TargetCreateDBExecute(r)
}

/*
TargetCreateDB Method for TargetCreateDB

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetCreateDBRequest
*/
func (a *V2ApiService) TargetCreateDB(ctx context.Context) ApiTargetCreateDBRequest {
	return ApiTargetCreateDBRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetCreateOutput
func (a *V2ApiService) TargetCreateDBExecute(r ApiTargetCreateDBRequest) (*TargetCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetCreateDB")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-create-db"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetCreateDockerhubRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetCreateDockerhub *TargetCreateDockerhub
    body interface{}
}

func (r ApiTargetCreateDockerhubRequest) TargetCreateDockerhub(targetCreateDockerhub TargetCreateDockerhub) ApiTargetCreateDockerhubRequest {
	r.targetCreateDockerhub = &targetCreateDockerhub
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetCreateDockerhubRequest) Body(body TargetCreateDockerhub) ApiTargetCreateDockerhubRequest {
    r.body = body
    return r
}

func (r ApiTargetCreateDockerhubRequest) Execute() (*TargetCreateOutput, *http.Response, error) {
	return r.ApiService.TargetCreateDockerhubExecute(r)
}

/*
TargetCreateDockerhub Method for TargetCreateDockerhub

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetCreateDockerhubRequest
*/
func (a *V2ApiService) TargetCreateDockerhub(ctx context.Context) ApiTargetCreateDockerhubRequest {
	return ApiTargetCreateDockerhubRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetCreateOutput
func (a *V2ApiService) TargetCreateDockerhubExecute(r ApiTargetCreateDockerhubRequest) (*TargetCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetCreateDockerhub")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-create-dockerhub"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetCreateEksRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetCreateEks *TargetCreateEks
    body interface{}
}

func (r ApiTargetCreateEksRequest) TargetCreateEks(targetCreateEks TargetCreateEks) ApiTargetCreateEksRequest {
	r.targetCreateEks = &targetCreateEks
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetCreateEksRequest) Body(body TargetCreateEks) ApiTargetCreateEksRequest {
    r.body = body
    return r
}

func (r ApiTargetCreateEksRequest) Execute() (*TargetCreateOutput, *http.Response, error) {
	return r.ApiService.TargetCreateEksExecute(r)
}

/*
TargetCreateEks Method for TargetCreateEks

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetCreateEksRequest
*/
func (a *V2ApiService) TargetCreateEks(ctx context.Context) ApiTargetCreateEksRequest {
	return ApiTargetCreateEksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetCreateOutput
func (a *V2ApiService) TargetCreateEksExecute(r ApiTargetCreateEksRequest) (*TargetCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetCreateEks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-create-eks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetCreateGcpRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetCreateGcp *TargetCreateGcp
    body interface{}
}

func (r ApiTargetCreateGcpRequest) TargetCreateGcp(targetCreateGcp TargetCreateGcp) ApiTargetCreateGcpRequest {
	r.targetCreateGcp = &targetCreateGcp
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetCreateGcpRequest) Body(body TargetCreateGcp) ApiTargetCreateGcpRequest {
    r.body = body
    return r
}

func (r ApiTargetCreateGcpRequest) Execute() (*TargetCreateOutput, *http.Response, error) {
	return r.ApiService.TargetCreateGcpExecute(r)
}

/*
TargetCreateGcp Method for TargetCreateGcp

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetCreateGcpRequest
*/
func (a *V2ApiService) TargetCreateGcp(ctx context.Context) ApiTargetCreateGcpRequest {
	return ApiTargetCreateGcpRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetCreateOutput
func (a *V2ApiService) TargetCreateGcpExecute(r ApiTargetCreateGcpRequest) (*TargetCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetCreateGcp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-create-gcp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetCreateGeminiRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetCreateGemini *TargetCreateGemini
    body interface{}
}

func (r ApiTargetCreateGeminiRequest) TargetCreateGemini(targetCreateGemini TargetCreateGemini) ApiTargetCreateGeminiRequest {
	r.targetCreateGemini = &targetCreateGemini
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetCreateGeminiRequest) Body(body TargetCreateGemini) ApiTargetCreateGeminiRequest {
    r.body = body
    return r
}

func (r ApiTargetCreateGeminiRequest) Execute() (*TargetCreateOutput, *http.Response, error) {
	return r.ApiService.TargetCreateGeminiExecute(r)
}

/*
TargetCreateGemini Method for TargetCreateGemini

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetCreateGeminiRequest
*/
func (a *V2ApiService) TargetCreateGemini(ctx context.Context) ApiTargetCreateGeminiRequest {
	return ApiTargetCreateGeminiRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetCreateOutput
func (a *V2ApiService) TargetCreateGeminiExecute(r ApiTargetCreateGeminiRequest) (*TargetCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetCreateGemini")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-create-gemini"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetCreateGithubRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetCreateGithub *TargetCreateGithub
    body interface{}
}

func (r ApiTargetCreateGithubRequest) TargetCreateGithub(targetCreateGithub TargetCreateGithub) ApiTargetCreateGithubRequest {
	r.targetCreateGithub = &targetCreateGithub
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetCreateGithubRequest) Body(body TargetCreateGithub) ApiTargetCreateGithubRequest {
    r.body = body
    return r
}

func (r ApiTargetCreateGithubRequest) Execute() (*TargetCreateOutput, *http.Response, error) {
	return r.ApiService.TargetCreateGithubExecute(r)
}

/*
TargetCreateGithub Method for TargetCreateGithub

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetCreateGithubRequest
*/
func (a *V2ApiService) TargetCreateGithub(ctx context.Context) ApiTargetCreateGithubRequest {
	return ApiTargetCreateGithubRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetCreateOutput
func (a *V2ApiService) TargetCreateGithubExecute(r ApiTargetCreateGithubRequest) (*TargetCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetCreateGithub")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-create-github"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetCreateGitlabRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetCreateGitlab *TargetCreateGitlab
    body interface{}
}

func (r ApiTargetCreateGitlabRequest) TargetCreateGitlab(targetCreateGitlab TargetCreateGitlab) ApiTargetCreateGitlabRequest {
	r.targetCreateGitlab = &targetCreateGitlab
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetCreateGitlabRequest) Body(body TargetCreateGitlab) ApiTargetCreateGitlabRequest {
    r.body = body
    return r
}

func (r ApiTargetCreateGitlabRequest) Execute() (*TargetCreateOutput, *http.Response, error) {
	return r.ApiService.TargetCreateGitlabExecute(r)
}

/*
TargetCreateGitlab Method for TargetCreateGitlab

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetCreateGitlabRequest
*/
func (a *V2ApiService) TargetCreateGitlab(ctx context.Context) ApiTargetCreateGitlabRequest {
	return ApiTargetCreateGitlabRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetCreateOutput
func (a *V2ApiService) TargetCreateGitlabExecute(r ApiTargetCreateGitlabRequest) (*TargetCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetCreateGitlab")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-create-gitlab"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetCreateGkeRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetCreateGke *TargetCreateGke
    body interface{}
}

func (r ApiTargetCreateGkeRequest) TargetCreateGke(targetCreateGke TargetCreateGke) ApiTargetCreateGkeRequest {
	r.targetCreateGke = &targetCreateGke
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetCreateGkeRequest) Body(body TargetCreateGke) ApiTargetCreateGkeRequest {
    r.body = body
    return r
}

func (r ApiTargetCreateGkeRequest) Execute() (*TargetCreateOutput, *http.Response, error) {
	return r.ApiService.TargetCreateGkeExecute(r)
}

/*
TargetCreateGke Method for TargetCreateGke

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetCreateGkeRequest
*/
func (a *V2ApiService) TargetCreateGke(ctx context.Context) ApiTargetCreateGkeRequest {
	return ApiTargetCreateGkeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetCreateOutput
func (a *V2ApiService) TargetCreateGkeExecute(r ApiTargetCreateGkeRequest) (*TargetCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetCreateGke")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-create-gke"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetCreateGlobalSignRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetCreateGlobalSign *TargetCreateGlobalSign
    body interface{}
}

func (r ApiTargetCreateGlobalSignRequest) TargetCreateGlobalSign(targetCreateGlobalSign TargetCreateGlobalSign) ApiTargetCreateGlobalSignRequest {
	r.targetCreateGlobalSign = &targetCreateGlobalSign
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetCreateGlobalSignRequest) Body(body TargetCreateGlobalSign) ApiTargetCreateGlobalSignRequest {
    r.body = body
    return r
}

func (r ApiTargetCreateGlobalSignRequest) Execute() (*TargetCreateOutput, *http.Response, error) {
	return r.ApiService.TargetCreateGlobalSignExecute(r)
}

/*
TargetCreateGlobalSign Method for TargetCreateGlobalSign

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetCreateGlobalSignRequest
*/
func (a *V2ApiService) TargetCreateGlobalSign(ctx context.Context) ApiTargetCreateGlobalSignRequest {
	return ApiTargetCreateGlobalSignRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetCreateOutput
func (a *V2ApiService) TargetCreateGlobalSignExecute(r ApiTargetCreateGlobalSignRequest) (*TargetCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetCreateGlobalSign")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-create-globalsign"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetCreateGlobalSignAtlasRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetCreateGlobalSignAtlas *TargetCreateGlobalSignAtlas
    body interface{}
}

func (r ApiTargetCreateGlobalSignAtlasRequest) TargetCreateGlobalSignAtlas(targetCreateGlobalSignAtlas TargetCreateGlobalSignAtlas) ApiTargetCreateGlobalSignAtlasRequest {
	r.targetCreateGlobalSignAtlas = &targetCreateGlobalSignAtlas
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetCreateGlobalSignAtlasRequest) Body(body TargetCreateGlobalSignAtlas) ApiTargetCreateGlobalSignAtlasRequest {
    r.body = body
    return r
}

func (r ApiTargetCreateGlobalSignAtlasRequest) Execute() (*TargetCreateOutput, *http.Response, error) {
	return r.ApiService.TargetCreateGlobalSignAtlasExecute(r)
}

/*
TargetCreateGlobalSignAtlas Method for TargetCreateGlobalSignAtlas

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetCreateGlobalSignAtlasRequest
*/
func (a *V2ApiService) TargetCreateGlobalSignAtlas(ctx context.Context) ApiTargetCreateGlobalSignAtlasRequest {
	return ApiTargetCreateGlobalSignAtlasRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetCreateOutput
func (a *V2ApiService) TargetCreateGlobalSignAtlasExecute(r ApiTargetCreateGlobalSignAtlasRequest) (*TargetCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetCreateGlobalSignAtlas")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-create-globalsign-atlas"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetCreateGodaddyRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetCreateGodaddy *TargetCreateGodaddy
    body interface{}
}

func (r ApiTargetCreateGodaddyRequest) TargetCreateGodaddy(targetCreateGodaddy TargetCreateGodaddy) ApiTargetCreateGodaddyRequest {
	r.targetCreateGodaddy = &targetCreateGodaddy
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetCreateGodaddyRequest) Body(body TargetCreateGodaddy) ApiTargetCreateGodaddyRequest {
    r.body = body
    return r
}

func (r ApiTargetCreateGodaddyRequest) Execute() (*TargetCreateOutput, *http.Response, error) {
	return r.ApiService.TargetCreateGodaddyExecute(r)
}

/*
TargetCreateGodaddy Method for TargetCreateGodaddy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetCreateGodaddyRequest
*/
func (a *V2ApiService) TargetCreateGodaddy(ctx context.Context) ApiTargetCreateGodaddyRequest {
	return ApiTargetCreateGodaddyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetCreateOutput
func (a *V2ApiService) TargetCreateGodaddyExecute(r ApiTargetCreateGodaddyRequest) (*TargetCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetCreateGodaddy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-create-godaddy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetCreateHashiVaultRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetCreateHashiVault *TargetCreateHashiVault
    body interface{}
}

func (r ApiTargetCreateHashiVaultRequest) TargetCreateHashiVault(targetCreateHashiVault TargetCreateHashiVault) ApiTargetCreateHashiVaultRequest {
	r.targetCreateHashiVault = &targetCreateHashiVault
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetCreateHashiVaultRequest) Body(body TargetCreateHashiVault) ApiTargetCreateHashiVaultRequest {
    r.body = body
    return r
}

func (r ApiTargetCreateHashiVaultRequest) Execute() (*TargetCreateOutput, *http.Response, error) {
	return r.ApiService.TargetCreateHashiVaultExecute(r)
}

/*
TargetCreateHashiVault Method for TargetCreateHashiVault

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetCreateHashiVaultRequest
*/
func (a *V2ApiService) TargetCreateHashiVault(ctx context.Context) ApiTargetCreateHashiVaultRequest {
	return ApiTargetCreateHashiVaultRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetCreateOutput
func (a *V2ApiService) TargetCreateHashiVaultExecute(r ApiTargetCreateHashiVaultRequest) (*TargetCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetCreateHashiVault")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-create-hashi-vault"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetCreateK8sRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetCreateK8s *TargetCreateK8s
    body interface{}
}

func (r ApiTargetCreateK8sRequest) TargetCreateK8s(targetCreateK8s TargetCreateK8s) ApiTargetCreateK8sRequest {
	r.targetCreateK8s = &targetCreateK8s
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetCreateK8sRequest) Body(body TargetCreateK8s) ApiTargetCreateK8sRequest {
    r.body = body
    return r
}

func (r ApiTargetCreateK8sRequest) Execute() (*TargetCreateOutput, *http.Response, error) {
	return r.ApiService.TargetCreateK8sExecute(r)
}

/*
TargetCreateK8s Method for TargetCreateK8s

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetCreateK8sRequest
*/
func (a *V2ApiService) TargetCreateK8s(ctx context.Context) ApiTargetCreateK8sRequest {
	return ApiTargetCreateK8sRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetCreateOutput
func (a *V2ApiService) TargetCreateK8sExecute(r ApiTargetCreateK8sRequest) (*TargetCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetCreateK8s")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-create-k8s"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetCreateLdapRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetCreateLdap *TargetCreateLdap
    body interface{}
}

func (r ApiTargetCreateLdapRequest) TargetCreateLdap(targetCreateLdap TargetCreateLdap) ApiTargetCreateLdapRequest {
	r.targetCreateLdap = &targetCreateLdap
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetCreateLdapRequest) Body(body TargetCreateLdap) ApiTargetCreateLdapRequest {
    r.body = body
    return r
}

func (r ApiTargetCreateLdapRequest) Execute() (*TargetCreateOutput, *http.Response, error) {
	return r.ApiService.TargetCreateLdapExecute(r)
}

/*
TargetCreateLdap Method for TargetCreateLdap

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetCreateLdapRequest
*/
func (a *V2ApiService) TargetCreateLdap(ctx context.Context) ApiTargetCreateLdapRequest {
	return ApiTargetCreateLdapRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetCreateOutput
func (a *V2ApiService) TargetCreateLdapExecute(r ApiTargetCreateLdapRequest) (*TargetCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetCreateLdap")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-create-ldap"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetCreateLinkedRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetCreateLinked *TargetCreateLinked
    body interface{}
}

func (r ApiTargetCreateLinkedRequest) TargetCreateLinked(targetCreateLinked TargetCreateLinked) ApiTargetCreateLinkedRequest {
	r.targetCreateLinked = &targetCreateLinked
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetCreateLinkedRequest) Body(body TargetCreateLinked) ApiTargetCreateLinkedRequest {
    r.body = body
    return r
}

func (r ApiTargetCreateLinkedRequest) Execute() (*TargetCreateOutput, *http.Response, error) {
	return r.ApiService.TargetCreateLinkedExecute(r)
}

/*
TargetCreateLinked Method for TargetCreateLinked

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetCreateLinkedRequest
*/
func (a *V2ApiService) TargetCreateLinked(ctx context.Context) ApiTargetCreateLinkedRequest {
	return ApiTargetCreateLinkedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetCreateOutput
func (a *V2ApiService) TargetCreateLinkedExecute(r ApiTargetCreateLinkedRequest) (*TargetCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetCreateLinked")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-create-linked"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetCreateOpenAIRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetCreateOpenAI *TargetCreateOpenAI
    body interface{}
}

func (r ApiTargetCreateOpenAIRequest) TargetCreateOpenAI(targetCreateOpenAI TargetCreateOpenAI) ApiTargetCreateOpenAIRequest {
	r.targetCreateOpenAI = &targetCreateOpenAI
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetCreateOpenAIRequest) Body(body TargetCreateOpenAI) ApiTargetCreateOpenAIRequest {
    r.body = body
    return r
}

func (r ApiTargetCreateOpenAIRequest) Execute() (*TargetCreateOutput, *http.Response, error) {
	return r.ApiService.TargetCreateOpenAIExecute(r)
}

/*
TargetCreateOpenAI Method for TargetCreateOpenAI

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetCreateOpenAIRequest
*/
func (a *V2ApiService) TargetCreateOpenAI(ctx context.Context) ApiTargetCreateOpenAIRequest {
	return ApiTargetCreateOpenAIRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetCreateOutput
func (a *V2ApiService) TargetCreateOpenAIExecute(r ApiTargetCreateOpenAIRequest) (*TargetCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetCreateOpenAI")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-create-openai"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetCreatePingRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetCreatePing *TargetCreatePing
    body interface{}
}

func (r ApiTargetCreatePingRequest) TargetCreatePing(targetCreatePing TargetCreatePing) ApiTargetCreatePingRequest {
	r.targetCreatePing = &targetCreatePing
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetCreatePingRequest) Body(body TargetCreatePing) ApiTargetCreatePingRequest {
    r.body = body
    return r
}

func (r ApiTargetCreatePingRequest) Execute() (*TargetCreateOutput, *http.Response, error) {
	return r.ApiService.TargetCreatePingExecute(r)
}

/*
TargetCreatePing Method for TargetCreatePing

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetCreatePingRequest
*/
func (a *V2ApiService) TargetCreatePing(ctx context.Context) ApiTargetCreatePingRequest {
	return ApiTargetCreatePingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetCreateOutput
func (a *V2ApiService) TargetCreatePingExecute(r ApiTargetCreatePingRequest) (*TargetCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetCreatePing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-create-ping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetCreateRabbitMqRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetCreateRabbitMq *TargetCreateRabbitMq
    body interface{}
}

func (r ApiTargetCreateRabbitMqRequest) TargetCreateRabbitMq(targetCreateRabbitMq TargetCreateRabbitMq) ApiTargetCreateRabbitMqRequest {
	r.targetCreateRabbitMq = &targetCreateRabbitMq
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetCreateRabbitMqRequest) Body(body TargetCreateRabbitMq) ApiTargetCreateRabbitMqRequest {
    r.body = body
    return r
}

func (r ApiTargetCreateRabbitMqRequest) Execute() (*TargetCreateOutput, *http.Response, error) {
	return r.ApiService.TargetCreateRabbitMqExecute(r)
}

/*
TargetCreateRabbitMq Method for TargetCreateRabbitMq

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetCreateRabbitMqRequest
*/
func (a *V2ApiService) TargetCreateRabbitMq(ctx context.Context) ApiTargetCreateRabbitMqRequest {
	return ApiTargetCreateRabbitMqRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetCreateOutput
func (a *V2ApiService) TargetCreateRabbitMqExecute(r ApiTargetCreateRabbitMqRequest) (*TargetCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetCreateRabbitMq")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-create-rabbitmq"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetCreateSalesforceRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetCreateSalesforce *TargetCreateSalesforce
    body interface{}
}

func (r ApiTargetCreateSalesforceRequest) TargetCreateSalesforce(targetCreateSalesforce TargetCreateSalesforce) ApiTargetCreateSalesforceRequest {
	r.targetCreateSalesforce = &targetCreateSalesforce
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetCreateSalesforceRequest) Body(body TargetCreateSalesforce) ApiTargetCreateSalesforceRequest {
    r.body = body
    return r
}

func (r ApiTargetCreateSalesforceRequest) Execute() (*TargetCreateOutput, *http.Response, error) {
	return r.ApiService.TargetCreateSalesforceExecute(r)
}

/*
TargetCreateSalesforce Method for TargetCreateSalesforce

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetCreateSalesforceRequest
*/
func (a *V2ApiService) TargetCreateSalesforce(ctx context.Context) ApiTargetCreateSalesforceRequest {
	return ApiTargetCreateSalesforceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetCreateOutput
func (a *V2ApiService) TargetCreateSalesforceExecute(r ApiTargetCreateSalesforceRequest) (*TargetCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetCreateSalesforce")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-create-salesforce"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetCreateSectigoRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetCreateSectigo *TargetCreateSectigo
    body interface{}
}

func (r ApiTargetCreateSectigoRequest) TargetCreateSectigo(targetCreateSectigo TargetCreateSectigo) ApiTargetCreateSectigoRequest {
	r.targetCreateSectigo = &targetCreateSectigo
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetCreateSectigoRequest) Body(body TargetCreateSectigo) ApiTargetCreateSectigoRequest {
    r.body = body
    return r
}

func (r ApiTargetCreateSectigoRequest) Execute() (*TargetCreateOutput, *http.Response, error) {
	return r.ApiService.TargetCreateSectigoExecute(r)
}

/*
TargetCreateSectigo Method for TargetCreateSectigo

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetCreateSectigoRequest
*/
func (a *V2ApiService) TargetCreateSectigo(ctx context.Context) ApiTargetCreateSectigoRequest {
	return ApiTargetCreateSectigoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetCreateOutput
func (a *V2ApiService) TargetCreateSectigoExecute(r ApiTargetCreateSectigoRequest) (*TargetCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetCreateSectigo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-create-sectigo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetCreateSshRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetCreateSsh *TargetCreateSsh
    body interface{}
}

func (r ApiTargetCreateSshRequest) TargetCreateSsh(targetCreateSsh TargetCreateSsh) ApiTargetCreateSshRequest {
	r.targetCreateSsh = &targetCreateSsh
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetCreateSshRequest) Body(body TargetCreateSsh) ApiTargetCreateSshRequest {
    r.body = body
    return r
}

func (r ApiTargetCreateSshRequest) Execute() (*TargetCreateOutput, *http.Response, error) {
	return r.ApiService.TargetCreateSshExecute(r)
}

/*
TargetCreateSsh Method for TargetCreateSsh

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetCreateSshRequest
*/
func (a *V2ApiService) TargetCreateSsh(ctx context.Context) ApiTargetCreateSshRequest {
	return ApiTargetCreateSshRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetCreateOutput
func (a *V2ApiService) TargetCreateSshExecute(r ApiTargetCreateSshRequest) (*TargetCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetCreateSsh")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-create-ssh"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetCreateWebRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetCreateWeb *TargetCreateWeb
    body interface{}
}

func (r ApiTargetCreateWebRequest) TargetCreateWeb(targetCreateWeb TargetCreateWeb) ApiTargetCreateWebRequest {
	r.targetCreateWeb = &targetCreateWeb
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetCreateWebRequest) Body(body TargetCreateWeb) ApiTargetCreateWebRequest {
    r.body = body
    return r
}

func (r ApiTargetCreateWebRequest) Execute() (*TargetCreateOutput, *http.Response, error) {
	return r.ApiService.TargetCreateWebExecute(r)
}

/*
TargetCreateWeb Method for TargetCreateWeb

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetCreateWebRequest
*/
func (a *V2ApiService) TargetCreateWeb(ctx context.Context) ApiTargetCreateWebRequest {
	return ApiTargetCreateWebRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetCreateOutput
func (a *V2ApiService) TargetCreateWebExecute(r ApiTargetCreateWebRequest) (*TargetCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetCreateWeb")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-create-web"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetCreateWindowsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetCreateWindows *TargetCreateWindows
    body interface{}
}

func (r ApiTargetCreateWindowsRequest) TargetCreateWindows(targetCreateWindows TargetCreateWindows) ApiTargetCreateWindowsRequest {
	r.targetCreateWindows = &targetCreateWindows
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetCreateWindowsRequest) Body(body TargetCreateWindows) ApiTargetCreateWindowsRequest {
    r.body = body
    return r
}

func (r ApiTargetCreateWindowsRequest) Execute() (*TargetCreateOutput, *http.Response, error) {
	return r.ApiService.TargetCreateWindowsExecute(r)
}

/*
TargetCreateWindows Method for TargetCreateWindows

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetCreateWindowsRequest
*/
func (a *V2ApiService) TargetCreateWindows(ctx context.Context) ApiTargetCreateWindowsRequest {
	return ApiTargetCreateWindowsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetCreateOutput
func (a *V2ApiService) TargetCreateWindowsExecute(r ApiTargetCreateWindowsRequest) (*TargetCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetCreateWindows")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-create-windows"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetCreateZeroSSLRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetCreateZeroSSL *TargetCreateZeroSSL
    body interface{}
}

func (r ApiTargetCreateZeroSSLRequest) TargetCreateZeroSSL(targetCreateZeroSSL TargetCreateZeroSSL) ApiTargetCreateZeroSSLRequest {
	r.targetCreateZeroSSL = &targetCreateZeroSSL
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetCreateZeroSSLRequest) Body(body TargetCreateZeroSSL) ApiTargetCreateZeroSSLRequest {
    r.body = body
    return r
}

func (r ApiTargetCreateZeroSSLRequest) Execute() (*TargetCreateOutput, *http.Response, error) {
	return r.ApiService.TargetCreateZeroSSLExecute(r)
}

/*
TargetCreateZeroSSL Method for TargetCreateZeroSSL

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetCreateZeroSSLRequest
*/
func (a *V2ApiService) TargetCreateZeroSSL(ctx context.Context) ApiTargetCreateZeroSSLRequest {
	return ApiTargetCreateZeroSSLRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetCreateOutput
func (a *V2ApiService) TargetCreateZeroSSLExecute(r ApiTargetCreateZeroSSLRequest) (*TargetCreateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetCreateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetCreateZeroSSL")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-create-zerossl"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetDeleteRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetDelete *TargetDelete
    body interface{}
}

func (r ApiTargetDeleteRequest) TargetDelete(targetDelete TargetDelete) ApiTargetDeleteRequest {
	r.targetDelete = &targetDelete
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetDeleteRequest) Body(body TargetDelete) ApiTargetDeleteRequest {
    r.body = body
    return r
}

func (r ApiTargetDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.TargetDeleteExecute(r)
}

/*
TargetDelete Method for TargetDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetDeleteRequest
*/
func (a *V2ApiService) TargetDelete(ctx context.Context) ApiTargetDeleteRequest {
	return ApiTargetDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) TargetDeleteExecute(r ApiTargetDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetGetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetGet *TargetGet
    body interface{}
}

func (r ApiTargetGetRequest) TargetGet(targetGet TargetGet) ApiTargetGetRequest {
	r.targetGet = &targetGet
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetGetRequest) Body(body TargetGet) ApiTargetGetRequest {
    r.body = body
    return r
}

func (r ApiTargetGetRequest) Execute() (*Target, *http.Response, error) {
	return r.ApiService.TargetGetExecute(r)
}

/*
TargetGet Method for TargetGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetGetRequest
*/
func (a *V2ApiService) TargetGet(ctx context.Context) ApiTargetGetRequest {
	return ApiTargetGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Target
func (a *V2ApiService) TargetGetExecute(r ApiTargetGetRequest) (*Target, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Target
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetGetDetailsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetGetDetails *TargetGetDetails
    body interface{}
}

func (r ApiTargetGetDetailsRequest) TargetGetDetails(targetGetDetails TargetGetDetails) ApiTargetGetDetailsRequest {
	r.targetGetDetails = &targetGetDetails
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetGetDetailsRequest) Body(body TargetGetDetails) ApiTargetGetDetailsRequest {
    r.body = body
    return r
}

func (r ApiTargetGetDetailsRequest) Execute() (*GetTargetDetailsOutput, *http.Response, error) {
	return r.ApiService.TargetGetDetailsExecute(r)
}

/*
TargetGetDetails Method for TargetGetDetails

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetGetDetailsRequest
*/
func (a *V2ApiService) TargetGetDetails(ctx context.Context) ApiTargetGetDetailsRequest {
	return ApiTargetGetDetailsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTargetDetailsOutput
func (a *V2ApiService) TargetGetDetailsExecute(r ApiTargetGetDetailsRequest) (*GetTargetDetailsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTargetDetailsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetGetDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-get-details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetListRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetList *TargetList
    body interface{}
}

func (r ApiTargetListRequest) TargetList(targetList TargetList) ApiTargetListRequest {
	r.targetList = &targetList
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetListRequest) Body(body TargetList) ApiTargetListRequest {
    r.body = body
    return r
}

func (r ApiTargetListRequest) Execute() (*ListTargetsOutput, *http.Response, error) {
	return r.ApiService.TargetListExecute(r)
}

/*
TargetList Method for TargetList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetListRequest
*/
func (a *V2ApiService) TargetList(ctx context.Context) ApiTargetListRequest {
	return ApiTargetListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListTargetsOutput
func (a *V2ApiService) TargetListExecute(r ApiTargetListRequest) (*ListTargetsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListTargetsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetUpdateArtifactoryRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetUpdateArtifactory *TargetUpdateArtifactory
    body interface{}
}

func (r ApiTargetUpdateArtifactoryRequest) TargetUpdateArtifactory(targetUpdateArtifactory TargetUpdateArtifactory) ApiTargetUpdateArtifactoryRequest {
	r.targetUpdateArtifactory = &targetUpdateArtifactory
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetUpdateArtifactoryRequest) Body(body TargetUpdateArtifactory) ApiTargetUpdateArtifactoryRequest {
    r.body = body
    return r
}

func (r ApiTargetUpdateArtifactoryRequest) Execute() (*TargetUpdateOutput, *http.Response, error) {
	return r.ApiService.TargetUpdateArtifactoryExecute(r)
}

/*
TargetUpdateArtifactory Method for TargetUpdateArtifactory

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetUpdateArtifactoryRequest
*/
func (a *V2ApiService) TargetUpdateArtifactory(ctx context.Context) ApiTargetUpdateArtifactoryRequest {
	return ApiTargetUpdateArtifactoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetUpdateOutput
func (a *V2ApiService) TargetUpdateArtifactoryExecute(r ApiTargetUpdateArtifactoryRequest) (*TargetUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetUpdateArtifactory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-update-artifactory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetUpdateAwsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetUpdateAws *TargetUpdateAws
    body interface{}
}

func (r ApiTargetUpdateAwsRequest) TargetUpdateAws(targetUpdateAws TargetUpdateAws) ApiTargetUpdateAwsRequest {
	r.targetUpdateAws = &targetUpdateAws
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetUpdateAwsRequest) Body(body TargetUpdateAws) ApiTargetUpdateAwsRequest {
    r.body = body
    return r
}

func (r ApiTargetUpdateAwsRequest) Execute() (*TargetUpdateOutput, *http.Response, error) {
	return r.ApiService.TargetUpdateAwsExecute(r)
}

/*
TargetUpdateAws Method for TargetUpdateAws

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetUpdateAwsRequest
*/
func (a *V2ApiService) TargetUpdateAws(ctx context.Context) ApiTargetUpdateAwsRequest {
	return ApiTargetUpdateAwsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetUpdateOutput
func (a *V2ApiService) TargetUpdateAwsExecute(r ApiTargetUpdateAwsRequest) (*TargetUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetUpdateAws")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-update-aws"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetUpdateAzureRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetUpdateAzure *TargetUpdateAzure
    body interface{}
}

func (r ApiTargetUpdateAzureRequest) TargetUpdateAzure(targetUpdateAzure TargetUpdateAzure) ApiTargetUpdateAzureRequest {
	r.targetUpdateAzure = &targetUpdateAzure
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetUpdateAzureRequest) Body(body TargetUpdateAzure) ApiTargetUpdateAzureRequest {
    r.body = body
    return r
}

func (r ApiTargetUpdateAzureRequest) Execute() (*TargetUpdateOutput, *http.Response, error) {
	return r.ApiService.TargetUpdateAzureExecute(r)
}

/*
TargetUpdateAzure Method for TargetUpdateAzure

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetUpdateAzureRequest
*/
func (a *V2ApiService) TargetUpdateAzure(ctx context.Context) ApiTargetUpdateAzureRequest {
	return ApiTargetUpdateAzureRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetUpdateOutput
func (a *V2ApiService) TargetUpdateAzureExecute(r ApiTargetUpdateAzureRequest) (*TargetUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetUpdateAzure")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-update-azure"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetUpdateDBRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetUpdateDB *TargetUpdateDB
    body interface{}
}

func (r ApiTargetUpdateDBRequest) TargetUpdateDB(targetUpdateDB TargetUpdateDB) ApiTargetUpdateDBRequest {
	r.targetUpdateDB = &targetUpdateDB
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetUpdateDBRequest) Body(body TargetUpdateDB) ApiTargetUpdateDBRequest {
    r.body = body
    return r
}

func (r ApiTargetUpdateDBRequest) Execute() (*TargetUpdateOutput, *http.Response, error) {
	return r.ApiService.TargetUpdateDBExecute(r)
}

/*
TargetUpdateDB Method for TargetUpdateDB

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetUpdateDBRequest
*/
func (a *V2ApiService) TargetUpdateDB(ctx context.Context) ApiTargetUpdateDBRequest {
	return ApiTargetUpdateDBRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetUpdateOutput
func (a *V2ApiService) TargetUpdateDBExecute(r ApiTargetUpdateDBRequest) (*TargetUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetUpdateDB")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-update-db"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetUpdateDockerhubRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetUpdateDockerhub *TargetUpdateDockerhub
    body interface{}
}

func (r ApiTargetUpdateDockerhubRequest) TargetUpdateDockerhub(targetUpdateDockerhub TargetUpdateDockerhub) ApiTargetUpdateDockerhubRequest {
	r.targetUpdateDockerhub = &targetUpdateDockerhub
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetUpdateDockerhubRequest) Body(body TargetUpdateDockerhub) ApiTargetUpdateDockerhubRequest {
    r.body = body
    return r
}

func (r ApiTargetUpdateDockerhubRequest) Execute() (*TargetUpdateOutput, *http.Response, error) {
	return r.ApiService.TargetUpdateDockerhubExecute(r)
}

/*
TargetUpdateDockerhub Method for TargetUpdateDockerhub

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetUpdateDockerhubRequest
*/
func (a *V2ApiService) TargetUpdateDockerhub(ctx context.Context) ApiTargetUpdateDockerhubRequest {
	return ApiTargetUpdateDockerhubRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetUpdateOutput
func (a *V2ApiService) TargetUpdateDockerhubExecute(r ApiTargetUpdateDockerhubRequest) (*TargetUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetUpdateDockerhub")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-update-dockerhub"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetUpdateEksRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetUpdateEks *TargetUpdateEks
    body interface{}
}

func (r ApiTargetUpdateEksRequest) TargetUpdateEks(targetUpdateEks TargetUpdateEks) ApiTargetUpdateEksRequest {
	r.targetUpdateEks = &targetUpdateEks
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetUpdateEksRequest) Body(body TargetUpdateEks) ApiTargetUpdateEksRequest {
    r.body = body
    return r
}

func (r ApiTargetUpdateEksRequest) Execute() (*TargetUpdateOutput, *http.Response, error) {
	return r.ApiService.TargetUpdateEksExecute(r)
}

/*
TargetUpdateEks Method for TargetUpdateEks

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetUpdateEksRequest
*/
func (a *V2ApiService) TargetUpdateEks(ctx context.Context) ApiTargetUpdateEksRequest {
	return ApiTargetUpdateEksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetUpdateOutput
func (a *V2ApiService) TargetUpdateEksExecute(r ApiTargetUpdateEksRequest) (*TargetUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetUpdateEks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-update-eks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetUpdateGcpRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetUpdateGcp *TargetUpdateGcp
    body interface{}
}

func (r ApiTargetUpdateGcpRequest) TargetUpdateGcp(targetUpdateGcp TargetUpdateGcp) ApiTargetUpdateGcpRequest {
	r.targetUpdateGcp = &targetUpdateGcp
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetUpdateGcpRequest) Body(body TargetUpdateGcp) ApiTargetUpdateGcpRequest {
    r.body = body
    return r
}

func (r ApiTargetUpdateGcpRequest) Execute() (*TargetUpdateOutput, *http.Response, error) {
	return r.ApiService.TargetUpdateGcpExecute(r)
}

/*
TargetUpdateGcp Method for TargetUpdateGcp

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetUpdateGcpRequest
*/
func (a *V2ApiService) TargetUpdateGcp(ctx context.Context) ApiTargetUpdateGcpRequest {
	return ApiTargetUpdateGcpRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetUpdateOutput
func (a *V2ApiService) TargetUpdateGcpExecute(r ApiTargetUpdateGcpRequest) (*TargetUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetUpdateGcp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-update-gcp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetUpdateGeminiRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetUpdateGemini *TargetUpdateGemini
    body interface{}
}

func (r ApiTargetUpdateGeminiRequest) TargetUpdateGemini(targetUpdateGemini TargetUpdateGemini) ApiTargetUpdateGeminiRequest {
	r.targetUpdateGemini = &targetUpdateGemini
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetUpdateGeminiRequest) Body(body TargetUpdateGemini) ApiTargetUpdateGeminiRequest {
    r.body = body
    return r
}

func (r ApiTargetUpdateGeminiRequest) Execute() (*TargetUpdateOutput, *http.Response, error) {
	return r.ApiService.TargetUpdateGeminiExecute(r)
}

/*
TargetUpdateGemini Method for TargetUpdateGemini

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetUpdateGeminiRequest
*/
func (a *V2ApiService) TargetUpdateGemini(ctx context.Context) ApiTargetUpdateGeminiRequest {
	return ApiTargetUpdateGeminiRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetUpdateOutput
func (a *V2ApiService) TargetUpdateGeminiExecute(r ApiTargetUpdateGeminiRequest) (*TargetUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetUpdateGemini")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-update-gemini"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetUpdateGithubRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetUpdateGithub *TargetUpdateGithub
    body interface{}
}

func (r ApiTargetUpdateGithubRequest) TargetUpdateGithub(targetUpdateGithub TargetUpdateGithub) ApiTargetUpdateGithubRequest {
	r.targetUpdateGithub = &targetUpdateGithub
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetUpdateGithubRequest) Body(body TargetUpdateGithub) ApiTargetUpdateGithubRequest {
    r.body = body
    return r
}

func (r ApiTargetUpdateGithubRequest) Execute() (*TargetUpdateOutput, *http.Response, error) {
	return r.ApiService.TargetUpdateGithubExecute(r)
}

/*
TargetUpdateGithub Method for TargetUpdateGithub

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetUpdateGithubRequest
*/
func (a *V2ApiService) TargetUpdateGithub(ctx context.Context) ApiTargetUpdateGithubRequest {
	return ApiTargetUpdateGithubRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetUpdateOutput
func (a *V2ApiService) TargetUpdateGithubExecute(r ApiTargetUpdateGithubRequest) (*TargetUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetUpdateGithub")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-update-github"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetUpdateGitlabRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetUpdateGitlab *TargetUpdateGitlab
    body interface{}
}

func (r ApiTargetUpdateGitlabRequest) TargetUpdateGitlab(targetUpdateGitlab TargetUpdateGitlab) ApiTargetUpdateGitlabRequest {
	r.targetUpdateGitlab = &targetUpdateGitlab
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetUpdateGitlabRequest) Body(body TargetUpdateGitlab) ApiTargetUpdateGitlabRequest {
    r.body = body
    return r
}

func (r ApiTargetUpdateGitlabRequest) Execute() (*TargetUpdateOutput, *http.Response, error) {
	return r.ApiService.TargetUpdateGitlabExecute(r)
}

/*
TargetUpdateGitlab Method for TargetUpdateGitlab

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetUpdateGitlabRequest
*/
func (a *V2ApiService) TargetUpdateGitlab(ctx context.Context) ApiTargetUpdateGitlabRequest {
	return ApiTargetUpdateGitlabRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetUpdateOutput
func (a *V2ApiService) TargetUpdateGitlabExecute(r ApiTargetUpdateGitlabRequest) (*TargetUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetUpdateGitlab")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-update-gitlab"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetUpdateGkeRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetUpdateGke *TargetUpdateGke
    body interface{}
}

func (r ApiTargetUpdateGkeRequest) TargetUpdateGke(targetUpdateGke TargetUpdateGke) ApiTargetUpdateGkeRequest {
	r.targetUpdateGke = &targetUpdateGke
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetUpdateGkeRequest) Body(body TargetUpdateGke) ApiTargetUpdateGkeRequest {
    r.body = body
    return r
}

func (r ApiTargetUpdateGkeRequest) Execute() (*TargetUpdateOutput, *http.Response, error) {
	return r.ApiService.TargetUpdateGkeExecute(r)
}

/*
TargetUpdateGke Method for TargetUpdateGke

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetUpdateGkeRequest
*/
func (a *V2ApiService) TargetUpdateGke(ctx context.Context) ApiTargetUpdateGkeRequest {
	return ApiTargetUpdateGkeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetUpdateOutput
func (a *V2ApiService) TargetUpdateGkeExecute(r ApiTargetUpdateGkeRequest) (*TargetUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetUpdateGke")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-update-gke"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetUpdateGlobalSignRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetUpdateGlobalSign *TargetUpdateGlobalSign
    body interface{}
}

func (r ApiTargetUpdateGlobalSignRequest) TargetUpdateGlobalSign(targetUpdateGlobalSign TargetUpdateGlobalSign) ApiTargetUpdateGlobalSignRequest {
	r.targetUpdateGlobalSign = &targetUpdateGlobalSign
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetUpdateGlobalSignRequest) Body(body TargetUpdateGlobalSign) ApiTargetUpdateGlobalSignRequest {
    r.body = body
    return r
}

func (r ApiTargetUpdateGlobalSignRequest) Execute() (*TargetUpdateOutput, *http.Response, error) {
	return r.ApiService.TargetUpdateGlobalSignExecute(r)
}

/*
TargetUpdateGlobalSign Method for TargetUpdateGlobalSign

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetUpdateGlobalSignRequest
*/
func (a *V2ApiService) TargetUpdateGlobalSign(ctx context.Context) ApiTargetUpdateGlobalSignRequest {
	return ApiTargetUpdateGlobalSignRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetUpdateOutput
func (a *V2ApiService) TargetUpdateGlobalSignExecute(r ApiTargetUpdateGlobalSignRequest) (*TargetUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetUpdateGlobalSign")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-update-globalsign"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetUpdateGlobalSignAtlasRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetUpdateGlobalSignAtlas *TargetUpdateGlobalSignAtlas
    body interface{}
}

func (r ApiTargetUpdateGlobalSignAtlasRequest) TargetUpdateGlobalSignAtlas(targetUpdateGlobalSignAtlas TargetUpdateGlobalSignAtlas) ApiTargetUpdateGlobalSignAtlasRequest {
	r.targetUpdateGlobalSignAtlas = &targetUpdateGlobalSignAtlas
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetUpdateGlobalSignAtlasRequest) Body(body TargetUpdateGlobalSignAtlas) ApiTargetUpdateGlobalSignAtlasRequest {
    r.body = body
    return r
}

func (r ApiTargetUpdateGlobalSignAtlasRequest) Execute() (*TargetUpdateOutput, *http.Response, error) {
	return r.ApiService.TargetUpdateGlobalSignAtlasExecute(r)
}

/*
TargetUpdateGlobalSignAtlas Method for TargetUpdateGlobalSignAtlas

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetUpdateGlobalSignAtlasRequest
*/
func (a *V2ApiService) TargetUpdateGlobalSignAtlas(ctx context.Context) ApiTargetUpdateGlobalSignAtlasRequest {
	return ApiTargetUpdateGlobalSignAtlasRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetUpdateOutput
func (a *V2ApiService) TargetUpdateGlobalSignAtlasExecute(r ApiTargetUpdateGlobalSignAtlasRequest) (*TargetUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetUpdateGlobalSignAtlas")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-update-globalsign-atlas"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetUpdateGodaddyRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetUpdateGodaddy *TargetUpdateGodaddy
    body interface{}
}

func (r ApiTargetUpdateGodaddyRequest) TargetUpdateGodaddy(targetUpdateGodaddy TargetUpdateGodaddy) ApiTargetUpdateGodaddyRequest {
	r.targetUpdateGodaddy = &targetUpdateGodaddy
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetUpdateGodaddyRequest) Body(body TargetUpdateGodaddy) ApiTargetUpdateGodaddyRequest {
    r.body = body
    return r
}

func (r ApiTargetUpdateGodaddyRequest) Execute() (*TargetUpdateOutput, *http.Response, error) {
	return r.ApiService.TargetUpdateGodaddyExecute(r)
}

/*
TargetUpdateGodaddy Method for TargetUpdateGodaddy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetUpdateGodaddyRequest
*/
func (a *V2ApiService) TargetUpdateGodaddy(ctx context.Context) ApiTargetUpdateGodaddyRequest {
	return ApiTargetUpdateGodaddyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetUpdateOutput
func (a *V2ApiService) TargetUpdateGodaddyExecute(r ApiTargetUpdateGodaddyRequest) (*TargetUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetUpdateGodaddy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-update-godaddy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetUpdateHashiVaultRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetUpdateHashiVault *TargetUpdateHashiVault
    body interface{}
}

func (r ApiTargetUpdateHashiVaultRequest) TargetUpdateHashiVault(targetUpdateHashiVault TargetUpdateHashiVault) ApiTargetUpdateHashiVaultRequest {
	r.targetUpdateHashiVault = &targetUpdateHashiVault
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetUpdateHashiVaultRequest) Body(body TargetUpdateHashiVault) ApiTargetUpdateHashiVaultRequest {
    r.body = body
    return r
}

func (r ApiTargetUpdateHashiVaultRequest) Execute() (*TargetUpdateOutput, *http.Response, error) {
	return r.ApiService.TargetUpdateHashiVaultExecute(r)
}

/*
TargetUpdateHashiVault Method for TargetUpdateHashiVault

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetUpdateHashiVaultRequest
*/
func (a *V2ApiService) TargetUpdateHashiVault(ctx context.Context) ApiTargetUpdateHashiVaultRequest {
	return ApiTargetUpdateHashiVaultRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetUpdateOutput
func (a *V2ApiService) TargetUpdateHashiVaultExecute(r ApiTargetUpdateHashiVaultRequest) (*TargetUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetUpdateHashiVault")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-update-hashi-vault"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetUpdateK8sRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetUpdateK8s *TargetUpdateK8s
    body interface{}
}

func (r ApiTargetUpdateK8sRequest) TargetUpdateK8s(targetUpdateK8s TargetUpdateK8s) ApiTargetUpdateK8sRequest {
	r.targetUpdateK8s = &targetUpdateK8s
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetUpdateK8sRequest) Body(body TargetUpdateK8s) ApiTargetUpdateK8sRequest {
    r.body = body
    return r
}

func (r ApiTargetUpdateK8sRequest) Execute() (*TargetUpdateOutput, *http.Response, error) {
	return r.ApiService.TargetUpdateK8sExecute(r)
}

/*
TargetUpdateK8s Method for TargetUpdateK8s

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetUpdateK8sRequest
*/
func (a *V2ApiService) TargetUpdateK8s(ctx context.Context) ApiTargetUpdateK8sRequest {
	return ApiTargetUpdateK8sRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetUpdateOutput
func (a *V2ApiService) TargetUpdateK8sExecute(r ApiTargetUpdateK8sRequest) (*TargetUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetUpdateK8s")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-update-k8s"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetUpdateLdapRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetUpdateLdap *TargetUpdateLdap
    body interface{}
}

func (r ApiTargetUpdateLdapRequest) TargetUpdateLdap(targetUpdateLdap TargetUpdateLdap) ApiTargetUpdateLdapRequest {
	r.targetUpdateLdap = &targetUpdateLdap
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetUpdateLdapRequest) Body(body TargetUpdateLdap) ApiTargetUpdateLdapRequest {
    r.body = body
    return r
}

func (r ApiTargetUpdateLdapRequest) Execute() (*TargetUpdateOutput, *http.Response, error) {
	return r.ApiService.TargetUpdateLdapExecute(r)
}

/*
TargetUpdateLdap Method for TargetUpdateLdap

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetUpdateLdapRequest
*/
func (a *V2ApiService) TargetUpdateLdap(ctx context.Context) ApiTargetUpdateLdapRequest {
	return ApiTargetUpdateLdapRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetUpdateOutput
func (a *V2ApiService) TargetUpdateLdapExecute(r ApiTargetUpdateLdapRequest) (*TargetUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetUpdateLdap")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-update-ldap"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetUpdateLinkedRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetUpdateLinked *TargetUpdateLinked
    body interface{}
}

func (r ApiTargetUpdateLinkedRequest) TargetUpdateLinked(targetUpdateLinked TargetUpdateLinked) ApiTargetUpdateLinkedRequest {
	r.targetUpdateLinked = &targetUpdateLinked
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetUpdateLinkedRequest) Body(body TargetUpdateLinked) ApiTargetUpdateLinkedRequest {
    r.body = body
    return r
}

func (r ApiTargetUpdateLinkedRequest) Execute() (*TargetUpdateOutput, *http.Response, error) {
	return r.ApiService.TargetUpdateLinkedExecute(r)
}

/*
TargetUpdateLinked Method for TargetUpdateLinked

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetUpdateLinkedRequest
*/
func (a *V2ApiService) TargetUpdateLinked(ctx context.Context) ApiTargetUpdateLinkedRequest {
	return ApiTargetUpdateLinkedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetUpdateOutput
func (a *V2ApiService) TargetUpdateLinkedExecute(r ApiTargetUpdateLinkedRequest) (*TargetUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetUpdateLinked")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-update-linked"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetUpdateOpenAIRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetUpdateOpenAI *TargetUpdateOpenAI
    body interface{}
}

func (r ApiTargetUpdateOpenAIRequest) TargetUpdateOpenAI(targetUpdateOpenAI TargetUpdateOpenAI) ApiTargetUpdateOpenAIRequest {
	r.targetUpdateOpenAI = &targetUpdateOpenAI
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetUpdateOpenAIRequest) Body(body TargetUpdateOpenAI) ApiTargetUpdateOpenAIRequest {
    r.body = body
    return r
}

func (r ApiTargetUpdateOpenAIRequest) Execute() (*TargetUpdateOutput, *http.Response, error) {
	return r.ApiService.TargetUpdateOpenAIExecute(r)
}

/*
TargetUpdateOpenAI Method for TargetUpdateOpenAI

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetUpdateOpenAIRequest
*/
func (a *V2ApiService) TargetUpdateOpenAI(ctx context.Context) ApiTargetUpdateOpenAIRequest {
	return ApiTargetUpdateOpenAIRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetUpdateOutput
func (a *V2ApiService) TargetUpdateOpenAIExecute(r ApiTargetUpdateOpenAIRequest) (*TargetUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetUpdateOpenAI")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-update-openai"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetUpdatePingRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetUpdatePing *TargetUpdatePing
    body interface{}
}

func (r ApiTargetUpdatePingRequest) TargetUpdatePing(targetUpdatePing TargetUpdatePing) ApiTargetUpdatePingRequest {
	r.targetUpdatePing = &targetUpdatePing
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetUpdatePingRequest) Body(body TargetUpdatePing) ApiTargetUpdatePingRequest {
    r.body = body
    return r
}

func (r ApiTargetUpdatePingRequest) Execute() (*TargetUpdateOutput, *http.Response, error) {
	return r.ApiService.TargetUpdatePingExecute(r)
}

/*
TargetUpdatePing Method for TargetUpdatePing

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetUpdatePingRequest
*/
func (a *V2ApiService) TargetUpdatePing(ctx context.Context) ApiTargetUpdatePingRequest {
	return ApiTargetUpdatePingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetUpdateOutput
func (a *V2ApiService) TargetUpdatePingExecute(r ApiTargetUpdatePingRequest) (*TargetUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetUpdatePing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-update-ping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetUpdateRabbitMqRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetUpdateRabbitMq *TargetUpdateRabbitMq
    body interface{}
}

func (r ApiTargetUpdateRabbitMqRequest) TargetUpdateRabbitMq(targetUpdateRabbitMq TargetUpdateRabbitMq) ApiTargetUpdateRabbitMqRequest {
	r.targetUpdateRabbitMq = &targetUpdateRabbitMq
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetUpdateRabbitMqRequest) Body(body TargetUpdateRabbitMq) ApiTargetUpdateRabbitMqRequest {
    r.body = body
    return r
}

func (r ApiTargetUpdateRabbitMqRequest) Execute() (*TargetUpdateOutput, *http.Response, error) {
	return r.ApiService.TargetUpdateRabbitMqExecute(r)
}

/*
TargetUpdateRabbitMq Method for TargetUpdateRabbitMq

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetUpdateRabbitMqRequest
*/
func (a *V2ApiService) TargetUpdateRabbitMq(ctx context.Context) ApiTargetUpdateRabbitMqRequest {
	return ApiTargetUpdateRabbitMqRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetUpdateOutput
func (a *V2ApiService) TargetUpdateRabbitMqExecute(r ApiTargetUpdateRabbitMqRequest) (*TargetUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetUpdateRabbitMq")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-update-rabbitmq"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetUpdateSalesforceRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetUpdateSalesforce *TargetUpdateSalesforce
    body interface{}
}

func (r ApiTargetUpdateSalesforceRequest) TargetUpdateSalesforce(targetUpdateSalesforce TargetUpdateSalesforce) ApiTargetUpdateSalesforceRequest {
	r.targetUpdateSalesforce = &targetUpdateSalesforce
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetUpdateSalesforceRequest) Body(body TargetUpdateSalesforce) ApiTargetUpdateSalesforceRequest {
    r.body = body
    return r
}

func (r ApiTargetUpdateSalesforceRequest) Execute() (*TargetUpdateOutput, *http.Response, error) {
	return r.ApiService.TargetUpdateSalesforceExecute(r)
}

/*
TargetUpdateSalesforce Method for TargetUpdateSalesforce

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetUpdateSalesforceRequest
*/
func (a *V2ApiService) TargetUpdateSalesforce(ctx context.Context) ApiTargetUpdateSalesforceRequest {
	return ApiTargetUpdateSalesforceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetUpdateOutput
func (a *V2ApiService) TargetUpdateSalesforceExecute(r ApiTargetUpdateSalesforceRequest) (*TargetUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetUpdateSalesforce")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-update-salesforce"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetUpdateSectigoRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetUpdateSectigo *TargetUpdateSectigo
    body interface{}
}

func (r ApiTargetUpdateSectigoRequest) TargetUpdateSectigo(targetUpdateSectigo TargetUpdateSectigo) ApiTargetUpdateSectigoRequest {
	r.targetUpdateSectigo = &targetUpdateSectigo
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetUpdateSectigoRequest) Body(body TargetUpdateSectigo) ApiTargetUpdateSectigoRequest {
    r.body = body
    return r
}

func (r ApiTargetUpdateSectigoRequest) Execute() (*TargetUpdateOutput, *http.Response, error) {
	return r.ApiService.TargetUpdateSectigoExecute(r)
}

/*
TargetUpdateSectigo Method for TargetUpdateSectigo

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetUpdateSectigoRequest
*/
func (a *V2ApiService) TargetUpdateSectigo(ctx context.Context) ApiTargetUpdateSectigoRequest {
	return ApiTargetUpdateSectigoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetUpdateOutput
func (a *V2ApiService) TargetUpdateSectigoExecute(r ApiTargetUpdateSectigoRequest) (*TargetUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetUpdateSectigo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-update-sectigo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetUpdateSshRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetUpdateSsh *TargetUpdateSsh
    body interface{}
}

func (r ApiTargetUpdateSshRequest) TargetUpdateSsh(targetUpdateSsh TargetUpdateSsh) ApiTargetUpdateSshRequest {
	r.targetUpdateSsh = &targetUpdateSsh
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetUpdateSshRequest) Body(body TargetUpdateSsh) ApiTargetUpdateSshRequest {
    r.body = body
    return r
}

func (r ApiTargetUpdateSshRequest) Execute() (*TargetUpdateOutput, *http.Response, error) {
	return r.ApiService.TargetUpdateSshExecute(r)
}

/*
TargetUpdateSsh Method for TargetUpdateSsh

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetUpdateSshRequest
*/
func (a *V2ApiService) TargetUpdateSsh(ctx context.Context) ApiTargetUpdateSshRequest {
	return ApiTargetUpdateSshRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetUpdateOutput
func (a *V2ApiService) TargetUpdateSshExecute(r ApiTargetUpdateSshRequest) (*TargetUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetUpdateSsh")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-update-ssh"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetUpdateWebRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetUpdateWeb *TargetUpdateWeb
    body interface{}
}

func (r ApiTargetUpdateWebRequest) TargetUpdateWeb(targetUpdateWeb TargetUpdateWeb) ApiTargetUpdateWebRequest {
	r.targetUpdateWeb = &targetUpdateWeb
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetUpdateWebRequest) Body(body TargetUpdateWeb) ApiTargetUpdateWebRequest {
    r.body = body
    return r
}

func (r ApiTargetUpdateWebRequest) Execute() (*TargetUpdateOutput, *http.Response, error) {
	return r.ApiService.TargetUpdateWebExecute(r)
}

/*
TargetUpdateWeb Method for TargetUpdateWeb

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetUpdateWebRequest
*/
func (a *V2ApiService) TargetUpdateWeb(ctx context.Context) ApiTargetUpdateWebRequest {
	return ApiTargetUpdateWebRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetUpdateOutput
func (a *V2ApiService) TargetUpdateWebExecute(r ApiTargetUpdateWebRequest) (*TargetUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetUpdateWeb")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-update-web"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetUpdateWindowsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetUpdateWindows *TargetUpdateWindows
    body interface{}
}

func (r ApiTargetUpdateWindowsRequest) TargetUpdateWindows(targetUpdateWindows TargetUpdateWindows) ApiTargetUpdateWindowsRequest {
	r.targetUpdateWindows = &targetUpdateWindows
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetUpdateWindowsRequest) Body(body TargetUpdateWindows) ApiTargetUpdateWindowsRequest {
    r.body = body
    return r
}

func (r ApiTargetUpdateWindowsRequest) Execute() (*TargetUpdateOutput, *http.Response, error) {
	return r.ApiService.TargetUpdateWindowsExecute(r)
}

/*
TargetUpdateWindows Method for TargetUpdateWindows

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetUpdateWindowsRequest
*/
func (a *V2ApiService) TargetUpdateWindows(ctx context.Context) ApiTargetUpdateWindowsRequest {
	return ApiTargetUpdateWindowsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetUpdateOutput
func (a *V2ApiService) TargetUpdateWindowsExecute(r ApiTargetUpdateWindowsRequest) (*TargetUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetUpdateWindows")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-update-windows"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTargetUpdateZeroSSLRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	targetUpdateZeroSSL *TargetUpdateZeroSSL
    body interface{}
}

func (r ApiTargetUpdateZeroSSLRequest) TargetUpdateZeroSSL(targetUpdateZeroSSL TargetUpdateZeroSSL) ApiTargetUpdateZeroSSLRequest {
	r.targetUpdateZeroSSL = &targetUpdateZeroSSL
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTargetUpdateZeroSSLRequest) Body(body TargetUpdateZeroSSL) ApiTargetUpdateZeroSSLRequest {
    r.body = body
    return r
}

func (r ApiTargetUpdateZeroSSLRequest) Execute() (*TargetUpdateOutput, *http.Response, error) {
	return r.ApiService.TargetUpdateZeroSSLExecute(r)
}

/*
TargetUpdateZeroSSL Method for TargetUpdateZeroSSL

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTargetUpdateZeroSSLRequest
*/
func (a *V2ApiService) TargetUpdateZeroSSL(ctx context.Context) ApiTargetUpdateZeroSSLRequest {
	return ApiTargetUpdateZeroSSLRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TargetUpdateOutput
func (a *V2ApiService) TargetUpdateZeroSSLExecute(r ApiTargetUpdateZeroSSLRequest) (*TargetUpdateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TargetUpdateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TargetUpdateZeroSSL")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/target-update-zerossl"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTokenizeRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	tokenize *Tokenize
    body interface{}
}

func (r ApiTokenizeRequest) Tokenize(tokenize Tokenize) ApiTokenizeRequest {
	r.tokenize = &tokenize
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTokenizeRequest) Body(body Tokenize) ApiTokenizeRequest {
    r.body = body
    return r
}

func (r ApiTokenizeRequest) Execute() (*TokenizeOutput, *http.Response, error) {
	return r.ApiService.TokenizeExecute(r)
}

/*
Tokenize Method for Tokenize

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTokenizeRequest
*/
func (a *V2ApiService) Tokenize(ctx context.Context) ApiTokenizeRequest {
	return ApiTokenizeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TokenizeOutput
func (a *V2ApiService) TokenizeExecute(r ApiTokenizeRequest) (*TokenizeOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TokenizeOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.Tokenize")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tokenize"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTokenizeBatchRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	batchTokenizationRequestLine *[]BatchTokenizationRequestLine
    body interface{}
}

func (r ApiTokenizeBatchRequest) BatchTokenizationRequestLine(batchTokenizationRequestLine []BatchTokenizationRequestLine) ApiTokenizeBatchRequest {
	r.batchTokenizationRequestLine = &batchTokenizationRequestLine
	return r
}


    // Body sets the body payload for the API call.
func (r ApiTokenizeBatchRequest) Body(body []BatchTokenizationRequestLine) ApiTokenizeBatchRequest {
    r.body = body
    return r
}

func (r ApiTokenizeBatchRequest) Execute() (*TokenizeOutput, *http.Response, error) {
	return r.ApiService.TokenizeBatchExecute(r)
}

/*
TokenizeBatch Method for TokenizeBatch

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTokenizeBatchRequest
*/
func (a *V2ApiService) TokenizeBatch(ctx context.Context) ApiTokenizeBatchRequest {
	return ApiTokenizeBatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TokenizeOutput
func (a *V2ApiService) TokenizeBatchExecute(r ApiTokenizeBatchRequest) (*TokenizeOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TokenizeOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.TokenizeBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tokenize-batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUidCreateChildTokenRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	uidCreateChildToken *UidCreateChildToken
    body interface{}
}

func (r ApiUidCreateChildTokenRequest) UidCreateChildToken(uidCreateChildToken UidCreateChildToken) ApiUidCreateChildTokenRequest {
	r.uidCreateChildToken = &uidCreateChildToken
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUidCreateChildTokenRequest) Body(body UidCreateChildToken) ApiUidCreateChildTokenRequest {
    r.body = body
    return r
}

func (r ApiUidCreateChildTokenRequest) Execute() (*UidCreateChildTokenOutput, *http.Response, error) {
	return r.ApiService.UidCreateChildTokenExecute(r)
}

/*
UidCreateChildToken Method for UidCreateChildToken

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUidCreateChildTokenRequest
*/
func (a *V2ApiService) UidCreateChildToken(ctx context.Context) ApiUidCreateChildTokenRequest {
	return ApiUidCreateChildTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UidCreateChildTokenOutput
func (a *V2ApiService) UidCreateChildTokenExecute(r ApiUidCreateChildTokenRequest) (*UidCreateChildTokenOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UidCreateChildTokenOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UidCreateChildToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/uid-create-child-token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUidGenerateTokenRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	uidGenerateToken *UidGenerateToken
    body interface{}
}

func (r ApiUidGenerateTokenRequest) UidGenerateToken(uidGenerateToken UidGenerateToken) ApiUidGenerateTokenRequest {
	r.uidGenerateToken = &uidGenerateToken
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUidGenerateTokenRequest) Body(body UidGenerateToken) ApiUidGenerateTokenRequest {
    r.body = body
    return r
}

func (r ApiUidGenerateTokenRequest) Execute() (*UidGenerateTokenOutput, *http.Response, error) {
	return r.ApiService.UidGenerateTokenExecute(r)
}

/*
UidGenerateToken Method for UidGenerateToken

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUidGenerateTokenRequest
*/
func (a *V2ApiService) UidGenerateToken(ctx context.Context) ApiUidGenerateTokenRequest {
	return ApiUidGenerateTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UidGenerateTokenOutput
func (a *V2ApiService) UidGenerateTokenExecute(r ApiUidGenerateTokenRequest) (*UidGenerateTokenOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UidGenerateTokenOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UidGenerateToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/uid-generate-token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUidListChildrenRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	uidListChildren *UidListChildren
    body interface{}
}

func (r ApiUidListChildrenRequest) UidListChildren(uidListChildren UidListChildren) ApiUidListChildrenRequest {
	r.uidListChildren = &uidListChildren
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUidListChildrenRequest) Body(body UidListChildren) ApiUidListChildrenRequest {
    r.body = body
    return r
}

func (r ApiUidListChildrenRequest) Execute() (*UniversalIdentityDetails, *http.Response, error) {
	return r.ApiService.UidListChildrenExecute(r)
}

/*
UidListChildren Method for UidListChildren

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUidListChildrenRequest
*/
func (a *V2ApiService) UidListChildren(ctx context.Context) ApiUidListChildrenRequest {
	return ApiUidListChildrenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UniversalIdentityDetails
func (a *V2ApiService) UidListChildrenExecute(r ApiUidListChildrenRequest) (*UniversalIdentityDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UniversalIdentityDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UidListChildren")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/uid-list-children"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUidRevokeTokenRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	uidRevokeToken *UidRevokeToken
    body interface{}
}

func (r ApiUidRevokeTokenRequest) UidRevokeToken(uidRevokeToken UidRevokeToken) ApiUidRevokeTokenRequest {
	r.uidRevokeToken = &uidRevokeToken
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUidRevokeTokenRequest) Body(body UidRevokeToken) ApiUidRevokeTokenRequest {
    r.body = body
    return r
}

func (r ApiUidRevokeTokenRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UidRevokeTokenExecute(r)
}

/*
UidRevokeToken Method for UidRevokeToken

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUidRevokeTokenRequest
*/
func (a *V2ApiService) UidRevokeToken(ctx context.Context) ApiUidRevokeTokenRequest {
	return ApiUidRevokeTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) UidRevokeTokenExecute(r ApiUidRevokeTokenRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UidRevokeToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/uid-revoke-token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUidRotateTokenRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	uidRotateToken *UidRotateToken
    body interface{}
}

func (r ApiUidRotateTokenRequest) UidRotateToken(uidRotateToken UidRotateToken) ApiUidRotateTokenRequest {
	r.uidRotateToken = &uidRotateToken
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUidRotateTokenRequest) Body(body UidRotateToken) ApiUidRotateTokenRequest {
    r.body = body
    return r
}

func (r ApiUidRotateTokenRequest) Execute() (*UidRotateTokenOutput, *http.Response, error) {
	return r.ApiService.UidRotateTokenExecute(r)
}

/*
UidRotateToken Method for UidRotateToken

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUidRotateTokenRequest
*/
func (a *V2ApiService) UidRotateToken(ctx context.Context) ApiUidRotateTokenRequest {
	return ApiUidRotateTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UidRotateTokenOutput
func (a *V2ApiService) UidRotateTokenExecute(r ApiUidRotateTokenRequest) (*UidRotateTokenOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UidRotateTokenOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UidRotateToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/uid-rotate-token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnwrapTokenRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	unwrapToken *UnwrapToken
    body interface{}
}

func (r ApiUnwrapTokenRequest) UnwrapToken(unwrapToken UnwrapToken) ApiUnwrapTokenRequest {
	r.unwrapToken = &unwrapToken
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUnwrapTokenRequest) Body(body UnwrapToken) ApiUnwrapTokenRequest {
    r.body = body
    return r
}

func (r ApiUnwrapTokenRequest) Execute() (*UnwrapTokenOutput, *http.Response, error) {
	return r.ApiService.UnwrapTokenExecute(r)
}

/*
UnwrapToken Method for UnwrapToken

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUnwrapTokenRequest
*/
func (a *V2ApiService) UnwrapToken(ctx context.Context) ApiUnwrapTokenRequest {
	return ApiUnwrapTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UnwrapTokenOutput
func (a *V2ApiService) UnwrapTokenExecute(r ApiUnwrapTokenRequest) (*UnwrapTokenOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UnwrapTokenOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UnwrapToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/unwrap-token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAWSTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateAWSTarget *UpdateAWSTarget
    body interface{}
}

func (r ApiUpdateAWSTargetRequest) UpdateAWSTarget(updateAWSTarget UpdateAWSTarget) ApiUpdateAWSTargetRequest {
	r.updateAWSTarget = &updateAWSTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateAWSTargetRequest) Body(body UpdateAWSTarget) ApiUpdateAWSTargetRequest {
    r.body = body
    return r
}

func (r ApiUpdateAWSTargetRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateAWSTargetExecute(r)
}

/*
UpdateAWSTarget Method for UpdateAWSTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateAWSTargetRequest
*/
func (a *V2ApiService) UpdateAWSTarget(ctx context.Context) ApiUpdateAWSTargetRequest {
	return ApiUpdateAWSTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) UpdateAWSTargetExecute(r ApiUpdateAWSTargetRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateAWSTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-aws-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAWSTargetDetailsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateAWSTargetDetails *UpdateAWSTargetDetails
    body interface{}
}

func (r ApiUpdateAWSTargetDetailsRequest) UpdateAWSTargetDetails(updateAWSTargetDetails UpdateAWSTargetDetails) ApiUpdateAWSTargetDetailsRequest {
	r.updateAWSTargetDetails = &updateAWSTargetDetails
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateAWSTargetDetailsRequest) Body(body UpdateAWSTargetDetails) ApiUpdateAWSTargetDetailsRequest {
    r.body = body
    return r
}

func (r ApiUpdateAWSTargetDetailsRequest) Execute() (*UpdateTargetOutput, *http.Response, error) {
	return r.ApiService.UpdateAWSTargetDetailsExecute(r)
}

/*
UpdateAWSTargetDetails Method for UpdateAWSTargetDetails

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateAWSTargetDetailsRequest
*/
func (a *V2ApiService) UpdateAWSTargetDetails(ctx context.Context) ApiUpdateAWSTargetDetailsRequest {
	return ApiUpdateAWSTargetDetailsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateTargetOutput
func (a *V2ApiService) UpdateAWSTargetDetailsExecute(r ApiUpdateAWSTargetDetailsRequest) (*UpdateTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateAWSTargetDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-aws-target-details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAccountSettingsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateAccountSettings *UpdateAccountSettings
    body interface{}
}

func (r ApiUpdateAccountSettingsRequest) UpdateAccountSettings(updateAccountSettings UpdateAccountSettings) ApiUpdateAccountSettingsRequest {
	r.updateAccountSettings = &updateAccountSettings
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateAccountSettingsRequest) Body(body UpdateAccountSettings) ApiUpdateAccountSettingsRequest {
    r.body = body
    return r
}

func (r ApiUpdateAccountSettingsRequest) Execute() (*UpdateAccountSettingsOutput, *http.Response, error) {
	return r.ApiService.UpdateAccountSettingsExecute(r)
}

/*
UpdateAccountSettings Method for UpdateAccountSettings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateAccountSettingsRequest
*/
func (a *V2ApiService) UpdateAccountSettings(ctx context.Context) ApiUpdateAccountSettingsRequest {
	return ApiUpdateAccountSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateAccountSettingsOutput
func (a *V2ApiService) UpdateAccountSettingsExecute(r ApiUpdateAccountSettingsRequest) (*UpdateAccountSettingsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateAccountSettingsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateAccountSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-account-settings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateArtifactoryTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateArtifactoryTarget *UpdateArtifactoryTarget
    body interface{}
}

func (r ApiUpdateArtifactoryTargetRequest) UpdateArtifactoryTarget(updateArtifactoryTarget UpdateArtifactoryTarget) ApiUpdateArtifactoryTargetRequest {
	r.updateArtifactoryTarget = &updateArtifactoryTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateArtifactoryTargetRequest) Body(body UpdateArtifactoryTarget) ApiUpdateArtifactoryTargetRequest {
    r.body = body
    return r
}

func (r ApiUpdateArtifactoryTargetRequest) Execute() (*UpdateArtifactoryTargetOutput, *http.Response, error) {
	return r.ApiService.UpdateArtifactoryTargetExecute(r)
}

/*
UpdateArtifactoryTarget Method for UpdateArtifactoryTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateArtifactoryTargetRequest
*/
func (a *V2ApiService) UpdateArtifactoryTarget(ctx context.Context) ApiUpdateArtifactoryTargetRequest {
	return ApiUpdateArtifactoryTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateArtifactoryTargetOutput
func (a *V2ApiService) UpdateArtifactoryTargetExecute(r ApiUpdateArtifactoryTargetRequest) (*UpdateArtifactoryTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateArtifactoryTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateArtifactoryTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-artifactory-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAssocRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateAssoc *UpdateAssoc
    body interface{}
}

func (r ApiUpdateAssocRequest) UpdateAssoc(updateAssoc UpdateAssoc) ApiUpdateAssocRequest {
	r.updateAssoc = &updateAssoc
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateAssocRequest) Body(body UpdateAssoc) ApiUpdateAssocRequest {
    r.body = body
    return r
}

func (r ApiUpdateAssocRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateAssocExecute(r)
}

/*
UpdateAssoc Method for UpdateAssoc

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateAssocRequest
*/
func (a *V2ApiService) UpdateAssoc(ctx context.Context) ApiUpdateAssocRequest {
	return ApiUpdateAssocRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) UpdateAssocExecute(r ApiUpdateAssocRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateAssoc")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-assoc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAuthMethodRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateAuthMethod *UpdateAuthMethod
    body interface{}
}

func (r ApiUpdateAuthMethodRequest) UpdateAuthMethod(updateAuthMethod UpdateAuthMethod) ApiUpdateAuthMethodRequest {
	r.updateAuthMethod = &updateAuthMethod
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateAuthMethodRequest) Body(body UpdateAuthMethod) ApiUpdateAuthMethodRequest {
    r.body = body
    return r
}

func (r ApiUpdateAuthMethodRequest) Execute() (*UpdateAuthMethodOutput, *http.Response, error) {
	return r.ApiService.UpdateAuthMethodExecute(r)
}

/*
UpdateAuthMethod Method for UpdateAuthMethod

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateAuthMethodRequest
*/
func (a *V2ApiService) UpdateAuthMethod(ctx context.Context) ApiUpdateAuthMethodRequest {
	return ApiUpdateAuthMethodRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateAuthMethodOutput
func (a *V2ApiService) UpdateAuthMethodExecute(r ApiUpdateAuthMethodRequest) (*UpdateAuthMethodOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateAuthMethodOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateAuthMethod")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-auth-method"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAuthMethodAWSIAMRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateAuthMethodAWSIAM *UpdateAuthMethodAWSIAM
    body interface{}
}

func (r ApiUpdateAuthMethodAWSIAMRequest) UpdateAuthMethodAWSIAM(updateAuthMethodAWSIAM UpdateAuthMethodAWSIAM) ApiUpdateAuthMethodAWSIAMRequest {
	r.updateAuthMethodAWSIAM = &updateAuthMethodAWSIAM
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateAuthMethodAWSIAMRequest) Body(body UpdateAuthMethodAWSIAM) ApiUpdateAuthMethodAWSIAMRequest {
    r.body = body
    return r
}

func (r ApiUpdateAuthMethodAWSIAMRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateAuthMethodAWSIAMExecute(r)
}

/*
UpdateAuthMethodAWSIAM Method for UpdateAuthMethodAWSIAM

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateAuthMethodAWSIAMRequest
*/
func (a *V2ApiService) UpdateAuthMethodAWSIAM(ctx context.Context) ApiUpdateAuthMethodAWSIAMRequest {
	return ApiUpdateAuthMethodAWSIAMRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) UpdateAuthMethodAWSIAMExecute(r ApiUpdateAuthMethodAWSIAMRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateAuthMethodAWSIAM")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-auth-method-aws-iam"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAuthMethodAzureADRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateAuthMethodAzureAD *UpdateAuthMethodAzureAD
    body interface{}
}

func (r ApiUpdateAuthMethodAzureADRequest) UpdateAuthMethodAzureAD(updateAuthMethodAzureAD UpdateAuthMethodAzureAD) ApiUpdateAuthMethodAzureADRequest {
	r.updateAuthMethodAzureAD = &updateAuthMethodAzureAD
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateAuthMethodAzureADRequest) Body(body UpdateAuthMethodAzureAD) ApiUpdateAuthMethodAzureADRequest {
    r.body = body
    return r
}

func (r ApiUpdateAuthMethodAzureADRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateAuthMethodAzureADExecute(r)
}

/*
UpdateAuthMethodAzureAD Method for UpdateAuthMethodAzureAD

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateAuthMethodAzureADRequest
*/
func (a *V2ApiService) UpdateAuthMethodAzureAD(ctx context.Context) ApiUpdateAuthMethodAzureADRequest {
	return ApiUpdateAuthMethodAzureADRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) UpdateAuthMethodAzureADExecute(r ApiUpdateAuthMethodAzureADRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateAuthMethodAzureAD")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-auth-method-azure-ad"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAuthMethodCertRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateAuthMethodCert *UpdateAuthMethodCert
    body interface{}
}

func (r ApiUpdateAuthMethodCertRequest) UpdateAuthMethodCert(updateAuthMethodCert UpdateAuthMethodCert) ApiUpdateAuthMethodCertRequest {
	r.updateAuthMethodCert = &updateAuthMethodCert
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateAuthMethodCertRequest) Body(body UpdateAuthMethodCert) ApiUpdateAuthMethodCertRequest {
    r.body = body
    return r
}

func (r ApiUpdateAuthMethodCertRequest) Execute() (*UpdateAuthMethodCertOutput, *http.Response, error) {
	return r.ApiService.UpdateAuthMethodCertExecute(r)
}

/*
UpdateAuthMethodCert Method for UpdateAuthMethodCert

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateAuthMethodCertRequest
*/
func (a *V2ApiService) UpdateAuthMethodCert(ctx context.Context) ApiUpdateAuthMethodCertRequest {
	return ApiUpdateAuthMethodCertRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateAuthMethodCertOutput
func (a *V2ApiService) UpdateAuthMethodCertExecute(r ApiUpdateAuthMethodCertRequest) (*UpdateAuthMethodCertOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateAuthMethodCertOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateAuthMethodCert")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-auth-method-cert"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAuthMethodGCPRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateAuthMethodGCP *UpdateAuthMethodGCP
    body interface{}
}

func (r ApiUpdateAuthMethodGCPRequest) UpdateAuthMethodGCP(updateAuthMethodGCP UpdateAuthMethodGCP) ApiUpdateAuthMethodGCPRequest {
	r.updateAuthMethodGCP = &updateAuthMethodGCP
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateAuthMethodGCPRequest) Body(body UpdateAuthMethodGCP) ApiUpdateAuthMethodGCPRequest {
    r.body = body
    return r
}

func (r ApiUpdateAuthMethodGCPRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateAuthMethodGCPExecute(r)
}

/*
UpdateAuthMethodGCP Method for UpdateAuthMethodGCP

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateAuthMethodGCPRequest
*/
func (a *V2ApiService) UpdateAuthMethodGCP(ctx context.Context) ApiUpdateAuthMethodGCPRequest {
	return ApiUpdateAuthMethodGCPRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) UpdateAuthMethodGCPExecute(r ApiUpdateAuthMethodGCPRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateAuthMethodGCP")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-auth-method-gcp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAuthMethodK8SRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateAuthMethodK8S *UpdateAuthMethodK8S
    body interface{}
}

func (r ApiUpdateAuthMethodK8SRequest) UpdateAuthMethodK8S(updateAuthMethodK8S UpdateAuthMethodK8S) ApiUpdateAuthMethodK8SRequest {
	r.updateAuthMethodK8S = &updateAuthMethodK8S
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateAuthMethodK8SRequest) Body(body UpdateAuthMethodK8S) ApiUpdateAuthMethodK8SRequest {
    r.body = body
    return r
}

func (r ApiUpdateAuthMethodK8SRequest) Execute() (*UpdateAuthMethodK8SOutput, *http.Response, error) {
	return r.ApiService.UpdateAuthMethodK8SExecute(r)
}

/*
UpdateAuthMethodK8S Method for UpdateAuthMethodK8S

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateAuthMethodK8SRequest
*/
func (a *V2ApiService) UpdateAuthMethodK8S(ctx context.Context) ApiUpdateAuthMethodK8SRequest {
	return ApiUpdateAuthMethodK8SRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateAuthMethodK8SOutput
func (a *V2ApiService) UpdateAuthMethodK8SExecute(r ApiUpdateAuthMethodK8SRequest) (*UpdateAuthMethodK8SOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateAuthMethodK8SOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateAuthMethodK8S")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-auth-method-k8s"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAuthMethodLDAPRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateAuthMethodLDAP *UpdateAuthMethodLDAP
    body interface{}
}

func (r ApiUpdateAuthMethodLDAPRequest) UpdateAuthMethodLDAP(updateAuthMethodLDAP UpdateAuthMethodLDAP) ApiUpdateAuthMethodLDAPRequest {
	r.updateAuthMethodLDAP = &updateAuthMethodLDAP
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateAuthMethodLDAPRequest) Body(body UpdateAuthMethodLDAP) ApiUpdateAuthMethodLDAPRequest {
    r.body = body
    return r
}

func (r ApiUpdateAuthMethodLDAPRequest) Execute() (*UpdateAuthMethodLDAPOutput, *http.Response, error) {
	return r.ApiService.UpdateAuthMethodLDAPExecute(r)
}

/*
UpdateAuthMethodLDAP Method for UpdateAuthMethodLDAP

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateAuthMethodLDAPRequest
*/
func (a *V2ApiService) UpdateAuthMethodLDAP(ctx context.Context) ApiUpdateAuthMethodLDAPRequest {
	return ApiUpdateAuthMethodLDAPRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateAuthMethodLDAPOutput
func (a *V2ApiService) UpdateAuthMethodLDAPExecute(r ApiUpdateAuthMethodLDAPRequest) (*UpdateAuthMethodLDAPOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateAuthMethodLDAPOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateAuthMethodLDAP")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-auth-method-ldap"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAuthMethodOAuth2Request struct {
	ctx context.Context
	ApiService *V2ApiService
	updateAuthMethodOAuth2 *UpdateAuthMethodOAuth2
    body interface{}
}

func (r ApiUpdateAuthMethodOAuth2Request) UpdateAuthMethodOAuth2(updateAuthMethodOAuth2 UpdateAuthMethodOAuth2) ApiUpdateAuthMethodOAuth2Request {
	r.updateAuthMethodOAuth2 = &updateAuthMethodOAuth2
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateAuthMethodOAuth2Request) Body(body UpdateAuthMethodOAuth2) ApiUpdateAuthMethodOAuth2Request {
    r.body = body
    return r
}

func (r ApiUpdateAuthMethodOAuth2Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateAuthMethodOAuth2Execute(r)
}

/*
UpdateAuthMethodOAuth2 Method for UpdateAuthMethodOAuth2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateAuthMethodOAuth2Request
*/
func (a *V2ApiService) UpdateAuthMethodOAuth2(ctx context.Context) ApiUpdateAuthMethodOAuth2Request {
	return ApiUpdateAuthMethodOAuth2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) UpdateAuthMethodOAuth2Execute(r ApiUpdateAuthMethodOAuth2Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateAuthMethodOAuth2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-auth-method-oauth2"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAuthMethodOCIRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateAuthMethodOCI *UpdateAuthMethodOCI
    body interface{}
}

func (r ApiUpdateAuthMethodOCIRequest) UpdateAuthMethodOCI(updateAuthMethodOCI UpdateAuthMethodOCI) ApiUpdateAuthMethodOCIRequest {
	r.updateAuthMethodOCI = &updateAuthMethodOCI
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateAuthMethodOCIRequest) Body(body UpdateAuthMethodOCI) ApiUpdateAuthMethodOCIRequest {
    r.body = body
    return r
}

func (r ApiUpdateAuthMethodOCIRequest) Execute() (*UpdateAuthMethodOCIOutput, *http.Response, error) {
	return r.ApiService.UpdateAuthMethodOCIExecute(r)
}

/*
UpdateAuthMethodOCI Method for UpdateAuthMethodOCI

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateAuthMethodOCIRequest
*/
func (a *V2ApiService) UpdateAuthMethodOCI(ctx context.Context) ApiUpdateAuthMethodOCIRequest {
	return ApiUpdateAuthMethodOCIRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateAuthMethodOCIOutput
func (a *V2ApiService) UpdateAuthMethodOCIExecute(r ApiUpdateAuthMethodOCIRequest) (*UpdateAuthMethodOCIOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateAuthMethodOCIOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateAuthMethodOCI")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-auth-method-oci"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAuthMethodOIDCRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateAuthMethodOIDC *UpdateAuthMethodOIDC
    body interface{}
}

func (r ApiUpdateAuthMethodOIDCRequest) UpdateAuthMethodOIDC(updateAuthMethodOIDC UpdateAuthMethodOIDC) ApiUpdateAuthMethodOIDCRequest {
	r.updateAuthMethodOIDC = &updateAuthMethodOIDC
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateAuthMethodOIDCRequest) Body(body UpdateAuthMethodOIDC) ApiUpdateAuthMethodOIDCRequest {
    r.body = body
    return r
}

func (r ApiUpdateAuthMethodOIDCRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateAuthMethodOIDCExecute(r)
}

/*
UpdateAuthMethodOIDC Method for UpdateAuthMethodOIDC

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateAuthMethodOIDCRequest
*/
func (a *V2ApiService) UpdateAuthMethodOIDC(ctx context.Context) ApiUpdateAuthMethodOIDCRequest {
	return ApiUpdateAuthMethodOIDCRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) UpdateAuthMethodOIDCExecute(r ApiUpdateAuthMethodOIDCRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateAuthMethodOIDC")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-auth-method-oidc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAuthMethodSAMLRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateAuthMethodSAML *UpdateAuthMethodSAML
    body interface{}
}

func (r ApiUpdateAuthMethodSAMLRequest) UpdateAuthMethodSAML(updateAuthMethodSAML UpdateAuthMethodSAML) ApiUpdateAuthMethodSAMLRequest {
	r.updateAuthMethodSAML = &updateAuthMethodSAML
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateAuthMethodSAMLRequest) Body(body UpdateAuthMethodSAML) ApiUpdateAuthMethodSAMLRequest {
    r.body = body
    return r
}

func (r ApiUpdateAuthMethodSAMLRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateAuthMethodSAMLExecute(r)
}

/*
UpdateAuthMethodSAML Method for UpdateAuthMethodSAML

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateAuthMethodSAMLRequest
*/
func (a *V2ApiService) UpdateAuthMethodSAML(ctx context.Context) ApiUpdateAuthMethodSAMLRequest {
	return ApiUpdateAuthMethodSAMLRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) UpdateAuthMethodSAMLExecute(r ApiUpdateAuthMethodSAMLRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateAuthMethodSAML")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-auth-method-saml"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAuthMethodUniversalIdentityRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateAuthMethodUniversalIdentity *UpdateAuthMethodUniversalIdentity
    body interface{}
}

func (r ApiUpdateAuthMethodUniversalIdentityRequest) UpdateAuthMethodUniversalIdentity(updateAuthMethodUniversalIdentity UpdateAuthMethodUniversalIdentity) ApiUpdateAuthMethodUniversalIdentityRequest {
	r.updateAuthMethodUniversalIdentity = &updateAuthMethodUniversalIdentity
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateAuthMethodUniversalIdentityRequest) Body(body UpdateAuthMethodUniversalIdentity) ApiUpdateAuthMethodUniversalIdentityRequest {
    r.body = body
    return r
}

func (r ApiUpdateAuthMethodUniversalIdentityRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateAuthMethodUniversalIdentityExecute(r)
}

/*
UpdateAuthMethodUniversalIdentity Method for UpdateAuthMethodUniversalIdentity

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateAuthMethodUniversalIdentityRequest
*/
func (a *V2ApiService) UpdateAuthMethodUniversalIdentity(ctx context.Context) ApiUpdateAuthMethodUniversalIdentityRequest {
	return ApiUpdateAuthMethodUniversalIdentityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) UpdateAuthMethodUniversalIdentityExecute(r ApiUpdateAuthMethodUniversalIdentityRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateAuthMethodUniversalIdentity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-auth-method-universal-identity"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAzureTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateAzureTarget *UpdateAzureTarget
    body interface{}
}

func (r ApiUpdateAzureTargetRequest) UpdateAzureTarget(updateAzureTarget UpdateAzureTarget) ApiUpdateAzureTargetRequest {
	r.updateAzureTarget = &updateAzureTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateAzureTargetRequest) Body(body UpdateAzureTarget) ApiUpdateAzureTargetRequest {
    r.body = body
    return r
}

func (r ApiUpdateAzureTargetRequest) Execute() (*UpdateAzureTargetOutput, *http.Response, error) {
	return r.ApiService.UpdateAzureTargetExecute(r)
}

/*
UpdateAzureTarget Method for UpdateAzureTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateAzureTargetRequest
*/
func (a *V2ApiService) UpdateAzureTarget(ctx context.Context) ApiUpdateAzureTargetRequest {
	return ApiUpdateAzureTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateAzureTargetOutput
func (a *V2ApiService) UpdateAzureTargetExecute(r ApiUpdateAzureTargetRequest) (*UpdateAzureTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateAzureTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateAzureTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-azure-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCertificateValueRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateCertificateValue *UpdateCertificateValue
    body interface{}
}

func (r ApiUpdateCertificateValueRequest) UpdateCertificateValue(updateCertificateValue UpdateCertificateValue) ApiUpdateCertificateValueRequest {
	r.updateCertificateValue = &updateCertificateValue
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateCertificateValueRequest) Body(body UpdateCertificateValue) ApiUpdateCertificateValueRequest {
    r.body = body
    return r
}

func (r ApiUpdateCertificateValueRequest) Execute() (*UpdateCertificateOutput, *http.Response, error) {
	return r.ApiService.UpdateCertificateValueExecute(r)
}

/*
UpdateCertificateValue Method for UpdateCertificateValue

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateCertificateValueRequest
*/
func (a *V2ApiService) UpdateCertificateValue(ctx context.Context) ApiUpdateCertificateValueRequest {
	return ApiUpdateCertificateValueRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateCertificateOutput
func (a *V2ApiService) UpdateCertificateValueExecute(r ApiUpdateCertificateValueRequest) (*UpdateCertificateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateCertificateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateCertificateValue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-certificate-value"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateClassicKeyCertificateRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateClassicKeyCertificate *UpdateClassicKeyCertificate
    body interface{}
}

func (r ApiUpdateClassicKeyCertificateRequest) UpdateClassicKeyCertificate(updateClassicKeyCertificate UpdateClassicKeyCertificate) ApiUpdateClassicKeyCertificateRequest {
	r.updateClassicKeyCertificate = &updateClassicKeyCertificate
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateClassicKeyCertificateRequest) Body(body UpdateClassicKeyCertificate) ApiUpdateClassicKeyCertificateRequest {
    r.body = body
    return r
}

func (r ApiUpdateClassicKeyCertificateRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateClassicKeyCertificateExecute(r)
}

/*
UpdateClassicKeyCertificate Method for UpdateClassicKeyCertificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateClassicKeyCertificateRequest
*/
func (a *V2ApiService) UpdateClassicKeyCertificate(ctx context.Context) ApiUpdateClassicKeyCertificateRequest {
	return ApiUpdateClassicKeyCertificateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) UpdateClassicKeyCertificateExecute(r ApiUpdateClassicKeyCertificateRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateClassicKeyCertificate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-classic-key-certificate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDBTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateDBTarget *UpdateDBTarget
    body interface{}
}

func (r ApiUpdateDBTargetRequest) UpdateDBTarget(updateDBTarget UpdateDBTarget) ApiUpdateDBTargetRequest {
	r.updateDBTarget = &updateDBTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateDBTargetRequest) Body(body UpdateDBTarget) ApiUpdateDBTargetRequest {
    r.body = body
    return r
}

func (r ApiUpdateDBTargetRequest) Execute() (*UpdateDBTargetOutput, *http.Response, error) {
	return r.ApiService.UpdateDBTargetExecute(r)
}

/*
UpdateDBTarget Method for UpdateDBTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateDBTargetRequest
*/
func (a *V2ApiService) UpdateDBTarget(ctx context.Context) ApiUpdateDBTargetRequest {
	return ApiUpdateDBTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateDBTargetOutput
func (a *V2ApiService) UpdateDBTargetExecute(r ApiUpdateDBTargetRequest) (*UpdateDBTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateDBTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateDBTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-db-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDBTargetDetailsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateDBTargetDetails *UpdateDBTargetDetails
    body interface{}
}

func (r ApiUpdateDBTargetDetailsRequest) UpdateDBTargetDetails(updateDBTargetDetails UpdateDBTargetDetails) ApiUpdateDBTargetDetailsRequest {
	r.updateDBTargetDetails = &updateDBTargetDetails
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateDBTargetDetailsRequest) Body(body UpdateDBTargetDetails) ApiUpdateDBTargetDetailsRequest {
    r.body = body
    return r
}

func (r ApiUpdateDBTargetDetailsRequest) Execute() (*UpdateTargetOutput, *http.Response, error) {
	return r.ApiService.UpdateDBTargetDetailsExecute(r)
}

/*
UpdateDBTargetDetails Method for UpdateDBTargetDetails

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateDBTargetDetailsRequest
*/
func (a *V2ApiService) UpdateDBTargetDetails(ctx context.Context) ApiUpdateDBTargetDetailsRequest {
	return ApiUpdateDBTargetDetailsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateTargetOutput
func (a *V2ApiService) UpdateDBTargetDetailsExecute(r ApiUpdateDBTargetDetailsRequest) (*UpdateTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateDBTargetDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-db-target-details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDockerhubTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateDockerhubTarget *UpdateDockerhubTarget
    body interface{}
}

func (r ApiUpdateDockerhubTargetRequest) UpdateDockerhubTarget(updateDockerhubTarget UpdateDockerhubTarget) ApiUpdateDockerhubTargetRequest {
	r.updateDockerhubTarget = &updateDockerhubTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateDockerhubTargetRequest) Body(body UpdateDockerhubTarget) ApiUpdateDockerhubTargetRequest {
    r.body = body
    return r
}

func (r ApiUpdateDockerhubTargetRequest) Execute() (*UpdateDockerhubTargetOutput, *http.Response, error) {
	return r.ApiService.UpdateDockerhubTargetExecute(r)
}

/*
UpdateDockerhubTarget Method for UpdateDockerhubTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateDockerhubTargetRequest
*/
func (a *V2ApiService) UpdateDockerhubTarget(ctx context.Context) ApiUpdateDockerhubTargetRequest {
	return ApiUpdateDockerhubTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateDockerhubTargetOutput
func (a *V2ApiService) UpdateDockerhubTargetExecute(r ApiUpdateDockerhubTargetRequest) (*UpdateDockerhubTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateDockerhubTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateDockerhubTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-dockerhub-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateEKSTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateEKSTarget *UpdateEKSTarget
    body interface{}
}

func (r ApiUpdateEKSTargetRequest) UpdateEKSTarget(updateEKSTarget UpdateEKSTarget) ApiUpdateEKSTargetRequest {
	r.updateEKSTarget = &updateEKSTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateEKSTargetRequest) Body(body UpdateEKSTarget) ApiUpdateEKSTargetRequest {
    r.body = body
    return r
}

func (r ApiUpdateEKSTargetRequest) Execute() (*UpdateEKSTargetOutput, *http.Response, error) {
	return r.ApiService.UpdateEKSTargetExecute(r)
}

/*
UpdateEKSTarget Method for UpdateEKSTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateEKSTargetRequest
*/
func (a *V2ApiService) UpdateEKSTarget(ctx context.Context) ApiUpdateEKSTargetRequest {
	return ApiUpdateEKSTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateEKSTargetOutput
func (a *V2ApiService) UpdateEKSTargetExecute(r ApiUpdateEKSTargetRequest) (*UpdateEKSTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateEKSTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateEKSTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-eks-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateEventForwarderRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateEventForwarder *UpdateEventForwarder
    body interface{}
}

func (r ApiUpdateEventForwarderRequest) UpdateEventForwarder(updateEventForwarder UpdateEventForwarder) ApiUpdateEventForwarderRequest {
	r.updateEventForwarder = &updateEventForwarder
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateEventForwarderRequest) Body(body UpdateEventForwarder) ApiUpdateEventForwarderRequest {
    r.body = body
    return r
}

func (r ApiUpdateEventForwarderRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateEventForwarderExecute(r)
}

/*
UpdateEventForwarder Method for UpdateEventForwarder

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateEventForwarderRequest
*/
func (a *V2ApiService) UpdateEventForwarder(ctx context.Context) ApiUpdateEventForwarderRequest {
	return ApiUpdateEventForwarderRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) UpdateEventForwarderExecute(r ApiUpdateEventForwarderRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateEventForwarder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-event-forwarder"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateGKETargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateGKETarget *UpdateGKETarget
    body interface{}
}

func (r ApiUpdateGKETargetRequest) UpdateGKETarget(updateGKETarget UpdateGKETarget) ApiUpdateGKETargetRequest {
	r.updateGKETarget = &updateGKETarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateGKETargetRequest) Body(body UpdateGKETarget) ApiUpdateGKETargetRequest {
    r.body = body
    return r
}

func (r ApiUpdateGKETargetRequest) Execute() (*UpdateGKETargetOutput, *http.Response, error) {
	return r.ApiService.UpdateGKETargetExecute(r)
}

/*
UpdateGKETarget Method for UpdateGKETarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateGKETargetRequest
*/
func (a *V2ApiService) UpdateGKETarget(ctx context.Context) ApiUpdateGKETargetRequest {
	return ApiUpdateGKETargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateGKETargetOutput
func (a *V2ApiService) UpdateGKETargetExecute(r ApiUpdateGKETargetRequest) (*UpdateGKETargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateGKETargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateGKETarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-gke-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateGcpTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateGcpTarget *UpdateGcpTarget
    body interface{}
}

func (r ApiUpdateGcpTargetRequest) UpdateGcpTarget(updateGcpTarget UpdateGcpTarget) ApiUpdateGcpTargetRequest {
	r.updateGcpTarget = &updateGcpTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateGcpTargetRequest) Body(body UpdateGcpTarget) ApiUpdateGcpTargetRequest {
    r.body = body
    return r
}

func (r ApiUpdateGcpTargetRequest) Execute() (*UpdateGcpTargetOutput, *http.Response, error) {
	return r.ApiService.UpdateGcpTargetExecute(r)
}

/*
UpdateGcpTarget Method for UpdateGcpTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateGcpTargetRequest
*/
func (a *V2ApiService) UpdateGcpTarget(ctx context.Context) ApiUpdateGcpTargetRequest {
	return ApiUpdateGcpTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateGcpTargetOutput
func (a *V2ApiService) UpdateGcpTargetExecute(r ApiUpdateGcpTargetRequest) (*UpdateGcpTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateGcpTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateGcpTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-gcp-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateGithubTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateGithubTarget *UpdateGithubTarget
    body interface{}
}

func (r ApiUpdateGithubTargetRequest) UpdateGithubTarget(updateGithubTarget UpdateGithubTarget) ApiUpdateGithubTargetRequest {
	r.updateGithubTarget = &updateGithubTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateGithubTargetRequest) Body(body UpdateGithubTarget) ApiUpdateGithubTargetRequest {
    r.body = body
    return r
}

func (r ApiUpdateGithubTargetRequest) Execute() (*UpdateGithubTargetOutput, *http.Response, error) {
	return r.ApiService.UpdateGithubTargetExecute(r)
}

/*
UpdateGithubTarget Method for UpdateGithubTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateGithubTargetRequest
*/
func (a *V2ApiService) UpdateGithubTarget(ctx context.Context) ApiUpdateGithubTargetRequest {
	return ApiUpdateGithubTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateGithubTargetOutput
func (a *V2ApiService) UpdateGithubTargetExecute(r ApiUpdateGithubTargetRequest) (*UpdateGithubTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateGithubTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateGithubTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-github-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateGitlabTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateGitlabTarget *UpdateGitlabTarget
    body interface{}
}

func (r ApiUpdateGitlabTargetRequest) UpdateGitlabTarget(updateGitlabTarget UpdateGitlabTarget) ApiUpdateGitlabTargetRequest {
	r.updateGitlabTarget = &updateGitlabTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateGitlabTargetRequest) Body(body UpdateGitlabTarget) ApiUpdateGitlabTargetRequest {
    r.body = body
    return r
}

func (r ApiUpdateGitlabTargetRequest) Execute() (*UpdateGitlabTargetOutput, *http.Response, error) {
	return r.ApiService.UpdateGitlabTargetExecute(r)
}

/*
UpdateGitlabTarget Method for UpdateGitlabTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateGitlabTargetRequest
*/
func (a *V2ApiService) UpdateGitlabTarget(ctx context.Context) ApiUpdateGitlabTargetRequest {
	return ApiUpdateGitlabTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateGitlabTargetOutput
func (a *V2ApiService) UpdateGitlabTargetExecute(r ApiUpdateGitlabTargetRequest) (*UpdateGitlabTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateGitlabTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateGitlabTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-gitlab-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateGlobalSignAtlasTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateGlobalSignAtlasTarget *UpdateGlobalSignAtlasTarget
    body interface{}
}

func (r ApiUpdateGlobalSignAtlasTargetRequest) UpdateGlobalSignAtlasTarget(updateGlobalSignAtlasTarget UpdateGlobalSignAtlasTarget) ApiUpdateGlobalSignAtlasTargetRequest {
	r.updateGlobalSignAtlasTarget = &updateGlobalSignAtlasTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateGlobalSignAtlasTargetRequest) Body(body UpdateGlobalSignAtlasTarget) ApiUpdateGlobalSignAtlasTargetRequest {
    r.body = body
    return r
}

func (r ApiUpdateGlobalSignAtlasTargetRequest) Execute() (*UpdateGlobalSignAtlasTargetOutput, *http.Response, error) {
	return r.ApiService.UpdateGlobalSignAtlasTargetExecute(r)
}

/*
UpdateGlobalSignAtlasTarget Method for UpdateGlobalSignAtlasTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateGlobalSignAtlasTargetRequest
*/
func (a *V2ApiService) UpdateGlobalSignAtlasTarget(ctx context.Context) ApiUpdateGlobalSignAtlasTargetRequest {
	return ApiUpdateGlobalSignAtlasTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateGlobalSignAtlasTargetOutput
func (a *V2ApiService) UpdateGlobalSignAtlasTargetExecute(r ApiUpdateGlobalSignAtlasTargetRequest) (*UpdateGlobalSignAtlasTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateGlobalSignAtlasTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateGlobalSignAtlasTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-globalsign-atlas-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateGlobalSignTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateGlobalSignTarget *UpdateGlobalSignTarget
    body interface{}
}

func (r ApiUpdateGlobalSignTargetRequest) UpdateGlobalSignTarget(updateGlobalSignTarget UpdateGlobalSignTarget) ApiUpdateGlobalSignTargetRequest {
	r.updateGlobalSignTarget = &updateGlobalSignTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateGlobalSignTargetRequest) Body(body UpdateGlobalSignTarget) ApiUpdateGlobalSignTargetRequest {
    r.body = body
    return r
}

func (r ApiUpdateGlobalSignTargetRequest) Execute() (*UpdateGlobalSignTargetOutput, *http.Response, error) {
	return r.ApiService.UpdateGlobalSignTargetExecute(r)
}

/*
UpdateGlobalSignTarget Method for UpdateGlobalSignTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateGlobalSignTargetRequest
*/
func (a *V2ApiService) UpdateGlobalSignTarget(ctx context.Context) ApiUpdateGlobalSignTargetRequest {
	return ApiUpdateGlobalSignTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateGlobalSignTargetOutput
func (a *V2ApiService) UpdateGlobalSignTargetExecute(r ApiUpdateGlobalSignTargetRequest) (*UpdateGlobalSignTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateGlobalSignTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateGlobalSignTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-globalsign-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateGodaddyTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateGodaddyTarget *UpdateGodaddyTarget
    body interface{}
}

func (r ApiUpdateGodaddyTargetRequest) UpdateGodaddyTarget(updateGodaddyTarget UpdateGodaddyTarget) ApiUpdateGodaddyTargetRequest {
	r.updateGodaddyTarget = &updateGodaddyTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateGodaddyTargetRequest) Body(body UpdateGodaddyTarget) ApiUpdateGodaddyTargetRequest {
    r.body = body
    return r
}

func (r ApiUpdateGodaddyTargetRequest) Execute() (*UpdateGodaddyTargetOutput, *http.Response, error) {
	return r.ApiService.UpdateGodaddyTargetExecute(r)
}

/*
UpdateGodaddyTarget Method for UpdateGodaddyTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateGodaddyTargetRequest
*/
func (a *V2ApiService) UpdateGodaddyTarget(ctx context.Context) ApiUpdateGodaddyTargetRequest {
	return ApiUpdateGodaddyTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateGodaddyTargetOutput
func (a *V2ApiService) UpdateGodaddyTargetExecute(r ApiUpdateGodaddyTargetRequest) (*UpdateGodaddyTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateGodaddyTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateGodaddyTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-godaddy-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateGroupRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateGroup *UpdateGroup
    body interface{}
}

func (r ApiUpdateGroupRequest) UpdateGroup(updateGroup UpdateGroup) ApiUpdateGroupRequest {
	r.updateGroup = &updateGroup
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateGroupRequest) Body(body UpdateGroup) ApiUpdateGroupRequest {
    r.body = body
    return r
}

func (r ApiUpdateGroupRequest) Execute() (*UpdateGroupOutput, *http.Response, error) {
	return r.ApiService.UpdateGroupExecute(r)
}

/*
UpdateGroup Method for UpdateGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateGroupRequest
*/
func (a *V2ApiService) UpdateGroup(ctx context.Context) ApiUpdateGroupRequest {
	return ApiUpdateGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateGroupOutput
func (a *V2ApiService) UpdateGroupExecute(r ApiUpdateGroupRequest) (*UpdateGroupOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateGroupOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-group"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateHashiVaultTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateHashiVaultTarget *UpdateHashiVaultTarget
    body interface{}
}

func (r ApiUpdateHashiVaultTargetRequest) UpdateHashiVaultTarget(updateHashiVaultTarget UpdateHashiVaultTarget) ApiUpdateHashiVaultTargetRequest {
	r.updateHashiVaultTarget = &updateHashiVaultTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateHashiVaultTargetRequest) Body(body UpdateHashiVaultTarget) ApiUpdateHashiVaultTargetRequest {
    r.body = body
    return r
}

func (r ApiUpdateHashiVaultTargetRequest) Execute() (*UpdateHashiVaultTargetOutput, *http.Response, error) {
	return r.ApiService.UpdateHashiVaultTargetExecute(r)
}

/*
UpdateHashiVaultTarget Method for UpdateHashiVaultTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateHashiVaultTargetRequest
*/
func (a *V2ApiService) UpdateHashiVaultTarget(ctx context.Context) ApiUpdateHashiVaultTargetRequest {
	return ApiUpdateHashiVaultTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateHashiVaultTargetOutput
func (a *V2ApiService) UpdateHashiVaultTargetExecute(r ApiUpdateHashiVaultTargetRequest) (*UpdateHashiVaultTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateHashiVaultTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateHashiVaultTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-hashi-vault-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateItemRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateItem *UpdateItem
    body interface{}
}

func (r ApiUpdateItemRequest) UpdateItem(updateItem UpdateItem) ApiUpdateItemRequest {
	r.updateItem = &updateItem
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateItemRequest) Body(body UpdateItem) ApiUpdateItemRequest {
    r.body = body
    return r
}

func (r ApiUpdateItemRequest) Execute() (*UpdateItemOutput, *http.Response, error) {
	return r.ApiService.UpdateItemExecute(r)
}

/*
UpdateItem Method for UpdateItem

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateItemRequest
*/
func (a *V2ApiService) UpdateItem(ctx context.Context) ApiUpdateItemRequest {
	return ApiUpdateItemRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateItemOutput
func (a *V2ApiService) UpdateItemExecute(r ApiUpdateItemRequest) (*UpdateItemOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateItemOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-item"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateLdapTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateLdapTarget *UpdateLdapTarget
    body interface{}
}

func (r ApiUpdateLdapTargetRequest) UpdateLdapTarget(updateLdapTarget UpdateLdapTarget) ApiUpdateLdapTargetRequest {
	r.updateLdapTarget = &updateLdapTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateLdapTargetRequest) Body(body UpdateLdapTarget) ApiUpdateLdapTargetRequest {
    r.body = body
    return r
}

func (r ApiUpdateLdapTargetRequest) Execute() (*UpdateLdapTargetOutput, *http.Response, error) {
	return r.ApiService.UpdateLdapTargetExecute(r)
}

/*
UpdateLdapTarget Method for UpdateLdapTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateLdapTargetRequest
*/
func (a *V2ApiService) UpdateLdapTarget(ctx context.Context) ApiUpdateLdapTargetRequest {
	return ApiUpdateLdapTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateLdapTargetOutput
func (a *V2ApiService) UpdateLdapTargetExecute(r ApiUpdateLdapTargetRequest) (*UpdateLdapTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateLdapTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateLdapTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-ldap-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateLdapTargetDetailsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateLdapTargetDetails *UpdateLdapTargetDetails
    body interface{}
}

func (r ApiUpdateLdapTargetDetailsRequest) UpdateLdapTargetDetails(updateLdapTargetDetails UpdateLdapTargetDetails) ApiUpdateLdapTargetDetailsRequest {
	r.updateLdapTargetDetails = &updateLdapTargetDetails
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateLdapTargetDetailsRequest) Body(body UpdateLdapTargetDetails) ApiUpdateLdapTargetDetailsRequest {
    r.body = body
    return r
}

func (r ApiUpdateLdapTargetDetailsRequest) Execute() (*UpdateTargetOutput, *http.Response, error) {
	return r.ApiService.UpdateLdapTargetDetailsExecute(r)
}

/*
UpdateLdapTargetDetails Method for UpdateLdapTargetDetails

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateLdapTargetDetailsRequest
*/
func (a *V2ApiService) UpdateLdapTargetDetails(ctx context.Context) ApiUpdateLdapTargetDetailsRequest {
	return ApiUpdateLdapTargetDetailsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateTargetOutput
func (a *V2ApiService) UpdateLdapTargetDetailsExecute(r ApiUpdateLdapTargetDetailsRequest) (*UpdateTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateLdapTargetDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-ldap-target-details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateLinkedTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateLinkedTarget *UpdateLinkedTarget
    body interface{}
}

func (r ApiUpdateLinkedTargetRequest) UpdateLinkedTarget(updateLinkedTarget UpdateLinkedTarget) ApiUpdateLinkedTargetRequest {
	r.updateLinkedTarget = &updateLinkedTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateLinkedTargetRequest) Body(body UpdateLinkedTarget) ApiUpdateLinkedTargetRequest {
    r.body = body
    return r
}

func (r ApiUpdateLinkedTargetRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateLinkedTargetExecute(r)
}

/*
UpdateLinkedTarget Method for UpdateLinkedTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateLinkedTargetRequest
*/
func (a *V2ApiService) UpdateLinkedTarget(ctx context.Context) ApiUpdateLinkedTargetRequest {
	return ApiUpdateLinkedTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) UpdateLinkedTargetExecute(r ApiUpdateLinkedTargetRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateLinkedTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-linked-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateNativeK8STargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateNativeK8STarget *UpdateNativeK8STarget
    body interface{}
}

func (r ApiUpdateNativeK8STargetRequest) UpdateNativeK8STarget(updateNativeK8STarget UpdateNativeK8STarget) ApiUpdateNativeK8STargetRequest {
	r.updateNativeK8STarget = &updateNativeK8STarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateNativeK8STargetRequest) Body(body UpdateNativeK8STarget) ApiUpdateNativeK8STargetRequest {
    r.body = body
    return r
}

func (r ApiUpdateNativeK8STargetRequest) Execute() (*UpdateNativeK8STargetOutput, *http.Response, error) {
	return r.ApiService.UpdateNativeK8STargetExecute(r)
}

/*
UpdateNativeK8STarget Method for UpdateNativeK8STarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateNativeK8STargetRequest
*/
func (a *V2ApiService) UpdateNativeK8STarget(ctx context.Context) ApiUpdateNativeK8STargetRequest {
	return ApiUpdateNativeK8STargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateNativeK8STargetOutput
func (a *V2ApiService) UpdateNativeK8STargetExecute(r ApiUpdateNativeK8STargetRequest) (*UpdateNativeK8STargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateNativeK8STargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateNativeK8STarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-k8s-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateOidcAppRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateOidcApp *UpdateOidcApp
    body interface{}
}

func (r ApiUpdateOidcAppRequest) UpdateOidcApp(updateOidcApp UpdateOidcApp) ApiUpdateOidcAppRequest {
	r.updateOidcApp = &updateOidcApp
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateOidcAppRequest) Body(body UpdateOidcApp) ApiUpdateOidcAppRequest {
    r.body = body
    return r
}

func (r ApiUpdateOidcAppRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateOidcAppExecute(r)
}

/*
UpdateOidcApp Method for UpdateOidcApp

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateOidcAppRequest
*/
func (a *V2ApiService) UpdateOidcApp(ctx context.Context) ApiUpdateOidcAppRequest {
	return ApiUpdateOidcAppRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) UpdateOidcAppExecute(r ApiUpdateOidcAppRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateOidcApp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-oidc-app"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePKICertIssuerRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updatePKICertIssuer *UpdatePKICertIssuer
    body interface{}
}

func (r ApiUpdatePKICertIssuerRequest) UpdatePKICertIssuer(updatePKICertIssuer UpdatePKICertIssuer) ApiUpdatePKICertIssuerRequest {
	r.updatePKICertIssuer = &updatePKICertIssuer
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdatePKICertIssuerRequest) Body(body UpdatePKICertIssuer) ApiUpdatePKICertIssuerRequest {
    r.body = body
    return r
}

func (r ApiUpdatePKICertIssuerRequest) Execute() (*UpdatePKICertIssuerOutput, *http.Response, error) {
	return r.ApiService.UpdatePKICertIssuerExecute(r)
}

/*
UpdatePKICertIssuer Method for UpdatePKICertIssuer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdatePKICertIssuerRequest
*/
func (a *V2ApiService) UpdatePKICertIssuer(ctx context.Context) ApiUpdatePKICertIssuerRequest {
	return ApiUpdatePKICertIssuerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdatePKICertIssuerOutput
func (a *V2ApiService) UpdatePKICertIssuerExecute(r ApiUpdatePKICertIssuerRequest) (*UpdatePKICertIssuerOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdatePKICertIssuerOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdatePKICertIssuer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-pki-cert-issuer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePingTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updatePingTarget *UpdatePingTarget
    body interface{}
}

func (r ApiUpdatePingTargetRequest) UpdatePingTarget(updatePingTarget UpdatePingTarget) ApiUpdatePingTargetRequest {
	r.updatePingTarget = &updatePingTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdatePingTargetRequest) Body(body UpdatePingTarget) ApiUpdatePingTargetRequest {
    r.body = body
    return r
}

func (r ApiUpdatePingTargetRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdatePingTargetExecute(r)
}

/*
UpdatePingTarget Method for UpdatePingTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdatePingTargetRequest
*/
func (a *V2ApiService) UpdatePingTarget(ctx context.Context) ApiUpdatePingTargetRequest {
	return ApiUpdatePingTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) UpdatePingTargetExecute(r ApiUpdatePingTargetRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdatePingTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-ping-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateRDPTargetDetailsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateRDPTargetDetails *UpdateRDPTargetDetails
    body interface{}
}

func (r ApiUpdateRDPTargetDetailsRequest) UpdateRDPTargetDetails(updateRDPTargetDetails UpdateRDPTargetDetails) ApiUpdateRDPTargetDetailsRequest {
	r.updateRDPTargetDetails = &updateRDPTargetDetails
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateRDPTargetDetailsRequest) Body(body UpdateRDPTargetDetails) ApiUpdateRDPTargetDetailsRequest {
    r.body = body
    return r
}

func (r ApiUpdateRDPTargetDetailsRequest) Execute() (*UpdateTargetOutput, *http.Response, error) {
	return r.ApiService.UpdateRDPTargetDetailsExecute(r)
}

/*
UpdateRDPTargetDetails Method for UpdateRDPTargetDetails

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateRDPTargetDetailsRequest
*/
func (a *V2ApiService) UpdateRDPTargetDetails(ctx context.Context) ApiUpdateRDPTargetDetailsRequest {
	return ApiUpdateRDPTargetDetailsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateTargetOutput
func (a *V2ApiService) UpdateRDPTargetDetailsExecute(r ApiUpdateRDPTargetDetailsRequest) (*UpdateTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateRDPTargetDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-rdp-target-details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateRabbitMQTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateRabbitMQTarget *UpdateRabbitMQTarget
    body interface{}
}

func (r ApiUpdateRabbitMQTargetRequest) UpdateRabbitMQTarget(updateRabbitMQTarget UpdateRabbitMQTarget) ApiUpdateRabbitMQTargetRequest {
	r.updateRabbitMQTarget = &updateRabbitMQTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateRabbitMQTargetRequest) Body(body UpdateRabbitMQTarget) ApiUpdateRabbitMQTargetRequest {
    r.body = body
    return r
}

func (r ApiUpdateRabbitMQTargetRequest) Execute() (*UpdateRabbitMQTargetOutput, *http.Response, error) {
	return r.ApiService.UpdateRabbitMQTargetExecute(r)
}

/*
UpdateRabbitMQTarget Method for UpdateRabbitMQTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateRabbitMQTargetRequest
*/
func (a *V2ApiService) UpdateRabbitMQTarget(ctx context.Context) ApiUpdateRabbitMQTargetRequest {
	return ApiUpdateRabbitMQTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateRabbitMQTargetOutput
func (a *V2ApiService) UpdateRabbitMQTargetExecute(r ApiUpdateRabbitMQTargetRequest) (*UpdateRabbitMQTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateRabbitMQTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateRabbitMQTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-rabbitmq-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateRabbitMQTargetDetailsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateRabbitMQTargetDetails *UpdateRabbitMQTargetDetails
    body interface{}
}

func (r ApiUpdateRabbitMQTargetDetailsRequest) UpdateRabbitMQTargetDetails(updateRabbitMQTargetDetails UpdateRabbitMQTargetDetails) ApiUpdateRabbitMQTargetDetailsRequest {
	r.updateRabbitMQTargetDetails = &updateRabbitMQTargetDetails
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateRabbitMQTargetDetailsRequest) Body(body UpdateRabbitMQTargetDetails) ApiUpdateRabbitMQTargetDetailsRequest {
    r.body = body
    return r
}

func (r ApiUpdateRabbitMQTargetDetailsRequest) Execute() (*UpdateTargetOutput, *http.Response, error) {
	return r.ApiService.UpdateRabbitMQTargetDetailsExecute(r)
}

/*
UpdateRabbitMQTargetDetails Method for UpdateRabbitMQTargetDetails

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateRabbitMQTargetDetailsRequest
*/
func (a *V2ApiService) UpdateRabbitMQTargetDetails(ctx context.Context) ApiUpdateRabbitMQTargetDetailsRequest {
	return ApiUpdateRabbitMQTargetDetailsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateTargetOutput
func (a *V2ApiService) UpdateRabbitMQTargetDetailsExecute(r ApiUpdateRabbitMQTargetDetailsRequest) (*UpdateTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateRabbitMQTargetDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-rabbitmq-target-details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateRoleRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateRole *UpdateRole
    body interface{}
}

func (r ApiUpdateRoleRequest) UpdateRole(updateRole UpdateRole) ApiUpdateRoleRequest {
	r.updateRole = &updateRole
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateRoleRequest) Body(body UpdateRole) ApiUpdateRoleRequest {
    r.body = body
    return r
}

func (r ApiUpdateRoleRequest) Execute() (*UpdateRoleOutput, *http.Response, error) {
	return r.ApiService.UpdateRoleExecute(r)
}

/*
UpdateRole Method for UpdateRole

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateRoleRequest
*/
func (a *V2ApiService) UpdateRole(ctx context.Context) ApiUpdateRoleRequest {
	return ApiUpdateRoleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateRoleOutput
func (a *V2ApiService) UpdateRoleExecute(r ApiUpdateRoleRequest) (*UpdateRoleOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateRoleOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-role"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateRotatedSecretRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateRotatedSecret *UpdateRotatedSecret
    body interface{}
}

func (r ApiUpdateRotatedSecretRequest) UpdateRotatedSecret(updateRotatedSecret UpdateRotatedSecret) ApiUpdateRotatedSecretRequest {
	r.updateRotatedSecret = &updateRotatedSecret
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateRotatedSecretRequest) Body(body UpdateRotatedSecret) ApiUpdateRotatedSecretRequest {
    r.body = body
    return r
}

func (r ApiUpdateRotatedSecretRequest) Execute() (*UpdateRotatedSecretOutput, *http.Response, error) {
	return r.ApiService.UpdateRotatedSecretExecute(r)
}

/*
UpdateRotatedSecret Method for UpdateRotatedSecret

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateRotatedSecretRequest
*/
func (a *V2ApiService) UpdateRotatedSecret(ctx context.Context) ApiUpdateRotatedSecretRequest {
	return ApiUpdateRotatedSecretRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateRotatedSecretOutput
func (a *V2ApiService) UpdateRotatedSecretExecute(r ApiUpdateRotatedSecretRequest) (*UpdateRotatedSecretOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateRotatedSecretOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateRotatedSecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-rotated-secret"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateRotationSettingsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateRotationSettings *UpdateRotationSettings
    body interface{}
}

func (r ApiUpdateRotationSettingsRequest) UpdateRotationSettings(updateRotationSettings UpdateRotationSettings) ApiUpdateRotationSettingsRequest {
	r.updateRotationSettings = &updateRotationSettings
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateRotationSettingsRequest) Body(body UpdateRotationSettings) ApiUpdateRotationSettingsRequest {
    r.body = body
    return r
}

func (r ApiUpdateRotationSettingsRequest) Execute() (*RotateKeyOutput, *http.Response, error) {
	return r.ApiService.UpdateRotationSettingsExecute(r)
}

/*
UpdateRotationSettings Method for UpdateRotationSettings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateRotationSettingsRequest
*/
func (a *V2ApiService) UpdateRotationSettings(ctx context.Context) ApiUpdateRotationSettingsRequest {
	return ApiUpdateRotationSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotateKeyOutput
func (a *V2ApiService) UpdateRotationSettingsExecute(r ApiUpdateRotationSettingsRequest) (*RotateKeyOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotateKeyOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateRotationSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-rotation-settings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSSHCertIssuerRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateSSHCertIssuer *UpdateSSHCertIssuer
    body interface{}
}

func (r ApiUpdateSSHCertIssuerRequest) UpdateSSHCertIssuer(updateSSHCertIssuer UpdateSSHCertIssuer) ApiUpdateSSHCertIssuerRequest {
	r.updateSSHCertIssuer = &updateSSHCertIssuer
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateSSHCertIssuerRequest) Body(body UpdateSSHCertIssuer) ApiUpdateSSHCertIssuerRequest {
    r.body = body
    return r
}

func (r ApiUpdateSSHCertIssuerRequest) Execute() (*UpdateSSHCertIssuerOutput, *http.Response, error) {
	return r.ApiService.UpdateSSHCertIssuerExecute(r)
}

/*
UpdateSSHCertIssuer Method for UpdateSSHCertIssuer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateSSHCertIssuerRequest
*/
func (a *V2ApiService) UpdateSSHCertIssuer(ctx context.Context) ApiUpdateSSHCertIssuerRequest {
	return ApiUpdateSSHCertIssuerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateSSHCertIssuerOutput
func (a *V2ApiService) UpdateSSHCertIssuerExecute(r ApiUpdateSSHCertIssuerRequest) (*UpdateSSHCertIssuerOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateSSHCertIssuerOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateSSHCertIssuer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-ssh-cert-issuer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSSHTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateSSHTarget *UpdateSSHTarget
    body interface{}
}

func (r ApiUpdateSSHTargetRequest) UpdateSSHTarget(updateSSHTarget UpdateSSHTarget) ApiUpdateSSHTargetRequest {
	r.updateSSHTarget = &updateSSHTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateSSHTargetRequest) Body(body UpdateSSHTarget) ApiUpdateSSHTargetRequest {
    r.body = body
    return r
}

func (r ApiUpdateSSHTargetRequest) Execute() (*UpdateSSHTargetOutput, *http.Response, error) {
	return r.ApiService.UpdateSSHTargetExecute(r)
}

/*
UpdateSSHTarget Method for UpdateSSHTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateSSHTargetRequest
*/
func (a *V2ApiService) UpdateSSHTarget(ctx context.Context) ApiUpdateSSHTargetRequest {
	return ApiUpdateSSHTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateSSHTargetOutput
func (a *V2ApiService) UpdateSSHTargetExecute(r ApiUpdateSSHTargetRequest) (*UpdateSSHTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateSSHTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateSSHTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-ssh-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSSHTargetDetailsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateSSHTargetDetails *UpdateSSHTargetDetails
    body interface{}
}

func (r ApiUpdateSSHTargetDetailsRequest) UpdateSSHTargetDetails(updateSSHTargetDetails UpdateSSHTargetDetails) ApiUpdateSSHTargetDetailsRequest {
	r.updateSSHTargetDetails = &updateSSHTargetDetails
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateSSHTargetDetailsRequest) Body(body UpdateSSHTargetDetails) ApiUpdateSSHTargetDetailsRequest {
    r.body = body
    return r
}

func (r ApiUpdateSSHTargetDetailsRequest) Execute() (*UpdateTargetOutput, *http.Response, error) {
	return r.ApiService.UpdateSSHTargetDetailsExecute(r)
}

/*
UpdateSSHTargetDetails Method for UpdateSSHTargetDetails

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateSSHTargetDetailsRequest
*/
func (a *V2ApiService) UpdateSSHTargetDetails(ctx context.Context) ApiUpdateSSHTargetDetailsRequest {
	return ApiUpdateSSHTargetDetailsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateTargetOutput
func (a *V2ApiService) UpdateSSHTargetDetailsExecute(r ApiUpdateSSHTargetDetailsRequest) (*UpdateTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateSSHTargetDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-ssh-target-details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSalesforceTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateSalesforceTarget *UpdateSalesforceTarget
    body interface{}
}

func (r ApiUpdateSalesforceTargetRequest) UpdateSalesforceTarget(updateSalesforceTarget UpdateSalesforceTarget) ApiUpdateSalesforceTargetRequest {
	r.updateSalesforceTarget = &updateSalesforceTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateSalesforceTargetRequest) Body(body UpdateSalesforceTarget) ApiUpdateSalesforceTargetRequest {
    r.body = body
    return r
}

func (r ApiUpdateSalesforceTargetRequest) Execute() (*UpdateSalesforceTargetOutput, *http.Response, error) {
	return r.ApiService.UpdateSalesforceTargetExecute(r)
}

/*
UpdateSalesforceTarget Method for UpdateSalesforceTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateSalesforceTargetRequest
*/
func (a *V2ApiService) UpdateSalesforceTarget(ctx context.Context) ApiUpdateSalesforceTargetRequest {
	return ApiUpdateSalesforceTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateSalesforceTargetOutput
func (a *V2ApiService) UpdateSalesforceTargetExecute(r ApiUpdateSalesforceTargetRequest) (*UpdateSalesforceTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateSalesforceTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateSalesforceTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-salesforce-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSecretValRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateSecretVal *UpdateSecretVal
    body interface{}
}

func (r ApiUpdateSecretValRequest) UpdateSecretVal(updateSecretVal UpdateSecretVal) ApiUpdateSecretValRequest {
	r.updateSecretVal = &updateSecretVal
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateSecretValRequest) Body(body UpdateSecretVal) ApiUpdateSecretValRequest {
    r.body = body
    return r
}

func (r ApiUpdateSecretValRequest) Execute() (*UpdateSecretValOutput, *http.Response, error) {
	return r.ApiService.UpdateSecretValExecute(r)
}

/*
UpdateSecretVal Method for UpdateSecretVal

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateSecretValRequest
*/
func (a *V2ApiService) UpdateSecretVal(ctx context.Context) ApiUpdateSecretValRequest {
	return ApiUpdateSecretValRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateSecretValOutput
func (a *V2ApiService) UpdateSecretValExecute(r ApiUpdateSecretValRequest) (*UpdateSecretValOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateSecretValOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateSecretVal")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-secret-val"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateTarget *UpdateTarget
    body interface{}
}

func (r ApiUpdateTargetRequest) UpdateTarget(updateTarget UpdateTarget) ApiUpdateTargetRequest {
	r.updateTarget = &updateTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateTargetRequest) Body(body UpdateTarget) ApiUpdateTargetRequest {
    r.body = body
    return r
}

func (r ApiUpdateTargetRequest) Execute() (*UpdateTargetOutput, *http.Response, error) {
	return r.ApiService.UpdateTargetExecute(r)
}

/*
UpdateTarget Method for UpdateTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateTargetRequest
*/
func (a *V2ApiService) UpdateTarget(ctx context.Context) ApiUpdateTargetRequest {
	return ApiUpdateTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateTargetOutput
func (a *V2ApiService) UpdateTargetExecute(r ApiUpdateTargetRequest) (*UpdateTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTargetDetailsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateTargetDetails *UpdateTargetDetails
    body interface{}
}

func (r ApiUpdateTargetDetailsRequest) UpdateTargetDetails(updateTargetDetails UpdateTargetDetails) ApiUpdateTargetDetailsRequest {
	r.updateTargetDetails = &updateTargetDetails
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateTargetDetailsRequest) Body(body UpdateTargetDetails) ApiUpdateTargetDetailsRequest {
    r.body = body
    return r
}

func (r ApiUpdateTargetDetailsRequest) Execute() (*UpdateTargetOutput, *http.Response, error) {
	return r.ApiService.UpdateTargetDetailsExecute(r)
}

/*
UpdateTargetDetails Method for UpdateTargetDetails

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateTargetDetailsRequest
*/
func (a *V2ApiService) UpdateTargetDetails(ctx context.Context) ApiUpdateTargetDetailsRequest {
	return ApiUpdateTargetDetailsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateTargetOutput
func (a *V2ApiService) UpdateTargetDetailsExecute(r ApiUpdateTargetDetailsRequest) (*UpdateTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateTargetDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-target-details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateWebTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateWebTarget *UpdateWebTarget
    body interface{}
}

func (r ApiUpdateWebTargetRequest) UpdateWebTarget(updateWebTarget UpdateWebTarget) ApiUpdateWebTargetRequest {
	r.updateWebTarget = &updateWebTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateWebTargetRequest) Body(body UpdateWebTarget) ApiUpdateWebTargetRequest {
    r.body = body
    return r
}

func (r ApiUpdateWebTargetRequest) Execute() (*UpdateWebTargetOutput, *http.Response, error) {
	return r.ApiService.UpdateWebTargetExecute(r)
}

/*
UpdateWebTarget Method for UpdateWebTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateWebTargetRequest
*/
func (a *V2ApiService) UpdateWebTarget(ctx context.Context) ApiUpdateWebTargetRequest {
	return ApiUpdateWebTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateWebTargetOutput
func (a *V2ApiService) UpdateWebTargetExecute(r ApiUpdateWebTargetRequest) (*UpdateWebTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateWebTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateWebTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-web-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateWebTargetDetailsRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateWebTargetDetails *UpdateWebTargetDetails
    body interface{}
}

func (r ApiUpdateWebTargetDetailsRequest) UpdateWebTargetDetails(updateWebTargetDetails UpdateWebTargetDetails) ApiUpdateWebTargetDetailsRequest {
	r.updateWebTargetDetails = &updateWebTargetDetails
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateWebTargetDetailsRequest) Body(body UpdateWebTargetDetails) ApiUpdateWebTargetDetailsRequest {
    r.body = body
    return r
}

func (r ApiUpdateWebTargetDetailsRequest) Execute() (*UpdateTargetOutput, *http.Response, error) {
	return r.ApiService.UpdateWebTargetDetailsExecute(r)
}

/*
UpdateWebTargetDetails Method for UpdateWebTargetDetails

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateWebTargetDetailsRequest
*/
func (a *V2ApiService) UpdateWebTargetDetails(ctx context.Context) ApiUpdateWebTargetDetailsRequest {
	return ApiUpdateWebTargetDetailsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateTargetOutput
func (a *V2ApiService) UpdateWebTargetDetailsExecute(r ApiUpdateWebTargetDetailsRequest) (*UpdateTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateWebTargetDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-web-target-details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateWindowsTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateWindowsTarget *UpdateWindowsTarget
    body interface{}
}

func (r ApiUpdateWindowsTargetRequest) UpdateWindowsTarget(updateWindowsTarget UpdateWindowsTarget) ApiUpdateWindowsTargetRequest {
	r.updateWindowsTarget = &updateWindowsTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateWindowsTargetRequest) Body(body UpdateWindowsTarget) ApiUpdateWindowsTargetRequest {
    r.body = body
    return r
}

func (r ApiUpdateWindowsTargetRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateWindowsTargetExecute(r)
}

/*
UpdateWindowsTarget Method for UpdateWindowsTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateWindowsTargetRequest
*/
func (a *V2ApiService) UpdateWindowsTarget(ctx context.Context) ApiUpdateWindowsTargetRequest {
	return ApiUpdateWindowsTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) UpdateWindowsTargetExecute(r ApiUpdateWindowsTargetRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateWindowsTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-windows-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateZeroSSLTargetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	updateZeroSSLTarget *UpdateZeroSSLTarget
    body interface{}
}

func (r ApiUpdateZeroSSLTargetRequest) UpdateZeroSSLTarget(updateZeroSSLTarget UpdateZeroSSLTarget) ApiUpdateZeroSSLTargetRequest {
	r.updateZeroSSLTarget = &updateZeroSSLTarget
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUpdateZeroSSLTargetRequest) Body(body UpdateZeroSSLTarget) ApiUpdateZeroSSLTargetRequest {
    r.body = body
    return r
}

func (r ApiUpdateZeroSSLTargetRequest) Execute() (*UpdateZeroSSLTargetOutput, *http.Response, error) {
	return r.ApiService.UpdateZeroSSLTargetExecute(r)
}

/*
UpdateZeroSSLTarget Method for UpdateZeroSSLTarget

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateZeroSSLTargetRequest
*/
func (a *V2ApiService) UpdateZeroSSLTarget(ctx context.Context) ApiUpdateZeroSSLTargetRequest {
	return ApiUpdateZeroSSLTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateZeroSSLTargetOutput
func (a *V2ApiService) UpdateZeroSSLTargetExecute(r ApiUpdateZeroSSLTargetRequest) (*UpdateZeroSSLTargetOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateZeroSSLTargetOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UpdateZeroSSLTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update-zerossl-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUploadRSARequest struct {
	ctx context.Context
	ApiService *V2ApiService
	uploadRSA *UploadRSA
    body interface{}
}

func (r ApiUploadRSARequest) UploadRSA(uploadRSA UploadRSA) ApiUploadRSARequest {
	r.uploadRSA = &uploadRSA
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUploadRSARequest) Body(body UploadRSA) ApiUploadRSARequest {
    r.body = body
    return r
}

func (r ApiUploadRSARequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UploadRSAExecute(r)
}

/*
UploadRSA Method for UploadRSA

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUploadRSARequest
*/
func (a *V2ApiService) UploadRSA(ctx context.Context) ApiUploadRSARequest {
	return ApiUploadRSARequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) UploadRSAExecute(r ApiUploadRSARequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UploadRSA")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/upload-rsa"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUscCreateRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	uscCreate *UscCreate
    body interface{}
}

func (r ApiUscCreateRequest) UscCreate(uscCreate UscCreate) ApiUscCreateRequest {
	r.uscCreate = &uscCreate
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUscCreateRequest) Body(body UscCreate) ApiUscCreateRequest {
    r.body = body
    return r
}

func (r ApiUscCreateRequest) Execute() (*UscCreateSecretOutput, *http.Response, error) {
	return r.ApiService.UscCreateExecute(r)
}

/*
UscCreate Method for UscCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUscCreateRequest
*/
func (a *V2ApiService) UscCreate(ctx context.Context) ApiUscCreateRequest {
	return ApiUscCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UscCreateSecretOutput
func (a *V2ApiService) UscCreateExecute(r ApiUscCreateRequest) (*UscCreateSecretOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UscCreateSecretOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UscCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/usc-create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUscDeleteRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	uscDelete *UscDelete
    body interface{}
}

func (r ApiUscDeleteRequest) UscDelete(uscDelete UscDelete) ApiUscDeleteRequest {
	r.uscDelete = &uscDelete
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUscDeleteRequest) Body(body UscDelete) ApiUscDeleteRequest {
    r.body = body
    return r
}

func (r ApiUscDeleteRequest) Execute() (*UscDeleteSecretOutput, *http.Response, error) {
	return r.ApiService.UscDeleteExecute(r)
}

/*
UscDelete Method for UscDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUscDeleteRequest
*/
func (a *V2ApiService) UscDelete(ctx context.Context) ApiUscDeleteRequest {
	return ApiUscDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UscDeleteSecretOutput
func (a *V2ApiService) UscDeleteExecute(r ApiUscDeleteRequest) (*UscDeleteSecretOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UscDeleteSecretOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UscDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/usc-delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUscGetRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	uscGet *UscGet
    body interface{}
}

func (r ApiUscGetRequest) UscGet(uscGet UscGet) ApiUscGetRequest {
	r.uscGet = &uscGet
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUscGetRequest) Body(body UscGet) ApiUscGetRequest {
    r.body = body
    return r
}

func (r ApiUscGetRequest) Execute() (*UscGetSecretOutput, *http.Response, error) {
	return r.ApiService.UscGetExecute(r)
}

/*
UscGet Method for UscGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUscGetRequest
*/
func (a *V2ApiService) UscGet(ctx context.Context) ApiUscGetRequest {
	return ApiUscGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UscGetSecretOutput
func (a *V2ApiService) UscGetExecute(r ApiUscGetRequest) (*UscGetSecretOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UscGetSecretOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UscGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/usc-get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUscListRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	uscList *UscList
    body interface{}
}

func (r ApiUscListRequest) UscList(uscList UscList) ApiUscListRequest {
	r.uscList = &uscList
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUscListRequest) Body(body UscList) ApiUscListRequest {
    r.body = body
    return r
}

func (r ApiUscListRequest) Execute() (*UscListSecretsOutput, *http.Response, error) {
	return r.ApiService.UscListExecute(r)
}

/*
UscList Method for UscList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUscListRequest
*/
func (a *V2ApiService) UscList(ctx context.Context) ApiUscListRequest {
	return ApiUscListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UscListSecretsOutput
func (a *V2ApiService) UscListExecute(r ApiUscListRequest) (*UscListSecretsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UscListSecretsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UscList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/usc-list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUscUpdateRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	uscUpdate *UscUpdate
    body interface{}
}

func (r ApiUscUpdateRequest) UscUpdate(uscUpdate UscUpdate) ApiUscUpdateRequest {
	r.uscUpdate = &uscUpdate
	return r
}


    // Body sets the body payload for the API call.
func (r ApiUscUpdateRequest) Body(body UscUpdate) ApiUscUpdateRequest {
    r.body = body
    return r
}

func (r ApiUscUpdateRequest) Execute() (*UscUpdateSecretOutput, *http.Response, error) {
	return r.ApiService.UscUpdateExecute(r)
}

/*
UscUpdate Method for UscUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUscUpdateRequest
*/
func (a *V2ApiService) UscUpdate(ctx context.Context) ApiUscUpdateRequest {
	return ApiUscUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UscUpdateSecretOutput
func (a *V2ApiService) UscUpdateExecute(r ApiUscUpdateRequest) (*UscUpdateSecretOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UscUpdateSecretOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.UscUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/usc-update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidateTokenRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	validateToken *ValidateToken
    body interface{}
}

func (r ApiValidateTokenRequest) ValidateToken(validateToken ValidateToken) ApiValidateTokenRequest {
	r.validateToken = &validateToken
	return r
}


    // Body sets the body payload for the API call.
func (r ApiValidateTokenRequest) Body(body ValidateToken) ApiValidateTokenRequest {
    r.body = body
    return r
}

func (r ApiValidateTokenRequest) Execute() (*ValidateTokenOutput, *http.Response, error) {
	return r.ApiService.ValidateTokenExecute(r)
}

/*
ValidateToken Method for ValidateToken

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiValidateTokenRequest
*/
func (a *V2ApiService) ValidateToken(ctx context.Context) ApiValidateTokenRequest {
	return ApiValidateTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ValidateTokenOutput
func (a *V2ApiService) ValidateTokenExecute(r ApiValidateTokenRequest) (*ValidateTokenOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ValidateTokenOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.ValidateToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validate-token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVerifyDataWithClassicKeyRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	verifyDataWithClassicKey *VerifyDataWithClassicKey
    body interface{}
}

func (r ApiVerifyDataWithClassicKeyRequest) VerifyDataWithClassicKey(verifyDataWithClassicKey VerifyDataWithClassicKey) ApiVerifyDataWithClassicKeyRequest {
	r.verifyDataWithClassicKey = &verifyDataWithClassicKey
	return r
}


    // Body sets the body payload for the API call.
func (r ApiVerifyDataWithClassicKeyRequest) Body(body VerifyDataWithClassicKey) ApiVerifyDataWithClassicKeyRequest {
    r.body = body
    return r
}

func (r ApiVerifyDataWithClassicKeyRequest) Execute() (*VerifyPKICertOutput, *http.Response, error) {
	return r.ApiService.VerifyDataWithClassicKeyExecute(r)
}

/*
VerifyDataWithClassicKey Method for VerifyDataWithClassicKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVerifyDataWithClassicKeyRequest
*/
func (a *V2ApiService) VerifyDataWithClassicKey(ctx context.Context) ApiVerifyDataWithClassicKeyRequest {
	return ApiVerifyDataWithClassicKeyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VerifyPKICertOutput
func (a *V2ApiService) VerifyDataWithClassicKeyExecute(r ApiVerifyDataWithClassicKeyRequest) (*VerifyPKICertOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VerifyPKICertOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.VerifyDataWithClassicKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/verify-data-with-classic-key"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVerifyEcDsaRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	verifyEcDsa *VerifyEcDsa
    body interface{}
}

func (r ApiVerifyEcDsaRequest) VerifyEcDsa(verifyEcDsa VerifyEcDsa) ApiVerifyEcDsaRequest {
	r.verifyEcDsa = &verifyEcDsa
	return r
}


    // Body sets the body payload for the API call.
func (r ApiVerifyEcDsaRequest) Body(body VerifyEcDsa) ApiVerifyEcDsaRequest {
    r.body = body
    return r
}

func (r ApiVerifyEcDsaRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.VerifyEcDsaExecute(r)
}

/*
VerifyEcDsa Method for VerifyEcDsa

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVerifyEcDsaRequest
*/
func (a *V2ApiService) VerifyEcDsa(ctx context.Context) ApiVerifyEcDsaRequest {
	return ApiVerifyEcDsaRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) VerifyEcDsaExecute(r ApiVerifyEcDsaRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.VerifyEcDsa")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/verify-ecdsa"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVerifyGPGRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	verifyGPG *VerifyGPG
    body interface{}
}

func (r ApiVerifyGPGRequest) VerifyGPG(verifyGPG VerifyGPG) ApiVerifyGPGRequest {
	r.verifyGPG = &verifyGPG
	return r
}


    // Body sets the body payload for the API call.
func (r ApiVerifyGPGRequest) Body(body VerifyGPG) ApiVerifyGPGRequest {
    r.body = body
    return r
}

func (r ApiVerifyGPGRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.VerifyGPGExecute(r)
}

/*
VerifyGPG Method for VerifyGPG

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVerifyGPGRequest
*/
func (a *V2ApiService) VerifyGPG(ctx context.Context) ApiVerifyGPGRequest {
	return ApiVerifyGPGRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) VerifyGPGExecute(r ApiVerifyGPGRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.VerifyGPG")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/verify-gpg"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVerifyJWTWithClassicKeyRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	verifyJWTWithClassicKey *VerifyJWTWithClassicKey
    body interface{}
}

func (r ApiVerifyJWTWithClassicKeyRequest) VerifyJWTWithClassicKey(verifyJWTWithClassicKey VerifyJWTWithClassicKey) ApiVerifyJWTWithClassicKeyRequest {
	r.verifyJWTWithClassicKey = &verifyJWTWithClassicKey
	return r
}


    // Body sets the body payload for the API call.
func (r ApiVerifyJWTWithClassicKeyRequest) Body(body VerifyJWTWithClassicKey) ApiVerifyJWTWithClassicKeyRequest {
    r.body = body
    return r
}

func (r ApiVerifyJWTWithClassicKeyRequest) Execute() (*VerifyJWTOutput, *http.Response, error) {
	return r.ApiService.VerifyJWTWithClassicKeyExecute(r)
}

/*
VerifyJWTWithClassicKey Method for VerifyJWTWithClassicKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVerifyJWTWithClassicKeyRequest
*/
func (a *V2ApiService) VerifyJWTWithClassicKey(ctx context.Context) ApiVerifyJWTWithClassicKeyRequest {
	return ApiVerifyJWTWithClassicKeyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VerifyJWTOutput
func (a *V2ApiService) VerifyJWTWithClassicKeyExecute(r ApiVerifyJWTWithClassicKeyRequest) (*VerifyJWTOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VerifyJWTOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.VerifyJWTWithClassicKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/verify-jwt-with-classic-key"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVerifyPKCS1Request struct {
	ctx context.Context
	ApiService *V2ApiService
	verifyPKCS1 *VerifyPKCS1
    body interface{}
}

func (r ApiVerifyPKCS1Request) VerifyPKCS1(verifyPKCS1 VerifyPKCS1) ApiVerifyPKCS1Request {
	r.verifyPKCS1 = &verifyPKCS1
	return r
}


    // Body sets the body payload for the API call.
func (r ApiVerifyPKCS1Request) Body(body VerifyPKCS1) ApiVerifyPKCS1Request {
    r.body = body
    return r
}

func (r ApiVerifyPKCS1Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.VerifyPKCS1Execute(r)
}

/*
VerifyPKCS1 Method for VerifyPKCS1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVerifyPKCS1Request
*/
func (a *V2ApiService) VerifyPKCS1(ctx context.Context) ApiVerifyPKCS1Request {
	return ApiVerifyPKCS1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) VerifyPKCS1Execute(r ApiVerifyPKCS1Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.VerifyPKCS1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/verify-pkcs1"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVerifyPKICertWithClassicKeyRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	verifyPKICertWithClassicKey *VerifyPKICertWithClassicKey
    body interface{}
}

func (r ApiVerifyPKICertWithClassicKeyRequest) VerifyPKICertWithClassicKey(verifyPKICertWithClassicKey VerifyPKICertWithClassicKey) ApiVerifyPKICertWithClassicKeyRequest {
	r.verifyPKICertWithClassicKey = &verifyPKICertWithClassicKey
	return r
}


    // Body sets the body payload for the API call.
func (r ApiVerifyPKICertWithClassicKeyRequest) Body(body VerifyPKICertWithClassicKey) ApiVerifyPKICertWithClassicKeyRequest {
    r.body = body
    return r
}

func (r ApiVerifyPKICertWithClassicKeyRequest) Execute() (*VerifyPKICertOutput, *http.Response, error) {
	return r.ApiService.VerifyPKICertWithClassicKeyExecute(r)
}

/*
VerifyPKICertWithClassicKey Method for VerifyPKICertWithClassicKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVerifyPKICertWithClassicKeyRequest
*/
func (a *V2ApiService) VerifyPKICertWithClassicKey(ctx context.Context) ApiVerifyPKICertWithClassicKeyRequest {
	return ApiVerifyPKICertWithClassicKeyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VerifyPKICertOutput
func (a *V2ApiService) VerifyPKICertWithClassicKeyExecute(r ApiVerifyPKICertWithClassicKeyRequest) (*VerifyPKICertOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VerifyPKICertOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.VerifyPKICertWithClassicKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/verify-pki-cert-with-classic-key"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVerifyRsaSsaPssRequest struct {
	ctx context.Context
	ApiService *V2ApiService
	verifyRsaSsaPss *VerifyRsaSsaPss
    body interface{}
}

func (r ApiVerifyRsaSsaPssRequest) VerifyRsaSsaPss(verifyRsaSsaPss VerifyRsaSsaPss) ApiVerifyRsaSsaPssRequest {
	r.verifyRsaSsaPss = &verifyRsaSsaPss
	return r
}


    // Body sets the body payload for the API call.
func (r ApiVerifyRsaSsaPssRequest) Body(body VerifyRsaSsaPss) ApiVerifyRsaSsaPssRequest {
    r.body = body
    return r
}

func (r ApiVerifyRsaSsaPssRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.VerifyRsaSsaPssExecute(r)
}

/*
VerifyRsaSsaPss Method for VerifyRsaSsaPss

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVerifyRsaSsaPssRequest
*/
func (a *V2ApiService) VerifyRsaSsaPss(ctx context.Context) ApiVerifyRsaSsaPssRequest {
	return ApiVerifyRsaSsaPssRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V2ApiService) VerifyRsaSsaPssExecute(r ApiVerifyRsaSsaPssRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2ApiService.VerifyRsaSsaPss")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/verify-rsassa-pss"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("Body() is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JSONError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
