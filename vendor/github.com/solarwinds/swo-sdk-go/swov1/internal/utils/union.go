// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package utils

import (
	"encoding/json"
	"math/big"
	"reflect"
	"strings"
	"time"

	"github.com/solarwinds/swo-sdk-go/swov1/types"
)

// UnionCandidate represents a candidate type during union deserialization
type UnionCandidate struct {
	Matched              int // Count of matched fields (includes inexact)
	Inexact              int // Count of fields with unknown/unrecognized enum values
	Unmatched            int // Count of struct fields not found in raw JSON
	AdditionalProperties int // Count of fields captured by additionalProperties
	Type                 any // The union type enum value
	Value                any // The unmarshaled value
}

// PickBestUnionCandidate selects the best union type candidate according to `betterCandidate`
func PickBestUnionCandidate(candidates []UnionCandidate, rawJSON []byte) *UnionCandidate {
	if len(candidates) == 0 {
		return nil
	}

	if len(candidates) == 1 {
		return &candidates[0]
	}

	var raw any
	_ = json.Unmarshal(rawJSON, &raw)

	var best *UnionCandidate
	for i := range candidates {
		countFields(&candidates[i], raw)
		best = betterCandidate(best, &candidates[i])
	}
	return best
}

// betterCandidate returns the better of two candidates based on:
// 1. Matched count (higher is better)
// 2. Inexact count (lower is better)
// 3. Unmatched count (lower is better - fewer zero defaulted values)
// 4. AdditionalProperties count (higher is better - captures more extra fields)
// Returns a if tied (preserving spec order).
func betterCandidate(a, b *UnionCandidate) *UnionCandidate {
	if a == nil {
		return b
	}
	if b == nil {
		return a
	}
	if a.Matched != b.Matched {
		if a.Matched > b.Matched {
			return a
		}
		return b
	}
	if a.Inexact != b.Inexact {
		if a.Inexact > b.Inexact {
			return b
		}
		return a
	}
	if a.Unmatched != b.Unmatched {
		if a.Unmatched > b.Unmatched {
			return b
		}
		return a
	}
	if a.AdditionalProperties != b.AdditionalProperties {
		if a.AdditionalProperties > b.AdditionalProperties {
			return a
		}
		return b
	}
	return a
}

// countFields populates UnionCandidate.Matched, UnionCandidate.Inexact, and UnionCandidate.Unmatched fields
func countFields(candidate *UnionCandidate, raw any) {
	typ := reflect.TypeOf(candidate.Value)
	val := reflect.ValueOf(candidate.Value)
	countFieldsRecursive(candidate, typ, val, raw)
}

func countFieldsRecursive(candidate *UnionCandidate, typ reflect.Type, val reflect.Value, raw any) {
	kind := typ.Kind()

	// Handle interface{}/any types - can hold any JSON value
	if kind == reflect.Interface {
		candidate.Matched++
		return
	}

	if typ.Kind() == reflect.Ptr {
		if raw == nil {
			// Handle null JSON value match
			candidate.Matched++
			return
		}
		typ, val = dereferencePointers(typ, val)
		kind = typ.Kind()
	}

	// Handle primitives
	if kind == reflect.String ||
		kind == reflect.Bool ||
		kind == reflect.Int || kind == reflect.Int8 || kind == reflect.Int16 || kind == reflect.Int32 || kind == reflect.Int64 ||
		kind == reflect.Uint || kind == reflect.Uint8 || kind == reflect.Uint16 || kind == reflect.Uint32 || kind == reflect.Uint64 ||
		kind == reflect.Float32 || kind == reflect.Float64 ||
		typ == reflect.TypeOf(time.Time{}) ||
		typ == reflect.TypeOf(big.Int{}) ||
		typ == reflect.TypeOf(types.Date{}) ||
		typ == reflect.TypeOf([]byte{}) {
		candidate.Matched++
		if !isExact(val) || raw == nil {
			candidate.Inexact++
		}
		return
	}

	// Handle unions
	if isUnion, activeVariant, variantVal := findActiveUnionVariant(typ, val); isUnion {
		if activeVariant != nil && !variantVal.IsNil() {
			countFieldsRecursive(candidate, activeVariant.Type.Elem(), variantVal.Elem(), raw)
		}
		return
	}

	// Handle regular structs
	if kind == reflect.Struct {
		rawObj, ok := raw.(map[string]any)
		if !ok {
			return
		}

		for i := 0; i < typ.NumField(); i++ {
			field := typ.Field(i)
			fieldVal := val.Field(i)

			if field.Tag.Get("additionalProperties") == "true" {
				if field.Type.Kind() == reflect.Map && !fieldVal.IsNil() {
					candidate.AdditionalProperties += fieldVal.Len()
				}
				continue
			}

			jsonName, ok := jsonFieldName(field)
			if !ok {
				continue
			}

			rawField, exists := rawObj[jsonName]
			if !exists {
				candidate.Unmatched++
				continue
			}

			countFieldsRecursive(candidate, field.Type, fieldVal, rawField)
		}
		return
	}

	// Handle slices and arrays
	if kind == reflect.Slice || kind == reflect.Array {
		if val.IsNil() || val.Len() == 0 {
			return
		}

		rawArr, ok := raw.([]any)
		if !ok {
			return
		}

		// Count each array/slice element
		for i := 0; i < val.Len() && i < len(rawArr); i++ {
			itemVal := val.Index(i)
			countFieldsRecursive(candidate, itemVal.Type(), itemVal, rawArr[i])
		}
		return
	}

	// Handle maps
	if kind == reflect.Map {
		if val.IsNil() || val.Len() == 0 {
			return
		}

		rawObj, ok := raw.(map[string]any)
		if !ok {
			return
		}

		for _, key := range val.MapKeys() {
			keyStr := key.String()
			rawVal, exists := rawObj[keyStr]
			if exists {
				mapVal := val.MapIndex(key)
				countFieldsRecursive(candidate, mapVal.Type(), mapVal, rawVal)
			}
		}
		return
	}
	// Anything else
	candidate.Matched++
	return
}

// jsonFieldName returns the JSON field name for a struct field.
// Returns ("", false) if the field should be skipped (json:"-").
func jsonFieldName(field reflect.StructField) (string, bool) {
	jsonTag := field.Tag.Get("json")
	if jsonTag == "-" {
		return "", false
	}
	if jsonTag != "" {
		parts := strings.Split(jsonTag, ",")
		if parts[0] != "" {
			return parts[0], true
		}
	}
	return field.Name, true
}

// findActiveUnionVariant detects if a struct is a union type and returns the active variant.
// A union type is detected by having fields with the `union:"member"` tag.
// Returns (false, nil, invalid) if not a union type.
// Returns (true, nil, invalid) if union type but no active variant found (all nil).
// Returns (true, field, value) if union type with an active variant.
func findActiveUnionVariant(typ reflect.Type, val reflect.Value) (bool, *reflect.StructField, reflect.Value) {
	if typ.Kind() != reflect.Struct {
		return false, nil, reflect.Value{}
	}

	var activeVariant *reflect.StructField
	var activeValue reflect.Value
	isUnion := false

	for i := 0; i < typ.NumField(); i++ {
		field := typ.Field(i)

		// Look for fields tagged as union members
		if field.Tag.Get("union") != "member" {
			continue
		}

		isUnion = true

		// All union variants are pointers - only set active if non-nil
		fieldVal := val.Field(i)
		if !fieldVal.IsNil() {
			activeVariant = &field
			activeValue = fieldVal
		}
	}

	return isUnion, activeVariant, activeValue
}

func isExact(val reflect.Value) bool {
	if !val.IsValid() {
		return true
	}

	// If not addressable, make an addressable copy
	if !val.CanAddr() && val.CanInterface() {
		ptr := reflect.New(val.Type())
		ptr.Elem().Set(val)
		val = ptr.Elem()
	}

	if val.CanInterface() && val.CanAddr() {
		ptrVal := val.Addr()
		if method := ptrVal.MethodByName("IsExact"); method.IsValid() {
			results := method.Call(nil)
			if len(results) == 1 && results[0].Kind() == reflect.Bool {
				return results[0].Bool()
			}
		}
	}
	return true
}
