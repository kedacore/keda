// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"fmt"
	"github.com/solarwinds/swo-sdk-go/swov1/internal/utils"
)

// AggregateBy - Aggregation method used to group measurements.
type AggregateBy string

const (
	AggregateByAvg   AggregateBy = "AVG"
	AggregateByCount AggregateBy = "COUNT"
	AggregateByMin   AggregateBy = "MIN"
	AggregateByMax   AggregateBy = "MAX"
	AggregateBySum   AggregateBy = "SUM"
	AggregateByLast  AggregateBy = "LAST"
)

func (e AggregateBy) ToPointer() *AggregateBy {
	return &e
}
func (e *AggregateBy) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "AVG":
		fallthrough
	case "COUNT":
		fallthrough
	case "MIN":
		fallthrough
	case "MAX":
		fallthrough
	case "SUM":
		fallthrough
	case "LAST":
		*e = AggregateBy(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AggregateBy: %v", v)
	}
}

// PreGroupByMethod - Aggregation method for secondary grouping, inside individual buckets. Has to be set together with `preGroupBy`.
type PreGroupByMethod string

const (
	PreGroupByMethodAvg   PreGroupByMethod = "AVG"
	PreGroupByMethodCount PreGroupByMethod = "COUNT"
	PreGroupByMethodMin   PreGroupByMethod = "MIN"
	PreGroupByMethodMax   PreGroupByMethod = "MAX"
	PreGroupByMethodSum   PreGroupByMethod = "SUM"
	PreGroupByMethodLast  PreGroupByMethod = "LAST"
)

func (e PreGroupByMethod) ToPointer() *PreGroupByMethod {
	return &e
}
func (e *PreGroupByMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "AVG":
		fallthrough
	case "COUNT":
		fallthrough
	case "MIN":
		fallthrough
	case "MAX":
		fallthrough
	case "SUM":
		fallthrough
	case "LAST":
		*e = PreGroupByMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PreGroupByMethod: %v", v)
	}
}

// SeriesType - Indicates what type of data to return.
type SeriesType string

const (
	SeriesTypeTimeseries SeriesType = "TIMESERIES"
	SeriesTypeScalar     SeriesType = "SCALAR"
)

func (e SeriesType) ToPointer() *SeriesType {
	return &e
}
func (e *SeriesType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TIMESERIES":
		fallthrough
	case "SCALAR":
		*e = SeriesType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SeriesType: %v", v)
	}
}

// FillMethod - Method for filling missing data points in the range.
type FillMethod string

const (
	FillMethodNone          FillMethod = "NONE"
	FillMethodZeroFill      FillMethod = "ZERO_FILL"
	FillMethodNullFill      FillMethod = "NULL_FILL"
	FillMethodLastValueFill FillMethod = "LAST_VALUE_FILL"
)

func (e FillMethod) ToPointer() *FillMethod {
	return &e
}
func (e *FillMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NONE":
		fallthrough
	case "ZERO_FILL":
		fallthrough
	case "NULL_FILL":
		fallthrough
	case "LAST_VALUE_FILL":
		*e = FillMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for FillMethod: %v", v)
	}
}

type MetricsMeasurementsRequest struct {
	// Optional identifier that will be echoed back for matching.
	ID *string `json:"id,omitempty"`
	// Metric name.
	Name string `json:"name"`
	// Query to filter the measurement values.
	Filter *string `json:"filter,omitempty"`
	// List of attribute names to group measurements by.
	GroupBy []string `json:"groupBy,omitempty"`
	// Aggregation method used to group measurements.
	AggregateBy *AggregateBy `json:"aggregateBy,omitempty"`
	// Secondary grouping, allowing aggregation inside individual buckets. Has to be set together with `preGroupByMethod`.
	PreGroupBy []string `json:"preGroupBy,omitempty"`
	// Aggregation method for secondary grouping, inside individual buckets. Has to be set together with `preGroupBy`.
	PreGroupByMethod *PreGroupByMethod `json:"preGroupByMethod,omitempty"`
	// Indicates what type of data to return.
	SeriesType *SeriesType `default:"TIMESERIES" json:"seriesType"`
	// Method for filling missing data points in the range.
	FillMethod *FillMethod `default:"NONE" json:"fillMethod"`
	// Asks for filling even if no data points were found in the range.
	FillIfEmpty *bool `default:"false" json:"fillIfEmpty"`
}

func (m MetricsMeasurementsRequest) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MetricsMeasurementsRequest) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, []string{"name"}); err != nil {
		return err
	}
	return nil
}

func (m *MetricsMeasurementsRequest) GetID() *string {
	if m == nil {
		return nil
	}
	return m.ID
}

func (m *MetricsMeasurementsRequest) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MetricsMeasurementsRequest) GetFilter() *string {
	if m == nil {
		return nil
	}
	return m.Filter
}

func (m *MetricsMeasurementsRequest) GetGroupBy() []string {
	if m == nil {
		return nil
	}
	return m.GroupBy
}

func (m *MetricsMeasurementsRequest) GetAggregateBy() *AggregateBy {
	if m == nil {
		return nil
	}
	return m.AggregateBy
}

func (m *MetricsMeasurementsRequest) GetPreGroupBy() []string {
	if m == nil {
		return nil
	}
	return m.PreGroupBy
}

func (m *MetricsMeasurementsRequest) GetPreGroupByMethod() *PreGroupByMethod {
	if m == nil {
		return nil
	}
	return m.PreGroupByMethod
}

func (m *MetricsMeasurementsRequest) GetSeriesType() *SeriesType {
	if m == nil {
		return nil
	}
	return m.SeriesType
}

func (m *MetricsMeasurementsRequest) GetFillMethod() *FillMethod {
	if m == nil {
		return nil
	}
	return m.FillMethod
}

func (m *MetricsMeasurementsRequest) GetFillIfEmpty() *bool {
	if m == nil {
		return nil
	}
	return m.FillIfEmpty
}
