// Code generated by protoc-gen-go. DO NOT EDIT.
// plugins:
// 	protoc-gen-go
// 	protoc
// source: temporal/api/workflow/v1/message.proto

package workflow

import (
	reflect "reflect"
	"strconv"
	sync "sync"
	unsafe "unsafe"

	v16 "go.temporal.io/api/activity/v1"
	v1 "go.temporal.io/api/common/v1"
	v12 "go.temporal.io/api/deployment/v1"
	v11 "go.temporal.io/api/enums/v1"
	v15 "go.temporal.io/api/failure/v1"
	v14 "go.temporal.io/api/sdk/v1"
	v13 "go.temporal.io/api/taskqueue/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	fieldmaskpb "google.golang.org/protobuf/types/known/fieldmaskpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type VersioningOverride_PinnedOverrideBehavior int32

const (
	VersioningOverride_PINNED_OVERRIDE_BEHAVIOR_UNSPECIFIED VersioningOverride_PinnedOverrideBehavior = // Unspecified.
	0
	VersioningOverride_PINNED_OVERRIDE_BEHAVIOR_PINNED VersioningOverride_PinnedOverrideBehavior = // Override workflow behavior to be Pinned.
	1
)

// Enum value maps for VersioningOverride_PinnedOverrideBehavior.
var (
	VersioningOverride_PinnedOverrideBehavior_name = map[int32]string{
		0: "PINNED_OVERRIDE_BEHAVIOR_UNSPECIFIED",
		1: "PINNED_OVERRIDE_BEHAVIOR_PINNED",
	}
	VersioningOverride_PinnedOverrideBehavior_value = map[string]int32{
		"PINNED_OVERRIDE_BEHAVIOR_UNSPECIFIED": 0,
		"PINNED_OVERRIDE_BEHAVIOR_PINNED":      1,
	}
)

func (x VersioningOverride_PinnedOverrideBehavior) Enum() *VersioningOverride_PinnedOverrideBehavior {
	p := new(VersioningOverride_PinnedOverrideBehavior)
	*p = x
	return p
}

func (x VersioningOverride_PinnedOverrideBehavior) String() string {
	switch x {
	case VersioningOverride_PINNED_OVERRIDE_BEHAVIOR_UNSPECIFIED:
		return "VersioningOverridePinnedOverrideBehaviorUnspecified"
	case VersioningOverride_PINNED_OVERRIDE_BEHAVIOR_PINNED:
		return "VersioningOverridePinnedOverrideBehaviorPinned"
	default:
		return strconv.Itoa(int(x))
	}

}

func (VersioningOverride_PinnedOverrideBehavior) Descriptor() protoreflect.EnumDescriptor {
	return file_temporal_api_workflow_v1_message_proto_enumTypes[0].Descriptor()
}

func (VersioningOverride_PinnedOverrideBehavior) Type() protoreflect.EnumType {
	return &file_temporal_api_workflow_v1_message_proto_enumTypes[0]
}

func (x VersioningOverride_PinnedOverrideBehavior) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use VersioningOverride_PinnedOverrideBehavior.Descriptor instead.
func (VersioningOverride_PinnedOverrideBehavior) EnumDescriptor() ([]byte, []int) {
	return file_temporal_api_workflow_v1_message_proto_rawDescGZIP(), []int{16, 0}
}

// Hold basic information about a workflow execution.
// This structure is a part of visibility, and thus contain a limited subset of information.
type WorkflowExecutionInfo struct {
	state                protoimpl.MessageState      `protogen:"open.v1"`
	Execution            *v1.WorkflowExecution       `protobuf:"bytes,1,opt,name=execution,proto3" json:"execution,omitempty"`
	Type                 *v1.WorkflowType            `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	StartTime            *timestamppb.Timestamp      `protobuf:"bytes,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	CloseTime            *timestamppb.Timestamp      `protobuf:"bytes,4,opt,name=close_time,json=closeTime,proto3" json:"close_time,omitempty"`
	Status               v11.WorkflowExecutionStatus `protobuf:"varint,5,opt,name=status,proto3,enum=temporal.api.enums.v1.WorkflowExecutionStatus" json:"status,omitempty"`
	HistoryLength        int64                       `protobuf:"varint,6,opt,name=history_length,json=historyLength,proto3" json:"history_length,omitempty"`
	ParentNamespaceId    string                      `protobuf:"bytes,7,opt,name=parent_namespace_id,json=parentNamespaceId,proto3" json:"parent_namespace_id,omitempty"`
	ParentExecution      *v1.WorkflowExecution       `protobuf:"bytes,8,opt,name=parent_execution,json=parentExecution,proto3" json:"parent_execution,omitempty"`
	ExecutionTime        *timestamppb.Timestamp      `protobuf:"bytes,9,opt,name=execution_time,json=executionTime,proto3" json:"execution_time,omitempty"`
	Memo                 *v1.Memo                    `protobuf:"bytes,10,opt,name=memo,proto3" json:"memo,omitempty"`
	SearchAttributes     *v1.SearchAttributes        `protobuf:"bytes,11,opt,name=search_attributes,json=searchAttributes,proto3" json:"search_attributes,omitempty"`
	AutoResetPoints      *ResetPoints                `protobuf:"bytes,12,opt,name=auto_reset_points,json=autoResetPoints,proto3" json:"auto_reset_points,omitempty"`
	TaskQueue            string                      `protobuf:"bytes,13,opt,name=task_queue,json=taskQueue,proto3" json:"task_queue,omitempty"`
	StateTransitionCount int64                       `protobuf:"varint,14,opt,name=state_transition_count,json=stateTransitionCount,proto3" json:"state_transition_count,omitempty"`
	HistorySizeBytes     int64                       `protobuf:"varint,15,opt,name=history_size_bytes,json=historySizeBytes,proto3" json:"history_size_bytes,omitempty"`
	// If set, the most recent worker version stamp that appeared in a workflow task completion
	// Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
	//
	// Deprecated: Marked as deprecated in temporal/api/workflow/v1/message.proto.
	MostRecentWorkerVersionStamp *v1.WorkerVersionStamp `protobuf:"bytes,16,opt,name=most_recent_worker_version_stamp,json=mostRecentWorkerVersionStamp,proto3" json:"most_recent_worker_version_stamp,omitempty"`
	// Workflow execution duration is defined as difference between close time and execution time.
	// This field is only populated if the workflow is closed.
	ExecutionDuration *durationpb.Duration `protobuf:"bytes,17,opt,name=execution_duration,json=executionDuration,proto3" json:"execution_duration,omitempty"`
	// Contains information about the root workflow execution.
	// The root workflow execution is defined as follows:
	// 1. A workflow without parent workflow is its own root workflow.
	// 2. A workflow that has a parent workflow has the same root workflow as its parent workflow.
	// Note: workflows continued as new or reseted may or may not have parents, check examples below.
	//
	// Examples:
	//
	//	Scenario 1: Workflow W1 starts child workflow W2, and W2 starts child workflow W3.
	//	  - The root workflow of all three workflows is W1.
	//	Scenario 2: Workflow W1 starts child workflow W2, and W2 continued as new W3.
	//	  - The root workflow of all three workflows is W1.
	//	Scenario 3: Workflow W1 continued as new W2.
	//	  - The root workflow of W1 is W1 and the root workflow of W2 is W2.
	//	Scenario 4: Workflow W1 starts child workflow W2, and W2 is reseted, creating W3
	//	  - The root workflow of all three workflows is W1.
	//	Scenario 5: Workflow W1 is reseted, creating W2.
	//	  - The root workflow of W1 is W1 and the root workflow of W2 is W2.
	RootExecution *v1.WorkflowExecution `protobuf:"bytes,18,opt,name=root_execution,json=rootExecution,proto3" json:"root_execution,omitempty"`
	// The currently assigned build ID for this execution. Presence of this value means worker versioning is used
	// for this execution. Assigned build ID is selected based on Worker Versioning Assignment Rules
	// when the first workflow task of the execution is scheduled. If the first workflow task fails and is scheduled
	// again, the assigned build ID may change according to the latest versioning rules.
	// Assigned build ID can also change in the middle of a execution if Compatible Redirect Rules are applied to
	// this execution.
	// Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
	//
	// Deprecated: Marked as deprecated in temporal/api/workflow/v1/message.proto.
	AssignedBuildId string `protobuf:"bytes,19,opt,name=assigned_build_id,json=assignedBuildId,proto3" json:"assigned_build_id,omitempty"`
	// Build ID inherited from a previous/parent execution. If present, assigned_build_id will be set to this, instead
	// of using the assignment rules.
	// Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
	//
	// Deprecated: Marked as deprecated in temporal/api/workflow/v1/message.proto.
	InheritedBuildId string `protobuf:"bytes,20,opt,name=inherited_build_id,json=inheritedBuildId,proto3" json:"inherited_build_id,omitempty"`
	// The first run ID in the execution chain.
	// Executions created via the following operations are considered to be in the same chain
	// - ContinueAsNew
	// - Workflow Retry
	// - Workflow Reset
	// - Cron Schedule
	FirstRunId string `protobuf:"bytes,21,opt,name=first_run_id,json=firstRunId,proto3" json:"first_run_id,omitempty"`
	// Absent value means the workflow execution is not versioned. When present, the execution might
	// be versioned or unversioned, depending on `versioning_info.behavior` and `versioning_info.versioning_override`.
	// Experimental. Versioning info is experimental and might change in the future.
	VersioningInfo *WorkflowExecutionVersioningInfo `protobuf:"bytes,22,opt,name=versioning_info,json=versioningInfo,proto3" json:"versioning_info,omitempty"`
	// The name of Worker Deployment that completed the most recent workflow task.
	// Experimental. Worker Deployments are experimental and might change in the future.
	WorkerDeploymentName string `protobuf:"bytes,23,opt,name=worker_deployment_name,json=workerDeploymentName,proto3" json:"worker_deployment_name,omitempty"`
	// Priority metadata
	Priority *v1.Priority `protobuf:"bytes,24,opt,name=priority,proto3" json:"priority,omitempty"`
	// Total size in bytes of all external payloads referenced in workflow history.
	ExternalPayloadSizeBytes int64 `protobuf:"varint,25,opt,name=external_payload_size_bytes,json=externalPayloadSizeBytes,proto3" json:"external_payload_size_bytes,omitempty"`
	// Count of external payloads referenced in workflow history.
	ExternalPayloadCount int64 `protobuf:"varint,26,opt,name=external_payload_count,json=externalPayloadCount,proto3" json:"external_payload_count,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *WorkflowExecutionInfo) Reset() {
	*x = WorkflowExecutionInfo{}
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WorkflowExecutionInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WorkflowExecutionInfo) ProtoMessage() {}

func (x *WorkflowExecutionInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WorkflowExecutionInfo.ProtoReflect.Descriptor instead.
func (*WorkflowExecutionInfo) Descriptor() ([]byte, []int) {
	return file_temporal_api_workflow_v1_message_proto_rawDescGZIP(), []int{0}
}

func (x *WorkflowExecutionInfo) GetExecution() *v1.WorkflowExecution {
	if x != nil {
		return x.Execution
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetType() *v1.WorkflowType {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetStartTime() *timestamppb.Timestamp {
	if x != nil {
		return x.StartTime
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetCloseTime() *timestamppb.Timestamp {
	if x != nil {
		return x.CloseTime
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetStatus() v11.WorkflowExecutionStatus {
	if x != nil {
		return x.Status
	}
	return v11.WorkflowExecutionStatus(0)
}

func (x *WorkflowExecutionInfo) GetHistoryLength() int64 {
	if x != nil {
		return x.HistoryLength
	}
	return 0
}

func (x *WorkflowExecutionInfo) GetParentNamespaceId() string {
	if x != nil {
		return x.ParentNamespaceId
	}
	return ""
}

func (x *WorkflowExecutionInfo) GetParentExecution() *v1.WorkflowExecution {
	if x != nil {
		return x.ParentExecution
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetExecutionTime() *timestamppb.Timestamp {
	if x != nil {
		return x.ExecutionTime
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetMemo() *v1.Memo {
	if x != nil {
		return x.Memo
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetSearchAttributes() *v1.SearchAttributes {
	if x != nil {
		return x.SearchAttributes
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetAutoResetPoints() *ResetPoints {
	if x != nil {
		return x.AutoResetPoints
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetTaskQueue() string {
	if x != nil {
		return x.TaskQueue
	}
	return ""
}

func (x *WorkflowExecutionInfo) GetStateTransitionCount() int64 {
	if x != nil {
		return x.StateTransitionCount
	}
	return 0
}

func (x *WorkflowExecutionInfo) GetHistorySizeBytes() int64 {
	if x != nil {
		return x.HistorySizeBytes
	}
	return 0
}

// Deprecated: Marked as deprecated in temporal/api/workflow/v1/message.proto.
func (x *WorkflowExecutionInfo) GetMostRecentWorkerVersionStamp() *v1.WorkerVersionStamp {
	if x != nil {
		return x.MostRecentWorkerVersionStamp
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetExecutionDuration() *durationpb.Duration {
	if x != nil {
		return x.ExecutionDuration
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetRootExecution() *v1.WorkflowExecution {
	if x != nil {
		return x.RootExecution
	}
	return nil
}

// Deprecated: Marked as deprecated in temporal/api/workflow/v1/message.proto.
func (x *WorkflowExecutionInfo) GetAssignedBuildId() string {
	if x != nil {
		return x.AssignedBuildId
	}
	return ""
}

// Deprecated: Marked as deprecated in temporal/api/workflow/v1/message.proto.
func (x *WorkflowExecutionInfo) GetInheritedBuildId() string {
	if x != nil {
		return x.InheritedBuildId
	}
	return ""
}

func (x *WorkflowExecutionInfo) GetFirstRunId() string {
	if x != nil {
		return x.FirstRunId
	}
	return ""
}

func (x *WorkflowExecutionInfo) GetVersioningInfo() *WorkflowExecutionVersioningInfo {
	if x != nil {
		return x.VersioningInfo
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetWorkerDeploymentName() string {
	if x != nil {
		return x.WorkerDeploymentName
	}
	return ""
}

func (x *WorkflowExecutionInfo) GetPriority() *v1.Priority {
	if x != nil {
		return x.Priority
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetExternalPayloadSizeBytes() int64 {
	if x != nil {
		return x.ExternalPayloadSizeBytes
	}
	return 0
}

func (x *WorkflowExecutionInfo) GetExternalPayloadCount() int64 {
	if x != nil {
		return x.ExternalPayloadCount
	}
	return 0
}

// Holds all the extra information about workflow execution that is not part of Visibility.
type WorkflowExecutionExtendedInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Workflow execution expiration time is defined as workflow start time plus expiration timeout.
	// Workflow start time may change after workflow reset.
	ExecutionExpirationTime *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=execution_expiration_time,json=executionExpirationTime,proto3" json:"execution_expiration_time,omitempty"`
	// Workflow run expiration time is defined as current workflow run start time plus workflow run timeout.
	RunExpirationTime *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=run_expiration_time,json=runExpirationTime,proto3" json:"run_expiration_time,omitempty"`
	// indicates if the workflow received a cancel request
	CancelRequested bool `protobuf:"varint,3,opt,name=cancel_requested,json=cancelRequested,proto3" json:"cancel_requested,omitempty"`
	// Last workflow reset time. Nil if the workflow was never reset.
	LastResetTime *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=last_reset_time,json=lastResetTime,proto3" json:"last_reset_time,omitempty"`
	// Original workflow start time.
	OriginalStartTime *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=original_start_time,json=originalStartTime,proto3" json:"original_start_time,omitempty"`
	// Reset Run ID points to the new run when this execution is reset. If the execution is reset multiple times, it points to the latest run.
	ResetRunId string `protobuf:"bytes,6,opt,name=reset_run_id,json=resetRunId,proto3" json:"reset_run_id,omitempty"`
	// Request ID information (eg: history event information associated with the request ID).
	// Note: It only contains request IDs from StartWorkflowExecution requests, including indirect
	// calls (eg: if SignalWithStartWorkflowExecution starts a new workflow, then the request ID is
	// used in the StartWorkflowExecution request).
	RequestIdInfos map[string]*RequestIdInfo `protobuf:"bytes,7,rep,name=request_id_infos,json=requestIdInfos,proto3" json:"request_id_infos,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Information about the workflow execution pause operation.
	PauseInfo     *WorkflowExecutionPauseInfo `protobuf:"bytes,8,opt,name=pause_info,json=pauseInfo,proto3" json:"pause_info,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WorkflowExecutionExtendedInfo) Reset() {
	*x = WorkflowExecutionExtendedInfo{}
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WorkflowExecutionExtendedInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WorkflowExecutionExtendedInfo) ProtoMessage() {}

func (x *WorkflowExecutionExtendedInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WorkflowExecutionExtendedInfo.ProtoReflect.Descriptor instead.
func (*WorkflowExecutionExtendedInfo) Descriptor() ([]byte, []int) {
	return file_temporal_api_workflow_v1_message_proto_rawDescGZIP(), []int{1}
}

func (x *WorkflowExecutionExtendedInfo) GetExecutionExpirationTime() *timestamppb.Timestamp {
	if x != nil {
		return x.ExecutionExpirationTime
	}
	return nil
}

func (x *WorkflowExecutionExtendedInfo) GetRunExpirationTime() *timestamppb.Timestamp {
	if x != nil {
		return x.RunExpirationTime
	}
	return nil
}

func (x *WorkflowExecutionExtendedInfo) GetCancelRequested() bool {
	if x != nil {
		return x.CancelRequested
	}
	return false
}

func (x *WorkflowExecutionExtendedInfo) GetLastResetTime() *timestamppb.Timestamp {
	if x != nil {
		return x.LastResetTime
	}
	return nil
}

func (x *WorkflowExecutionExtendedInfo) GetOriginalStartTime() *timestamppb.Timestamp {
	if x != nil {
		return x.OriginalStartTime
	}
	return nil
}

func (x *WorkflowExecutionExtendedInfo) GetResetRunId() string {
	if x != nil {
		return x.ResetRunId
	}
	return ""
}

func (x *WorkflowExecutionExtendedInfo) GetRequestIdInfos() map[string]*RequestIdInfo {
	if x != nil {
		return x.RequestIdInfos
	}
	return nil
}

func (x *WorkflowExecutionExtendedInfo) GetPauseInfo() *WorkflowExecutionPauseInfo {
	if x != nil {
		return x.PauseInfo
	}
	return nil
}

// Holds all the information about worker versioning for a particular workflow execution.
// Experimental. Versioning info is experimental and might change in the future.
type WorkflowExecutionVersioningInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Versioning behavior determines how the server should treat this execution when workers are
	// upgraded. When present it means this workflow execution is versioned; UNSPECIFIED means
	// unversioned. See the comments in `VersioningBehavior` enum for more info about different
	// behaviors.
	//
	// Child workflows or CaN executions **inherit** their parent/previous run's effective Versioning
	// Behavior and Version (except when the new execution runs on a task queue not belonging to the
	// same deployment version as the parent/previous run's task queue). The first workflow task will
	// be dispatched according to the inherited behavior (or to the current version of the task-queue's
	// deployment in the case of AutoUpgrade.) After completion of their first workflow task the
	// Deployment Version and Behavior of the execution will update according to configuration on the worker.
	//
	// Note that `behavior` is overridden by `versioning_override` if the latter is present.
	Behavior v11.VersioningBehavior `protobuf:"varint,1,opt,name=behavior,proto3,enum=temporal.api.enums.v1.VersioningBehavior" json:"behavior,omitempty"`
	// The worker deployment that completed the last workflow task of this workflow execution. Must
	// be present if `behavior` is set. Absent value means no workflow task is completed, or the
	// last workflow task was completed by an unversioned worker. Unversioned workers may still send
	// a deployment value which will be stored here, so the right way to check if an execution is
	// versioned if an execution is versioned or not is via the `behavior` field.
	// Note that `deployment` is overridden by `versioning_override` if the latter is present.
	// Deprecated. Use `deployment_version`.
	//
	// Deprecated: Marked as deprecated in temporal/api/workflow/v1/message.proto.
	Deployment *v12.Deployment `protobuf:"bytes,2,opt,name=deployment,proto3" json:"deployment,omitempty"`
	// Deprecated. Use `deployment_version`.
	//
	// Deprecated: Marked as deprecated in temporal/api/workflow/v1/message.proto.
	Version string `protobuf:"bytes,5,opt,name=version,proto3" json:"version,omitempty"`
	// The Worker Deployment Version that completed the last workflow task of this workflow execution.
	// An absent value means no workflow task is completed, or the workflow is unversioned.
	// If present, and `behavior` is UNSPECIFIED, the last task of this workflow execution was completed
	// by a worker that is not using versioning but _is_ passing Deployment Name and Build ID.
	//
	// Child workflows or CaN executions **inherit** their parent/previous run's effective Versioning
	// Behavior and Version (except when the new execution runs on a task queue not belonging to the
	// same deployment version as the parent/previous run's task queue). The first workflow task will
	// be dispatched according to the inherited behavior (or to the current version of the task-queue's
	// deployment in the case of AutoUpgrade.) After completion of their first workflow task the
	// Deployment Version and Behavior of the execution will update according to configuration on the worker.
	//
	// Note that if `versioning_override.behavior` is PINNED then `versioning_override.pinned_version`
	// will override this value.
	DeploymentVersion *v12.WorkerDeploymentVersion `protobuf:"bytes,7,opt,name=deployment_version,json=deploymentVersion,proto3" json:"deployment_version,omitempty"`
	// Present if user has set an execution-specific versioning override. This override takes
	// precedence over SDK-sent `behavior` (and `version` when override is PINNED). An
	// override can be set when starting a new execution, as well as afterwards by calling the
	// `UpdateWorkflowExecutionOptions` API.
	// Pinned overrides are automatically inherited by child workflows, continue-as-new workflows,
	// workflow retries, and cron workflows.
	VersioningOverride *VersioningOverride `protobuf:"bytes,3,opt,name=versioning_override,json=versioningOverride,proto3" json:"versioning_override,omitempty"`
	// When present, indicates the workflow is transitioning to a different deployment. Can
	// indicate one of the following transitions: unversioned -> versioned, versioned -> versioned
	// on a different deployment, or versioned -> unversioned.
	// Not applicable to workflows with PINNED behavior.
	// When a workflow with AUTO_UPGRADE behavior creates a new workflow task, it will automatically
	// start a transition to the task queue's current deployment if the task queue's current
	// deployment is different from the workflow's deployment.
	// If the AUTO_UPGRADE workflow is stuck due to backlogged activity or workflow tasks, those
	// tasks will be redirected to the task queue's current deployment. As soon as a poller from
	// that deployment is available to receive the task, the workflow will automatically start a
	// transition to that deployment and continue execution there.
	// A deployment transition can only exist while there is a pending or started workflow task.
	// Once the pending workflow task completes on the transition's target deployment, the
	// transition completes and the workflow's `deployment` and `behavior` fields are updated per
	// the worker's task completion response.
	// Pending activities will not start new attempts during a transition. Once the transition is
	// completed, pending activities will start their next attempt on the new deployment.
	// Deprecated. Use version_transition.
	//
	// Deprecated: Marked as deprecated in temporal/api/workflow/v1/message.proto.
	DeploymentTransition *DeploymentTransition `protobuf:"bytes,4,opt,name=deployment_transition,json=deploymentTransition,proto3" json:"deployment_transition,omitempty"`
	// When present, indicates the workflow is transitioning to a different deployment version
	// (which may belong to the same deployment name or another). Can indicate one of the following
	// transitions: unversioned -> versioned, versioned -> versioned
	// on a different deployment version, or versioned -> unversioned.
	// Not applicable to workflows with PINNED behavior.
	// When a workflow with AUTO_UPGRADE behavior creates a new workflow task, it will automatically
	// start a transition to the task queue's current version if the task queue's current version is
	// different from the workflow's current deployment version.
	// If the AUTO_UPGRADE workflow is stuck due to backlogged activity or workflow tasks, those
	// tasks will be redirected to the task queue's current version. As soon as a poller from
	// that deployment version is available to receive the task, the workflow will automatically
	// start a transition to that version and continue execution there.
	// A version transition can only exist while there is a pending or started workflow task.
	// Once the pending workflow task completes on the transition's target version, the
	// transition completes and the workflow's `behavior`, and `deployment_version` fields are updated per the
	// worker's task completion response.
	// Pending activities will not start new attempts during a transition. Once the transition is
	// completed, pending activities will start their next attempt on the new version.
	VersionTransition *DeploymentVersionTransition `protobuf:"bytes,6,opt,name=version_transition,json=versionTransition,proto3" json:"version_transition,omitempty"`
	// Monotonic counter reflecting the latest routing decision for this workflow execution.
	// Used for staleness detection between history and matching when dispatching tasks to workers.
	// Incremented when a workflow execution routes to a new deployment version, which happens
	// when a worker of the new deployment version completes a workflow task.
	// Note: Pinned tasks and sticky tasks send a value of 0 for this field since these tasks do not
	// face the problem of inconsistent dispatching that arises from eventual consistency between
	// task queues and their partitions.
	RevisionNumber int64 `protobuf:"varint,8,opt,name=revision_number,json=revisionNumber,proto3" json:"revision_number,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *WorkflowExecutionVersioningInfo) Reset() {
	*x = WorkflowExecutionVersioningInfo{}
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WorkflowExecutionVersioningInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WorkflowExecutionVersioningInfo) ProtoMessage() {}

func (x *WorkflowExecutionVersioningInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WorkflowExecutionVersioningInfo.ProtoReflect.Descriptor instead.
func (*WorkflowExecutionVersioningInfo) Descriptor() ([]byte, []int) {
	return file_temporal_api_workflow_v1_message_proto_rawDescGZIP(), []int{2}
}

func (x *WorkflowExecutionVersioningInfo) GetBehavior() v11.VersioningBehavior {
	if x != nil {
		return x.Behavior
	}
	return v11.VersioningBehavior(0)
}

// Deprecated: Marked as deprecated in temporal/api/workflow/v1/message.proto.
func (x *WorkflowExecutionVersioningInfo) GetDeployment() *v12.Deployment {
	if x != nil {
		return x.Deployment
	}
	return nil
}

// Deprecated: Marked as deprecated in temporal/api/workflow/v1/message.proto.
func (x *WorkflowExecutionVersioningInfo) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *WorkflowExecutionVersioningInfo) GetDeploymentVersion() *v12.WorkerDeploymentVersion {
	if x != nil {
		return x.DeploymentVersion
	}
	return nil
}

func (x *WorkflowExecutionVersioningInfo) GetVersioningOverride() *VersioningOverride {
	if x != nil {
		return x.VersioningOverride
	}
	return nil
}

// Deprecated: Marked as deprecated in temporal/api/workflow/v1/message.proto.
func (x *WorkflowExecutionVersioningInfo) GetDeploymentTransition() *DeploymentTransition {
	if x != nil {
		return x.DeploymentTransition
	}
	return nil
}

func (x *WorkflowExecutionVersioningInfo) GetVersionTransition() *DeploymentVersionTransition {
	if x != nil {
		return x.VersionTransition
	}
	return nil
}

func (x *WorkflowExecutionVersioningInfo) GetRevisionNumber() int64 {
	if x != nil {
		return x.RevisionNumber
	}
	return 0
}

// Holds information about ongoing transition of a workflow execution from one deployment to another.
// Deprecated. Use DeploymentVersionTransition.
type DeploymentTransition struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The target deployment of the transition. Null means a so-far-versioned workflow is
	// transitioning to unversioned workers.
	Deployment    *v12.Deployment `protobuf:"bytes,1,opt,name=deployment,proto3" json:"deployment,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeploymentTransition) Reset() {
	*x = DeploymentTransition{}
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeploymentTransition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeploymentTransition) ProtoMessage() {}

func (x *DeploymentTransition) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeploymentTransition.ProtoReflect.Descriptor instead.
func (*DeploymentTransition) Descriptor() ([]byte, []int) {
	return file_temporal_api_workflow_v1_message_proto_rawDescGZIP(), []int{3}
}

func (x *DeploymentTransition) GetDeployment() *v12.Deployment {
	if x != nil {
		return x.Deployment
	}
	return nil
}

// Holds information about ongoing transition of a workflow execution from one worker
// deployment version to another.
// Experimental. Might change in the future.
type DeploymentVersionTransition struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Deprecated. Use `deployment_version`.
	//
	// Deprecated: Marked as deprecated in temporal/api/workflow/v1/message.proto.
	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// The target Version of the transition.
	// If nil, a so-far-versioned workflow is transitioning to unversioned workers.
	DeploymentVersion *v12.WorkerDeploymentVersion `protobuf:"bytes,2,opt,name=deployment_version,json=deploymentVersion,proto3" json:"deployment_version,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *DeploymentVersionTransition) Reset() {
	*x = DeploymentVersionTransition{}
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeploymentVersionTransition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeploymentVersionTransition) ProtoMessage() {}

func (x *DeploymentVersionTransition) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeploymentVersionTransition.ProtoReflect.Descriptor instead.
func (*DeploymentVersionTransition) Descriptor() ([]byte, []int) {
	return file_temporal_api_workflow_v1_message_proto_rawDescGZIP(), []int{4}
}

// Deprecated: Marked as deprecated in temporal/api/workflow/v1/message.proto.
func (x *DeploymentVersionTransition) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *DeploymentVersionTransition) GetDeploymentVersion() *v12.WorkerDeploymentVersion {
	if x != nil {
		return x.DeploymentVersion
	}
	return nil
}

type WorkflowExecutionConfig struct {
	state                      protoimpl.MessageState `protogen:"open.v1"`
	TaskQueue                  *v13.TaskQueue         `protobuf:"bytes,1,opt,name=task_queue,json=taskQueue,proto3" json:"task_queue,omitempty"`
	WorkflowExecutionTimeout   *durationpb.Duration   `protobuf:"bytes,2,opt,name=workflow_execution_timeout,json=workflowExecutionTimeout,proto3" json:"workflow_execution_timeout,omitempty"`
	WorkflowRunTimeout         *durationpb.Duration   `protobuf:"bytes,3,opt,name=workflow_run_timeout,json=workflowRunTimeout,proto3" json:"workflow_run_timeout,omitempty"`
	DefaultWorkflowTaskTimeout *durationpb.Duration   `protobuf:"bytes,4,opt,name=default_workflow_task_timeout,json=defaultWorkflowTaskTimeout,proto3" json:"default_workflow_task_timeout,omitempty"`
	// User metadata provided on start workflow.
	UserMetadata  *v14.UserMetadata `protobuf:"bytes,5,opt,name=user_metadata,json=userMetadata,proto3" json:"user_metadata,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WorkflowExecutionConfig) Reset() {
	*x = WorkflowExecutionConfig{}
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WorkflowExecutionConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WorkflowExecutionConfig) ProtoMessage() {}

func (x *WorkflowExecutionConfig) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WorkflowExecutionConfig.ProtoReflect.Descriptor instead.
func (*WorkflowExecutionConfig) Descriptor() ([]byte, []int) {
	return file_temporal_api_workflow_v1_message_proto_rawDescGZIP(), []int{5}
}

func (x *WorkflowExecutionConfig) GetTaskQueue() *v13.TaskQueue {
	if x != nil {
		return x.TaskQueue
	}
	return nil
}

func (x *WorkflowExecutionConfig) GetWorkflowExecutionTimeout() *durationpb.Duration {
	if x != nil {
		return x.WorkflowExecutionTimeout
	}
	return nil
}

func (x *WorkflowExecutionConfig) GetWorkflowRunTimeout() *durationpb.Duration {
	if x != nil {
		return x.WorkflowRunTimeout
	}
	return nil
}

func (x *WorkflowExecutionConfig) GetDefaultWorkflowTaskTimeout() *durationpb.Duration {
	if x != nil {
		return x.DefaultWorkflowTaskTimeout
	}
	return nil
}

func (x *WorkflowExecutionConfig) GetUserMetadata() *v14.UserMetadata {
	if x != nil {
		return x.UserMetadata
	}
	return nil
}

type PendingActivityInfo struct {
	state              protoimpl.MessageState   `protogen:"open.v1"`
	ActivityId         string                   `protobuf:"bytes,1,opt,name=activity_id,json=activityId,proto3" json:"activity_id,omitempty"`
	ActivityType       *v1.ActivityType         `protobuf:"bytes,2,opt,name=activity_type,json=activityType,proto3" json:"activity_type,omitempty"`
	State              v11.PendingActivityState `protobuf:"varint,3,opt,name=state,proto3,enum=temporal.api.enums.v1.PendingActivityState" json:"state,omitempty"`
	HeartbeatDetails   *v1.Payloads             `protobuf:"bytes,4,opt,name=heartbeat_details,json=heartbeatDetails,proto3" json:"heartbeat_details,omitempty"`
	LastHeartbeatTime  *timestamppb.Timestamp   `protobuf:"bytes,5,opt,name=last_heartbeat_time,json=lastHeartbeatTime,proto3" json:"last_heartbeat_time,omitempty"`
	LastStartedTime    *timestamppb.Timestamp   `protobuf:"bytes,6,opt,name=last_started_time,json=lastStartedTime,proto3" json:"last_started_time,omitempty"`
	Attempt            int32                    `protobuf:"varint,7,opt,name=attempt,proto3" json:"attempt,omitempty"`
	MaximumAttempts    int32                    `protobuf:"varint,8,opt,name=maximum_attempts,json=maximumAttempts,proto3" json:"maximum_attempts,omitempty"`
	ScheduledTime      *timestamppb.Timestamp   `protobuf:"bytes,9,opt,name=scheduled_time,json=scheduledTime,proto3" json:"scheduled_time,omitempty"`
	ExpirationTime     *timestamppb.Timestamp   `protobuf:"bytes,10,opt,name=expiration_time,json=expirationTime,proto3" json:"expiration_time,omitempty"`
	LastFailure        *v15.Failure             `protobuf:"bytes,11,opt,name=last_failure,json=lastFailure,proto3" json:"last_failure,omitempty"`
	LastWorkerIdentity string                   `protobuf:"bytes,12,opt,name=last_worker_identity,json=lastWorkerIdentity,proto3" json:"last_worker_identity,omitempty"`
	// Absence of `assigned_build_id` generally means this task is on an "unversioned" task queue.
	// In rare cases, it can also mean that the task queue is versioned but we failed to write activity's
	// independently-assigned build ID to the database. This case heals automatically once the task is dispatched.
	// Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
	//
	// Types that are valid to be assigned to AssignedBuildId:
	//
	//	*PendingActivityInfo_UseWorkflowBuildId
	//	*PendingActivityInfo_LastIndependentlyAssignedBuildId
	AssignedBuildId isPendingActivityInfo_AssignedBuildId `protobuf_oneof:"assigned_build_id"`
	// Deprecated. The version stamp of the worker to whom this activity was most recently dispatched
	// This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
	//
	// Deprecated: Marked as deprecated in temporal/api/workflow/v1/message.proto.
	LastWorkerVersionStamp *v1.WorkerVersionStamp `protobuf:"bytes,15,opt,name=last_worker_version_stamp,json=lastWorkerVersionStamp,proto3" json:"last_worker_version_stamp,omitempty"`
	// The time activity will wait until the next retry.
	// If activity is currently running it will be next retry interval if activity failed.
	// If activity is currently waiting it will be current retry interval.
	// If there will be no retry it will be null.
	CurrentRetryInterval *durationpb.Duration `protobuf:"bytes,16,opt,name=current_retry_interval,json=currentRetryInterval,proto3" json:"current_retry_interval,omitempty"`
	// The time when the last activity attempt was completed. If activity has not been completed yet then it will be null.
	LastAttemptCompleteTime *timestamppb.Timestamp `protobuf:"bytes,17,opt,name=last_attempt_complete_time,json=lastAttemptCompleteTime,proto3" json:"last_attempt_complete_time,omitempty"`
	// Next time when activity will be scheduled.
	// If activity is currently scheduled or started it will be null.
	NextAttemptScheduleTime *timestamppb.Timestamp `protobuf:"bytes,18,opt,name=next_attempt_schedule_time,json=nextAttemptScheduleTime,proto3" json:"next_attempt_schedule_time,omitempty"`
	// Indicates if activity is paused.
	Paused bool `protobuf:"varint,19,opt,name=paused,proto3" json:"paused,omitempty"`
	// The deployment this activity was dispatched to most recently. Present only if the activity
	// was dispatched to a versioned worker.
	// Deprecated. Use `last_deployment_version`.
	//
	// Deprecated: Marked as deprecated in temporal/api/workflow/v1/message.proto.
	LastDeployment *v12.Deployment `protobuf:"bytes,20,opt,name=last_deployment,json=lastDeployment,proto3" json:"last_deployment,omitempty"`
	// The Worker Deployment Version this activity was dispatched to most recently.
	// Deprecated. Use `last_deployment_version`.
	//
	// Deprecated: Marked as deprecated in temporal/api/workflow/v1/message.proto.
	LastWorkerDeploymentVersion string `protobuf:"bytes,21,opt,name=last_worker_deployment_version,json=lastWorkerDeploymentVersion,proto3" json:"last_worker_deployment_version,omitempty"`
	// The Worker Deployment Version this activity was dispatched to most recently.
	// If nil, the activity has not yet been dispatched or was last dispatched to an unversioned worker.
	LastDeploymentVersion *v12.WorkerDeploymentVersion `protobuf:"bytes,25,opt,name=last_deployment_version,json=lastDeploymentVersion,proto3" json:"last_deployment_version,omitempty"`
	// Priority metadata. If this message is not present, or any fields are not
	// present, they inherit the values from the workflow.
	Priority  *v1.Priority                   `protobuf:"bytes,22,opt,name=priority,proto3" json:"priority,omitempty"`
	PauseInfo *PendingActivityInfo_PauseInfo `protobuf:"bytes,23,opt,name=pause_info,json=pauseInfo,proto3" json:"pause_info,omitempty"`
	// Current activity options. May be different from the one used to start the activity.
	ActivityOptions *v16.ActivityOptions `protobuf:"bytes,24,opt,name=activity_options,json=activityOptions,proto3" json:"activity_options,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *PendingActivityInfo) Reset() {
	*x = PendingActivityInfo{}
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PendingActivityInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PendingActivityInfo) ProtoMessage() {}

func (x *PendingActivityInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PendingActivityInfo.ProtoReflect.Descriptor instead.
func (*PendingActivityInfo) Descriptor() ([]byte, []int) {
	return file_temporal_api_workflow_v1_message_proto_rawDescGZIP(), []int{6}
}

func (x *PendingActivityInfo) GetActivityId() string {
	if x != nil {
		return x.ActivityId
	}
	return ""
}

func (x *PendingActivityInfo) GetActivityType() *v1.ActivityType {
	if x != nil {
		return x.ActivityType
	}
	return nil
}

func (x *PendingActivityInfo) GetState() v11.PendingActivityState {
	if x != nil {
		return x.State
	}
	return v11.PendingActivityState(0)
}

func (x *PendingActivityInfo) GetHeartbeatDetails() *v1.Payloads {
	if x != nil {
		return x.HeartbeatDetails
	}
	return nil
}

func (x *PendingActivityInfo) GetLastHeartbeatTime() *timestamppb.Timestamp {
	if x != nil {
		return x.LastHeartbeatTime
	}
	return nil
}

func (x *PendingActivityInfo) GetLastStartedTime() *timestamppb.Timestamp {
	if x != nil {
		return x.LastStartedTime
	}
	return nil
}

func (x *PendingActivityInfo) GetAttempt() int32 {
	if x != nil {
		return x.Attempt
	}
	return 0
}

func (x *PendingActivityInfo) GetMaximumAttempts() int32 {
	if x != nil {
		return x.MaximumAttempts
	}
	return 0
}

func (x *PendingActivityInfo) GetScheduledTime() *timestamppb.Timestamp {
	if x != nil {
		return x.ScheduledTime
	}
	return nil
}

func (x *PendingActivityInfo) GetExpirationTime() *timestamppb.Timestamp {
	if x != nil {
		return x.ExpirationTime
	}
	return nil
}

func (x *PendingActivityInfo) GetLastFailure() *v15.Failure {
	if x != nil {
		return x.LastFailure
	}
	return nil
}

func (x *PendingActivityInfo) GetLastWorkerIdentity() string {
	if x != nil {
		return x.LastWorkerIdentity
	}
	return ""
}

func (x *PendingActivityInfo) GetAssignedBuildId() isPendingActivityInfo_AssignedBuildId {
	if x != nil {
		return x.AssignedBuildId
	}
	return nil
}

// Deprecated: Marked as deprecated in temporal/api/workflow/v1/message.proto.
func (x *PendingActivityInfo) GetUseWorkflowBuildId() *emptypb.Empty {
	if x != nil {
		if x, ok := x.AssignedBuildId.(*PendingActivityInfo_UseWorkflowBuildId); ok {
			return x.UseWorkflowBuildId
		}
	}
	return nil
}

// Deprecated: Marked as deprecated in temporal/api/workflow/v1/message.proto.
func (x *PendingActivityInfo) GetLastIndependentlyAssignedBuildId() string {
	if x != nil {
		if x, ok := x.AssignedBuildId.(*PendingActivityInfo_LastIndependentlyAssignedBuildId); ok {
			return x.LastIndependentlyAssignedBuildId
		}
	}
	return ""
}

// Deprecated: Marked as deprecated in temporal/api/workflow/v1/message.proto.
func (x *PendingActivityInfo) GetLastWorkerVersionStamp() *v1.WorkerVersionStamp {
	if x != nil {
		return x.LastWorkerVersionStamp
	}
	return nil
}

func (x *PendingActivityInfo) GetCurrentRetryInterval() *durationpb.Duration {
	if x != nil {
		return x.CurrentRetryInterval
	}
	return nil
}

func (x *PendingActivityInfo) GetLastAttemptCompleteTime() *timestamppb.Timestamp {
	if x != nil {
		return x.LastAttemptCompleteTime
	}
	return nil
}

func (x *PendingActivityInfo) GetNextAttemptScheduleTime() *timestamppb.Timestamp {
	if x != nil {
		return x.NextAttemptScheduleTime
	}
	return nil
}

func (x *PendingActivityInfo) GetPaused() bool {
	if x != nil {
		return x.Paused
	}
	return false
}

// Deprecated: Marked as deprecated in temporal/api/workflow/v1/message.proto.
func (x *PendingActivityInfo) GetLastDeployment() *v12.Deployment {
	if x != nil {
		return x.LastDeployment
	}
	return nil
}

// Deprecated: Marked as deprecated in temporal/api/workflow/v1/message.proto.
func (x *PendingActivityInfo) GetLastWorkerDeploymentVersion() string {
	if x != nil {
		return x.LastWorkerDeploymentVersion
	}
	return ""
}

func (x *PendingActivityInfo) GetLastDeploymentVersion() *v12.WorkerDeploymentVersion {
	if x != nil {
		return x.LastDeploymentVersion
	}
	return nil
}

func (x *PendingActivityInfo) GetPriority() *v1.Priority {
	if x != nil {
		return x.Priority
	}
	return nil
}

func (x *PendingActivityInfo) GetPauseInfo() *PendingActivityInfo_PauseInfo {
	if x != nil {
		return x.PauseInfo
	}
	return nil
}

func (x *PendingActivityInfo) GetActivityOptions() *v16.ActivityOptions {
	if x != nil {
		return x.ActivityOptions
	}
	return nil
}

type isPendingActivityInfo_AssignedBuildId interface {
	isPendingActivityInfo_AssignedBuildId()
}

type PendingActivityInfo_UseWorkflowBuildId struct {
	// Deprecated. When present, it means this activity is assigned to the build ID of its workflow.
	//
	// Deprecated: Marked as deprecated in temporal/api/workflow/v1/message.proto.
	UseWorkflowBuildId *emptypb.Empty `protobuf:"bytes,13,opt,name=use_workflow_build_id,json=useWorkflowBuildId,proto3,oneof"`
}

type PendingActivityInfo_LastIndependentlyAssignedBuildId struct {
	// Deprecated. This means the activity is independently versioned and not bound to the build ID of its workflow.
	// The activity will use the build id in this field instead.
	// If the task fails and is scheduled again, the assigned build ID may change according to the latest versioning
	// rules.
	//
	// Deprecated: Marked as deprecated in temporal/api/workflow/v1/message.proto.
	LastIndependentlyAssignedBuildId string `protobuf:"bytes,14,opt,name=last_independently_assigned_build_id,json=lastIndependentlyAssignedBuildId,proto3,oneof"`
}

func (*PendingActivityInfo_UseWorkflowBuildId) isPendingActivityInfo_AssignedBuildId() {}

func (*PendingActivityInfo_LastIndependentlyAssignedBuildId) isPendingActivityInfo_AssignedBuildId() {
}

type PendingChildExecutionInfo struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	WorkflowId       string                 `protobuf:"bytes,1,opt,name=workflow_id,json=workflowId,proto3" json:"workflow_id,omitempty"`
	RunId            string                 `protobuf:"bytes,2,opt,name=run_id,json=runId,proto3" json:"run_id,omitempty"`
	WorkflowTypeName string                 `protobuf:"bytes,3,opt,name=workflow_type_name,json=workflowTypeName,proto3" json:"workflow_type_name,omitempty"`
	InitiatedId      int64                  `protobuf:"varint,4,opt,name=initiated_id,json=initiatedId,proto3" json:"initiated_id,omitempty"`
	// Default: PARENT_CLOSE_POLICY_TERMINATE.
	ParentClosePolicy v11.ParentClosePolicy `protobuf:"varint,5,opt,name=parent_close_policy,json=parentClosePolicy,proto3,enum=temporal.api.enums.v1.ParentClosePolicy" json:"parent_close_policy,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *PendingChildExecutionInfo) Reset() {
	*x = PendingChildExecutionInfo{}
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PendingChildExecutionInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PendingChildExecutionInfo) ProtoMessage() {}

func (x *PendingChildExecutionInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PendingChildExecutionInfo.ProtoReflect.Descriptor instead.
func (*PendingChildExecutionInfo) Descriptor() ([]byte, []int) {
	return file_temporal_api_workflow_v1_message_proto_rawDescGZIP(), []int{7}
}

func (x *PendingChildExecutionInfo) GetWorkflowId() string {
	if x != nil {
		return x.WorkflowId
	}
	return ""
}

func (x *PendingChildExecutionInfo) GetRunId() string {
	if x != nil {
		return x.RunId
	}
	return ""
}

func (x *PendingChildExecutionInfo) GetWorkflowTypeName() string {
	if x != nil {
		return x.WorkflowTypeName
	}
	return ""
}

func (x *PendingChildExecutionInfo) GetInitiatedId() int64 {
	if x != nil {
		return x.InitiatedId
	}
	return 0
}

func (x *PendingChildExecutionInfo) GetParentClosePolicy() v11.ParentClosePolicy {
	if x != nil {
		return x.ParentClosePolicy
	}
	return v11.ParentClosePolicy(0)
}

type PendingWorkflowTaskInfo struct {
	state         protoimpl.MessageState       `protogen:"open.v1"`
	State         v11.PendingWorkflowTaskState `protobuf:"varint,1,opt,name=state,proto3,enum=temporal.api.enums.v1.PendingWorkflowTaskState" json:"state,omitempty"`
	ScheduledTime *timestamppb.Timestamp       `protobuf:"bytes,2,opt,name=scheduled_time,json=scheduledTime,proto3" json:"scheduled_time,omitempty"`
	// original_scheduled_time is the scheduled time of the first workflow task during workflow task heartbeat.
	// Heartbeat workflow task is done by RespondWorkflowTaskComplete with ForceCreateNewWorkflowTask == true and no command
	// In this case, OriginalScheduledTime won't change. Then when current time - original_scheduled_time exceeds
	// some threshold, the workflow task will be forced timeout.
	OriginalScheduledTime *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=original_scheduled_time,json=originalScheduledTime,proto3" json:"original_scheduled_time,omitempty"`
	StartedTime           *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=started_time,json=startedTime,proto3" json:"started_time,omitempty"`
	Attempt               int32                  `protobuf:"varint,5,opt,name=attempt,proto3" json:"attempt,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *PendingWorkflowTaskInfo) Reset() {
	*x = PendingWorkflowTaskInfo{}
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PendingWorkflowTaskInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PendingWorkflowTaskInfo) ProtoMessage() {}

func (x *PendingWorkflowTaskInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PendingWorkflowTaskInfo.ProtoReflect.Descriptor instead.
func (*PendingWorkflowTaskInfo) Descriptor() ([]byte, []int) {
	return file_temporal_api_workflow_v1_message_proto_rawDescGZIP(), []int{8}
}

func (x *PendingWorkflowTaskInfo) GetState() v11.PendingWorkflowTaskState {
	if x != nil {
		return x.State
	}
	return v11.PendingWorkflowTaskState(0)
}

func (x *PendingWorkflowTaskInfo) GetScheduledTime() *timestamppb.Timestamp {
	if x != nil {
		return x.ScheduledTime
	}
	return nil
}

func (x *PendingWorkflowTaskInfo) GetOriginalScheduledTime() *timestamppb.Timestamp {
	if x != nil {
		return x.OriginalScheduledTime
	}
	return nil
}

func (x *PendingWorkflowTaskInfo) GetStartedTime() *timestamppb.Timestamp {
	if x != nil {
		return x.StartedTime
	}
	return nil
}

func (x *PendingWorkflowTaskInfo) GetAttempt() int32 {
	if x != nil {
		return x.Attempt
	}
	return 0
}

type ResetPoints struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Points        []*ResetPointInfo      `protobuf:"bytes,1,rep,name=points,proto3" json:"points,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ResetPoints) Reset() {
	*x = ResetPoints{}
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ResetPoints) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ResetPoints) ProtoMessage() {}

func (x *ResetPoints) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ResetPoints.ProtoReflect.Descriptor instead.
func (*ResetPoints) Descriptor() ([]byte, []int) {
	return file_temporal_api_workflow_v1_message_proto_rawDescGZIP(), []int{9}
}

func (x *ResetPoints) GetPoints() []*ResetPointInfo {
	if x != nil {
		return x.Points
	}
	return nil
}

// ResetPointInfo records the workflow event id that is the first one processed by a given
// build id or binary checksum. A new reset point will be created if either build id or binary
// checksum changes (although in general only one or the other will be used at a time).
type ResetPointInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Worker build id.
	BuildId string `protobuf:"bytes,7,opt,name=build_id,json=buildId,proto3" json:"build_id,omitempty"`
	// Deprecated. A worker binary version identifier.
	//
	// Deprecated: Marked as deprecated in temporal/api/workflow/v1/message.proto.
	BinaryChecksum string `protobuf:"bytes,1,opt,name=binary_checksum,json=binaryChecksum,proto3" json:"binary_checksum,omitempty"`
	// The first run ID in the execution chain that was touched by this worker build.
	RunId string `protobuf:"bytes,2,opt,name=run_id,json=runId,proto3" json:"run_id,omitempty"`
	// Event ID of the first WorkflowTaskCompleted event processed by this worker build.
	FirstWorkflowTaskCompletedId int64                  `protobuf:"varint,3,opt,name=first_workflow_task_completed_id,json=firstWorkflowTaskCompletedId,proto3" json:"first_workflow_task_completed_id,omitempty"`
	CreateTime                   *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	// (-- api-linter: core::0214::resource-expiry=disabled
	//
	//	aip.dev/not-precedent: TTL is not defined for ResetPointInfo. --)
	//
	// The time that the run is deleted due to retention.
	ExpireTime *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=expire_time,json=expireTime,proto3" json:"expire_time,omitempty"`
	// false if the reset point has pending childWFs/reqCancels/signalExternals.
	Resettable    bool `protobuf:"varint,6,opt,name=resettable,proto3" json:"resettable,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ResetPointInfo) Reset() {
	*x = ResetPointInfo{}
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ResetPointInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ResetPointInfo) ProtoMessage() {}

func (x *ResetPointInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ResetPointInfo.ProtoReflect.Descriptor instead.
func (*ResetPointInfo) Descriptor() ([]byte, []int) {
	return file_temporal_api_workflow_v1_message_proto_rawDescGZIP(), []int{10}
}

func (x *ResetPointInfo) GetBuildId() string {
	if x != nil {
		return x.BuildId
	}
	return ""
}

// Deprecated: Marked as deprecated in temporal/api/workflow/v1/message.proto.
func (x *ResetPointInfo) GetBinaryChecksum() string {
	if x != nil {
		return x.BinaryChecksum
	}
	return ""
}

func (x *ResetPointInfo) GetRunId() string {
	if x != nil {
		return x.RunId
	}
	return ""
}

func (x *ResetPointInfo) GetFirstWorkflowTaskCompletedId() int64 {
	if x != nil {
		return x.FirstWorkflowTaskCompletedId
	}
	return 0
}

func (x *ResetPointInfo) GetCreateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.CreateTime
	}
	return nil
}

func (x *ResetPointInfo) GetExpireTime() *timestamppb.Timestamp {
	if x != nil {
		return x.ExpireTime
	}
	return nil
}

func (x *ResetPointInfo) GetResettable() bool {
	if x != nil {
		return x.Resettable
	}
	return false
}

// NewWorkflowExecutionInfo is a shared message that encapsulates all the
// required arguments to starting a workflow in different contexts.
type NewWorkflowExecutionInfo struct {
	state        protoimpl.MessageState `protogen:"open.v1"`
	WorkflowId   string                 `protobuf:"bytes,1,opt,name=workflow_id,json=workflowId,proto3" json:"workflow_id,omitempty"`
	WorkflowType *v1.WorkflowType       `protobuf:"bytes,2,opt,name=workflow_type,json=workflowType,proto3" json:"workflow_type,omitempty"`
	TaskQueue    *v13.TaskQueue         `protobuf:"bytes,3,opt,name=task_queue,json=taskQueue,proto3" json:"task_queue,omitempty"`
	// Serialized arguments to the workflow.
	Input *v1.Payloads `protobuf:"bytes,4,opt,name=input,proto3" json:"input,omitempty"`
	// Total workflow execution timeout including retries and continue as new.
	WorkflowExecutionTimeout *durationpb.Duration `protobuf:"bytes,5,opt,name=workflow_execution_timeout,json=workflowExecutionTimeout,proto3" json:"workflow_execution_timeout,omitempty"`
	// Timeout of a single workflow run.
	WorkflowRunTimeout *durationpb.Duration `protobuf:"bytes,6,opt,name=workflow_run_timeout,json=workflowRunTimeout,proto3" json:"workflow_run_timeout,omitempty"`
	// Timeout of a single workflow task.
	WorkflowTaskTimeout *durationpb.Duration `protobuf:"bytes,7,opt,name=workflow_task_timeout,json=workflowTaskTimeout,proto3" json:"workflow_task_timeout,omitempty"`
	// Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
	WorkflowIdReusePolicy v11.WorkflowIdReusePolicy `protobuf:"varint,8,opt,name=workflow_id_reuse_policy,json=workflowIdReusePolicy,proto3,enum=temporal.api.enums.v1.WorkflowIdReusePolicy" json:"workflow_id_reuse_policy,omitempty"`
	// The retry policy for the workflow. Will never exceed `workflow_execution_timeout`.
	RetryPolicy *v1.RetryPolicy `protobuf:"bytes,9,opt,name=retry_policy,json=retryPolicy,proto3" json:"retry_policy,omitempty"`
	// See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/
	CronSchedule     string               `protobuf:"bytes,10,opt,name=cron_schedule,json=cronSchedule,proto3" json:"cron_schedule,omitempty"`
	Memo             *v1.Memo             `protobuf:"bytes,11,opt,name=memo,proto3" json:"memo,omitempty"`
	SearchAttributes *v1.SearchAttributes `protobuf:"bytes,12,opt,name=search_attributes,json=searchAttributes,proto3" json:"search_attributes,omitempty"`
	Header           *v1.Header           `protobuf:"bytes,13,opt,name=header,proto3" json:"header,omitempty"`
	// Metadata on the workflow if it is started. This is carried over to the WorkflowExecutionConfig
	// for use by user interfaces to display the fixed as-of-start summary and details of the
	// workflow.
	UserMetadata *v14.UserMetadata `protobuf:"bytes,14,opt,name=user_metadata,json=userMetadata,proto3" json:"user_metadata,omitempty"`
	// If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion.
	// To unset the override after the workflow is running, use UpdateWorkflowExecutionOptions.
	VersioningOverride *VersioningOverride `protobuf:"bytes,15,opt,name=versioning_override,json=versioningOverride,proto3" json:"versioning_override,omitempty"`
	// Priority metadata
	Priority      *v1.Priority `protobuf:"bytes,16,opt,name=priority,proto3" json:"priority,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NewWorkflowExecutionInfo) Reset() {
	*x = NewWorkflowExecutionInfo{}
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NewWorkflowExecutionInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NewWorkflowExecutionInfo) ProtoMessage() {}

func (x *NewWorkflowExecutionInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NewWorkflowExecutionInfo.ProtoReflect.Descriptor instead.
func (*NewWorkflowExecutionInfo) Descriptor() ([]byte, []int) {
	return file_temporal_api_workflow_v1_message_proto_rawDescGZIP(), []int{11}
}

func (x *NewWorkflowExecutionInfo) GetWorkflowId() string {
	if x != nil {
		return x.WorkflowId
	}
	return ""
}

func (x *NewWorkflowExecutionInfo) GetWorkflowType() *v1.WorkflowType {
	if x != nil {
		return x.WorkflowType
	}
	return nil
}

func (x *NewWorkflowExecutionInfo) GetTaskQueue() *v13.TaskQueue {
	if x != nil {
		return x.TaskQueue
	}
	return nil
}

func (x *NewWorkflowExecutionInfo) GetInput() *v1.Payloads {
	if x != nil {
		return x.Input
	}
	return nil
}

func (x *NewWorkflowExecutionInfo) GetWorkflowExecutionTimeout() *durationpb.Duration {
	if x != nil {
		return x.WorkflowExecutionTimeout
	}
	return nil
}

func (x *NewWorkflowExecutionInfo) GetWorkflowRunTimeout() *durationpb.Duration {
	if x != nil {
		return x.WorkflowRunTimeout
	}
	return nil
}

func (x *NewWorkflowExecutionInfo) GetWorkflowTaskTimeout() *durationpb.Duration {
	if x != nil {
		return x.WorkflowTaskTimeout
	}
	return nil
}

func (x *NewWorkflowExecutionInfo) GetWorkflowIdReusePolicy() v11.WorkflowIdReusePolicy {
	if x != nil {
		return x.WorkflowIdReusePolicy
	}
	return v11.WorkflowIdReusePolicy(0)
}

func (x *NewWorkflowExecutionInfo) GetRetryPolicy() *v1.RetryPolicy {
	if x != nil {
		return x.RetryPolicy
	}
	return nil
}

func (x *NewWorkflowExecutionInfo) GetCronSchedule() string {
	if x != nil {
		return x.CronSchedule
	}
	return ""
}

func (x *NewWorkflowExecutionInfo) GetMemo() *v1.Memo {
	if x != nil {
		return x.Memo
	}
	return nil
}

func (x *NewWorkflowExecutionInfo) GetSearchAttributes() *v1.SearchAttributes {
	if x != nil {
		return x.SearchAttributes
	}
	return nil
}

func (x *NewWorkflowExecutionInfo) GetHeader() *v1.Header {
	if x != nil {
		return x.Header
	}
	return nil
}

func (x *NewWorkflowExecutionInfo) GetUserMetadata() *v14.UserMetadata {
	if x != nil {
		return x.UserMetadata
	}
	return nil
}

func (x *NewWorkflowExecutionInfo) GetVersioningOverride() *VersioningOverride {
	if x != nil {
		return x.VersioningOverride
	}
	return nil
}

func (x *NewWorkflowExecutionInfo) GetPriority() *v1.Priority {
	if x != nil {
		return x.Priority
	}
	return nil
}

// CallbackInfo contains the state of an attached workflow callback.
type CallbackInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Information on how this callback should be invoked (e.g. its URL and type).
	Callback *v1.Callback `protobuf:"bytes,1,opt,name=callback,proto3" json:"callback,omitempty"`
	// Trigger for this callback.
	Trigger *CallbackInfo_Trigger `protobuf:"bytes,2,opt,name=trigger,proto3" json:"trigger,omitempty"`
	// The time when the callback was registered.
	RegistrationTime *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=registration_time,json=registrationTime,proto3" json:"registration_time,omitempty"`
	State            v11.CallbackState      `protobuf:"varint,4,opt,name=state,proto3,enum=temporal.api.enums.v1.CallbackState" json:"state,omitempty"`
	// The number of attempts made to deliver the callback.
	// This number represents a minimum bound since the attempt is incremented after the callback request completes.
	Attempt int32 `protobuf:"varint,5,opt,name=attempt,proto3" json:"attempt,omitempty"`
	// The time when the last attempt completed.
	LastAttemptCompleteTime *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=last_attempt_complete_time,json=lastAttemptCompleteTime,proto3" json:"last_attempt_complete_time,omitempty"`
	// The last attempt's failure, if any.
	LastAttemptFailure *v15.Failure `protobuf:"bytes,7,opt,name=last_attempt_failure,json=lastAttemptFailure,proto3" json:"last_attempt_failure,omitempty"`
	// The time when the next attempt is scheduled.
	NextAttemptScheduleTime *timestamppb.Timestamp `protobuf:"bytes,8,opt,name=next_attempt_schedule_time,json=nextAttemptScheduleTime,proto3" json:"next_attempt_schedule_time,omitempty"`
	// If the state is BLOCKED, blocked reason provides additional information.
	BlockedReason string `protobuf:"bytes,9,opt,name=blocked_reason,json=blockedReason,proto3" json:"blocked_reason,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CallbackInfo) Reset() {
	*x = CallbackInfo{}
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CallbackInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CallbackInfo) ProtoMessage() {}

func (x *CallbackInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CallbackInfo.ProtoReflect.Descriptor instead.
func (*CallbackInfo) Descriptor() ([]byte, []int) {
	return file_temporal_api_workflow_v1_message_proto_rawDescGZIP(), []int{12}
}

func (x *CallbackInfo) GetCallback() *v1.Callback {
	if x != nil {
		return x.Callback
	}
	return nil
}

func (x *CallbackInfo) GetTrigger() *CallbackInfo_Trigger {
	if x != nil {
		return x.Trigger
	}
	return nil
}

func (x *CallbackInfo) GetRegistrationTime() *timestamppb.Timestamp {
	if x != nil {
		return x.RegistrationTime
	}
	return nil
}

func (x *CallbackInfo) GetState() v11.CallbackState {
	if x != nil {
		return x.State
	}
	return v11.CallbackState(0)
}

func (x *CallbackInfo) GetAttempt() int32 {
	if x != nil {
		return x.Attempt
	}
	return 0
}

func (x *CallbackInfo) GetLastAttemptCompleteTime() *timestamppb.Timestamp {
	if x != nil {
		return x.LastAttemptCompleteTime
	}
	return nil
}

func (x *CallbackInfo) GetLastAttemptFailure() *v15.Failure {
	if x != nil {
		return x.LastAttemptFailure
	}
	return nil
}

func (x *CallbackInfo) GetNextAttemptScheduleTime() *timestamppb.Timestamp {
	if x != nil {
		return x.NextAttemptScheduleTime
	}
	return nil
}

func (x *CallbackInfo) GetBlockedReason() string {
	if x != nil {
		return x.BlockedReason
	}
	return ""
}

// PendingNexusOperationInfo contains the state of a pending Nexus operation.
type PendingNexusOperationInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Endpoint name.
	// Resolved to a URL via the cluster's endpoint registry.
	Endpoint string `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// Service name.
	Service string `protobuf:"bytes,2,opt,name=service,proto3" json:"service,omitempty"`
	// Operation name.
	Operation string `protobuf:"bytes,3,opt,name=operation,proto3" json:"operation,omitempty"`
	// Operation ID. Only set for asynchronous operations after a successful StartOperation call.
	//
	// Deprecated. Renamed to operation_token.
	//
	// Deprecated: Marked as deprecated in temporal/api/workflow/v1/message.proto.
	OperationId string `protobuf:"bytes,4,opt,name=operation_id,json=operationId,proto3" json:"operation_id,omitempty"`
	// Schedule-to-close timeout for this operation.
	// This is the only timeout settable by a workflow.
	// (-- api-linter: core::0140::prepositions=disabled
	//
	//	aip.dev/not-precedent: "to" is used to indicate interval. --)
	ScheduleToCloseTimeout *durationpb.Duration `protobuf:"bytes,5,opt,name=schedule_to_close_timeout,json=scheduleToCloseTimeout,proto3" json:"schedule_to_close_timeout,omitempty"`
	// The time when the operation was scheduled.
	ScheduledTime *timestamppb.Timestamp         `protobuf:"bytes,6,opt,name=scheduled_time,json=scheduledTime,proto3" json:"scheduled_time,omitempty"`
	State         v11.PendingNexusOperationState `protobuf:"varint,7,opt,name=state,proto3,enum=temporal.api.enums.v1.PendingNexusOperationState" json:"state,omitempty"`
	// The number of attempts made to deliver the start operation request.
	// This number represents a minimum bound since the attempt is incremented after the request completes.
	Attempt int32 `protobuf:"varint,8,opt,name=attempt,proto3" json:"attempt,omitempty"`
	// The time when the last attempt completed.
	LastAttemptCompleteTime *timestamppb.Timestamp `protobuf:"bytes,9,opt,name=last_attempt_complete_time,json=lastAttemptCompleteTime,proto3" json:"last_attempt_complete_time,omitempty"`
	// The last attempt's failure, if any.
	LastAttemptFailure *v15.Failure `protobuf:"bytes,10,opt,name=last_attempt_failure,json=lastAttemptFailure,proto3" json:"last_attempt_failure,omitempty"`
	// The time when the next attempt is scheduled.
	NextAttemptScheduleTime *timestamppb.Timestamp          `protobuf:"bytes,11,opt,name=next_attempt_schedule_time,json=nextAttemptScheduleTime,proto3" json:"next_attempt_schedule_time,omitempty"`
	CancellationInfo        *NexusOperationCancellationInfo `protobuf:"bytes,12,opt,name=cancellation_info,json=cancellationInfo,proto3" json:"cancellation_info,omitempty"`
	// The event ID of the NexusOperationScheduled event. Can be used to correlate an operation in the
	// DescribeWorkflowExecution response with workflow history.
	ScheduledEventId int64 `protobuf:"varint,13,opt,name=scheduled_event_id,json=scheduledEventId,proto3" json:"scheduled_event_id,omitempty"`
	// If the state is BLOCKED, blocked reason provides additional information.
	BlockedReason string `protobuf:"bytes,14,opt,name=blocked_reason,json=blockedReason,proto3" json:"blocked_reason,omitempty"`
	// Operation token. Only set for asynchronous operations after a successful StartOperation call.
	OperationToken string `protobuf:"bytes,15,opt,name=operation_token,json=operationToken,proto3" json:"operation_token,omitempty"`
	// Schedule-to-start timeout for this operation.
	// (-- api-linter: core::0140::prepositions=disabled
	//
	//	aip.dev/not-precedent: "to" is used to indicate interval. --)
	ScheduleToStartTimeout *durationpb.Duration `protobuf:"bytes,16,opt,name=schedule_to_start_timeout,json=scheduleToStartTimeout,proto3" json:"schedule_to_start_timeout,omitempty"`
	// Start-to-close timeout for this operation.
	// (-- api-linter: core::0140::prepositions=disabled
	//
	//	aip.dev/not-precedent: "to" is used to indicate interval. --)
	StartToCloseTimeout *durationpb.Duration `protobuf:"bytes,17,opt,name=start_to_close_timeout,json=startToCloseTimeout,proto3" json:"start_to_close_timeout,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *PendingNexusOperationInfo) Reset() {
	*x = PendingNexusOperationInfo{}
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PendingNexusOperationInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PendingNexusOperationInfo) ProtoMessage() {}

func (x *PendingNexusOperationInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PendingNexusOperationInfo.ProtoReflect.Descriptor instead.
func (*PendingNexusOperationInfo) Descriptor() ([]byte, []int) {
	return file_temporal_api_workflow_v1_message_proto_rawDescGZIP(), []int{13}
}

func (x *PendingNexusOperationInfo) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *PendingNexusOperationInfo) GetService() string {
	if x != nil {
		return x.Service
	}
	return ""
}

func (x *PendingNexusOperationInfo) GetOperation() string {
	if x != nil {
		return x.Operation
	}
	return ""
}

// Deprecated: Marked as deprecated in temporal/api/workflow/v1/message.proto.
func (x *PendingNexusOperationInfo) GetOperationId() string {
	if x != nil {
		return x.OperationId
	}
	return ""
}

func (x *PendingNexusOperationInfo) GetScheduleToCloseTimeout() *durationpb.Duration {
	if x != nil {
		return x.ScheduleToCloseTimeout
	}
	return nil
}

func (x *PendingNexusOperationInfo) GetScheduledTime() *timestamppb.Timestamp {
	if x != nil {
		return x.ScheduledTime
	}
	return nil
}

func (x *PendingNexusOperationInfo) GetState() v11.PendingNexusOperationState {
	if x != nil {
		return x.State
	}
	return v11.PendingNexusOperationState(0)
}

func (x *PendingNexusOperationInfo) GetAttempt() int32 {
	if x != nil {
		return x.Attempt
	}
	return 0
}

func (x *PendingNexusOperationInfo) GetLastAttemptCompleteTime() *timestamppb.Timestamp {
	if x != nil {
		return x.LastAttemptCompleteTime
	}
	return nil
}

func (x *PendingNexusOperationInfo) GetLastAttemptFailure() *v15.Failure {
	if x != nil {
		return x.LastAttemptFailure
	}
	return nil
}

func (x *PendingNexusOperationInfo) GetNextAttemptScheduleTime() *timestamppb.Timestamp {
	if x != nil {
		return x.NextAttemptScheduleTime
	}
	return nil
}

func (x *PendingNexusOperationInfo) GetCancellationInfo() *NexusOperationCancellationInfo {
	if x != nil {
		return x.CancellationInfo
	}
	return nil
}

func (x *PendingNexusOperationInfo) GetScheduledEventId() int64 {
	if x != nil {
		return x.ScheduledEventId
	}
	return 0
}

func (x *PendingNexusOperationInfo) GetBlockedReason() string {
	if x != nil {
		return x.BlockedReason
	}
	return ""
}

func (x *PendingNexusOperationInfo) GetOperationToken() string {
	if x != nil {
		return x.OperationToken
	}
	return ""
}

func (x *PendingNexusOperationInfo) GetScheduleToStartTimeout() *durationpb.Duration {
	if x != nil {
		return x.ScheduleToStartTimeout
	}
	return nil
}

func (x *PendingNexusOperationInfo) GetStartToCloseTimeout() *durationpb.Duration {
	if x != nil {
		return x.StartToCloseTimeout
	}
	return nil
}

// NexusOperationCancellationInfo contains the state of a nexus operation cancellation.
type NexusOperationCancellationInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The time when cancellation was requested.
	RequestedTime *timestamppb.Timestamp              `protobuf:"bytes,1,opt,name=requested_time,json=requestedTime,proto3" json:"requested_time,omitempty"`
	State         v11.NexusOperationCancellationState `protobuf:"varint,2,opt,name=state,proto3,enum=temporal.api.enums.v1.NexusOperationCancellationState" json:"state,omitempty"`
	// The number of attempts made to deliver the cancel operation request.
	// This number represents a minimum bound since the attempt is incremented after the request completes.
	Attempt int32 `protobuf:"varint,3,opt,name=attempt,proto3" json:"attempt,omitempty"`
	// The time when the last attempt completed.
	LastAttemptCompleteTime *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=last_attempt_complete_time,json=lastAttemptCompleteTime,proto3" json:"last_attempt_complete_time,omitempty"`
	// The last attempt's failure, if any.
	LastAttemptFailure *v15.Failure `protobuf:"bytes,5,opt,name=last_attempt_failure,json=lastAttemptFailure,proto3" json:"last_attempt_failure,omitempty"`
	// The time when the next attempt is scheduled.
	NextAttemptScheduleTime *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=next_attempt_schedule_time,json=nextAttemptScheduleTime,proto3" json:"next_attempt_schedule_time,omitempty"`
	// If the state is BLOCKED, blocked reason provides additional information.
	BlockedReason string `protobuf:"bytes,7,opt,name=blocked_reason,json=blockedReason,proto3" json:"blocked_reason,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NexusOperationCancellationInfo) Reset() {
	*x = NexusOperationCancellationInfo{}
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NexusOperationCancellationInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NexusOperationCancellationInfo) ProtoMessage() {}

func (x *NexusOperationCancellationInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NexusOperationCancellationInfo.ProtoReflect.Descriptor instead.
func (*NexusOperationCancellationInfo) Descriptor() ([]byte, []int) {
	return file_temporal_api_workflow_v1_message_proto_rawDescGZIP(), []int{14}
}

func (x *NexusOperationCancellationInfo) GetRequestedTime() *timestamppb.Timestamp {
	if x != nil {
		return x.RequestedTime
	}
	return nil
}

func (x *NexusOperationCancellationInfo) GetState() v11.NexusOperationCancellationState {
	if x != nil {
		return x.State
	}
	return v11.NexusOperationCancellationState(0)
}

func (x *NexusOperationCancellationInfo) GetAttempt() int32 {
	if x != nil {
		return x.Attempt
	}
	return 0
}

func (x *NexusOperationCancellationInfo) GetLastAttemptCompleteTime() *timestamppb.Timestamp {
	if x != nil {
		return x.LastAttemptCompleteTime
	}
	return nil
}

func (x *NexusOperationCancellationInfo) GetLastAttemptFailure() *v15.Failure {
	if x != nil {
		return x.LastAttemptFailure
	}
	return nil
}

func (x *NexusOperationCancellationInfo) GetNextAttemptScheduleTime() *timestamppb.Timestamp {
	if x != nil {
		return x.NextAttemptScheduleTime
	}
	return nil
}

func (x *NexusOperationCancellationInfo) GetBlockedReason() string {
	if x != nil {
		return x.BlockedReason
	}
	return ""
}

type WorkflowExecutionOptions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion.
	VersioningOverride *VersioningOverride `protobuf:"bytes,1,opt,name=versioning_override,json=versioningOverride,proto3" json:"versioning_override,omitempty"`
	// If set, overrides the workflow's priority sent by the SDK.
	Priority      *v1.Priority `protobuf:"bytes,2,opt,name=priority,proto3" json:"priority,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WorkflowExecutionOptions) Reset() {
	*x = WorkflowExecutionOptions{}
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WorkflowExecutionOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WorkflowExecutionOptions) ProtoMessage() {}

func (x *WorkflowExecutionOptions) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WorkflowExecutionOptions.ProtoReflect.Descriptor instead.
func (*WorkflowExecutionOptions) Descriptor() ([]byte, []int) {
	return file_temporal_api_workflow_v1_message_proto_rawDescGZIP(), []int{15}
}

func (x *WorkflowExecutionOptions) GetVersioningOverride() *VersioningOverride {
	if x != nil {
		return x.VersioningOverride
	}
	return nil
}

func (x *WorkflowExecutionOptions) GetPriority() *v1.Priority {
	if x != nil {
		return x.Priority
	}
	return nil
}

// Used to override the versioning behavior (and pinned deployment version, if applicable) of a
// specific workflow execution. If set, this override takes precedence over worker-sent values.
// See `WorkflowExecutionInfo.VersioningInfo` for more information.
//
// To remove the override, call `UpdateWorkflowExecutionOptions` with a null
// `VersioningOverride`, and use the `update_mask` to indicate that it should be mutated.
//
// Pinned behavior overrides are automatically inherited by child workflows, workflow retries, continue-as-new
// workflows, and cron workflows.
type VersioningOverride struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Indicates whether to override the workflow to be AutoUpgrade or Pinned.
	//
	// Types that are valid to be assigned to Override:
	//
	//	*VersioningOverride_Pinned
	//	*VersioningOverride_AutoUpgrade
	Override isVersioningOverride_Override `protobuf_oneof:"override"`
	// Required.
	// Deprecated. Use `override`.
	//
	// Deprecated: Marked as deprecated in temporal/api/workflow/v1/message.proto.
	Behavior v11.VersioningBehavior `protobuf:"varint,1,opt,name=behavior,proto3,enum=temporal.api.enums.v1.VersioningBehavior" json:"behavior,omitempty"`
	// Required if behavior is `PINNED`. Must be null if behavior is `AUTO_UPGRADE`.
	// Identifies the worker deployment to pin the workflow to.
	// Deprecated. Use `override.pinned.version`.
	//
	// Deprecated: Marked as deprecated in temporal/api/workflow/v1/message.proto.
	Deployment *v12.Deployment `protobuf:"bytes,2,opt,name=deployment,proto3" json:"deployment,omitempty"`
	// Required if behavior is `PINNED`. Must be absent if behavior is not `PINNED`.
	// Identifies the worker deployment version to pin the workflow to, in the format
	// "<deployment_name>.<build_id>".
	// Deprecated. Use `override.pinned.version`.
	//
	// Deprecated: Marked as deprecated in temporal/api/workflow/v1/message.proto.
	PinnedVersion string `protobuf:"bytes,9,opt,name=pinned_version,json=pinnedVersion,proto3" json:"pinned_version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VersioningOverride) Reset() {
	*x = VersioningOverride{}
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VersioningOverride) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VersioningOverride) ProtoMessage() {}

func (x *VersioningOverride) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VersioningOverride.ProtoReflect.Descriptor instead.
func (*VersioningOverride) Descriptor() ([]byte, []int) {
	return file_temporal_api_workflow_v1_message_proto_rawDescGZIP(), []int{16}
}

func (x *VersioningOverride) GetOverride() isVersioningOverride_Override {
	if x != nil {
		return x.Override
	}
	return nil
}

func (x *VersioningOverride) GetPinned() *VersioningOverride_PinnedOverride {
	if x != nil {
		if x, ok := x.Override.(*VersioningOverride_Pinned); ok {
			return x.Pinned
		}
	}
	return nil
}

func (x *VersioningOverride) GetAutoUpgrade() bool {
	if x != nil {
		if x, ok := x.Override.(*VersioningOverride_AutoUpgrade); ok {
			return x.AutoUpgrade
		}
	}
	return false
}

// Deprecated: Marked as deprecated in temporal/api/workflow/v1/message.proto.
func (x *VersioningOverride) GetBehavior() v11.VersioningBehavior {
	if x != nil {
		return x.Behavior
	}
	return v11.VersioningBehavior(0)
}

// Deprecated: Marked as deprecated in temporal/api/workflow/v1/message.proto.
func (x *VersioningOverride) GetDeployment() *v12.Deployment {
	if x != nil {
		return x.Deployment
	}
	return nil
}

// Deprecated: Marked as deprecated in temporal/api/workflow/v1/message.proto.
func (x *VersioningOverride) GetPinnedVersion() string {
	if x != nil {
		return x.PinnedVersion
	}
	return ""
}

type isVersioningOverride_Override interface {
	isVersioningOverride_Override()
}

type VersioningOverride_Pinned struct {
	// Override the workflow to have Pinned behavior.
	Pinned *VersioningOverride_PinnedOverride `protobuf:"bytes,3,opt,name=pinned,proto3,oneof"`
}

type VersioningOverride_AutoUpgrade struct {
	// Override the workflow to have AutoUpgrade behavior.
	AutoUpgrade bool `protobuf:"varint,4,opt,name=auto_upgrade,json=autoUpgrade,proto3,oneof"`
}

func (*VersioningOverride_Pinned) isVersioningOverride_Override() {}

func (*VersioningOverride_AutoUpgrade) isVersioningOverride_Override() {}

// When StartWorkflowExecution uses the conflict policy WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING and
// there is already an existing running workflow, OnConflictOptions defines actions to be taken on
// the existing running workflow. In this case, it will create a WorkflowExecutionOptionsUpdatedEvent
// history event in the running workflow with the changes requested in this object.
type OnConflictOptions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Attaches the request ID to the running workflow.
	AttachRequestId bool `protobuf:"varint,1,opt,name=attach_request_id,json=attachRequestId,proto3" json:"attach_request_id,omitempty"`
	// Attaches the completion callbacks to the running workflow.
	AttachCompletionCallbacks bool `protobuf:"varint,2,opt,name=attach_completion_callbacks,json=attachCompletionCallbacks,proto3" json:"attach_completion_callbacks,omitempty"`
	// Attaches the links to the WorkflowExecutionOptionsUpdatedEvent history event.
	AttachLinks   bool `protobuf:"varint,3,opt,name=attach_links,json=attachLinks,proto3" json:"attach_links,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OnConflictOptions) Reset() {
	*x = OnConflictOptions{}
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OnConflictOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OnConflictOptions) ProtoMessage() {}

func (x *OnConflictOptions) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OnConflictOptions.ProtoReflect.Descriptor instead.
func (*OnConflictOptions) Descriptor() ([]byte, []int) {
	return file_temporal_api_workflow_v1_message_proto_rawDescGZIP(), []int{17}
}

func (x *OnConflictOptions) GetAttachRequestId() bool {
	if x != nil {
		return x.AttachRequestId
	}
	return false
}

func (x *OnConflictOptions) GetAttachCompletionCallbacks() bool {
	if x != nil {
		return x.AttachCompletionCallbacks
	}
	return false
}

func (x *OnConflictOptions) GetAttachLinks() bool {
	if x != nil {
		return x.AttachLinks
	}
	return false
}

// RequestIdInfo contains details of a request ID.
type RequestIdInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The event type of the history event generated by the request.
	EventType v11.EventType `protobuf:"varint,1,opt,name=event_type,json=eventType,proto3,enum=temporal.api.enums.v1.EventType" json:"event_type,omitempty"`
	// The event id of the history event generated by the request. It's possible the event ID is not
	// known (unflushed buffered event). In this case, the value will be zero or a negative value,
	// representing an invalid ID.
	EventId int64 `protobuf:"varint,2,opt,name=event_id,json=eventId,proto3" json:"event_id,omitempty"`
	// Indicate if the request is still buffered. If so, the event ID is not known and its value
	// will be an invalid event ID.
	Buffered      bool `protobuf:"varint,3,opt,name=buffered,proto3" json:"buffered,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RequestIdInfo) Reset() {
	*x = RequestIdInfo{}
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RequestIdInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RequestIdInfo) ProtoMessage() {}

func (x *RequestIdInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RequestIdInfo.ProtoReflect.Descriptor instead.
func (*RequestIdInfo) Descriptor() ([]byte, []int) {
	return file_temporal_api_workflow_v1_message_proto_rawDescGZIP(), []int{18}
}

func (x *RequestIdInfo) GetEventType() v11.EventType {
	if x != nil {
		return x.EventType
	}
	return v11.EventType(0)
}

func (x *RequestIdInfo) GetEventId() int64 {
	if x != nil {
		return x.EventId
	}
	return 0
}

func (x *RequestIdInfo) GetBuffered() bool {
	if x != nil {
		return x.Buffered
	}
	return false
}

// PostResetOperation represents an operation to be performed on the new workflow execution after a workflow reset.
type PostResetOperation struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Variant:
	//
	//	*PostResetOperation_SignalWorkflow_
	//	*PostResetOperation_UpdateWorkflowOptions_
	Variant       isPostResetOperation_Variant `protobuf_oneof:"variant"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PostResetOperation) Reset() {
	*x = PostResetOperation{}
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PostResetOperation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PostResetOperation) ProtoMessage() {}

func (x *PostResetOperation) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PostResetOperation.ProtoReflect.Descriptor instead.
func (*PostResetOperation) Descriptor() ([]byte, []int) {
	return file_temporal_api_workflow_v1_message_proto_rawDescGZIP(), []int{19}
}

func (x *PostResetOperation) GetVariant() isPostResetOperation_Variant {
	if x != nil {
		return x.Variant
	}
	return nil
}

func (x *PostResetOperation) GetSignalWorkflow() *PostResetOperation_SignalWorkflow {
	if x != nil {
		if x, ok := x.Variant.(*PostResetOperation_SignalWorkflow_); ok {
			return x.SignalWorkflow
		}
	}
	return nil
}

func (x *PostResetOperation) GetUpdateWorkflowOptions() *PostResetOperation_UpdateWorkflowOptions {
	if x != nil {
		if x, ok := x.Variant.(*PostResetOperation_UpdateWorkflowOptions_); ok {
			return x.UpdateWorkflowOptions
		}
	}
	return nil
}

type isPostResetOperation_Variant interface {
	isPostResetOperation_Variant()
}

type PostResetOperation_SignalWorkflow_ struct {
	SignalWorkflow *PostResetOperation_SignalWorkflow `protobuf:"bytes,1,opt,name=signal_workflow,json=signalWorkflow,proto3,oneof"`
}

type PostResetOperation_UpdateWorkflowOptions_ struct {
	UpdateWorkflowOptions *PostResetOperation_UpdateWorkflowOptions `protobuf:"bytes,2,opt,name=update_workflow_options,json=updateWorkflowOptions,proto3,oneof"`
}

func (*PostResetOperation_SignalWorkflow_) isPostResetOperation_Variant() {}

func (*PostResetOperation_UpdateWorkflowOptions_) isPostResetOperation_Variant() {}

// WorkflowExecutionPauseInfo contains the information about a workflow execution pause.
type WorkflowExecutionPauseInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The identity of the client who paused the workflow execution.
	Identity string `protobuf:"bytes,1,opt,name=identity,proto3" json:"identity,omitempty"`
	// The time when the workflow execution was paused.
	PausedTime *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=paused_time,json=pausedTime,proto3" json:"paused_time,omitempty"`
	// The reason for pausing the workflow execution.
	Reason        string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WorkflowExecutionPauseInfo) Reset() {
	*x = WorkflowExecutionPauseInfo{}
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WorkflowExecutionPauseInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WorkflowExecutionPauseInfo) ProtoMessage() {}

func (x *WorkflowExecutionPauseInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WorkflowExecutionPauseInfo.ProtoReflect.Descriptor instead.
func (*WorkflowExecutionPauseInfo) Descriptor() ([]byte, []int) {
	return file_temporal_api_workflow_v1_message_proto_rawDescGZIP(), []int{20}
}

func (x *WorkflowExecutionPauseInfo) GetIdentity() string {
	if x != nil {
		return x.Identity
	}
	return ""
}

func (x *WorkflowExecutionPauseInfo) GetPausedTime() *timestamppb.Timestamp {
	if x != nil {
		return x.PausedTime
	}
	return nil
}

func (x *WorkflowExecutionPauseInfo) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

type PendingActivityInfo_PauseInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The time when the activity was paused.
	PauseTime *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=pause_time,json=pauseTime,proto3" json:"pause_time,omitempty"`
	// Types that are valid to be assigned to PausedBy:
	//
	//	*PendingActivityInfo_PauseInfo_Manual_
	//	*PendingActivityInfo_PauseInfo_Rule_
	PausedBy      isPendingActivityInfo_PauseInfo_PausedBy `protobuf_oneof:"paused_by"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PendingActivityInfo_PauseInfo) Reset() {
	*x = PendingActivityInfo_PauseInfo{}
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PendingActivityInfo_PauseInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PendingActivityInfo_PauseInfo) ProtoMessage() {}

func (x *PendingActivityInfo_PauseInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PendingActivityInfo_PauseInfo.ProtoReflect.Descriptor instead.
func (*PendingActivityInfo_PauseInfo) Descriptor() ([]byte, []int) {
	return file_temporal_api_workflow_v1_message_proto_rawDescGZIP(), []int{6, 0}
}

func (x *PendingActivityInfo_PauseInfo) GetPauseTime() *timestamppb.Timestamp {
	if x != nil {
		return x.PauseTime
	}
	return nil
}

func (x *PendingActivityInfo_PauseInfo) GetPausedBy() isPendingActivityInfo_PauseInfo_PausedBy {
	if x != nil {
		return x.PausedBy
	}
	return nil
}

func (x *PendingActivityInfo_PauseInfo) GetManual() *PendingActivityInfo_PauseInfo_Manual {
	if x != nil {
		if x, ok := x.PausedBy.(*PendingActivityInfo_PauseInfo_Manual_); ok {
			return x.Manual
		}
	}
	return nil
}

func (x *PendingActivityInfo_PauseInfo) GetRule() *PendingActivityInfo_PauseInfo_Rule {
	if x != nil {
		if x, ok := x.PausedBy.(*PendingActivityInfo_PauseInfo_Rule_); ok {
			return x.Rule
		}
	}
	return nil
}

type isPendingActivityInfo_PauseInfo_PausedBy interface {
	isPendingActivityInfo_PauseInfo_PausedBy()
}

type PendingActivityInfo_PauseInfo_Manual_ struct {
	// activity was paused by the manual intervention
	Manual *PendingActivityInfo_PauseInfo_Manual `protobuf:"bytes,2,opt,name=manual,proto3,oneof"`
}

type PendingActivityInfo_PauseInfo_Rule_ struct {
	// activity was paused by the rule
	Rule *PendingActivityInfo_PauseInfo_Rule `protobuf:"bytes,4,opt,name=rule,proto3,oneof"`
}

func (*PendingActivityInfo_PauseInfo_Manual_) isPendingActivityInfo_PauseInfo_PausedBy() {}

func (*PendingActivityInfo_PauseInfo_Rule_) isPendingActivityInfo_PauseInfo_PausedBy() {}

type PendingActivityInfo_PauseInfo_Manual struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The identity of the actor that paused the activity.
	Identity string `protobuf:"bytes,1,opt,name=identity,proto3" json:"identity,omitempty"`
	// Reason for pausing the activity.
	Reason        string `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PendingActivityInfo_PauseInfo_Manual) Reset() {
	*x = PendingActivityInfo_PauseInfo_Manual{}
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PendingActivityInfo_PauseInfo_Manual) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PendingActivityInfo_PauseInfo_Manual) ProtoMessage() {}

func (x *PendingActivityInfo_PauseInfo_Manual) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PendingActivityInfo_PauseInfo_Manual.ProtoReflect.Descriptor instead.
func (*PendingActivityInfo_PauseInfo_Manual) Descriptor() ([]byte, []int) {
	return file_temporal_api_workflow_v1_message_proto_rawDescGZIP(), []int{6, 0, 0}
}

func (x *PendingActivityInfo_PauseInfo_Manual) GetIdentity() string {
	if x != nil {
		return x.Identity
	}
	return ""
}

func (x *PendingActivityInfo_PauseInfo_Manual) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

type PendingActivityInfo_PauseInfo_Rule struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The rule that paused the activity.
	RuleId string `protobuf:"bytes,1,opt,name=rule_id,json=ruleId,proto3" json:"rule_id,omitempty"`
	// The identity of the actor that created the rule.
	Identity string `protobuf:"bytes,2,opt,name=identity,proto3" json:"identity,omitempty"`
	// Reason why rule was created. Populated from rule description.
	Reason        string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PendingActivityInfo_PauseInfo_Rule) Reset() {
	*x = PendingActivityInfo_PauseInfo_Rule{}
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PendingActivityInfo_PauseInfo_Rule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PendingActivityInfo_PauseInfo_Rule) ProtoMessage() {}

func (x *PendingActivityInfo_PauseInfo_Rule) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PendingActivityInfo_PauseInfo_Rule.ProtoReflect.Descriptor instead.
func (*PendingActivityInfo_PauseInfo_Rule) Descriptor() ([]byte, []int) {
	return file_temporal_api_workflow_v1_message_proto_rawDescGZIP(), []int{6, 0, 1}
}

func (x *PendingActivityInfo_PauseInfo_Rule) GetRuleId() string {
	if x != nil {
		return x.RuleId
	}
	return ""
}

func (x *PendingActivityInfo_PauseInfo_Rule) GetIdentity() string {
	if x != nil {
		return x.Identity
	}
	return ""
}

func (x *PendingActivityInfo_PauseInfo_Rule) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

// Trigger for when the workflow is closed.
type CallbackInfo_WorkflowClosed struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CallbackInfo_WorkflowClosed) Reset() {
	*x = CallbackInfo_WorkflowClosed{}
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CallbackInfo_WorkflowClosed) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CallbackInfo_WorkflowClosed) ProtoMessage() {}

func (x *CallbackInfo_WorkflowClosed) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CallbackInfo_WorkflowClosed.ProtoReflect.Descriptor instead.
func (*CallbackInfo_WorkflowClosed) Descriptor() ([]byte, []int) {
	return file_temporal_api_workflow_v1_message_proto_rawDescGZIP(), []int{12, 0}
}

type CallbackInfo_Trigger struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Variant:
	//
	//	*CallbackInfo_Trigger_WorkflowClosed
	Variant       isCallbackInfo_Trigger_Variant `protobuf_oneof:"variant"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CallbackInfo_Trigger) Reset() {
	*x = CallbackInfo_Trigger{}
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CallbackInfo_Trigger) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CallbackInfo_Trigger) ProtoMessage() {}

func (x *CallbackInfo_Trigger) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CallbackInfo_Trigger.ProtoReflect.Descriptor instead.
func (*CallbackInfo_Trigger) Descriptor() ([]byte, []int) {
	return file_temporal_api_workflow_v1_message_proto_rawDescGZIP(), []int{12, 1}
}

func (x *CallbackInfo_Trigger) GetVariant() isCallbackInfo_Trigger_Variant {
	if x != nil {
		return x.Variant
	}
	return nil
}

func (x *CallbackInfo_Trigger) GetWorkflowClosed() *CallbackInfo_WorkflowClosed {
	if x != nil {
		if x, ok := x.Variant.(*CallbackInfo_Trigger_WorkflowClosed); ok {
			return x.WorkflowClosed
		}
	}
	return nil
}

type isCallbackInfo_Trigger_Variant interface {
	isCallbackInfo_Trigger_Variant()
}

type CallbackInfo_Trigger_WorkflowClosed struct {
	WorkflowClosed *CallbackInfo_WorkflowClosed `protobuf:"bytes,1,opt,name=workflow_closed,json=workflowClosed,proto3,oneof"`
}

func (*CallbackInfo_Trigger_WorkflowClosed) isCallbackInfo_Trigger_Variant() {}

type VersioningOverride_PinnedOverride struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Defaults to PINNED_OVERRIDE_BEHAVIOR_UNSPECIFIED.
	// See `PinnedOverrideBehavior` for details.
	Behavior VersioningOverride_PinnedOverrideBehavior `protobuf:"varint,1,opt,name=behavior,proto3,enum=temporal.api.workflow.v1.VersioningOverride_PinnedOverrideBehavior" json:"behavior,omitempty"`
	// Specifies the Worker Deployment Version to pin this workflow to.
	// Required if the target workflow is not already pinned to a version.
	//
	// If omitted and the target workflow is already pinned, the effective
	// pinned version will be the existing pinned version.
	//
	// If omitted and the target workflow is not pinned, the override request
	// will be rejected with a PreconditionFailed error.
	Version       *v12.WorkerDeploymentVersion `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VersioningOverride_PinnedOverride) Reset() {
	*x = VersioningOverride_PinnedOverride{}
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VersioningOverride_PinnedOverride) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VersioningOverride_PinnedOverride) ProtoMessage() {}

func (x *VersioningOverride_PinnedOverride) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VersioningOverride_PinnedOverride.ProtoReflect.Descriptor instead.
func (*VersioningOverride_PinnedOverride) Descriptor() ([]byte, []int) {
	return file_temporal_api_workflow_v1_message_proto_rawDescGZIP(), []int{16, 0}
}

func (x *VersioningOverride_PinnedOverride) GetBehavior() VersioningOverride_PinnedOverrideBehavior {
	if x != nil {
		return x.Behavior
	}
	return VersioningOverride_PINNED_OVERRIDE_BEHAVIOR_UNSPECIFIED
}

func (x *VersioningOverride_PinnedOverride) GetVersion() *v12.WorkerDeploymentVersion {
	if x != nil {
		return x.Version
	}
	return nil
}

// SignalWorkflow represents sending a signal after a workflow reset.
// Keep the parameter in sync with temporal.api.workflowservice.v1.SignalWorkflowExecutionRequest.
type PostResetOperation_SignalWorkflow struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The workflow author-defined name of the signal to send to the workflow.
	SignalName string `protobuf:"bytes,1,opt,name=signal_name,json=signalName,proto3" json:"signal_name,omitempty"`
	// Serialized value(s) to provide with the signal.
	Input *v1.Payloads `protobuf:"bytes,2,opt,name=input,proto3" json:"input,omitempty"`
	// Headers that are passed with the signal to the processing workflow.
	Header *v1.Header `protobuf:"bytes,3,opt,name=header,proto3" json:"header,omitempty"`
	// Links to be associated with the WorkflowExecutionSignaled event.
	Links         []*v1.Link `protobuf:"bytes,4,rep,name=links,proto3" json:"links,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PostResetOperation_SignalWorkflow) Reset() {
	*x = PostResetOperation_SignalWorkflow{}
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PostResetOperation_SignalWorkflow) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PostResetOperation_SignalWorkflow) ProtoMessage() {}

func (x *PostResetOperation_SignalWorkflow) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PostResetOperation_SignalWorkflow.ProtoReflect.Descriptor instead.
func (*PostResetOperation_SignalWorkflow) Descriptor() ([]byte, []int) {
	return file_temporal_api_workflow_v1_message_proto_rawDescGZIP(), []int{19, 0}
}

func (x *PostResetOperation_SignalWorkflow) GetSignalName() string {
	if x != nil {
		return x.SignalName
	}
	return ""
}

func (x *PostResetOperation_SignalWorkflow) GetInput() *v1.Payloads {
	if x != nil {
		return x.Input
	}
	return nil
}

func (x *PostResetOperation_SignalWorkflow) GetHeader() *v1.Header {
	if x != nil {
		return x.Header
	}
	return nil
}

func (x *PostResetOperation_SignalWorkflow) GetLinks() []*v1.Link {
	if x != nil {
		return x.Links
	}
	return nil
}

// UpdateWorkflowOptions represents updating workflow execution options after a workflow reset.
// Keep the parameters in sync with temporal.api.workflowservice.v1.UpdateWorkflowExecutionOptionsRequest.
type PostResetOperation_UpdateWorkflowOptions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Update Workflow options that were originally specified via StartWorkflowExecution. Partial updates are accepted and controlled by update_mask.
	WorkflowExecutionOptions *WorkflowExecutionOptions `protobuf:"bytes,1,opt,name=workflow_execution_options,json=workflowExecutionOptions,proto3" json:"workflow_execution_options,omitempty"`
	// Controls which fields from `workflow_execution_options` will be applied.
	// To unset a field, set it to null and use the update mask to indicate that it should be mutated.
	UpdateMask    *fieldmaskpb.FieldMask `protobuf:"bytes,2,opt,name=update_mask,json=updateMask,proto3" json:"update_mask,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PostResetOperation_UpdateWorkflowOptions) Reset() {
	*x = PostResetOperation_UpdateWorkflowOptions{}
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PostResetOperation_UpdateWorkflowOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PostResetOperation_UpdateWorkflowOptions) ProtoMessage() {}

func (x *PostResetOperation_UpdateWorkflowOptions) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_workflow_v1_message_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PostResetOperation_UpdateWorkflowOptions.ProtoReflect.Descriptor instead.
func (*PostResetOperation_UpdateWorkflowOptions) Descriptor() ([]byte, []int) {
	return file_temporal_api_workflow_v1_message_proto_rawDescGZIP(), []int{19, 1}
}

func (x *PostResetOperation_UpdateWorkflowOptions) GetWorkflowExecutionOptions() *WorkflowExecutionOptions {
	if x != nil {
		return x.WorkflowExecutionOptions
	}
	return nil
}

func (x *PostResetOperation_UpdateWorkflowOptions) GetUpdateMask() *fieldmaskpb.FieldMask {
	if x != nil {
		return x.UpdateMask
	}
	return nil
}

var File_temporal_api_workflow_v1_message_proto protoreflect.FileDescriptor

const file_temporal_api_workflow_v1_message_proto_rawDesc = "" +
	"\n" +
	"&temporal/api/workflow/v1/message.proto\x12\x18temporal.api.workflow.v1\x1a\x1egoogle/protobuf/duration.proto\x1a\x1bgoogle/protobuf/empty.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a google/protobuf/field_mask.proto\x1a&temporal/api/activity/v1/message.proto\x1a\"temporal/api/enums/v1/common.proto\x1a&temporal/api/enums/v1/event_type.proto\x1a$temporal/api/enums/v1/workflow.proto\x1a$temporal/api/common/v1/message.proto\x1a(temporal/api/deployment/v1/message.proto\x1a%temporal/api/failure/v1/message.proto\x1a'temporal/api/taskqueue/v1/message.proto\x1a'temporal/api/sdk/v1/user_metadata.proto\"\x8c\r\n" +
	"\x15WorkflowExecutionInfo\x12G\n" +
	"\texecution\x18\x01 \x01(\v2).temporal.api.common.v1.WorkflowExecutionR\texecution\x128\n" +
	"\x04type\x18\x02 \x01(\v2$.temporal.api.common.v1.WorkflowTypeR\x04type\x129\n" +
	"\n" +
	"start_time\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\tstartTime\x129\n" +
	"\n" +
	"close_time\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\tcloseTime\x12F\n" +
	"\x06status\x18\x05 \x01(\x0e2..temporal.api.enums.v1.WorkflowExecutionStatusR\x06status\x12%\n" +
	"\x0ehistory_length\x18\x06 \x01(\x03R\rhistoryLength\x12.\n" +
	"\x13parent_namespace_id\x18\a \x01(\tR\x11parentNamespaceId\x12T\n" +
	"\x10parent_execution\x18\b \x01(\v2).temporal.api.common.v1.WorkflowExecutionR\x0fparentExecution\x12A\n" +
	"\x0eexecution_time\x18\t \x01(\v2\x1a.google.protobuf.TimestampR\rexecutionTime\x120\n" +
	"\x04memo\x18\n" +
	" \x01(\v2\x1c.temporal.api.common.v1.MemoR\x04memo\x12U\n" +
	"\x11search_attributes\x18\v \x01(\v2(.temporal.api.common.v1.SearchAttributesR\x10searchAttributes\x12Q\n" +
	"\x11auto_reset_points\x18\f \x01(\v2%.temporal.api.workflow.v1.ResetPointsR\x0fautoResetPoints\x12\x1d\n" +
	"\n" +
	"task_queue\x18\r \x01(\tR\ttaskQueue\x124\n" +
	"\x16state_transition_count\x18\x0e \x01(\x03R\x14stateTransitionCount\x12,\n" +
	"\x12history_size_bytes\x18\x0f \x01(\x03R\x10historySizeBytes\x12v\n" +
	" most_recent_worker_version_stamp\x18\x10 \x01(\v2*.temporal.api.common.v1.WorkerVersionStampB\x02\x18\x01R\x1cmostRecentWorkerVersionStamp\x12H\n" +
	"\x12execution_duration\x18\x11 \x01(\v2\x19.google.protobuf.DurationR\x11executionDuration\x12P\n" +
	"\x0eroot_execution\x18\x12 \x01(\v2).temporal.api.common.v1.WorkflowExecutionR\rrootExecution\x12.\n" +
	"\x11assigned_build_id\x18\x13 \x01(\tB\x02\x18\x01R\x0fassignedBuildId\x120\n" +
	"\x12inherited_build_id\x18\x14 \x01(\tB\x02\x18\x01R\x10inheritedBuildId\x12 \n" +
	"\ffirst_run_id\x18\x15 \x01(\tR\n" +
	"firstRunId\x12b\n" +
	"\x0fversioning_info\x18\x16 \x01(\v29.temporal.api.workflow.v1.WorkflowExecutionVersioningInfoR\x0eversioningInfo\x124\n" +
	"\x16worker_deployment_name\x18\x17 \x01(\tR\x14workerDeploymentName\x12<\n" +
	"\bpriority\x18\x18 \x01(\v2 .temporal.api.common.v1.PriorityR\bpriority\x12=\n" +
	"\x1bexternal_payload_size_bytes\x18\x19 \x01(\x03R\x18externalPayloadSizeBytes\x124\n" +
	"\x16external_payload_count\x18\x1a \x01(\x03R\x14externalPayloadCount\"\xd8\x05\n" +
	"\x1dWorkflowExecutionExtendedInfo\x12V\n" +
	"\x19execution_expiration_time\x18\x01 \x01(\v2\x1a.google.protobuf.TimestampR\x17executionExpirationTime\x12J\n" +
	"\x13run_expiration_time\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\x11runExpirationTime\x12)\n" +
	"\x10cancel_requested\x18\x03 \x01(\bR\x0fcancelRequested\x12B\n" +
	"\x0flast_reset_time\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\rlastResetTime\x12J\n" +
	"\x13original_start_time\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\x11originalStartTime\x12 \n" +
	"\freset_run_id\x18\x06 \x01(\tR\n" +
	"resetRunId\x12u\n" +
	"\x10request_id_infos\x18\a \x03(\v2K.temporal.api.workflow.v1.WorkflowExecutionExtendedInfo.RequestIdInfosEntryR\x0erequestIdInfos\x12S\n" +
	"\n" +
	"pause_info\x18\b \x01(\v24.temporal.api.workflow.v1.WorkflowExecutionPauseInfoR\tpauseInfo\x1aj\n" +
	"\x13RequestIdInfosEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12=\n" +
	"\x05value\x18\x02 \x01(\v2'.temporal.api.workflow.v1.RequestIdInfoR\x05value:\x028\x01\"\x8d\x05\n" +
	"\x1fWorkflowExecutionVersioningInfo\x12E\n" +
	"\bbehavior\x18\x01 \x01(\x0e2).temporal.api.enums.v1.VersioningBehaviorR\bbehavior\x12J\n" +
	"\n" +
	"deployment\x18\x02 \x01(\v2&.temporal.api.deployment.v1.DeploymentB\x02\x18\x01R\n" +
	"deployment\x12\x1c\n" +
	"\aversion\x18\x05 \x01(\tB\x02\x18\x01R\aversion\x12b\n" +
	"\x12deployment_version\x18\a \x01(\v23.temporal.api.deployment.v1.WorkerDeploymentVersionR\x11deploymentVersion\x12]\n" +
	"\x13versioning_override\x18\x03 \x01(\v2,.temporal.api.workflow.v1.VersioningOverrideR\x12versioningOverride\x12g\n" +
	"\x15deployment_transition\x18\x04 \x01(\v2..temporal.api.workflow.v1.DeploymentTransitionB\x02\x18\x01R\x14deploymentTransition\x12d\n" +
	"\x12version_transition\x18\x06 \x01(\v25.temporal.api.workflow.v1.DeploymentVersionTransitionR\x11versionTransition\x12'\n" +
	"\x0frevision_number\x18\b \x01(\x03R\x0erevisionNumber\"^\n" +
	"\x14DeploymentTransition\x12F\n" +
	"\n" +
	"deployment\x18\x01 \x01(\v2&.temporal.api.deployment.v1.DeploymentR\n" +
	"deployment\"\x9f\x01\n" +
	"\x1bDeploymentVersionTransition\x12\x1c\n" +
	"\aversion\x18\x01 \x01(\tB\x02\x18\x01R\aversion\x12b\n" +
	"\x12deployment_version\x18\x02 \x01(\v23.temporal.api.deployment.v1.WorkerDeploymentVersionR\x11deploymentVersion\"\xaa\x03\n" +
	"\x17WorkflowExecutionConfig\x12C\n" +
	"\n" +
	"task_queue\x18\x01 \x01(\v2$.temporal.api.taskqueue.v1.TaskQueueR\ttaskQueue\x12W\n" +
	"\x1aworkflow_execution_timeout\x18\x02 \x01(\v2\x19.google.protobuf.DurationR\x18workflowExecutionTimeout\x12K\n" +
	"\x14workflow_run_timeout\x18\x03 \x01(\v2\x19.google.protobuf.DurationR\x12workflowRunTimeout\x12\\\n" +
	"\x1ddefault_workflow_task_timeout\x18\x04 \x01(\v2\x19.google.protobuf.DurationR\x1adefaultWorkflowTaskTimeout\x12F\n" +
	"\ruser_metadata\x18\x05 \x01(\v2!.temporal.api.sdk.v1.UserMetadataR\fuserMetadata\"\xbb\x11\n" +
	"\x13PendingActivityInfo\x12\x1f\n" +
	"\vactivity_id\x18\x01 \x01(\tR\n" +
	"activityId\x12I\n" +
	"\ractivity_type\x18\x02 \x01(\v2$.temporal.api.common.v1.ActivityTypeR\factivityType\x12A\n" +
	"\x05state\x18\x03 \x01(\x0e2+.temporal.api.enums.v1.PendingActivityStateR\x05state\x12M\n" +
	"\x11heartbeat_details\x18\x04 \x01(\v2 .temporal.api.common.v1.PayloadsR\x10heartbeatDetails\x12J\n" +
	"\x13last_heartbeat_time\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\x11lastHeartbeatTime\x12F\n" +
	"\x11last_started_time\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\x0flastStartedTime\x12\x18\n" +
	"\aattempt\x18\a \x01(\x05R\aattempt\x12)\n" +
	"\x10maximum_attempts\x18\b \x01(\x05R\x0fmaximumAttempts\x12A\n" +
	"\x0escheduled_time\x18\t \x01(\v2\x1a.google.protobuf.TimestampR\rscheduledTime\x12C\n" +
	"\x0fexpiration_time\x18\n" +
	" \x01(\v2\x1a.google.protobuf.TimestampR\x0eexpirationTime\x12C\n" +
	"\flast_failure\x18\v \x01(\v2 .temporal.api.failure.v1.FailureR\vlastFailure\x120\n" +
	"\x14last_worker_identity\x18\f \x01(\tR\x12lastWorkerIdentity\x12O\n" +
	"\x15use_workflow_build_id\x18\r \x01(\v2\x16.google.protobuf.EmptyB\x02\x18\x01H\x00R\x12useWorkflowBuildId\x12T\n" +
	"$last_independently_assigned_build_id\x18\x0e \x01(\tB\x02\x18\x01H\x00R lastIndependentlyAssignedBuildId\x12i\n" +
	"\x19last_worker_version_stamp\x18\x0f \x01(\v2*.temporal.api.common.v1.WorkerVersionStampB\x02\x18\x01R\x16lastWorkerVersionStamp\x12O\n" +
	"\x16current_retry_interval\x18\x10 \x01(\v2\x19.google.protobuf.DurationR\x14currentRetryInterval\x12W\n" +
	"\x1alast_attempt_complete_time\x18\x11 \x01(\v2\x1a.google.protobuf.TimestampR\x17lastAttemptCompleteTime\x12W\n" +
	"\x1anext_attempt_schedule_time\x18\x12 \x01(\v2\x1a.google.protobuf.TimestampR\x17nextAttemptScheduleTime\x12\x16\n" +
	"\x06paused\x18\x13 \x01(\bR\x06paused\x12S\n" +
	"\x0flast_deployment\x18\x14 \x01(\v2&.temporal.api.deployment.v1.DeploymentB\x02\x18\x01R\x0elastDeployment\x12G\n" +
	"\x1elast_worker_deployment_version\x18\x15 \x01(\tB\x02\x18\x01R\x1blastWorkerDeploymentVersion\x12k\n" +
	"\x17last_deployment_version\x18\x19 \x01(\v23.temporal.api.deployment.v1.WorkerDeploymentVersionR\x15lastDeploymentVersion\x12<\n" +
	"\bpriority\x18\x16 \x01(\v2 .temporal.api.common.v1.PriorityR\bpriority\x12V\n" +
	"\n" +
	"pause_info\x18\x17 \x01(\v27.temporal.api.workflow.v1.PendingActivityInfo.PauseInfoR\tpauseInfo\x12T\n" +
	"\x10activity_options\x18\x18 \x01(\v2).temporal.api.activity.v1.ActivityOptionsR\x0factivityOptions\x1a\x94\x03\n" +
	"\tPauseInfo\x129\n" +
	"\n" +
	"pause_time\x18\x01 \x01(\v2\x1a.google.protobuf.TimestampR\tpauseTime\x12X\n" +
	"\x06manual\x18\x02 \x01(\v2>.temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.ManualH\x00R\x06manual\x12R\n" +
	"\x04rule\x18\x04 \x01(\v2<.temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.RuleH\x00R\x04rule\x1a<\n" +
	"\x06Manual\x12\x1a\n" +
	"\bidentity\x18\x01 \x01(\tR\bidentity\x12\x16\n" +
	"\x06reason\x18\x02 \x01(\tR\x06reason\x1aS\n" +
	"\x04Rule\x12\x17\n" +
	"\arule_id\x18\x01 \x01(\tR\x06ruleId\x12\x1a\n" +
	"\bidentity\x18\x02 \x01(\tR\bidentity\x12\x16\n" +
	"\x06reason\x18\x03 \x01(\tR\x06reasonB\v\n" +
	"\tpaused_byB\x13\n" +
	"\x11assigned_build_id\"\xfe\x01\n" +
	"\x19PendingChildExecutionInfo\x12\x1f\n" +
	"\vworkflow_id\x18\x01 \x01(\tR\n" +
	"workflowId\x12\x15\n" +
	"\x06run_id\x18\x02 \x01(\tR\x05runId\x12,\n" +
	"\x12workflow_type_name\x18\x03 \x01(\tR\x10workflowTypeName\x12!\n" +
	"\finitiated_id\x18\x04 \x01(\x03R\vinitiatedId\x12X\n" +
	"\x13parent_close_policy\x18\x05 \x01(\x0e2(.temporal.api.enums.v1.ParentClosePolicyR\x11parentClosePolicy\"\xd0\x02\n" +
	"\x17PendingWorkflowTaskInfo\x12E\n" +
	"\x05state\x18\x01 \x01(\x0e2/.temporal.api.enums.v1.PendingWorkflowTaskStateR\x05state\x12A\n" +
	"\x0escheduled_time\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\rscheduledTime\x12R\n" +
	"\x17original_scheduled_time\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\x15originalScheduledTime\x12=\n" +
	"\fstarted_time\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\vstartedTime\x12\x18\n" +
	"\aattempt\x18\x05 \x01(\x05R\aattempt\"O\n" +
	"\vResetPoints\x12@\n" +
	"\x06points\x18\x01 \x03(\v2(.temporal.api.workflow.v1.ResetPointInfoR\x06points\"\xd1\x02\n" +
	"\x0eResetPointInfo\x12\x19\n" +
	"\bbuild_id\x18\a \x01(\tR\abuildId\x12+\n" +
	"\x0fbinary_checksum\x18\x01 \x01(\tB\x02\x18\x01R\x0ebinaryChecksum\x12\x15\n" +
	"\x06run_id\x18\x02 \x01(\tR\x05runId\x12F\n" +
	" first_workflow_task_completed_id\x18\x03 \x01(\x03R\x1cfirstWorkflowTaskCompletedId\x12;\n" +
	"\vcreate_time\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"createTime\x12;\n" +
	"\vexpire_time\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"expireTime\x12\x1e\n" +
	"\n" +
	"resettable\x18\x06 \x01(\bR\n" +
	"resettable\"\xf2\b\n" +
	"\x18NewWorkflowExecutionInfo\x12\x1f\n" +
	"\vworkflow_id\x18\x01 \x01(\tR\n" +
	"workflowId\x12I\n" +
	"\rworkflow_type\x18\x02 \x01(\v2$.temporal.api.common.v1.WorkflowTypeR\fworkflowType\x12C\n" +
	"\n" +
	"task_queue\x18\x03 \x01(\v2$.temporal.api.taskqueue.v1.TaskQueueR\ttaskQueue\x126\n" +
	"\x05input\x18\x04 \x01(\v2 .temporal.api.common.v1.PayloadsR\x05input\x12W\n" +
	"\x1aworkflow_execution_timeout\x18\x05 \x01(\v2\x19.google.protobuf.DurationR\x18workflowExecutionTimeout\x12K\n" +
	"\x14workflow_run_timeout\x18\x06 \x01(\v2\x19.google.protobuf.DurationR\x12workflowRunTimeout\x12M\n" +
	"\x15workflow_task_timeout\x18\a \x01(\v2\x19.google.protobuf.DurationR\x13workflowTaskTimeout\x12e\n" +
	"\x18workflow_id_reuse_policy\x18\b \x01(\x0e2,.temporal.api.enums.v1.WorkflowIdReusePolicyR\x15workflowIdReusePolicy\x12F\n" +
	"\fretry_policy\x18\t \x01(\v2#.temporal.api.common.v1.RetryPolicyR\vretryPolicy\x12#\n" +
	"\rcron_schedule\x18\n" +
	" \x01(\tR\fcronSchedule\x120\n" +
	"\x04memo\x18\v \x01(\v2\x1c.temporal.api.common.v1.MemoR\x04memo\x12U\n" +
	"\x11search_attributes\x18\f \x01(\v2(.temporal.api.common.v1.SearchAttributesR\x10searchAttributes\x126\n" +
	"\x06header\x18\r \x01(\v2\x1e.temporal.api.common.v1.HeaderR\x06header\x12F\n" +
	"\ruser_metadata\x18\x0e \x01(\v2!.temporal.api.sdk.v1.UserMetadataR\fuserMetadata\x12]\n" +
	"\x13versioning_override\x18\x0f \x01(\v2,.temporal.api.workflow.v1.VersioningOverrideR\x12versioningOverride\x12<\n" +
	"\bpriority\x18\x10 \x01(\v2 .temporal.api.common.v1.PriorityR\bpriority\"\xec\x05\n" +
	"\fCallbackInfo\x12<\n" +
	"\bcallback\x18\x01 \x01(\v2 .temporal.api.common.v1.CallbackR\bcallback\x12H\n" +
	"\atrigger\x18\x02 \x01(\v2..temporal.api.workflow.v1.CallbackInfo.TriggerR\atrigger\x12G\n" +
	"\x11registration_time\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\x10registrationTime\x12:\n" +
	"\x05state\x18\x04 \x01(\x0e2$.temporal.api.enums.v1.CallbackStateR\x05state\x12\x18\n" +
	"\aattempt\x18\x05 \x01(\x05R\aattempt\x12W\n" +
	"\x1alast_attempt_complete_time\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\x17lastAttemptCompleteTime\x12R\n" +
	"\x14last_attempt_failure\x18\a \x01(\v2 .temporal.api.failure.v1.FailureR\x12lastAttemptFailure\x12W\n" +
	"\x1anext_attempt_schedule_time\x18\b \x01(\v2\x1a.google.protobuf.TimestampR\x17nextAttemptScheduleTime\x12%\n" +
	"\x0eblocked_reason\x18\t \x01(\tR\rblockedReason\x1a\x10\n" +
	"\x0eWorkflowClosed\x1av\n" +
	"\aTrigger\x12`\n" +
	"\x0fworkflow_closed\x18\x01 \x01(\v25.temporal.api.workflow.v1.CallbackInfo.WorkflowClosedH\x00R\x0eworkflowClosedB\t\n" +
	"\avariant\"\xa3\b\n" +
	"\x19PendingNexusOperationInfo\x12\x1a\n" +
	"\bendpoint\x18\x01 \x01(\tR\bendpoint\x12\x18\n" +
	"\aservice\x18\x02 \x01(\tR\aservice\x12\x1c\n" +
	"\toperation\x18\x03 \x01(\tR\toperation\x12%\n" +
	"\foperation_id\x18\x04 \x01(\tB\x02\x18\x01R\voperationId\x12T\n" +
	"\x19schedule_to_close_timeout\x18\x05 \x01(\v2\x19.google.protobuf.DurationR\x16scheduleToCloseTimeout\x12A\n" +
	"\x0escheduled_time\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\rscheduledTime\x12G\n" +
	"\x05state\x18\a \x01(\x0e21.temporal.api.enums.v1.PendingNexusOperationStateR\x05state\x12\x18\n" +
	"\aattempt\x18\b \x01(\x05R\aattempt\x12W\n" +
	"\x1alast_attempt_complete_time\x18\t \x01(\v2\x1a.google.protobuf.TimestampR\x17lastAttemptCompleteTime\x12R\n" +
	"\x14last_attempt_failure\x18\n" +
	" \x01(\v2 .temporal.api.failure.v1.FailureR\x12lastAttemptFailure\x12W\n" +
	"\x1anext_attempt_schedule_time\x18\v \x01(\v2\x1a.google.protobuf.TimestampR\x17nextAttemptScheduleTime\x12e\n" +
	"\x11cancellation_info\x18\f \x01(\v28.temporal.api.workflow.v1.NexusOperationCancellationInfoR\x10cancellationInfo\x12,\n" +
	"\x12scheduled_event_id\x18\r \x01(\x03R\x10scheduledEventId\x12%\n" +
	"\x0eblocked_reason\x18\x0e \x01(\tR\rblockedReason\x12'\n" +
	"\x0foperation_token\x18\x0f \x01(\tR\x0eoperationToken\x12T\n" +
	"\x19schedule_to_start_timeout\x18\x10 \x01(\v2\x19.google.protobuf.DurationR\x16scheduleToStartTimeout\x12N\n" +
	"\x16start_to_close_timeout\x18\x11 \x01(\v2\x19.google.protobuf.DurationR\x13startToCloseTimeout\"\xf8\x03\n" +
	"\x1eNexusOperationCancellationInfo\x12A\n" +
	"\x0erequested_time\x18\x01 \x01(\v2\x1a.google.protobuf.TimestampR\rrequestedTime\x12L\n" +
	"\x05state\x18\x02 \x01(\x0e26.temporal.api.enums.v1.NexusOperationCancellationStateR\x05state\x12\x18\n" +
	"\aattempt\x18\x03 \x01(\x05R\aattempt\x12W\n" +
	"\x1alast_attempt_complete_time\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\x17lastAttemptCompleteTime\x12R\n" +
	"\x14last_attempt_failure\x18\x05 \x01(\v2 .temporal.api.failure.v1.FailureR\x12lastAttemptFailure\x12W\n" +
	"\x1anext_attempt_schedule_time\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\x17nextAttemptScheduleTime\x12%\n" +
	"\x0eblocked_reason\x18\a \x01(\tR\rblockedReason\"\xb7\x01\n" +
	"\x18WorkflowExecutionOptions\x12]\n" +
	"\x13versioning_override\x18\x01 \x01(\v2,.temporal.api.workflow.v1.VersioningOverrideR\x12versioningOverride\x12<\n" +
	"\bpriority\x18\x02 \x01(\v2 .temporal.api.common.v1.PriorityR\bpriority\"\x8a\x05\n" +
	"\x12VersioningOverride\x12U\n" +
	"\x06pinned\x18\x03 \x01(\v2;.temporal.api.workflow.v1.VersioningOverride.PinnedOverrideH\x00R\x06pinned\x12#\n" +
	"\fauto_upgrade\x18\x04 \x01(\bH\x00R\vautoUpgrade\x12I\n" +
	"\bbehavior\x18\x01 \x01(\x0e2).temporal.api.enums.v1.VersioningBehaviorB\x02\x18\x01R\bbehavior\x12J\n" +
	"\n" +
	"deployment\x18\x02 \x01(\v2&.temporal.api.deployment.v1.DeploymentB\x02\x18\x01R\n" +
	"deployment\x12)\n" +
	"\x0epinned_version\x18\t \x01(\tB\x02\x18\x01R\rpinnedVersion\x1a\xc0\x01\n" +
	"\x0ePinnedOverride\x12_\n" +
	"\bbehavior\x18\x01 \x01(\x0e2C.temporal.api.workflow.v1.VersioningOverride.PinnedOverrideBehaviorR\bbehavior\x12M\n" +
	"\aversion\x18\x02 \x01(\v23.temporal.api.deployment.v1.WorkerDeploymentVersionR\aversion\"g\n" +
	"\x16PinnedOverrideBehavior\x12(\n" +
	"$PINNED_OVERRIDE_BEHAVIOR_UNSPECIFIED\x10\x00\x12#\n" +
	"\x1fPINNED_OVERRIDE_BEHAVIOR_PINNED\x10\x01B\n" +
	"\n" +
	"\boverride\"\xa2\x01\n" +
	"\x11OnConflictOptions\x12*\n" +
	"\x11attach_request_id\x18\x01 \x01(\bR\x0fattachRequestId\x12>\n" +
	"\x1battach_completion_callbacks\x18\x02 \x01(\bR\x19attachCompletionCallbacks\x12!\n" +
	"\fattach_links\x18\x03 \x01(\bR\vattachLinks\"\x87\x01\n" +
	"\rRequestIdInfo\x12?\n" +
	"\n" +
	"event_type\x18\x01 \x01(\x0e2 .temporal.api.enums.v1.EventTypeR\teventType\x12\x19\n" +
	"\bevent_id\x18\x02 \x01(\x03R\aeventId\x12\x1a\n" +
	"\bbuffered\x18\x03 \x01(\bR\bbuffered\"\xa6\x05\n" +
	"\x12PostResetOperation\x12f\n" +
	"\x0fsignal_workflow\x18\x01 \x01(\v2;.temporal.api.workflow.v1.PostResetOperation.SignalWorkflowH\x00R\x0esignalWorkflow\x12|\n" +
	"\x17update_workflow_options\x18\x02 \x01(\v2B.temporal.api.workflow.v1.PostResetOperation.UpdateWorkflowOptionsH\x00R\x15updateWorkflowOptions\x1a\xd5\x01\n" +
	"\x0eSignalWorkflow\x12\x1f\n" +
	"\vsignal_name\x18\x01 \x01(\tR\n" +
	"signalName\x126\n" +
	"\x05input\x18\x02 \x01(\v2 .temporal.api.common.v1.PayloadsR\x05input\x126\n" +
	"\x06header\x18\x03 \x01(\v2\x1e.temporal.api.common.v1.HeaderR\x06header\x122\n" +
	"\x05links\x18\x04 \x03(\v2\x1c.temporal.api.common.v1.LinkR\x05links\x1a\xc6\x01\n" +
	"\x15UpdateWorkflowOptions\x12p\n" +
	"\x1aworkflow_execution_options\x18\x01 \x01(\v22.temporal.api.workflow.v1.WorkflowExecutionOptionsR\x18workflowExecutionOptions\x12;\n" +
	"\vupdate_mask\x18\x02 \x01(\v2\x1a.google.protobuf.FieldMaskR\n" +
	"updateMaskB\t\n" +
	"\avariant\"\x8d\x01\n" +
	"\x1aWorkflowExecutionPauseInfo\x12\x1a\n" +
	"\bidentity\x18\x01 \x01(\tR\bidentity\x12;\n" +
	"\vpaused_time\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"pausedTime\x12\x16\n" +
	"\x06reason\x18\x03 \x01(\tR\x06reasonB\x93\x01\n" +
	"\x1bio.temporal.api.workflow.v1B\fMessageProtoP\x01Z'go.temporal.io/api/workflow/v1;workflow\xaa\x02\x1aTemporalio.Api.Workflow.V1\xea\x02\x1dTemporalio::Api::Workflow::V1b\x06proto3"

var (
	file_temporal_api_workflow_v1_message_proto_rawDescOnce sync.Once
	file_temporal_api_workflow_v1_message_proto_rawDescData []byte
)

func file_temporal_api_workflow_v1_message_proto_rawDescGZIP() []byte {
	file_temporal_api_workflow_v1_message_proto_rawDescOnce.Do(func() {
		file_temporal_api_workflow_v1_message_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_temporal_api_workflow_v1_message_proto_rawDesc), len(file_temporal_api_workflow_v1_message_proto_rawDesc)))
	})
	return file_temporal_api_workflow_v1_message_proto_rawDescData
}

var file_temporal_api_workflow_v1_message_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_temporal_api_workflow_v1_message_proto_msgTypes = make([]protoimpl.MessageInfo, 30)
var file_temporal_api_workflow_v1_message_proto_goTypes = []any{
	(VersioningOverride_PinnedOverrideBehavior)(0),   // 0: temporal.api.workflow.v1.VersioningOverride.PinnedOverrideBehavior
	(*WorkflowExecutionInfo)(nil),                    // 1: temporal.api.workflow.v1.WorkflowExecutionInfo
	(*WorkflowExecutionExtendedInfo)(nil),            // 2: temporal.api.workflow.v1.WorkflowExecutionExtendedInfo
	(*WorkflowExecutionVersioningInfo)(nil),          // 3: temporal.api.workflow.v1.WorkflowExecutionVersioningInfo
	(*DeploymentTransition)(nil),                     // 4: temporal.api.workflow.v1.DeploymentTransition
	(*DeploymentVersionTransition)(nil),              // 5: temporal.api.workflow.v1.DeploymentVersionTransition
	(*WorkflowExecutionConfig)(nil),                  // 6: temporal.api.workflow.v1.WorkflowExecutionConfig
	(*PendingActivityInfo)(nil),                      // 7: temporal.api.workflow.v1.PendingActivityInfo
	(*PendingChildExecutionInfo)(nil),                // 8: temporal.api.workflow.v1.PendingChildExecutionInfo
	(*PendingWorkflowTaskInfo)(nil),                  // 9: temporal.api.workflow.v1.PendingWorkflowTaskInfo
	(*ResetPoints)(nil),                              // 10: temporal.api.workflow.v1.ResetPoints
	(*ResetPointInfo)(nil),                           // 11: temporal.api.workflow.v1.ResetPointInfo
	(*NewWorkflowExecutionInfo)(nil),                 // 12: temporal.api.workflow.v1.NewWorkflowExecutionInfo
	(*CallbackInfo)(nil),                             // 13: temporal.api.workflow.v1.CallbackInfo
	(*PendingNexusOperationInfo)(nil),                // 14: temporal.api.workflow.v1.PendingNexusOperationInfo
	(*NexusOperationCancellationInfo)(nil),           // 15: temporal.api.workflow.v1.NexusOperationCancellationInfo
	(*WorkflowExecutionOptions)(nil),                 // 16: temporal.api.workflow.v1.WorkflowExecutionOptions
	(*VersioningOverride)(nil),                       // 17: temporal.api.workflow.v1.VersioningOverride
	(*OnConflictOptions)(nil),                        // 18: temporal.api.workflow.v1.OnConflictOptions
	(*RequestIdInfo)(nil),                            // 19: temporal.api.workflow.v1.RequestIdInfo
	(*PostResetOperation)(nil),                       // 20: temporal.api.workflow.v1.PostResetOperation
	(*WorkflowExecutionPauseInfo)(nil),               // 21: temporal.api.workflow.v1.WorkflowExecutionPauseInfo
	nil,                                              // 22: temporal.api.workflow.v1.WorkflowExecutionExtendedInfo.RequestIdInfosEntry
	(*PendingActivityInfo_PauseInfo)(nil),            // 23: temporal.api.workflow.v1.PendingActivityInfo.PauseInfo
	(*PendingActivityInfo_PauseInfo_Manual)(nil),     // 24: temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.Manual
	(*PendingActivityInfo_PauseInfo_Rule)(nil),       // 25: temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.Rule
	(*CallbackInfo_WorkflowClosed)(nil),              // 26: temporal.api.workflow.v1.CallbackInfo.WorkflowClosed
	(*CallbackInfo_Trigger)(nil),                     // 27: temporal.api.workflow.v1.CallbackInfo.Trigger
	(*VersioningOverride_PinnedOverride)(nil),        // 28: temporal.api.workflow.v1.VersioningOverride.PinnedOverride
	(*PostResetOperation_SignalWorkflow)(nil),        // 29: temporal.api.workflow.v1.PostResetOperation.SignalWorkflow
	(*PostResetOperation_UpdateWorkflowOptions)(nil), // 30: temporal.api.workflow.v1.PostResetOperation.UpdateWorkflowOptions
	(*v1.WorkflowExecution)(nil),                     // 31: temporal.api.common.v1.WorkflowExecution
	(*v1.WorkflowType)(nil),                          // 32: temporal.api.common.v1.WorkflowType
	(*timestamppb.Timestamp)(nil),                    // 33: google.protobuf.Timestamp
	(v11.WorkflowExecutionStatus)(0),                 // 34: temporal.api.enums.v1.WorkflowExecutionStatus
	(*v1.Memo)(nil),                                  // 35: temporal.api.common.v1.Memo
	(*v1.SearchAttributes)(nil),                      // 36: temporal.api.common.v1.SearchAttributes
	(*v1.WorkerVersionStamp)(nil),                    // 37: temporal.api.common.v1.WorkerVersionStamp
	(*durationpb.Duration)(nil),                      // 38: google.protobuf.Duration
	(*v1.Priority)(nil),                              // 39: temporal.api.common.v1.Priority
	(v11.VersioningBehavior)(0),                      // 40: temporal.api.enums.v1.VersioningBehavior
	(*v12.Deployment)(nil),                           // 41: temporal.api.deployment.v1.Deployment
	(*v12.WorkerDeploymentVersion)(nil),              // 42: temporal.api.deployment.v1.WorkerDeploymentVersion
	(*v13.TaskQueue)(nil),                            // 43: temporal.api.taskqueue.v1.TaskQueue
	(*v14.UserMetadata)(nil),                         // 44: temporal.api.sdk.v1.UserMetadata
	(*v1.ActivityType)(nil),                          // 45: temporal.api.common.v1.ActivityType
	(v11.PendingActivityState)(0),                    // 46: temporal.api.enums.v1.PendingActivityState
	(*v1.Payloads)(nil),                              // 47: temporal.api.common.v1.Payloads
	(*v15.Failure)(nil),                              // 48: temporal.api.failure.v1.Failure
	(*emptypb.Empty)(nil),                            // 49: google.protobuf.Empty
	(*v16.ActivityOptions)(nil),                      // 50: temporal.api.activity.v1.ActivityOptions
	(v11.ParentClosePolicy)(0),                       // 51: temporal.api.enums.v1.ParentClosePolicy
	(v11.PendingWorkflowTaskState)(0),                // 52: temporal.api.enums.v1.PendingWorkflowTaskState
	(v11.WorkflowIdReusePolicy)(0),                   // 53: temporal.api.enums.v1.WorkflowIdReusePolicy
	(*v1.RetryPolicy)(nil),                           // 54: temporal.api.common.v1.RetryPolicy
	(*v1.Header)(nil),                                // 55: temporal.api.common.v1.Header
	(*v1.Callback)(nil),                              // 56: temporal.api.common.v1.Callback
	(v11.CallbackState)(0),                           // 57: temporal.api.enums.v1.CallbackState
	(v11.PendingNexusOperationState)(0),              // 58: temporal.api.enums.v1.PendingNexusOperationState
	(v11.NexusOperationCancellationState)(0),         // 59: temporal.api.enums.v1.NexusOperationCancellationState
	(v11.EventType)(0),                               // 60: temporal.api.enums.v1.EventType
	(*v1.Link)(nil),                                  // 61: temporal.api.common.v1.Link
	(*fieldmaskpb.FieldMask)(nil),                    // 62: google.protobuf.FieldMask
}
var file_temporal_api_workflow_v1_message_proto_depIdxs = []int32{
	31,  // 0: temporal.api.workflow.v1.WorkflowExecutionInfo.execution:type_name -> temporal.api.common.v1.WorkflowExecution
	32,  // 1: temporal.api.workflow.v1.WorkflowExecutionInfo.type:type_name -> temporal.api.common.v1.WorkflowType
	33,  // 2: temporal.api.workflow.v1.WorkflowExecutionInfo.start_time:type_name -> google.protobuf.Timestamp
	33,  // 3: temporal.api.workflow.v1.WorkflowExecutionInfo.close_time:type_name -> google.protobuf.Timestamp
	34,  // 4: temporal.api.workflow.v1.WorkflowExecutionInfo.status:type_name -> temporal.api.enums.v1.WorkflowExecutionStatus
	31,  // 5: temporal.api.workflow.v1.WorkflowExecutionInfo.parent_execution:type_name -> temporal.api.common.v1.WorkflowExecution
	33,  // 6: temporal.api.workflow.v1.WorkflowExecutionInfo.execution_time:type_name -> google.protobuf.Timestamp
	35,  // 7: temporal.api.workflow.v1.WorkflowExecutionInfo.memo:type_name -> temporal.api.common.v1.Memo
	36,  // 8: temporal.api.workflow.v1.WorkflowExecutionInfo.search_attributes:type_name -> temporal.api.common.v1.SearchAttributes
	10,  // 9: temporal.api.workflow.v1.WorkflowExecutionInfo.auto_reset_points:type_name -> temporal.api.workflow.v1.ResetPoints
	37,  // 10: temporal.api.workflow.v1.WorkflowExecutionInfo.most_recent_worker_version_stamp:type_name -> temporal.api.common.v1.WorkerVersionStamp
	38,  // 11: temporal.api.workflow.v1.WorkflowExecutionInfo.execution_duration:type_name -> google.protobuf.Duration
	31,  // 12: temporal.api.workflow.v1.WorkflowExecutionInfo.root_execution:type_name -> temporal.api.common.v1.WorkflowExecution
	3,   // 13: temporal.api.workflow.v1.WorkflowExecutionInfo.versioning_info:type_name -> temporal.api.workflow.v1.WorkflowExecutionVersioningInfo
	39,  // 14: temporal.api.workflow.v1.WorkflowExecutionInfo.priority:type_name -> temporal.api.common.v1.Priority
	33,  // 15: temporal.api.workflow.v1.WorkflowExecutionExtendedInfo.execution_expiration_time:type_name -> google.protobuf.Timestamp
	33,  // 16: temporal.api.workflow.v1.WorkflowExecutionExtendedInfo.run_expiration_time:type_name -> google.protobuf.Timestamp
	33,  // 17: temporal.api.workflow.v1.WorkflowExecutionExtendedInfo.last_reset_time:type_name -> google.protobuf.Timestamp
	33,  // 18: temporal.api.workflow.v1.WorkflowExecutionExtendedInfo.original_start_time:type_name -> google.protobuf.Timestamp
	22,  // 19: temporal.api.workflow.v1.WorkflowExecutionExtendedInfo.request_id_infos:type_name -> temporal.api.workflow.v1.WorkflowExecutionExtendedInfo.RequestIdInfosEntry
	21,  // 20: temporal.api.workflow.v1.WorkflowExecutionExtendedInfo.pause_info:type_name -> temporal.api.workflow.v1.WorkflowExecutionPauseInfo
	40,  // 21: temporal.api.workflow.v1.WorkflowExecutionVersioningInfo.behavior:type_name -> temporal.api.enums.v1.VersioningBehavior
	41,  // 22: temporal.api.workflow.v1.WorkflowExecutionVersioningInfo.deployment:type_name -> temporal.api.deployment.v1.Deployment
	42,  // 23: temporal.api.workflow.v1.WorkflowExecutionVersioningInfo.deployment_version:type_name -> temporal.api.deployment.v1.WorkerDeploymentVersion
	17,  // 24: temporal.api.workflow.v1.WorkflowExecutionVersioningInfo.versioning_override:type_name -> temporal.api.workflow.v1.VersioningOverride
	4,   // 25: temporal.api.workflow.v1.WorkflowExecutionVersioningInfo.deployment_transition:type_name -> temporal.api.workflow.v1.DeploymentTransition
	5,   // 26: temporal.api.workflow.v1.WorkflowExecutionVersioningInfo.version_transition:type_name -> temporal.api.workflow.v1.DeploymentVersionTransition
	41,  // 27: temporal.api.workflow.v1.DeploymentTransition.deployment:type_name -> temporal.api.deployment.v1.Deployment
	42,  // 28: temporal.api.workflow.v1.DeploymentVersionTransition.deployment_version:type_name -> temporal.api.deployment.v1.WorkerDeploymentVersion
	43,  // 29: temporal.api.workflow.v1.WorkflowExecutionConfig.task_queue:type_name -> temporal.api.taskqueue.v1.TaskQueue
	38,  // 30: temporal.api.workflow.v1.WorkflowExecutionConfig.workflow_execution_timeout:type_name -> google.protobuf.Duration
	38,  // 31: temporal.api.workflow.v1.WorkflowExecutionConfig.workflow_run_timeout:type_name -> google.protobuf.Duration
	38,  // 32: temporal.api.workflow.v1.WorkflowExecutionConfig.default_workflow_task_timeout:type_name -> google.protobuf.Duration
	44,  // 33: temporal.api.workflow.v1.WorkflowExecutionConfig.user_metadata:type_name -> temporal.api.sdk.v1.UserMetadata
	45,  // 34: temporal.api.workflow.v1.PendingActivityInfo.activity_type:type_name -> temporal.api.common.v1.ActivityType
	46,  // 35: temporal.api.workflow.v1.PendingActivityInfo.state:type_name -> temporal.api.enums.v1.PendingActivityState
	47,  // 36: temporal.api.workflow.v1.PendingActivityInfo.heartbeat_details:type_name -> temporal.api.common.v1.Payloads
	33,  // 37: temporal.api.workflow.v1.PendingActivityInfo.last_heartbeat_time:type_name -> google.protobuf.Timestamp
	33,  // 38: temporal.api.workflow.v1.PendingActivityInfo.last_started_time:type_name -> google.protobuf.Timestamp
	33,  // 39: temporal.api.workflow.v1.PendingActivityInfo.scheduled_time:type_name -> google.protobuf.Timestamp
	33,  // 40: temporal.api.workflow.v1.PendingActivityInfo.expiration_time:type_name -> google.protobuf.Timestamp
	48,  // 41: temporal.api.workflow.v1.PendingActivityInfo.last_failure:type_name -> temporal.api.failure.v1.Failure
	49,  // 42: temporal.api.workflow.v1.PendingActivityInfo.use_workflow_build_id:type_name -> google.protobuf.Empty
	37,  // 43: temporal.api.workflow.v1.PendingActivityInfo.last_worker_version_stamp:type_name -> temporal.api.common.v1.WorkerVersionStamp
	38,  // 44: temporal.api.workflow.v1.PendingActivityInfo.current_retry_interval:type_name -> google.protobuf.Duration
	33,  // 45: temporal.api.workflow.v1.PendingActivityInfo.last_attempt_complete_time:type_name -> google.protobuf.Timestamp
	33,  // 46: temporal.api.workflow.v1.PendingActivityInfo.next_attempt_schedule_time:type_name -> google.protobuf.Timestamp
	41,  // 47: temporal.api.workflow.v1.PendingActivityInfo.last_deployment:type_name -> temporal.api.deployment.v1.Deployment
	42,  // 48: temporal.api.workflow.v1.PendingActivityInfo.last_deployment_version:type_name -> temporal.api.deployment.v1.WorkerDeploymentVersion
	39,  // 49: temporal.api.workflow.v1.PendingActivityInfo.priority:type_name -> temporal.api.common.v1.Priority
	23,  // 50: temporal.api.workflow.v1.PendingActivityInfo.pause_info:type_name -> temporal.api.workflow.v1.PendingActivityInfo.PauseInfo
	50,  // 51: temporal.api.workflow.v1.PendingActivityInfo.activity_options:type_name -> temporal.api.activity.v1.ActivityOptions
	51,  // 52: temporal.api.workflow.v1.PendingChildExecutionInfo.parent_close_policy:type_name -> temporal.api.enums.v1.ParentClosePolicy
	52,  // 53: temporal.api.workflow.v1.PendingWorkflowTaskInfo.state:type_name -> temporal.api.enums.v1.PendingWorkflowTaskState
	33,  // 54: temporal.api.workflow.v1.PendingWorkflowTaskInfo.scheduled_time:type_name -> google.protobuf.Timestamp
	33,  // 55: temporal.api.workflow.v1.PendingWorkflowTaskInfo.original_scheduled_time:type_name -> google.protobuf.Timestamp
	33,  // 56: temporal.api.workflow.v1.PendingWorkflowTaskInfo.started_time:type_name -> google.protobuf.Timestamp
	11,  // 57: temporal.api.workflow.v1.ResetPoints.points:type_name -> temporal.api.workflow.v1.ResetPointInfo
	33,  // 58: temporal.api.workflow.v1.ResetPointInfo.create_time:type_name -> google.protobuf.Timestamp
	33,  // 59: temporal.api.workflow.v1.ResetPointInfo.expire_time:type_name -> google.protobuf.Timestamp
	32,  // 60: temporal.api.workflow.v1.NewWorkflowExecutionInfo.workflow_type:type_name -> temporal.api.common.v1.WorkflowType
	43,  // 61: temporal.api.workflow.v1.NewWorkflowExecutionInfo.task_queue:type_name -> temporal.api.taskqueue.v1.TaskQueue
	47,  // 62: temporal.api.workflow.v1.NewWorkflowExecutionInfo.input:type_name -> temporal.api.common.v1.Payloads
	38,  // 63: temporal.api.workflow.v1.NewWorkflowExecutionInfo.workflow_execution_timeout:type_name -> google.protobuf.Duration
	38,  // 64: temporal.api.workflow.v1.NewWorkflowExecutionInfo.workflow_run_timeout:type_name -> google.protobuf.Duration
	38,  // 65: temporal.api.workflow.v1.NewWorkflowExecutionInfo.workflow_task_timeout:type_name -> google.protobuf.Duration
	53,  // 66: temporal.api.workflow.v1.NewWorkflowExecutionInfo.workflow_id_reuse_policy:type_name -> temporal.api.enums.v1.WorkflowIdReusePolicy
	54,  // 67: temporal.api.workflow.v1.NewWorkflowExecutionInfo.retry_policy:type_name -> temporal.api.common.v1.RetryPolicy
	35,  // 68: temporal.api.workflow.v1.NewWorkflowExecutionInfo.memo:type_name -> temporal.api.common.v1.Memo
	36,  // 69: temporal.api.workflow.v1.NewWorkflowExecutionInfo.search_attributes:type_name -> temporal.api.common.v1.SearchAttributes
	55,  // 70: temporal.api.workflow.v1.NewWorkflowExecutionInfo.header:type_name -> temporal.api.common.v1.Header
	44,  // 71: temporal.api.workflow.v1.NewWorkflowExecutionInfo.user_metadata:type_name -> temporal.api.sdk.v1.UserMetadata
	17,  // 72: temporal.api.workflow.v1.NewWorkflowExecutionInfo.versioning_override:type_name -> temporal.api.workflow.v1.VersioningOverride
	39,  // 73: temporal.api.workflow.v1.NewWorkflowExecutionInfo.priority:type_name -> temporal.api.common.v1.Priority
	56,  // 74: temporal.api.workflow.v1.CallbackInfo.callback:type_name -> temporal.api.common.v1.Callback
	27,  // 75: temporal.api.workflow.v1.CallbackInfo.trigger:type_name -> temporal.api.workflow.v1.CallbackInfo.Trigger
	33,  // 76: temporal.api.workflow.v1.CallbackInfo.registration_time:type_name -> google.protobuf.Timestamp
	57,  // 77: temporal.api.workflow.v1.CallbackInfo.state:type_name -> temporal.api.enums.v1.CallbackState
	33,  // 78: temporal.api.workflow.v1.CallbackInfo.last_attempt_complete_time:type_name -> google.protobuf.Timestamp
	48,  // 79: temporal.api.workflow.v1.CallbackInfo.last_attempt_failure:type_name -> temporal.api.failure.v1.Failure
	33,  // 80: temporal.api.workflow.v1.CallbackInfo.next_attempt_schedule_time:type_name -> google.protobuf.Timestamp
	38,  // 81: temporal.api.workflow.v1.PendingNexusOperationInfo.schedule_to_close_timeout:type_name -> google.protobuf.Duration
	33,  // 82: temporal.api.workflow.v1.PendingNexusOperationInfo.scheduled_time:type_name -> google.protobuf.Timestamp
	58,  // 83: temporal.api.workflow.v1.PendingNexusOperationInfo.state:type_name -> temporal.api.enums.v1.PendingNexusOperationState
	33,  // 84: temporal.api.workflow.v1.PendingNexusOperationInfo.last_attempt_complete_time:type_name -> google.protobuf.Timestamp
	48,  // 85: temporal.api.workflow.v1.PendingNexusOperationInfo.last_attempt_failure:type_name -> temporal.api.failure.v1.Failure
	33,  // 86: temporal.api.workflow.v1.PendingNexusOperationInfo.next_attempt_schedule_time:type_name -> google.protobuf.Timestamp
	15,  // 87: temporal.api.workflow.v1.PendingNexusOperationInfo.cancellation_info:type_name -> temporal.api.workflow.v1.NexusOperationCancellationInfo
	38,  // 88: temporal.api.workflow.v1.PendingNexusOperationInfo.schedule_to_start_timeout:type_name -> google.protobuf.Duration
	38,  // 89: temporal.api.workflow.v1.PendingNexusOperationInfo.start_to_close_timeout:type_name -> google.protobuf.Duration
	33,  // 90: temporal.api.workflow.v1.NexusOperationCancellationInfo.requested_time:type_name -> google.protobuf.Timestamp
	59,  // 91: temporal.api.workflow.v1.NexusOperationCancellationInfo.state:type_name -> temporal.api.enums.v1.NexusOperationCancellationState
	33,  // 92: temporal.api.workflow.v1.NexusOperationCancellationInfo.last_attempt_complete_time:type_name -> google.protobuf.Timestamp
	48,  // 93: temporal.api.workflow.v1.NexusOperationCancellationInfo.last_attempt_failure:type_name -> temporal.api.failure.v1.Failure
	33,  // 94: temporal.api.workflow.v1.NexusOperationCancellationInfo.next_attempt_schedule_time:type_name -> google.protobuf.Timestamp
	17,  // 95: temporal.api.workflow.v1.WorkflowExecutionOptions.versioning_override:type_name -> temporal.api.workflow.v1.VersioningOverride
	39,  // 96: temporal.api.workflow.v1.WorkflowExecutionOptions.priority:type_name -> temporal.api.common.v1.Priority
	28,  // 97: temporal.api.workflow.v1.VersioningOverride.pinned:type_name -> temporal.api.workflow.v1.VersioningOverride.PinnedOverride
	40,  // 98: temporal.api.workflow.v1.VersioningOverride.behavior:type_name -> temporal.api.enums.v1.VersioningBehavior
	41,  // 99: temporal.api.workflow.v1.VersioningOverride.deployment:type_name -> temporal.api.deployment.v1.Deployment
	60,  // 100: temporal.api.workflow.v1.RequestIdInfo.event_type:type_name -> temporal.api.enums.v1.EventType
	29,  // 101: temporal.api.workflow.v1.PostResetOperation.signal_workflow:type_name -> temporal.api.workflow.v1.PostResetOperation.SignalWorkflow
	30,  // 102: temporal.api.workflow.v1.PostResetOperation.update_workflow_options:type_name -> temporal.api.workflow.v1.PostResetOperation.UpdateWorkflowOptions
	33,  // 103: temporal.api.workflow.v1.WorkflowExecutionPauseInfo.paused_time:type_name -> google.protobuf.Timestamp
	19,  // 104: temporal.api.workflow.v1.WorkflowExecutionExtendedInfo.RequestIdInfosEntry.value:type_name -> temporal.api.workflow.v1.RequestIdInfo
	33,  // 105: temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.pause_time:type_name -> google.protobuf.Timestamp
	24,  // 106: temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.manual:type_name -> temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.Manual
	25,  // 107: temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.rule:type_name -> temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.Rule
	26,  // 108: temporal.api.workflow.v1.CallbackInfo.Trigger.workflow_closed:type_name -> temporal.api.workflow.v1.CallbackInfo.WorkflowClosed
	0,   // 109: temporal.api.workflow.v1.VersioningOverride.PinnedOverride.behavior:type_name -> temporal.api.workflow.v1.VersioningOverride.PinnedOverrideBehavior
	42,  // 110: temporal.api.workflow.v1.VersioningOverride.PinnedOverride.version:type_name -> temporal.api.deployment.v1.WorkerDeploymentVersion
	47,  // 111: temporal.api.workflow.v1.PostResetOperation.SignalWorkflow.input:type_name -> temporal.api.common.v1.Payloads
	55,  // 112: temporal.api.workflow.v1.PostResetOperation.SignalWorkflow.header:type_name -> temporal.api.common.v1.Header
	61,  // 113: temporal.api.workflow.v1.PostResetOperation.SignalWorkflow.links:type_name -> temporal.api.common.v1.Link
	16,  // 114: temporal.api.workflow.v1.PostResetOperation.UpdateWorkflowOptions.workflow_execution_options:type_name -> temporal.api.workflow.v1.WorkflowExecutionOptions
	62,  // 115: temporal.api.workflow.v1.PostResetOperation.UpdateWorkflowOptions.update_mask:type_name -> google.protobuf.FieldMask
	116, // [116:116] is the sub-list for method output_type
	116, // [116:116] is the sub-list for method input_type
	116, // [116:116] is the sub-list for extension type_name
	116, // [116:116] is the sub-list for extension extendee
	0,   // [0:116] is the sub-list for field type_name
}

func init() { file_temporal_api_workflow_v1_message_proto_init() }
func file_temporal_api_workflow_v1_message_proto_init() {
	if File_temporal_api_workflow_v1_message_proto != nil {
		return
	}
	file_temporal_api_workflow_v1_message_proto_msgTypes[6].OneofWrappers = []any{
		(*PendingActivityInfo_UseWorkflowBuildId)(nil),
		(*PendingActivityInfo_LastIndependentlyAssignedBuildId)(nil),
	}
	file_temporal_api_workflow_v1_message_proto_msgTypes[16].OneofWrappers = []any{
		(*VersioningOverride_Pinned)(nil),
		(*VersioningOverride_AutoUpgrade)(nil),
	}
	file_temporal_api_workflow_v1_message_proto_msgTypes[19].OneofWrappers = []any{
		(*PostResetOperation_SignalWorkflow_)(nil),
		(*PostResetOperation_UpdateWorkflowOptions_)(nil),
	}
	file_temporal_api_workflow_v1_message_proto_msgTypes[22].OneofWrappers = []any{
		(*PendingActivityInfo_PauseInfo_Manual_)(nil),
		(*PendingActivityInfo_PauseInfo_Rule_)(nil),
	}
	file_temporal_api_workflow_v1_message_proto_msgTypes[26].OneofWrappers = []any{
		(*CallbackInfo_Trigger_WorkflowClosed)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_temporal_api_workflow_v1_message_proto_rawDesc), len(file_temporal_api_workflow_v1_message_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   30,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_temporal_api_workflow_v1_message_proto_goTypes,
		DependencyIndexes: file_temporal_api_workflow_v1_message_proto_depIdxs,
		EnumInfos:         file_temporal_api_workflow_v1_message_proto_enumTypes,
		MessageInfos:      file_temporal_api_workflow_v1_message_proto_msgTypes,
	}.Build()
	File_temporal_api_workflow_v1_message_proto = out.File
	file_temporal_api_workflow_v1_message_proto_goTypes = nil
	file_temporal_api_workflow_v1_message_proto_depIdxs = nil
}
