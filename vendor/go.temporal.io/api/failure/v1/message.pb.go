// Code generated by protoc-gen-go. DO NOT EDIT.
// plugins:
// 	protoc-gen-go
// 	protoc
// source: temporal/api/failure/v1/message.proto

package failure

import (
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"

	v1 "go.temporal.io/api/common/v1"
	v11 "go.temporal.io/api/enums/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type ApplicationFailureInfo struct {
	state        protoimpl.MessageState `protogen:"open.v1"`
	Type         string                 `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	NonRetryable bool                   `protobuf:"varint,2,opt,name=non_retryable,json=nonRetryable,proto3" json:"non_retryable,omitempty"`
	Details      *v1.Payloads           `protobuf:"bytes,3,opt,name=details,proto3" json:"details,omitempty"`
	// next_retry_delay can be used by the client to override the activity
	// retry interval calculated by the retry policy. Retry attempts will
	// still be subject to the maximum retries limit and total time limit
	// defined by the policy.
	NextRetryDelay *durationpb.Duration         `protobuf:"bytes,4,opt,name=next_retry_delay,json=nextRetryDelay,proto3" json:"next_retry_delay,omitempty"`
	Category       v11.ApplicationErrorCategory `protobuf:"varint,5,opt,name=category,proto3,enum=temporal.api.enums.v1.ApplicationErrorCategory" json:"category,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ApplicationFailureInfo) Reset() {
	*x = ApplicationFailureInfo{}
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ApplicationFailureInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApplicationFailureInfo) ProtoMessage() {}

func (x *ApplicationFailureInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ApplicationFailureInfo.ProtoReflect.Descriptor instead.
func (*ApplicationFailureInfo) Descriptor() ([]byte, []int) {
	return file_temporal_api_failure_v1_message_proto_rawDescGZIP(), []int{0}
}

func (x *ApplicationFailureInfo) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *ApplicationFailureInfo) GetNonRetryable() bool {
	if x != nil {
		return x.NonRetryable
	}
	return false
}

func (x *ApplicationFailureInfo) GetDetails() *v1.Payloads {
	if x != nil {
		return x.Details
	}
	return nil
}

func (x *ApplicationFailureInfo) GetNextRetryDelay() *durationpb.Duration {
	if x != nil {
		return x.NextRetryDelay
	}
	return nil
}

func (x *ApplicationFailureInfo) GetCategory() v11.ApplicationErrorCategory {
	if x != nil {
		return x.Category
	}
	return v11.ApplicationErrorCategory(0)
}

type TimeoutFailureInfo struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	TimeoutType          v11.TimeoutType        `protobuf:"varint,1,opt,name=timeout_type,json=timeoutType,proto3,enum=temporal.api.enums.v1.TimeoutType" json:"timeout_type,omitempty"`
	LastHeartbeatDetails *v1.Payloads           `protobuf:"bytes,2,opt,name=last_heartbeat_details,json=lastHeartbeatDetails,proto3" json:"last_heartbeat_details,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *TimeoutFailureInfo) Reset() {
	*x = TimeoutFailureInfo{}
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TimeoutFailureInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TimeoutFailureInfo) ProtoMessage() {}

func (x *TimeoutFailureInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TimeoutFailureInfo.ProtoReflect.Descriptor instead.
func (*TimeoutFailureInfo) Descriptor() ([]byte, []int) {
	return file_temporal_api_failure_v1_message_proto_rawDescGZIP(), []int{1}
}

func (x *TimeoutFailureInfo) GetTimeoutType() v11.TimeoutType {
	if x != nil {
		return x.TimeoutType
	}
	return v11.TimeoutType(0)
}

func (x *TimeoutFailureInfo) GetLastHeartbeatDetails() *v1.Payloads {
	if x != nil {
		return x.LastHeartbeatDetails
	}
	return nil
}

type CanceledFailureInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Details       *v1.Payloads           `protobuf:"bytes,1,opt,name=details,proto3" json:"details,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CanceledFailureInfo) Reset() {
	*x = CanceledFailureInfo{}
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CanceledFailureInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CanceledFailureInfo) ProtoMessage() {}

func (x *CanceledFailureInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CanceledFailureInfo.ProtoReflect.Descriptor instead.
func (*CanceledFailureInfo) Descriptor() ([]byte, []int) {
	return file_temporal_api_failure_v1_message_proto_rawDescGZIP(), []int{2}
}

func (x *CanceledFailureInfo) GetDetails() *v1.Payloads {
	if x != nil {
		return x.Details
	}
	return nil
}

type TerminatedFailureInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TerminatedFailureInfo) Reset() {
	*x = TerminatedFailureInfo{}
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TerminatedFailureInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TerminatedFailureInfo) ProtoMessage() {}

func (x *TerminatedFailureInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TerminatedFailureInfo.ProtoReflect.Descriptor instead.
func (*TerminatedFailureInfo) Descriptor() ([]byte, []int) {
	return file_temporal_api_failure_v1_message_proto_rawDescGZIP(), []int{3}
}

type ServerFailureInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	NonRetryable  bool                   `protobuf:"varint,1,opt,name=non_retryable,json=nonRetryable,proto3" json:"non_retryable,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ServerFailureInfo) Reset() {
	*x = ServerFailureInfo{}
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ServerFailureInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServerFailureInfo) ProtoMessage() {}

func (x *ServerFailureInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ServerFailureInfo.ProtoReflect.Descriptor instead.
func (*ServerFailureInfo) Descriptor() ([]byte, []int) {
	return file_temporal_api_failure_v1_message_proto_rawDescGZIP(), []int{4}
}

func (x *ServerFailureInfo) GetNonRetryable() bool {
	if x != nil {
		return x.NonRetryable
	}
	return false
}

type ResetWorkflowFailureInfo struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	LastHeartbeatDetails *v1.Payloads           `protobuf:"bytes,1,opt,name=last_heartbeat_details,json=lastHeartbeatDetails,proto3" json:"last_heartbeat_details,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *ResetWorkflowFailureInfo) Reset() {
	*x = ResetWorkflowFailureInfo{}
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ResetWorkflowFailureInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ResetWorkflowFailureInfo) ProtoMessage() {}

func (x *ResetWorkflowFailureInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ResetWorkflowFailureInfo.ProtoReflect.Descriptor instead.
func (*ResetWorkflowFailureInfo) Descriptor() ([]byte, []int) {
	return file_temporal_api_failure_v1_message_proto_rawDescGZIP(), []int{5}
}

func (x *ResetWorkflowFailureInfo) GetLastHeartbeatDetails() *v1.Payloads {
	if x != nil {
		return x.LastHeartbeatDetails
	}
	return nil
}

type ActivityFailureInfo struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	ScheduledEventId int64                  `protobuf:"varint,1,opt,name=scheduled_event_id,json=scheduledEventId,proto3" json:"scheduled_event_id,omitempty"`
	StartedEventId   int64                  `protobuf:"varint,2,opt,name=started_event_id,json=startedEventId,proto3" json:"started_event_id,omitempty"`
	Identity         string                 `protobuf:"bytes,3,opt,name=identity,proto3" json:"identity,omitempty"`
	ActivityType     *v1.ActivityType       `protobuf:"bytes,4,opt,name=activity_type,json=activityType,proto3" json:"activity_type,omitempty"`
	ActivityId       string                 `protobuf:"bytes,5,opt,name=activity_id,json=activityId,proto3" json:"activity_id,omitempty"`
	RetryState       v11.RetryState         `protobuf:"varint,6,opt,name=retry_state,json=retryState,proto3,enum=temporal.api.enums.v1.RetryState" json:"retry_state,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *ActivityFailureInfo) Reset() {
	*x = ActivityFailureInfo{}
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ActivityFailureInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ActivityFailureInfo) ProtoMessage() {}

func (x *ActivityFailureInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ActivityFailureInfo.ProtoReflect.Descriptor instead.
func (*ActivityFailureInfo) Descriptor() ([]byte, []int) {
	return file_temporal_api_failure_v1_message_proto_rawDescGZIP(), []int{6}
}

func (x *ActivityFailureInfo) GetScheduledEventId() int64 {
	if x != nil {
		return x.ScheduledEventId
	}
	return 0
}

func (x *ActivityFailureInfo) GetStartedEventId() int64 {
	if x != nil {
		return x.StartedEventId
	}
	return 0
}

func (x *ActivityFailureInfo) GetIdentity() string {
	if x != nil {
		return x.Identity
	}
	return ""
}

func (x *ActivityFailureInfo) GetActivityType() *v1.ActivityType {
	if x != nil {
		return x.ActivityType
	}
	return nil
}

func (x *ActivityFailureInfo) GetActivityId() string {
	if x != nil {
		return x.ActivityId
	}
	return ""
}

func (x *ActivityFailureInfo) GetRetryState() v11.RetryState {
	if x != nil {
		return x.RetryState
	}
	return v11.RetryState(0)
}

type ChildWorkflowExecutionFailureInfo struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	Namespace         string                 `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	WorkflowExecution *v1.WorkflowExecution  `protobuf:"bytes,2,opt,name=workflow_execution,json=workflowExecution,proto3" json:"workflow_execution,omitempty"`
	WorkflowType      *v1.WorkflowType       `protobuf:"bytes,3,opt,name=workflow_type,json=workflowType,proto3" json:"workflow_type,omitempty"`
	InitiatedEventId  int64                  `protobuf:"varint,4,opt,name=initiated_event_id,json=initiatedEventId,proto3" json:"initiated_event_id,omitempty"`
	StartedEventId    int64                  `protobuf:"varint,5,opt,name=started_event_id,json=startedEventId,proto3" json:"started_event_id,omitempty"`
	RetryState        v11.RetryState         `protobuf:"varint,6,opt,name=retry_state,json=retryState,proto3,enum=temporal.api.enums.v1.RetryState" json:"retry_state,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *ChildWorkflowExecutionFailureInfo) Reset() {
	*x = ChildWorkflowExecutionFailureInfo{}
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChildWorkflowExecutionFailureInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChildWorkflowExecutionFailureInfo) ProtoMessage() {}

func (x *ChildWorkflowExecutionFailureInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChildWorkflowExecutionFailureInfo.ProtoReflect.Descriptor instead.
func (*ChildWorkflowExecutionFailureInfo) Descriptor() ([]byte, []int) {
	return file_temporal_api_failure_v1_message_proto_rawDescGZIP(), []int{7}
}

func (x *ChildWorkflowExecutionFailureInfo) GetNamespace() string {
	if x != nil {
		return x.Namespace
	}
	return ""
}

func (x *ChildWorkflowExecutionFailureInfo) GetWorkflowExecution() *v1.WorkflowExecution {
	if x != nil {
		return x.WorkflowExecution
	}
	return nil
}

func (x *ChildWorkflowExecutionFailureInfo) GetWorkflowType() *v1.WorkflowType {
	if x != nil {
		return x.WorkflowType
	}
	return nil
}

func (x *ChildWorkflowExecutionFailureInfo) GetInitiatedEventId() int64 {
	if x != nil {
		return x.InitiatedEventId
	}
	return 0
}

func (x *ChildWorkflowExecutionFailureInfo) GetStartedEventId() int64 {
	if x != nil {
		return x.StartedEventId
	}
	return 0
}

func (x *ChildWorkflowExecutionFailureInfo) GetRetryState() v11.RetryState {
	if x != nil {
		return x.RetryState
	}
	return v11.RetryState(0)
}

type NexusOperationFailureInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The NexusOperationScheduled event ID.
	ScheduledEventId int64 `protobuf:"varint,1,opt,name=scheduled_event_id,json=scheduledEventId,proto3" json:"scheduled_event_id,omitempty"`
	// Endpoint name.
	Endpoint string `protobuf:"bytes,2,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// Service name.
	Service string `protobuf:"bytes,3,opt,name=service,proto3" json:"service,omitempty"`
	// Operation name.
	Operation string `protobuf:"bytes,4,opt,name=operation,proto3" json:"operation,omitempty"`
	// Operation ID - may be empty if the operation completed synchronously.
	//
	// Deprecated: Renamed to operation_token.
	OperationId string `protobuf:"bytes,5,opt,name=operation_id,json=operationId,proto3" json:"operation_id,omitempty"`
	// Operation token - may be empty if the operation completed synchronously.
	OperationToken string `protobuf:"bytes,6,opt,name=operation_token,json=operationToken,proto3" json:"operation_token,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *NexusOperationFailureInfo) Reset() {
	*x = NexusOperationFailureInfo{}
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NexusOperationFailureInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NexusOperationFailureInfo) ProtoMessage() {}

func (x *NexusOperationFailureInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NexusOperationFailureInfo.ProtoReflect.Descriptor instead.
func (*NexusOperationFailureInfo) Descriptor() ([]byte, []int) {
	return file_temporal_api_failure_v1_message_proto_rawDescGZIP(), []int{8}
}

func (x *NexusOperationFailureInfo) GetScheduledEventId() int64 {
	if x != nil {
		return x.ScheduledEventId
	}
	return 0
}

func (x *NexusOperationFailureInfo) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *NexusOperationFailureInfo) GetService() string {
	if x != nil {
		return x.Service
	}
	return ""
}

func (x *NexusOperationFailureInfo) GetOperation() string {
	if x != nil {
		return x.Operation
	}
	return ""
}

func (x *NexusOperationFailureInfo) GetOperationId() string {
	if x != nil {
		return x.OperationId
	}
	return ""
}

func (x *NexusOperationFailureInfo) GetOperationToken() string {
	if x != nil {
		return x.OperationToken
	}
	return ""
}

type NexusHandlerFailureInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The Nexus error type as defined in the spec:
	// https://github.com/nexus-rpc/api/blob/main/SPEC.md#predefined-handler-errors.
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// Retry behavior, defaults to the retry behavior of the error type as defined in the spec.
	RetryBehavior v11.NexusHandlerErrorRetryBehavior `protobuf:"varint,2,opt,name=retry_behavior,json=retryBehavior,proto3,enum=temporal.api.enums.v1.NexusHandlerErrorRetryBehavior" json:"retry_behavior,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NexusHandlerFailureInfo) Reset() {
	*x = NexusHandlerFailureInfo{}
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NexusHandlerFailureInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NexusHandlerFailureInfo) ProtoMessage() {}

func (x *NexusHandlerFailureInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NexusHandlerFailureInfo.ProtoReflect.Descriptor instead.
func (*NexusHandlerFailureInfo) Descriptor() ([]byte, []int) {
	return file_temporal_api_failure_v1_message_proto_rawDescGZIP(), []int{9}
}

func (x *NexusHandlerFailureInfo) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *NexusHandlerFailureInfo) GetRetryBehavior() v11.NexusHandlerErrorRetryBehavior {
	if x != nil {
		return x.RetryBehavior
	}
	return v11.NexusHandlerErrorRetryBehavior(0)
}

type Failure struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	Message string                 `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	// The source this Failure originated in, e.g. TypeScriptSDK / JavaSDK
	// In some SDKs this is used to rehydrate the stack trace into an exception object.
	Source     string `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty"`
	StackTrace string `protobuf:"bytes,3,opt,name=stack_trace,json=stackTrace,proto3" json:"stack_trace,omitempty"`
	// Alternative way to supply `message` and `stack_trace` and possibly other attributes, used for encryption of
	// errors originating in user code which might contain sensitive information.
	// The `encoded_attributes` Payload could represent any serializable object, e.g. JSON object or a `Failure` proto
	// message.
	//
	// SDK authors:
	// - The SDK should provide a default `encodeFailureAttributes` and `decodeFailureAttributes` implementation that:
	//   - Uses a JSON object to represent `{ message, stack_trace }`.
	//   - Overwrites the original message with "Encoded failure" to indicate that more information could be extracted.
	//   - Overwrites the original stack_trace with an empty string.
	//   - The resulting JSON object is converted to Payload using the default PayloadConverter and should be processed
	//     by the user-provided PayloadCodec
	//
	// - If there's demand, we could allow overriding the default SDK implementation to encode other opaque Failure attributes.
	// (-- api-linter: core::0203::optional=disabled --)
	EncodedAttributes *v1.Payload `protobuf:"bytes,20,opt,name=encoded_attributes,json=encodedAttributes,proto3" json:"encoded_attributes,omitempty"`
	Cause             *Failure    `protobuf:"bytes,4,opt,name=cause,proto3" json:"cause,omitempty"`
	// Types that are valid to be assigned to FailureInfo:
	//
	//	*Failure_ApplicationFailureInfo
	//	*Failure_TimeoutFailureInfo
	//	*Failure_CanceledFailureInfo
	//	*Failure_TerminatedFailureInfo
	//	*Failure_ServerFailureInfo
	//	*Failure_ResetWorkflowFailureInfo
	//	*Failure_ActivityFailureInfo
	//	*Failure_ChildWorkflowExecutionFailureInfo
	//	*Failure_NexusOperationExecutionFailureInfo
	//	*Failure_NexusHandlerFailureInfo
	FailureInfo   isFailure_FailureInfo `protobuf_oneof:"failure_info"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Failure) Reset() {
	*x = Failure{}
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Failure) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Failure) ProtoMessage() {}

func (x *Failure) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Failure.ProtoReflect.Descriptor instead.
func (*Failure) Descriptor() ([]byte, []int) {
	return file_temporal_api_failure_v1_message_proto_rawDescGZIP(), []int{10}
}

func (x *Failure) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *Failure) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

func (x *Failure) GetStackTrace() string {
	if x != nil {
		return x.StackTrace
	}
	return ""
}

func (x *Failure) GetEncodedAttributes() *v1.Payload {
	if x != nil {
		return x.EncodedAttributes
	}
	return nil
}

func (x *Failure) GetCause() *Failure {
	if x != nil {
		return x.Cause
	}
	return nil
}

func (x *Failure) GetFailureInfo() isFailure_FailureInfo {
	if x != nil {
		return x.FailureInfo
	}
	return nil
}

func (x *Failure) GetApplicationFailureInfo() *ApplicationFailureInfo {
	if x != nil {
		if x, ok := x.FailureInfo.(*Failure_ApplicationFailureInfo); ok {
			return x.ApplicationFailureInfo
		}
	}
	return nil
}

func (x *Failure) GetTimeoutFailureInfo() *TimeoutFailureInfo {
	if x != nil {
		if x, ok := x.FailureInfo.(*Failure_TimeoutFailureInfo); ok {
			return x.TimeoutFailureInfo
		}
	}
	return nil
}

func (x *Failure) GetCanceledFailureInfo() *CanceledFailureInfo {
	if x != nil {
		if x, ok := x.FailureInfo.(*Failure_CanceledFailureInfo); ok {
			return x.CanceledFailureInfo
		}
	}
	return nil
}

func (x *Failure) GetTerminatedFailureInfo() *TerminatedFailureInfo {
	if x != nil {
		if x, ok := x.FailureInfo.(*Failure_TerminatedFailureInfo); ok {
			return x.TerminatedFailureInfo
		}
	}
	return nil
}

func (x *Failure) GetServerFailureInfo() *ServerFailureInfo {
	if x != nil {
		if x, ok := x.FailureInfo.(*Failure_ServerFailureInfo); ok {
			return x.ServerFailureInfo
		}
	}
	return nil
}

func (x *Failure) GetResetWorkflowFailureInfo() *ResetWorkflowFailureInfo {
	if x != nil {
		if x, ok := x.FailureInfo.(*Failure_ResetWorkflowFailureInfo); ok {
			return x.ResetWorkflowFailureInfo
		}
	}
	return nil
}

func (x *Failure) GetActivityFailureInfo() *ActivityFailureInfo {
	if x != nil {
		if x, ok := x.FailureInfo.(*Failure_ActivityFailureInfo); ok {
			return x.ActivityFailureInfo
		}
	}
	return nil
}

func (x *Failure) GetChildWorkflowExecutionFailureInfo() *ChildWorkflowExecutionFailureInfo {
	if x != nil {
		if x, ok := x.FailureInfo.(*Failure_ChildWorkflowExecutionFailureInfo); ok {
			return x.ChildWorkflowExecutionFailureInfo
		}
	}
	return nil
}

func (x *Failure) GetNexusOperationExecutionFailureInfo() *NexusOperationFailureInfo {
	if x != nil {
		if x, ok := x.FailureInfo.(*Failure_NexusOperationExecutionFailureInfo); ok {
			return x.NexusOperationExecutionFailureInfo
		}
	}
	return nil
}

func (x *Failure) GetNexusHandlerFailureInfo() *NexusHandlerFailureInfo {
	if x != nil {
		if x, ok := x.FailureInfo.(*Failure_NexusHandlerFailureInfo); ok {
			return x.NexusHandlerFailureInfo
		}
	}
	return nil
}

type isFailure_FailureInfo interface {
	isFailure_FailureInfo()
}

type Failure_ApplicationFailureInfo struct {
	ApplicationFailureInfo *ApplicationFailureInfo `protobuf:"bytes,5,opt,name=application_failure_info,json=applicationFailureInfo,proto3,oneof"`
}

type Failure_TimeoutFailureInfo struct {
	TimeoutFailureInfo *TimeoutFailureInfo `protobuf:"bytes,6,opt,name=timeout_failure_info,json=timeoutFailureInfo,proto3,oneof"`
}

type Failure_CanceledFailureInfo struct {
	CanceledFailureInfo *CanceledFailureInfo `protobuf:"bytes,7,opt,name=canceled_failure_info,json=canceledFailureInfo,proto3,oneof"`
}

type Failure_TerminatedFailureInfo struct {
	TerminatedFailureInfo *TerminatedFailureInfo `protobuf:"bytes,8,opt,name=terminated_failure_info,json=terminatedFailureInfo,proto3,oneof"`
}

type Failure_ServerFailureInfo struct {
	ServerFailureInfo *ServerFailureInfo `protobuf:"bytes,9,opt,name=server_failure_info,json=serverFailureInfo,proto3,oneof"`
}

type Failure_ResetWorkflowFailureInfo struct {
	ResetWorkflowFailureInfo *ResetWorkflowFailureInfo `protobuf:"bytes,10,opt,name=reset_workflow_failure_info,json=resetWorkflowFailureInfo,proto3,oneof"`
}

type Failure_ActivityFailureInfo struct {
	ActivityFailureInfo *ActivityFailureInfo `protobuf:"bytes,11,opt,name=activity_failure_info,json=activityFailureInfo,proto3,oneof"`
}

type Failure_ChildWorkflowExecutionFailureInfo struct {
	ChildWorkflowExecutionFailureInfo *ChildWorkflowExecutionFailureInfo `protobuf:"bytes,12,opt,name=child_workflow_execution_failure_info,json=childWorkflowExecutionFailureInfo,proto3,oneof"`
}

type Failure_NexusOperationExecutionFailureInfo struct {
	NexusOperationExecutionFailureInfo *NexusOperationFailureInfo `protobuf:"bytes,13,opt,name=nexus_operation_execution_failure_info,json=nexusOperationExecutionFailureInfo,proto3,oneof"`
}

type Failure_NexusHandlerFailureInfo struct {
	NexusHandlerFailureInfo *NexusHandlerFailureInfo `protobuf:"bytes,14,opt,name=nexus_handler_failure_info,json=nexusHandlerFailureInfo,proto3,oneof"`
}

func (*Failure_ApplicationFailureInfo) isFailure_FailureInfo() {}

func (*Failure_TimeoutFailureInfo) isFailure_FailureInfo() {}

func (*Failure_CanceledFailureInfo) isFailure_FailureInfo() {}

func (*Failure_TerminatedFailureInfo) isFailure_FailureInfo() {}

func (*Failure_ServerFailureInfo) isFailure_FailureInfo() {}

func (*Failure_ResetWorkflowFailureInfo) isFailure_FailureInfo() {}

func (*Failure_ActivityFailureInfo) isFailure_FailureInfo() {}

func (*Failure_ChildWorkflowExecutionFailureInfo) isFailure_FailureInfo() {}

func (*Failure_NexusOperationExecutionFailureInfo) isFailure_FailureInfo() {}

func (*Failure_NexusHandlerFailureInfo) isFailure_FailureInfo() {}

type MultiOperationExecutionAborted struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MultiOperationExecutionAborted) Reset() {
	*x = MultiOperationExecutionAborted{}
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MultiOperationExecutionAborted) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MultiOperationExecutionAborted) ProtoMessage() {}

func (x *MultiOperationExecutionAborted) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MultiOperationExecutionAborted.ProtoReflect.Descriptor instead.
func (*MultiOperationExecutionAborted) Descriptor() ([]byte, []int) {
	return file_temporal_api_failure_v1_message_proto_rawDescGZIP(), []int{11}
}

var File_temporal_api_failure_v1_message_proto protoreflect.FileDescriptor

const file_temporal_api_failure_v1_message_proto_rawDesc = "" +
	"\n" +
	"%temporal/api/failure/v1/message.proto\x12\x17temporal.api.failure.v1\x1a$temporal/api/common/v1/message.proto\x1a$temporal/api/enums/v1/workflow.proto\x1a!temporal/api/enums/v1/nexus.proto\x1a\"temporal/api/enums/v1/common.proto\x1a\x1egoogle/protobuf/duration.proto\"\x9f\x02\n" +
	"\x16ApplicationFailureInfo\x12\x12\n" +
	"\x04type\x18\x01 \x01(\tR\x04type\x12#\n" +
	"\rnon_retryable\x18\x02 \x01(\bR\fnonRetryable\x12:\n" +
	"\adetails\x18\x03 \x01(\v2 .temporal.api.common.v1.PayloadsR\adetails\x12C\n" +
	"\x10next_retry_delay\x18\x04 \x01(\v2\x19.google.protobuf.DurationR\x0enextRetryDelay\x12K\n" +
	"\bcategory\x18\x05 \x01(\x0e2/.temporal.api.enums.v1.ApplicationErrorCategoryR\bcategory\"\xb3\x01\n" +
	"\x12TimeoutFailureInfo\x12E\n" +
	"\ftimeout_type\x18\x01 \x01(\x0e2\".temporal.api.enums.v1.TimeoutTypeR\vtimeoutType\x12V\n" +
	"\x16last_heartbeat_details\x18\x02 \x01(\v2 .temporal.api.common.v1.PayloadsR\x14lastHeartbeatDetails\"Q\n" +
	"\x13CanceledFailureInfo\x12:\n" +
	"\adetails\x18\x01 \x01(\v2 .temporal.api.common.v1.PayloadsR\adetails\"\x17\n" +
	"\x15TerminatedFailureInfo\"8\n" +
	"\x11ServerFailureInfo\x12#\n" +
	"\rnon_retryable\x18\x01 \x01(\bR\fnonRetryable\"r\n" +
	"\x18ResetWorkflowFailureInfo\x12V\n" +
	"\x16last_heartbeat_details\x18\x01 \x01(\v2 .temporal.api.common.v1.PayloadsR\x14lastHeartbeatDetails\"\xb9\x02\n" +
	"\x13ActivityFailureInfo\x12,\n" +
	"\x12scheduled_event_id\x18\x01 \x01(\x03R\x10scheduledEventId\x12(\n" +
	"\x10started_event_id\x18\x02 \x01(\x03R\x0estartedEventId\x12\x1a\n" +
	"\bidentity\x18\x03 \x01(\tR\bidentity\x12I\n" +
	"\ractivity_type\x18\x04 \x01(\v2$.temporal.api.common.v1.ActivityTypeR\factivityType\x12\x1f\n" +
	"\vactivity_id\x18\x05 \x01(\tR\n" +
	"activityId\x12B\n" +
	"\vretry_state\x18\x06 \x01(\x0e2!.temporal.api.enums.v1.RetryStateR\n" +
	"retryState\"\x82\x03\n" +
	"!ChildWorkflowExecutionFailureInfo\x12\x1c\n" +
	"\tnamespace\x18\x01 \x01(\tR\tnamespace\x12X\n" +
	"\x12workflow_execution\x18\x02 \x01(\v2).temporal.api.common.v1.WorkflowExecutionR\x11workflowExecution\x12I\n" +
	"\rworkflow_type\x18\x03 \x01(\v2$.temporal.api.common.v1.WorkflowTypeR\fworkflowType\x12,\n" +
	"\x12initiated_event_id\x18\x04 \x01(\x03R\x10initiatedEventId\x12(\n" +
	"\x10started_event_id\x18\x05 \x01(\x03R\x0estartedEventId\x12B\n" +
	"\vretry_state\x18\x06 \x01(\x0e2!.temporal.api.enums.v1.RetryStateR\n" +
	"retryState\"\xe9\x01\n" +
	"\x19NexusOperationFailureInfo\x12,\n" +
	"\x12scheduled_event_id\x18\x01 \x01(\x03R\x10scheduledEventId\x12\x1a\n" +
	"\bendpoint\x18\x02 \x01(\tR\bendpoint\x12\x18\n" +
	"\aservice\x18\x03 \x01(\tR\aservice\x12\x1c\n" +
	"\toperation\x18\x04 \x01(\tR\toperation\x12!\n" +
	"\foperation_id\x18\x05 \x01(\tR\voperationId\x12'\n" +
	"\x0foperation_token\x18\x06 \x01(\tR\x0eoperationToken\"\x8b\x01\n" +
	"\x17NexusHandlerFailureInfo\x12\x12\n" +
	"\x04type\x18\x01 \x01(\tR\x04type\x12\\\n" +
	"\x0eretry_behavior\x18\x02 \x01(\x0e25.temporal.api.enums.v1.NexusHandlerErrorRetryBehaviorR\rretryBehavior\"\xd3\n" +
	"\n" +
	"\aFailure\x12\x18\n" +
	"\amessage\x18\x01 \x01(\tR\amessage\x12\x16\n" +
	"\x06source\x18\x02 \x01(\tR\x06source\x12\x1f\n" +
	"\vstack_trace\x18\x03 \x01(\tR\n" +
	"stackTrace\x12N\n" +
	"\x12encoded_attributes\x18\x14 \x01(\v2\x1f.temporal.api.common.v1.PayloadR\x11encodedAttributes\x126\n" +
	"\x05cause\x18\x04 \x01(\v2 .temporal.api.failure.v1.FailureR\x05cause\x12k\n" +
	"\x18application_failure_info\x18\x05 \x01(\v2/.temporal.api.failure.v1.ApplicationFailureInfoH\x00R\x16applicationFailureInfo\x12_\n" +
	"\x14timeout_failure_info\x18\x06 \x01(\v2+.temporal.api.failure.v1.TimeoutFailureInfoH\x00R\x12timeoutFailureInfo\x12b\n" +
	"\x15canceled_failure_info\x18\a \x01(\v2,.temporal.api.failure.v1.CanceledFailureInfoH\x00R\x13canceledFailureInfo\x12h\n" +
	"\x17terminated_failure_info\x18\b \x01(\v2..temporal.api.failure.v1.TerminatedFailureInfoH\x00R\x15terminatedFailureInfo\x12\\\n" +
	"\x13server_failure_info\x18\t \x01(\v2*.temporal.api.failure.v1.ServerFailureInfoH\x00R\x11serverFailureInfo\x12r\n" +
	"\x1breset_workflow_failure_info\x18\n" +
	" \x01(\v21.temporal.api.failure.v1.ResetWorkflowFailureInfoH\x00R\x18resetWorkflowFailureInfo\x12b\n" +
	"\x15activity_failure_info\x18\v \x01(\v2,.temporal.api.failure.v1.ActivityFailureInfoH\x00R\x13activityFailureInfo\x12\x8e\x01\n" +
	"%child_workflow_execution_failure_info\x18\f \x01(\v2:.temporal.api.failure.v1.ChildWorkflowExecutionFailureInfoH\x00R!childWorkflowExecutionFailureInfo\x12\x88\x01\n" +
	"&nexus_operation_execution_failure_info\x18\r \x01(\v22.temporal.api.failure.v1.NexusOperationFailureInfoH\x00R\"nexusOperationExecutionFailureInfo\x12o\n" +
	"\x1anexus_handler_failure_info\x18\x0e \x01(\v20.temporal.api.failure.v1.NexusHandlerFailureInfoH\x00R\x17nexusHandlerFailureInfoB\x0e\n" +
	"\ffailure_info\" \n" +
	"\x1eMultiOperationExecutionAbortedB\x8e\x01\n" +
	"\x1aio.temporal.api.failure.v1B\fMessageProtoP\x01Z%go.temporal.io/api/failure/v1;failure\xaa\x02\x19Temporalio.Api.Failure.V1\xea\x02\x1cTemporalio::Api::Failure::V1b\x06proto3"

var (
	file_temporal_api_failure_v1_message_proto_rawDescOnce sync.Once
	file_temporal_api_failure_v1_message_proto_rawDescData []byte
)

func file_temporal_api_failure_v1_message_proto_rawDescGZIP() []byte {
	file_temporal_api_failure_v1_message_proto_rawDescOnce.Do(func() {
		file_temporal_api_failure_v1_message_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_temporal_api_failure_v1_message_proto_rawDesc), len(file_temporal_api_failure_v1_message_proto_rawDesc)))
	})
	return file_temporal_api_failure_v1_message_proto_rawDescData
}

var file_temporal_api_failure_v1_message_proto_msgTypes = make([]protoimpl.MessageInfo, 12)
var file_temporal_api_failure_v1_message_proto_goTypes = []any{
	(*ApplicationFailureInfo)(nil),            // 0: temporal.api.failure.v1.ApplicationFailureInfo
	(*TimeoutFailureInfo)(nil),                // 1: temporal.api.failure.v1.TimeoutFailureInfo
	(*CanceledFailureInfo)(nil),               // 2: temporal.api.failure.v1.CanceledFailureInfo
	(*TerminatedFailureInfo)(nil),             // 3: temporal.api.failure.v1.TerminatedFailureInfo
	(*ServerFailureInfo)(nil),                 // 4: temporal.api.failure.v1.ServerFailureInfo
	(*ResetWorkflowFailureInfo)(nil),          // 5: temporal.api.failure.v1.ResetWorkflowFailureInfo
	(*ActivityFailureInfo)(nil),               // 6: temporal.api.failure.v1.ActivityFailureInfo
	(*ChildWorkflowExecutionFailureInfo)(nil), // 7: temporal.api.failure.v1.ChildWorkflowExecutionFailureInfo
	(*NexusOperationFailureInfo)(nil),         // 8: temporal.api.failure.v1.NexusOperationFailureInfo
	(*NexusHandlerFailureInfo)(nil),           // 9: temporal.api.failure.v1.NexusHandlerFailureInfo
	(*Failure)(nil),                           // 10: temporal.api.failure.v1.Failure
	(*MultiOperationExecutionAborted)(nil),    // 11: temporal.api.failure.v1.MultiOperationExecutionAborted
	(*v1.Payloads)(nil),                       // 12: temporal.api.common.v1.Payloads
	(*durationpb.Duration)(nil),               // 13: google.protobuf.Duration
	(v11.ApplicationErrorCategory)(0),         // 14: temporal.api.enums.v1.ApplicationErrorCategory
	(v11.TimeoutType)(0),                      // 15: temporal.api.enums.v1.TimeoutType
	(*v1.ActivityType)(nil),                   // 16: temporal.api.common.v1.ActivityType
	(v11.RetryState)(0),                       // 17: temporal.api.enums.v1.RetryState
	(*v1.WorkflowExecution)(nil),              // 18: temporal.api.common.v1.WorkflowExecution
	(*v1.WorkflowType)(nil),                   // 19: temporal.api.common.v1.WorkflowType
	(v11.NexusHandlerErrorRetryBehavior)(0),   // 20: temporal.api.enums.v1.NexusHandlerErrorRetryBehavior
	(*v1.Payload)(nil),                        // 21: temporal.api.common.v1.Payload
}
var file_temporal_api_failure_v1_message_proto_depIdxs = []int32{
	12, // 0: temporal.api.failure.v1.ApplicationFailureInfo.details:type_name -> temporal.api.common.v1.Payloads
	13, // 1: temporal.api.failure.v1.ApplicationFailureInfo.next_retry_delay:type_name -> google.protobuf.Duration
	14, // 2: temporal.api.failure.v1.ApplicationFailureInfo.category:type_name -> temporal.api.enums.v1.ApplicationErrorCategory
	15, // 3: temporal.api.failure.v1.TimeoutFailureInfo.timeout_type:type_name -> temporal.api.enums.v1.TimeoutType
	12, // 4: temporal.api.failure.v1.TimeoutFailureInfo.last_heartbeat_details:type_name -> temporal.api.common.v1.Payloads
	12, // 5: temporal.api.failure.v1.CanceledFailureInfo.details:type_name -> temporal.api.common.v1.Payloads
	12, // 6: temporal.api.failure.v1.ResetWorkflowFailureInfo.last_heartbeat_details:type_name -> temporal.api.common.v1.Payloads
	16, // 7: temporal.api.failure.v1.ActivityFailureInfo.activity_type:type_name -> temporal.api.common.v1.ActivityType
	17, // 8: temporal.api.failure.v1.ActivityFailureInfo.retry_state:type_name -> temporal.api.enums.v1.RetryState
	18, // 9: temporal.api.failure.v1.ChildWorkflowExecutionFailureInfo.workflow_execution:type_name -> temporal.api.common.v1.WorkflowExecution
	19, // 10: temporal.api.failure.v1.ChildWorkflowExecutionFailureInfo.workflow_type:type_name -> temporal.api.common.v1.WorkflowType
	17, // 11: temporal.api.failure.v1.ChildWorkflowExecutionFailureInfo.retry_state:type_name -> temporal.api.enums.v1.RetryState
	20, // 12: temporal.api.failure.v1.NexusHandlerFailureInfo.retry_behavior:type_name -> temporal.api.enums.v1.NexusHandlerErrorRetryBehavior
	21, // 13: temporal.api.failure.v1.Failure.encoded_attributes:type_name -> temporal.api.common.v1.Payload
	10, // 14: temporal.api.failure.v1.Failure.cause:type_name -> temporal.api.failure.v1.Failure
	0,  // 15: temporal.api.failure.v1.Failure.application_failure_info:type_name -> temporal.api.failure.v1.ApplicationFailureInfo
	1,  // 16: temporal.api.failure.v1.Failure.timeout_failure_info:type_name -> temporal.api.failure.v1.TimeoutFailureInfo
	2,  // 17: temporal.api.failure.v1.Failure.canceled_failure_info:type_name -> temporal.api.failure.v1.CanceledFailureInfo
	3,  // 18: temporal.api.failure.v1.Failure.terminated_failure_info:type_name -> temporal.api.failure.v1.TerminatedFailureInfo
	4,  // 19: temporal.api.failure.v1.Failure.server_failure_info:type_name -> temporal.api.failure.v1.ServerFailureInfo
	5,  // 20: temporal.api.failure.v1.Failure.reset_workflow_failure_info:type_name -> temporal.api.failure.v1.ResetWorkflowFailureInfo
	6,  // 21: temporal.api.failure.v1.Failure.activity_failure_info:type_name -> temporal.api.failure.v1.ActivityFailureInfo
	7,  // 22: temporal.api.failure.v1.Failure.child_workflow_execution_failure_info:type_name -> temporal.api.failure.v1.ChildWorkflowExecutionFailureInfo
	8,  // 23: temporal.api.failure.v1.Failure.nexus_operation_execution_failure_info:type_name -> temporal.api.failure.v1.NexusOperationFailureInfo
	9,  // 24: temporal.api.failure.v1.Failure.nexus_handler_failure_info:type_name -> temporal.api.failure.v1.NexusHandlerFailureInfo
	25, // [25:25] is the sub-list for method output_type
	25, // [25:25] is the sub-list for method input_type
	25, // [25:25] is the sub-list for extension type_name
	25, // [25:25] is the sub-list for extension extendee
	0,  // [0:25] is the sub-list for field type_name
}

func init() { file_temporal_api_failure_v1_message_proto_init() }
func file_temporal_api_failure_v1_message_proto_init() {
	if File_temporal_api_failure_v1_message_proto != nil {
		return
	}
	file_temporal_api_failure_v1_message_proto_msgTypes[10].OneofWrappers = []any{
		(*Failure_ApplicationFailureInfo)(nil),
		(*Failure_TimeoutFailureInfo)(nil),
		(*Failure_CanceledFailureInfo)(nil),
		(*Failure_TerminatedFailureInfo)(nil),
		(*Failure_ServerFailureInfo)(nil),
		(*Failure_ResetWorkflowFailureInfo)(nil),
		(*Failure_ActivityFailureInfo)(nil),
		(*Failure_ChildWorkflowExecutionFailureInfo)(nil),
		(*Failure_NexusOperationExecutionFailureInfo)(nil),
		(*Failure_NexusHandlerFailureInfo)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_temporal_api_failure_v1_message_proto_rawDesc), len(file_temporal_api_failure_v1_message_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   12,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_temporal_api_failure_v1_message_proto_goTypes,
		DependencyIndexes: file_temporal_api_failure_v1_message_proto_depIdxs,
		MessageInfos:      file_temporal_api_failure_v1_message_proto_msgTypes,
	}.Build()
	File_temporal_api_failure_v1_message_proto = out.File
	file_temporal_api_failure_v1_message_proto_goTypes = nil
	file_temporal_api_failure_v1_message_proto_depIdxs = nil
}
