// Code generated by protoc-gen-go-helpers. DO NOT EDIT.
package enums

import (
	"fmt"
)

var (
	TaskQueueKind_shorthandValue = map[string]int32{
		"Unspecified": 0,
		"Normal":      1,
		"Sticky":      2,
	}
)

// TaskQueueKindFromString parses a TaskQueueKind value from  either the protojson
// canonical SCREAMING_CASE enum or the traditional temporal PascalCase enum to TaskQueueKind
func TaskQueueKindFromString(s string) (TaskQueueKind, error) {
	if v, ok := TaskQueueKind_value[s]; ok {
		return TaskQueueKind(v), nil
	} else if v, ok := TaskQueueKind_shorthandValue[s]; ok {
		return TaskQueueKind(v), nil
	}
	return TaskQueueKind(0), fmt.Errorf("%s is not a valid TaskQueueKind", s)
}

var (
	TaskQueueType_shorthandValue = map[string]int32{
		"Unspecified": 0,
		"Workflow":    1,
		"Activity":    2,
		"Nexus":       3,
	}
)

// TaskQueueTypeFromString parses a TaskQueueType value from  either the protojson
// canonical SCREAMING_CASE enum or the traditional temporal PascalCase enum to TaskQueueType
func TaskQueueTypeFromString(s string) (TaskQueueType, error) {
	if v, ok := TaskQueueType_value[s]; ok {
		return TaskQueueType(v), nil
	} else if v, ok := TaskQueueType_shorthandValue[s]; ok {
		return TaskQueueType(v), nil
	}
	return TaskQueueType(0), fmt.Errorf("%s is not a valid TaskQueueType", s)
}

var (
	TaskReachability_shorthandValue = map[string]int32{
		"Unspecified":       0,
		"NewWorkflows":      1,
		"ExistingWorkflows": 2,
		"OpenWorkflows":     3,
		"ClosedWorkflows":   4,
	}
)

// TaskReachabilityFromString parses a TaskReachability value from  either the protojson
// canonical SCREAMING_CASE enum or the traditional temporal PascalCase enum to TaskReachability
func TaskReachabilityFromString(s string) (TaskReachability, error) {
	if v, ok := TaskReachability_value[s]; ok {
		return TaskReachability(v), nil
	} else if v, ok := TaskReachability_shorthandValue[s]; ok {
		return TaskReachability(v), nil
	}
	return TaskReachability(0), fmt.Errorf("%s is not a valid TaskReachability", s)
}

var (
	BuildIdTaskReachability_shorthandValue = map[string]int32{
		"Unspecified":         0,
		"Reachable":           1,
		"ClosedWorkflowsOnly": 2,
		"Unreachable":         3,
	}
)

// BuildIdTaskReachabilityFromString parses a BuildIdTaskReachability value from  either the protojson
// canonical SCREAMING_CASE enum or the traditional temporal PascalCase enum to BuildIdTaskReachability
func BuildIdTaskReachabilityFromString(s string) (BuildIdTaskReachability, error) {
	if v, ok := BuildIdTaskReachability_value[s]; ok {
		return BuildIdTaskReachability(v), nil
	} else if v, ok := BuildIdTaskReachability_shorthandValue[s]; ok {
		return BuildIdTaskReachability(v), nil
	}
	return BuildIdTaskReachability(0), fmt.Errorf("%s is not a valid BuildIdTaskReachability", s)
}

var (
	DescribeTaskQueueMode_shorthandValue = map[string]int32{
		"Unspecified": 0,
		"Enhanced":    1,
	}
)

// DescribeTaskQueueModeFromString parses a DescribeTaskQueueMode value from  either the protojson
// canonical SCREAMING_CASE enum or the traditional temporal PascalCase enum to DescribeTaskQueueMode
func DescribeTaskQueueModeFromString(s string) (DescribeTaskQueueMode, error) {
	if v, ok := DescribeTaskQueueMode_value[s]; ok {
		return DescribeTaskQueueMode(v), nil
	} else if v, ok := DescribeTaskQueueMode_shorthandValue[s]; ok {
		return DescribeTaskQueueMode(v), nil
	}
	return DescribeTaskQueueMode(0), fmt.Errorf("%s is not a valid DescribeTaskQueueMode", s)
}

var (
	RateLimitSource_shorthandValue = map[string]int32{
		"Unspecified": 0,
		"Api":         1,
		"Worker":      2,
		"System":      3,
	}
)

// RateLimitSourceFromString parses a RateLimitSource value from  either the protojson
// canonical SCREAMING_CASE enum or the traditional temporal PascalCase enum to RateLimitSource
func RateLimitSourceFromString(s string) (RateLimitSource, error) {
	if v, ok := RateLimitSource_value[s]; ok {
		return RateLimitSource(v), nil
	} else if v, ok := RateLimitSource_shorthandValue[s]; ok {
		return RateLimitSource(v), nil
	}
	return RateLimitSource(0), fmt.Errorf("%s is not a valid RateLimitSource", s)
}

var (
	RoutingConfigUpdateState_shorthandValue = map[string]int32{
		"Unspecified": 0,
		"InProgress":  1,
		"Completed":   2,
	}
)

// RoutingConfigUpdateStateFromString parses a RoutingConfigUpdateState value from  either the protojson
// canonical SCREAMING_CASE enum or the traditional temporal PascalCase enum to RoutingConfigUpdateState
func RoutingConfigUpdateStateFromString(s string) (RoutingConfigUpdateState, error) {
	if v, ok := RoutingConfigUpdateState_value[s]; ok {
		return RoutingConfigUpdateState(v), nil
	} else if v, ok := RoutingConfigUpdateState_shorthandValue[s]; ok {
		return RoutingConfigUpdateState(v), nil
	}
	return RoutingConfigUpdateState(0), fmt.Errorf("%s is not a valid RoutingConfigUpdateState", s)
}
