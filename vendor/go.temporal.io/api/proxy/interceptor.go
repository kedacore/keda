// The MIT License
//
// Copyright (c) 2022 Temporal Technologies Inc.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Code generated by proxygenerator; DO NOT EDIT.

package proxy

import (
	"context"
	"fmt"

	"github.com/gogo/protobuf/proto"
	"go.temporal.io/api/batch/v1"
	"go.temporal.io/api/command/v1"
	"go.temporal.io/api/common/v1"
	"go.temporal.io/api/failure/v1"
	"go.temporal.io/api/history/v1"
	"go.temporal.io/api/query/v1"
	"go.temporal.io/api/schedule/v1"
	"go.temporal.io/api/update/v1"
	"go.temporal.io/api/workflow/v1"
	"go.temporal.io/api/workflowservice/v1"
	"google.golang.org/grpc"
)

// VisitPayloadsContext provides Payload context for visitor functions.
type VisitPayloadsContext struct {
	context.Context
	// The parent message for this payload.
	Parent proto.Message
	// If true, a single payload is given and a single payload must be returned.
	SinglePayloadRequired bool
}

// VisitPayloadsOptions configure visitor behaviour.
type VisitPayloadsOptions struct {
	// Context is the same for every call of a visit, callers should not store it. This must never
	// return an empty set of payloads.
	Visitor func(*VisitPayloadsContext, []*common.Payload) ([]*common.Payload, error)
	// Don't visit search attribute payloads.
	SkipSearchAttributes bool
}

// VisitPayloads calls the options.Visitor function for every Payload proto within msg.
func VisitPayloads(ctx context.Context, msg proto.Message, options VisitPayloadsOptions) error {
	visitCtx := VisitPayloadsContext{Context: ctx, Parent: msg}

	return visitPayloads(&visitCtx, &options, msg)
}

// PayloadVisitorInterceptorOptions configures outbound/inbound interception of Payloads within msgs.
type PayloadVisitorInterceptorOptions struct {
	// Visit options for outbound messages
	Outbound *VisitPayloadsOptions
	// Visit options for inbound messages
	Inbound *VisitPayloadsOptions
}

// NewPayloadVisitorInterceptor creates a new gRPC interceptor for workflowservice messages.
func NewPayloadVisitorInterceptor(options PayloadVisitorInterceptorOptions) (grpc.UnaryClientInterceptor, error) {
	return func(ctx context.Context, method string, req, response interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {
		if reqMsg, ok := req.(proto.Message); ok && options.Outbound != nil {
			err := VisitPayloads(ctx, reqMsg, *options.Outbound)
			if err != nil {
				return err
			}
		}

		err := invoker(ctx, method, req, response, cc, opts...)
		if err != nil {
			return err
		}

		if resMsg, ok := response.(proto.Message); ok && options.Inbound != nil {
			return VisitPayloads(ctx, resMsg, *options.Inbound)
		}

		return nil
	}, nil
}

// VisitFailuresContext provides Failure context for visitor functions.
type VisitFailuresContext struct {
	context.Context
	// The parent message for this failure.
	Parent proto.Message
}

// VisitFailuresOptions configure visitor behaviour.
type VisitFailuresOptions struct {
	// Context is the same for every call of a visit, callers should not store it.
	// Visitor is free to mutate the passed failure struct.
	Visitor func(*VisitFailuresContext, *failure.Failure) error
}

// VisitFailures calls the options.Visitor function for every Failure proto within msg.
func VisitFailures(ctx context.Context, msg proto.Message, options VisitFailuresOptions) error {
	visitCtx := VisitFailuresContext{Context: ctx, Parent: msg}

	return visitFailures(&visitCtx, &options, msg)
}

// FailureVisitorInterceptorOptions configures outbound/inbound interception of Failures within msgs.
type FailureVisitorInterceptorOptions struct {
	// Visit options for outbound messages
	Outbound *VisitFailuresOptions
	// Visit options for inbound messages
	Inbound *VisitFailuresOptions
}

// NewFailureVisitorInterceptor creates a new gRPC interceptor for workflowservice messages.
func NewFailureVisitorInterceptor(options FailureVisitorInterceptorOptions) (grpc.UnaryClientInterceptor, error) {
	return func(ctx context.Context, method string, req, response interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {
		if reqMsg, ok := req.(proto.Message); ok && options.Outbound != nil {
			err := VisitFailures(ctx, reqMsg, *options.Outbound)
			if err != nil {
				return err
			}
		}

		err := invoker(ctx, method, req, response, cc, opts...)
		if err != nil {
			return err
		}

		if resMsg, ok := response.(proto.Message); ok && options.Inbound != nil {
			return VisitFailures(ctx, resMsg, *options.Inbound)
		}

		return nil
	}, nil
}

func visitPayload(ctx *VisitPayloadsContext, options *VisitPayloadsOptions, msg *common.Payload) error {
	ctx.SinglePayloadRequired = true

	newPayloads, err := options.Visitor(ctx, []*common.Payload{msg})
	if err != nil {
		return err
	}

	if len(newPayloads) != 1 {
		return fmt.Errorf("visitor func must return 1 payload when SinglePayloadRequired = true")
	}

	*msg = *newPayloads[0]

	return nil
}

func visitPayloads(ctx *VisitPayloadsContext, options *VisitPayloadsOptions, objs ...interface{}) error {
	for _, obj := range objs {
		ctx.SinglePayloadRequired = false

		switch o := obj.(type) {
		case *common.Payload:
			if o == nil {
				continue
			}
			err := visitPayload(ctx, options, o)
			if err != nil {
				return err
			}
		case map[string]*common.Payload:
			for _, x := range o {
				if err := visitPayload(ctx, options, x); err != nil {
					return err
				}
			}
		case *common.Payloads:
			if o == nil {
				continue
			}
			newPayloads, err := options.Visitor(ctx, o.Payloads)
			if err != nil {
				return err
			}
			o.Payloads = newPayloads
		case map[string]*common.Payloads:
			for _, x := range o {
				if err := visitPayloads(ctx, options, x); err != nil {
					return err
				}
			}

		case *batch.BatchOperationSignal:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetHeader(),
				o.GetInput(),
			); err != nil {
				return err
			}

		case *batch.BatchOperationTermination:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case *command.CancelWorkflowExecutionCommandAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case []*command.Command:
			for _, x := range o {
				if err := visitPayloads(ctx, options, x); err != nil {
					return err
				}
			}

		case *command.Command:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetCancelWorkflowExecutionCommandAttributes(),
				o.GetCompleteWorkflowExecutionCommandAttributes(),
				o.GetContinueAsNewWorkflowExecutionCommandAttributes(),
				o.GetFailWorkflowExecutionCommandAttributes(),
				o.GetModifyWorkflowPropertiesCommandAttributes(),
				o.GetRecordMarkerCommandAttributes(),
				o.GetScheduleActivityTaskCommandAttributes(),
				o.GetSignalExternalWorkflowExecutionCommandAttributes(),
				o.GetStartChildWorkflowExecutionCommandAttributes(),
				o.GetUpsertWorkflowSearchAttributesCommandAttributes(),
			); err != nil {
				return err
			}

		case *command.CompleteWorkflowExecutionCommandAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetResult(),
			); err != nil {
				return err
			}

		case *command.ContinueAsNewWorkflowExecutionCommandAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetFailure(),
				o.GetHeader(),
				o.GetInput(),
				o.GetLastCompletionResult(),
				o.GetMemo(),
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *command.FailWorkflowExecutionCommandAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *command.ModifyWorkflowPropertiesCommandAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetUpsertedMemo(),
			); err != nil {
				return err
			}

		case *command.RecordMarkerCommandAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetDetails(),
				o.GetFailure(),
				o.GetHeader(),
			); err != nil {
				return err
			}

		case *command.ScheduleActivityTaskCommandAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetHeader(),
				o.GetInput(),
			); err != nil {
				return err
			}

		case *command.SignalExternalWorkflowExecutionCommandAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetHeader(),
				o.GetInput(),
			); err != nil {
				return err
			}

		case *command.StartChildWorkflowExecutionCommandAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetHeader(),
				o.GetInput(),
				o.GetMemo(),
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *command.UpsertWorkflowSearchAttributesCommandAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *common.Header:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetFields(),
			); err != nil {
				return err
			}

		case *common.Memo:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetFields(),
			); err != nil {
				return err
			}

		case *common.SearchAttributes:

			if options.SkipSearchAttributes {
				continue
			}

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetIndexedFields(),
			); err != nil {
				return err
			}

		case *failure.ApplicationFailureInfo:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case *failure.CanceledFailureInfo:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case []*failure.Failure:
			for _, x := range o {
				if err := visitPayloads(ctx, options, x); err != nil {
					return err
				}
			}

		case *failure.Failure:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetApplicationFailureInfo(),
				o.GetCanceledFailureInfo(),
				o.GetCause(),
				o.GetEncodedAttributes(),
				o.GetResetWorkflowFailureInfo(),
				o.GetTimeoutFailureInfo(),
			); err != nil {
				return err
			}

		case *failure.ResetWorkflowFailureInfo:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetLastHeartbeatDetails(),
			); err != nil {
				return err
			}

		case *failure.TimeoutFailureInfo:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetLastHeartbeatDetails(),
			); err != nil {
				return err
			}

		case *history.ActivityTaskCanceledEventAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case *history.ActivityTaskCompletedEventAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetResult(),
			); err != nil {
				return err
			}

		case *history.ActivityTaskFailedEventAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *history.ActivityTaskScheduledEventAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetHeader(),
				o.GetInput(),
			); err != nil {
				return err
			}

		case *history.ActivityTaskStartedEventAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetLastFailure(),
			); err != nil {
				return err
			}

		case *history.ActivityTaskTimedOutEventAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *history.ChildWorkflowExecutionCanceledEventAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case *history.ChildWorkflowExecutionCompletedEventAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetResult(),
			); err != nil {
				return err
			}

		case *history.ChildWorkflowExecutionFailedEventAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *history.ChildWorkflowExecutionStartedEventAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetHeader(),
			); err != nil {
				return err
			}

		case *history.History:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetEvents(),
			); err != nil {
				return err
			}

		case []*history.HistoryEvent:
			for _, x := range o {
				if err := visitPayloads(ctx, options, x); err != nil {
					return err
				}
			}

		case *history.HistoryEvent:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetActivityTaskCanceledEventAttributes(),
				o.GetActivityTaskCompletedEventAttributes(),
				o.GetActivityTaskFailedEventAttributes(),
				o.GetActivityTaskScheduledEventAttributes(),
				o.GetActivityTaskStartedEventAttributes(),
				o.GetActivityTaskTimedOutEventAttributes(),
				o.GetChildWorkflowExecutionCanceledEventAttributes(),
				o.GetChildWorkflowExecutionCompletedEventAttributes(),
				o.GetChildWorkflowExecutionFailedEventAttributes(),
				o.GetChildWorkflowExecutionStartedEventAttributes(),
				o.GetMarkerRecordedEventAttributes(),
				o.GetSignalExternalWorkflowExecutionInitiatedEventAttributes(),
				o.GetStartChildWorkflowExecutionInitiatedEventAttributes(),
				o.GetUpsertWorkflowSearchAttributesEventAttributes(),
				o.GetWorkflowExecutionCanceledEventAttributes(),
				o.GetWorkflowExecutionCompletedEventAttributes(),
				o.GetWorkflowExecutionContinuedAsNewEventAttributes(),
				o.GetWorkflowExecutionFailedEventAttributes(),
				o.GetWorkflowExecutionSignaledEventAttributes(),
				o.GetWorkflowExecutionStartedEventAttributes(),
				o.GetWorkflowExecutionTerminatedEventAttributes(),
				o.GetWorkflowExecutionUpdateAcceptedEventAttributes(),
				o.GetWorkflowExecutionUpdateCompletedEventAttributes(),
				o.GetWorkflowExecutionUpdateRejectedEventAttributes(),
				o.GetWorkflowPropertiesModifiedEventAttributes(),
				o.GetWorkflowPropertiesModifiedExternallyEventAttributes(),
				o.GetWorkflowTaskFailedEventAttributes(),
			); err != nil {
				return err
			}

		case *history.MarkerRecordedEventAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetDetails(),
				o.GetFailure(),
				o.GetHeader(),
			); err != nil {
				return err
			}

		case *history.SignalExternalWorkflowExecutionInitiatedEventAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetHeader(),
				o.GetInput(),
			); err != nil {
				return err
			}

		case *history.StartChildWorkflowExecutionInitiatedEventAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetHeader(),
				o.GetInput(),
				o.GetMemo(),
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *history.UpsertWorkflowSearchAttributesEventAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *history.WorkflowExecutionCanceledEventAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case *history.WorkflowExecutionCompletedEventAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetResult(),
			); err != nil {
				return err
			}

		case *history.WorkflowExecutionContinuedAsNewEventAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetFailure(),
				o.GetHeader(),
				o.GetInput(),
				o.GetLastCompletionResult(),
				o.GetMemo(),
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *history.WorkflowExecutionFailedEventAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *history.WorkflowExecutionSignaledEventAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetHeader(),
				o.GetInput(),
			); err != nil {
				return err
			}

		case *history.WorkflowExecutionStartedEventAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetContinuedFailure(),
				o.GetHeader(),
				o.GetInput(),
				o.GetLastCompletionResult(),
				o.GetMemo(),
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *history.WorkflowExecutionTerminatedEventAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case *history.WorkflowExecutionUpdateAcceptedEventAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetAcceptedRequest(),
			); err != nil {
				return err
			}

		case *history.WorkflowExecutionUpdateCompletedEventAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetOutcome(),
			); err != nil {
				return err
			}

		case *history.WorkflowExecutionUpdateRejectedEventAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetFailure(),
				o.GetRejectedRequest(),
			); err != nil {
				return err
			}

		case *history.WorkflowPropertiesModifiedEventAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetUpsertedMemo(),
			); err != nil {
				return err
			}

		case *history.WorkflowPropertiesModifiedExternallyEventAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetUpsertedMemo(),
			); err != nil {
				return err
			}

		case *history.WorkflowTaskFailedEventAttributes:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case map[string]*query.WorkflowQuery:
			for _, x := range o {
				if err := visitPayloads(ctx, options, x); err != nil {
					return err
				}
			}

		case *query.WorkflowQuery:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetHeader(),
				o.GetQueryArgs(),
			); err != nil {
				return err
			}

		case map[string]*query.WorkflowQueryResult:
			for _, x := range o {
				if err := visitPayloads(ctx, options, x); err != nil {
					return err
				}
			}

		case *query.WorkflowQueryResult:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetAnswer(),
			); err != nil {
				return err
			}

		case *schedule.Schedule:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetAction(),
			); err != nil {
				return err
			}

		case *schedule.ScheduleAction:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetStartWorkflow(),
			); err != nil {
				return err
			}

		case []*schedule.ScheduleListEntry:
			for _, x := range o {
				if err := visitPayloads(ctx, options, x); err != nil {
					return err
				}
			}

		case *schedule.ScheduleListEntry:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetMemo(),
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *update.Input:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetArgs(),
				o.GetHeader(),
			); err != nil {
				return err
			}

		case *update.Outcome:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetFailure(),
				o.GetSuccess(),
			); err != nil {
				return err
			}

		case *update.Request:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetInput(),
			); err != nil {
				return err
			}

		case *workflow.NewWorkflowExecutionInfo:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetHeader(),
				o.GetInput(),
				o.GetMemo(),
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case []*workflow.PendingActivityInfo:
			for _, x := range o {
				if err := visitPayloads(ctx, options, x); err != nil {
					return err
				}
			}

		case *workflow.PendingActivityInfo:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetHeartbeatDetails(),
				o.GetLastFailure(),
			); err != nil {
				return err
			}

		case []*workflow.WorkflowExecutionInfo:
			for _, x := range o {
				if err := visitPayloads(ctx, options, x); err != nil {
					return err
				}
			}

		case *workflow.WorkflowExecutionInfo:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetMemo(),
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *workflowservice.CreateScheduleRequest:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetMemo(),
				o.GetSchedule(),
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *workflowservice.DescribeScheduleResponse:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetMemo(),
				o.GetSchedule(),
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *workflowservice.DescribeWorkflowExecutionResponse:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetPendingActivities(),
				o.GetWorkflowExecutionInfo(),
			); err != nil {
				return err
			}

		case *workflowservice.GetWorkflowExecutionHistoryResponse:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetHistory(),
			); err != nil {
				return err
			}

		case *workflowservice.GetWorkflowExecutionHistoryReverseResponse:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetHistory(),
			); err != nil {
				return err
			}

		case *workflowservice.ListArchivedWorkflowExecutionsResponse:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetExecutions(),
			); err != nil {
				return err
			}

		case *workflowservice.ListClosedWorkflowExecutionsResponse:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetExecutions(),
			); err != nil {
				return err
			}

		case *workflowservice.ListOpenWorkflowExecutionsResponse:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetExecutions(),
			); err != nil {
				return err
			}

		case *workflowservice.ListSchedulesResponse:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetSchedules(),
			); err != nil {
				return err
			}

		case *workflowservice.ListWorkflowExecutionsResponse:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetExecutions(),
			); err != nil {
				return err
			}

		case []*workflowservice.PollActivityTaskQueueResponse:
			for _, x := range o {
				if err := visitPayloads(ctx, options, x); err != nil {
					return err
				}
			}

		case *workflowservice.PollActivityTaskQueueResponse:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetHeader(),
				o.GetHeartbeatDetails(),
				o.GetInput(),
			); err != nil {
				return err
			}

		case *workflowservice.PollWorkflowExecutionUpdateResponse:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetOutcome(),
			); err != nil {
				return err
			}

		case *workflowservice.PollWorkflowTaskQueueResponse:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetHistory(),
				o.GetQueries(),
				o.GetQuery(),
			); err != nil {
				return err
			}

		case *workflowservice.QueryWorkflowRequest:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetQuery(),
			); err != nil {
				return err
			}

		case *workflowservice.QueryWorkflowResponse:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetQueryResult(),
			); err != nil {
				return err
			}

		case *workflowservice.RecordActivityTaskHeartbeatByIdRequest:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case *workflowservice.RecordActivityTaskHeartbeatRequest:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondActivityTaskCanceledByIdRequest:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondActivityTaskCanceledRequest:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondActivityTaskCompletedByIdRequest:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetResult(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondActivityTaskCompletedRequest:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetResult(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondActivityTaskFailedByIdRequest:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetFailure(),
				o.GetLastHeartbeatDetails(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondActivityTaskFailedByIdResponse:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetFailures(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondActivityTaskFailedRequest:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetFailure(),
				o.GetLastHeartbeatDetails(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondActivityTaskFailedResponse:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetFailures(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondQueryTaskCompletedRequest:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetQueryResult(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondWorkflowTaskCompletedRequest:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetCommands(),
				o.GetQueryResults(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondWorkflowTaskCompletedResponse:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetActivityTasks(),
				o.GetWorkflowTask(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondWorkflowTaskFailedRequest:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *workflowservice.ScanWorkflowExecutionsResponse:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetExecutions(),
			); err != nil {
				return err
			}

		case *workflowservice.SignalWithStartWorkflowExecutionRequest:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetHeader(),
				o.GetInput(),
				o.GetMemo(),
				o.GetSearchAttributes(),
				o.GetSignalInput(),
			); err != nil {
				return err
			}

		case *workflowservice.SignalWorkflowExecutionRequest:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetHeader(),
				o.GetInput(),
			); err != nil {
				return err
			}

		case *workflowservice.StartBatchOperationRequest:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetSignalOperation(),
				o.GetTerminationOperation(),
			); err != nil {
				return err
			}

		case *workflowservice.StartWorkflowExecutionRequest:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetContinuedFailure(),
				o.GetHeader(),
				o.GetInput(),
				o.GetLastCompletionResult(),
				o.GetMemo(),
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *workflowservice.StartWorkflowExecutionResponse:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetEagerWorkflowTask(),
			); err != nil {
				return err
			}

		case *workflowservice.TerminateWorkflowExecutionRequest:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case *workflowservice.UpdateScheduleRequest:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetSchedule(),
			); err != nil {
				return err
			}

		case *workflowservice.UpdateWorkflowExecutionRequest:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetRequest(),
			); err != nil {
				return err
			}

		case *workflowservice.UpdateWorkflowExecutionResponse:

			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetOutcome(),
			); err != nil {
				return err
			}

		}
	}

	return nil
}

func visitFailures(ctx *VisitFailuresContext, options *VisitFailuresOptions, objs ...interface{}) error {
	for _, obj := range objs {
		switch o := obj.(type) {
		case *failure.Failure:
			if o == nil {
				continue
			}
			if err := options.Visitor(ctx, o); err != nil {
				return err
			}
			if err := visitFailures(ctx, options, o.GetCause()); err != nil {
				return err
			}

		case []*command.Command:
			for _, x := range o {
				if err := visitFailures(ctx, options, x); err != nil {
					return err
				}
			}

		case *command.Command:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetContinueAsNewWorkflowExecutionCommandAttributes(),
				o.GetFailWorkflowExecutionCommandAttributes(),
				o.GetRecordMarkerCommandAttributes(),
			); err != nil {
				return err
			}

		case *command.ContinueAsNewWorkflowExecutionCommandAttributes:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *command.FailWorkflowExecutionCommandAttributes:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *command.RecordMarkerCommandAttributes:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *history.ActivityTaskFailedEventAttributes:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *history.ActivityTaskStartedEventAttributes:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetLastFailure(),
			); err != nil {
				return err
			}

		case *history.ActivityTaskTimedOutEventAttributes:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *history.ChildWorkflowExecutionFailedEventAttributes:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *history.History:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetEvents(),
			); err != nil {
				return err
			}

		case []*history.HistoryEvent:
			for _, x := range o {
				if err := visitFailures(ctx, options, x); err != nil {
					return err
				}
			}

		case *history.HistoryEvent:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetActivityTaskFailedEventAttributes(),
				o.GetActivityTaskStartedEventAttributes(),
				o.GetActivityTaskTimedOutEventAttributes(),
				o.GetChildWorkflowExecutionFailedEventAttributes(),
				o.GetMarkerRecordedEventAttributes(),
				o.GetWorkflowExecutionContinuedAsNewEventAttributes(),
				o.GetWorkflowExecutionFailedEventAttributes(),
				o.GetWorkflowExecutionStartedEventAttributes(),
				o.GetWorkflowExecutionUpdateCompletedEventAttributes(),
				o.GetWorkflowExecutionUpdateRejectedEventAttributes(),
				o.GetWorkflowTaskFailedEventAttributes(),
			); err != nil {
				return err
			}

		case *history.MarkerRecordedEventAttributes:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *history.WorkflowExecutionContinuedAsNewEventAttributes:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *history.WorkflowExecutionFailedEventAttributes:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *history.WorkflowExecutionStartedEventAttributes:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetContinuedFailure(),
			); err != nil {
				return err
			}

		case *history.WorkflowExecutionUpdateCompletedEventAttributes:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetOutcome(),
			); err != nil {
				return err
			}

		case *history.WorkflowExecutionUpdateRejectedEventAttributes:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *history.WorkflowTaskFailedEventAttributes:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *update.Outcome:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case []*workflow.PendingActivityInfo:
			for _, x := range o {
				if err := visitFailures(ctx, options, x); err != nil {
					return err
				}
			}

		case *workflow.PendingActivityInfo:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetLastFailure(),
			); err != nil {
				return err
			}

		case *workflowservice.DescribeWorkflowExecutionResponse:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetPendingActivities(),
			); err != nil {
				return err
			}

		case *workflowservice.GetWorkflowExecutionHistoryResponse:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetHistory(),
			); err != nil {
				return err
			}

		case *workflowservice.GetWorkflowExecutionHistoryReverseResponse:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetHistory(),
			); err != nil {
				return err
			}

		case *workflowservice.PollWorkflowExecutionUpdateResponse:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetOutcome(),
			); err != nil {
				return err
			}

		case *workflowservice.PollWorkflowTaskQueueResponse:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetHistory(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondActivityTaskFailedByIdRequest:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondActivityTaskFailedByIdResponse:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailures(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondActivityTaskFailedRequest:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondActivityTaskFailedResponse:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailures(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondWorkflowTaskCompletedRequest:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetCommands(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondWorkflowTaskCompletedResponse:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetWorkflowTask(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondWorkflowTaskFailedRequest:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *workflowservice.StartWorkflowExecutionRequest:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetContinuedFailure(),
			); err != nil {
				return err
			}

		case *workflowservice.StartWorkflowExecutionResponse:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetEagerWorkflowTask(),
			); err != nil {
				return err
			}

		case *workflowservice.UpdateWorkflowExecutionResponse:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetOutcome(),
			); err != nil {
				return err
			}

		}
	}

	return nil
}
