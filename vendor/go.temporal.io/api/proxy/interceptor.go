// The MIT License
//
// Copyright (c) 2022 Temporal Technologies Inc.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Code generated by proxygenerator; DO NOT EDIT.

package proxy

import (
	"context"
	"fmt"

	"go.temporal.io/api/batch/v1"
	"go.temporal.io/api/command/v1"
	"go.temporal.io/api/common/v1"
	"go.temporal.io/api/deployment/v1"
	"go.temporal.io/api/export/v1"
	"go.temporal.io/api/failure/v1"
	"go.temporal.io/api/history/v1"
	"go.temporal.io/api/nexus/v1"
	"go.temporal.io/api/operatorservice/v1"
	"go.temporal.io/api/protocol/v1"
	"go.temporal.io/api/query/v1"
	"go.temporal.io/api/schedule/v1"
	"go.temporal.io/api/sdk/v1"
	"go.temporal.io/api/update/v1"
	"go.temporal.io/api/workflow/v1"
	"go.temporal.io/api/workflowservice/v1"
	"google.golang.org/grpc"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/known/anypb"
)

// VisitPayloadsContext provides Payload context for visitor functions.
type VisitPayloadsContext struct {
	context.Context
	// The parent message for this payload.
	Parent proto.Message
	// If true, a single payload is given and a single payload must be returned.
	SinglePayloadRequired bool
}

// VisitPayloadsOptions configure visitor behaviour.
type VisitPayloadsOptions struct {
	// Context is the same for every call of a visit, callers should not store it. This must never
	// return an empty set of payloads.
	Visitor func(*VisitPayloadsContext, []*common.Payload) ([]*common.Payload, error)
	// Don't visit search attribute payloads.
	SkipSearchAttributes bool
	// Will be called for each Any encountered. If not set, the default is to recurse into the Any
	// object, unmarshal it, visit, and re-marshal it always (even if there are no changes).
	WellKnownAnyVisitor func(*VisitPayloadsContext, *anypb.Any) error
}

// VisitPayloads calls the options.Visitor function for every Payload proto within msg.
func VisitPayloads(ctx context.Context, msg proto.Message, options VisitPayloadsOptions) error {
	visitCtx := VisitPayloadsContext{Context: ctx, Parent: msg}

	return visitPayloads(&visitCtx, &options, nil, msg)
}

// PayloadVisitorInterceptorOptions configures outbound/inbound interception of Payloads within msgs.
type PayloadVisitorInterceptorOptions struct {
	// Visit options for outbound messages
	Outbound *VisitPayloadsOptions
	// Visit options for inbound messages
	Inbound *VisitPayloadsOptions
}

// NewPayloadVisitorInterceptor creates a new gRPC interceptor for workflowservice messages.
func NewPayloadVisitorInterceptor(options PayloadVisitorInterceptorOptions) (grpc.UnaryClientInterceptor, error) {
	return func(ctx context.Context, method string, req, response interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {
		if reqMsg, ok := req.(proto.Message); ok && options.Outbound != nil {
			err := VisitPayloads(ctx, reqMsg, *options.Outbound)
			if err != nil {
				return err
			}
		}

		err := invoker(ctx, method, req, response, cc, opts...)
		if err != nil {
			return err
		}

		if resMsg, ok := response.(proto.Message); ok && options.Inbound != nil {
			return VisitPayloads(ctx, resMsg, *options.Inbound)
		}

		return nil
	}, nil
}

// VisitFailuresContext provides Failure context for visitor functions.
type VisitFailuresContext struct {
	context.Context
	// The parent message for this failure.
	Parent proto.Message
}

// VisitFailuresOptions configure visitor behaviour.
type VisitFailuresOptions struct {
	// Context is the same for every call of a visit, callers should not store it.
	// Visitor is free to mutate the passed failure struct.
	Visitor func(*VisitFailuresContext, *failure.Failure) error
}

// VisitFailures calls the options.Visitor function for every Failure proto within msg.
func VisitFailures(ctx context.Context, msg proto.Message, options VisitFailuresOptions) error {
	visitCtx := VisitFailuresContext{Context: ctx, Parent: msg}

	return visitFailures(&visitCtx, &options, msg)
}

// FailureVisitorInterceptorOptions configures outbound/inbound interception of Failures within msgs.
type FailureVisitorInterceptorOptions struct {
	// Visit options for outbound messages
	Outbound *VisitFailuresOptions
	// Visit options for inbound messages
	Inbound *VisitFailuresOptions
}

// NewFailureVisitorInterceptor creates a new gRPC interceptor for workflowservice messages.
func NewFailureVisitorInterceptor(options FailureVisitorInterceptorOptions) (grpc.UnaryClientInterceptor, error) {
	return func(ctx context.Context, method string, req, response interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {
		if reqMsg, ok := req.(proto.Message); ok && options.Outbound != nil {
			err := VisitFailures(ctx, reqMsg, *options.Outbound)
			if err != nil {
				return err
			}
		}

		err := invoker(ctx, method, req, response, cc, opts...)
		if err != nil {
			return err
		}

		if resMsg, ok := response.(proto.Message); ok && options.Inbound != nil {
			return VisitFailures(ctx, resMsg, *options.Inbound)
		}

		return nil
	}, nil
}

func (o *VisitPayloadsOptions) defaultWellKnownAnyVisitor(ctx *VisitPayloadsContext, p *anypb.Any) error {
	child, err := p.UnmarshalNew()
	if err != nil {
		return fmt.Errorf("failed to unmarshal any: %w", err)
	}
	// We choose to visit and re-marshal always instead of cloning, visiting,
	// and checking if anything changed before re-marshaling. It is assumed the
	// clone + equality check is not much cheaper than re-marshal.
	if err := visitPayloads(ctx, o, p, child); err != nil {
		return err
	}
	// Confirmed this replaces both Any fields on non-error, there is nothing
	// left over
	if err := p.MarshalFrom(child); err != nil {
		return fmt.Errorf("failed to marshal any: %w", err)
	}
	return nil
}

func visitPayload(
	ctx *VisitPayloadsContext,
	options *VisitPayloadsOptions,
	parent proto.Message,
	msg *common.Payload,
) (*common.Payload, error) {
	ctx.SinglePayloadRequired, ctx.Parent = true, parent
	newPayloads, err := options.Visitor(ctx, []*common.Payload{msg})
	ctx.SinglePayloadRequired, ctx.Parent = false, nil
	if err != nil {
		return nil, err
	}

	if len(newPayloads) != 1 {
		return nil, fmt.Errorf("visitor func must return 1 payload when SinglePayloadRequired = true")
	}

	return newPayloads[0], nil
}

func visitPayloads(
	ctx *VisitPayloadsContext,
	options *VisitPayloadsOptions,
	parent proto.Message,
	objs ...interface{},
) error {
	for i, obj := range objs {
		ctx.SinglePayloadRequired = false

		switch o := obj.(type) {
		case *common.Payload:
			if o == nil {
				continue
			}
			no, err := visitPayload(ctx, options, parent, o)
			if err != nil {
				return err
			}
			objs[i] = no
		case map[string]*common.Payload:
			for ix, x := range o {
				if nx, err := visitPayload(ctx, options, parent, x); err != nil {
					return err
				} else {
					o[ix] = nx
				}
			}
		case *common.Payloads:
			if o == nil {
				continue
			}
			ctx.Parent = parent
			newPayloads, err := options.Visitor(ctx, o.Payloads)
			ctx.Parent = nil
			if err != nil {
				return err
			}
			o.Payloads = newPayloads
		case map[string]*common.Payloads:
			for _, x := range o {
				if err := visitPayloads(ctx, options, parent, x); err != nil {
					return err
				}
			}
		case *anypb.Any:
			if o == nil {
				continue
			}
			visitor := options.WellKnownAnyVisitor
			if visitor == nil {
				visitor = options.defaultWellKnownAnyVisitor
			}
			ctx.Parent = o
			err := visitor(ctx, o)
			ctx.Parent = nil
			if err != nil {
				return err
			}

		case *batch.BatchOperationSignal:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetHeader(),
				o.GetInput(),
			); err != nil {
				return err
			}

		case *batch.BatchOperationTermination:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case *command.CancelWorkflowExecutionCommandAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case []*command.Command:
			for _, x := range o {
				if err := visitPayloads(ctx, options, parent, x); err != nil {
					return err
				}
			}

		case *command.Command:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetCancelWorkflowExecutionCommandAttributes(),
				o.GetCompleteWorkflowExecutionCommandAttributes(),
				o.GetContinueAsNewWorkflowExecutionCommandAttributes(),
				o.GetFailWorkflowExecutionCommandAttributes(),
				o.GetModifyWorkflowPropertiesCommandAttributes(),
				o.GetRecordMarkerCommandAttributes(),
				o.GetScheduleActivityTaskCommandAttributes(),
				o.GetScheduleNexusOperationCommandAttributes(),
				o.GetSignalExternalWorkflowExecutionCommandAttributes(),
				o.GetStartChildWorkflowExecutionCommandAttributes(),
				o.GetUpsertWorkflowSearchAttributesCommandAttributes(),
				o.GetUserMetadata(),
			); err != nil {
				return err
			}

		case *command.CompleteWorkflowExecutionCommandAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetResult(),
			); err != nil {
				return err
			}

		case *command.ContinueAsNewWorkflowExecutionCommandAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetFailure(),
				o.GetHeader(),
				o.GetInput(),
				o.GetLastCompletionResult(),
				o.GetMemo(),
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *command.FailWorkflowExecutionCommandAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *command.ModifyWorkflowPropertiesCommandAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetUpsertedMemo(),
			); err != nil {
				return err
			}

		case *command.RecordMarkerCommandAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetDetails(),
				o.GetFailure(),
				o.GetHeader(),
			); err != nil {
				return err
			}

		case *command.ScheduleActivityTaskCommandAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetHeader(),
				o.GetInput(),
			); err != nil {
				return err
			}

		case *command.ScheduleNexusOperationCommandAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetInput(),
			); err != nil {
				return err
			}

		case *command.SignalExternalWorkflowExecutionCommandAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetHeader(),
				o.GetInput(),
			); err != nil {
				return err
			}

		case *command.StartChildWorkflowExecutionCommandAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetHeader(),
				o.GetInput(),
				o.GetMemo(),
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *command.UpsertWorkflowSearchAttributesCommandAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *common.Header:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetFields(),
			); err != nil {
				return err
			}

		case *common.Memo:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetFields(),
			); err != nil {
				return err
			}

		case *common.SearchAttributes:

			if options.SkipSearchAttributes {
				continue
			}

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetIndexedFields(),
			); err != nil {
				return err
			}

		case *deployment.DeploymentInfo:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetMetadata(),
			); err != nil {
				return err
			}

		case *deployment.UpdateDeploymentMetadata:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetUpsertEntries(),
			); err != nil {
				return err
			}

		case []*export.WorkflowExecution:
			for _, x := range o {
				if err := visitPayloads(ctx, options, parent, x); err != nil {
					return err
				}
			}

		case *export.WorkflowExecution:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetHistory(),
			); err != nil {
				return err
			}

		case *export.WorkflowExecutions:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetItems(),
			); err != nil {
				return err
			}

		case *failure.ApplicationFailureInfo:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case *failure.CanceledFailureInfo:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case []*failure.Failure:
			for _, x := range o {
				if err := visitPayloads(ctx, options, parent, x); err != nil {
					return err
				}
			}

		case *failure.Failure:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetApplicationFailureInfo(),
				o.GetCanceledFailureInfo(),
				o.GetCause(),
				o.GetEncodedAttributes(),
				o.GetResetWorkflowFailureInfo(),
				o.GetTimeoutFailureInfo(),
			); err != nil {
				return err
			}

		case *failure.ResetWorkflowFailureInfo:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetLastHeartbeatDetails(),
			); err != nil {
				return err
			}

		case *failure.TimeoutFailureInfo:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetLastHeartbeatDetails(),
			); err != nil {
				return err
			}

		case *history.ActivityTaskCanceledEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case *history.ActivityTaskCompletedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetResult(),
			); err != nil {
				return err
			}

		case *history.ActivityTaskFailedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *history.ActivityTaskScheduledEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetHeader(),
				o.GetInput(),
			); err != nil {
				return err
			}

		case *history.ActivityTaskStartedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetLastFailure(),
			); err != nil {
				return err
			}

		case *history.ActivityTaskTimedOutEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *history.ChildWorkflowExecutionCanceledEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case *history.ChildWorkflowExecutionCompletedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetResult(),
			); err != nil {
				return err
			}

		case *history.ChildWorkflowExecutionFailedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *history.ChildWorkflowExecutionStartedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetHeader(),
			); err != nil {
				return err
			}

		case *history.History:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetEvents(),
			); err != nil {
				return err
			}

		case []*history.HistoryEvent:
			for _, x := range o {
				if err := visitPayloads(ctx, options, parent, x); err != nil {
					return err
				}
			}

		case *history.HistoryEvent:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetActivityTaskCanceledEventAttributes(),
				o.GetActivityTaskCompletedEventAttributes(),
				o.GetActivityTaskFailedEventAttributes(),
				o.GetActivityTaskScheduledEventAttributes(),
				o.GetActivityTaskStartedEventAttributes(),
				o.GetActivityTaskTimedOutEventAttributes(),
				o.GetChildWorkflowExecutionCanceledEventAttributes(),
				o.GetChildWorkflowExecutionCompletedEventAttributes(),
				o.GetChildWorkflowExecutionFailedEventAttributes(),
				o.GetChildWorkflowExecutionStartedEventAttributes(),
				o.GetMarkerRecordedEventAttributes(),
				o.GetNexusOperationCanceledEventAttributes(),
				o.GetNexusOperationCompletedEventAttributes(),
				o.GetNexusOperationFailedEventAttributes(),
				o.GetNexusOperationScheduledEventAttributes(),
				o.GetNexusOperationTimedOutEventAttributes(),
				o.GetSignalExternalWorkflowExecutionInitiatedEventAttributes(),
				o.GetStartChildWorkflowExecutionInitiatedEventAttributes(),
				o.GetUpsertWorkflowSearchAttributesEventAttributes(),
				o.GetUserMetadata(),
				o.GetWorkflowExecutionCanceledEventAttributes(),
				o.GetWorkflowExecutionCompletedEventAttributes(),
				o.GetWorkflowExecutionContinuedAsNewEventAttributes(),
				o.GetWorkflowExecutionFailedEventAttributes(),
				o.GetWorkflowExecutionSignaledEventAttributes(),
				o.GetWorkflowExecutionStartedEventAttributes(),
				o.GetWorkflowExecutionTerminatedEventAttributes(),
				o.GetWorkflowExecutionUpdateAcceptedEventAttributes(),
				o.GetWorkflowExecutionUpdateAdmittedEventAttributes(),
				o.GetWorkflowExecutionUpdateCompletedEventAttributes(),
				o.GetWorkflowExecutionUpdateRejectedEventAttributes(),
				o.GetWorkflowPropertiesModifiedEventAttributes(),
				o.GetWorkflowPropertiesModifiedExternallyEventAttributes(),
				o.GetWorkflowTaskFailedEventAttributes(),
			); err != nil {
				return err
			}

		case *history.MarkerRecordedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetDetails(),
				o.GetFailure(),
				o.GetHeader(),
			); err != nil {
				return err
			}

		case *history.NexusOperationCanceledEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *history.NexusOperationCompletedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetResult(),
			); err != nil {
				return err
			}

		case *history.NexusOperationFailedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *history.NexusOperationScheduledEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetInput(),
			); err != nil {
				return err
			}

		case *history.NexusOperationTimedOutEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *history.SignalExternalWorkflowExecutionInitiatedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetHeader(),
				o.GetInput(),
			); err != nil {
				return err
			}

		case *history.StartChildWorkflowExecutionInitiatedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetHeader(),
				o.GetInput(),
				o.GetMemo(),
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *history.UpsertWorkflowSearchAttributesEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *history.WorkflowExecutionCanceledEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case *history.WorkflowExecutionCompletedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetResult(),
			); err != nil {
				return err
			}

		case *history.WorkflowExecutionContinuedAsNewEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetFailure(),
				o.GetHeader(),
				o.GetInput(),
				o.GetLastCompletionResult(),
				o.GetMemo(),
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *history.WorkflowExecutionFailedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *history.WorkflowExecutionSignaledEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetHeader(),
				o.GetInput(),
			); err != nil {
				return err
			}

		case *history.WorkflowExecutionStartedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetContinuedFailure(),
				o.GetHeader(),
				o.GetInput(),
				o.GetLastCompletionResult(),
				o.GetMemo(),
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *history.WorkflowExecutionTerminatedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case *history.WorkflowExecutionUpdateAcceptedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetAcceptedRequest(),
			); err != nil {
				return err
			}

		case *history.WorkflowExecutionUpdateAdmittedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetRequest(),
			); err != nil {
				return err
			}

		case *history.WorkflowExecutionUpdateCompletedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetOutcome(),
			); err != nil {
				return err
			}

		case *history.WorkflowExecutionUpdateRejectedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetFailure(),
				o.GetRejectedRequest(),
			); err != nil {
				return err
			}

		case *history.WorkflowPropertiesModifiedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetUpsertedMemo(),
			); err != nil {
				return err
			}

		case *history.WorkflowPropertiesModifiedExternallyEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetUpsertedMemo(),
			); err != nil {
				return err
			}

		case *history.WorkflowTaskFailedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case []*nexus.Endpoint:
			for _, x := range o {
				if err := visitPayloads(ctx, options, parent, x); err != nil {
					return err
				}
			}

		case *nexus.Endpoint:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetSpec(),
			); err != nil {
				return err
			}

		case *nexus.EndpointSpec:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetDescription(),
			); err != nil {
				return err
			}

		case *nexus.Request:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetStartOperation(),
			); err != nil {
				return err
			}

		case *nexus.Response:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetStartOperation(),
			); err != nil {
				return err
			}

		case *nexus.StartOperationRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetPayload(),
			); err != nil {
				return err
			}

		case *nexus.StartOperationResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetSyncSuccess(),
			); err != nil {
				return err
			}

		case *nexus.StartOperationResponse_Sync:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetPayload(),
			); err != nil {
				return err
			}

		case *operatorservice.CreateNexusEndpointRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetSpec(),
			); err != nil {
				return err
			}

		case *operatorservice.CreateNexusEndpointResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetEndpoint(),
			); err != nil {
				return err
			}

		case *operatorservice.GetNexusEndpointResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetEndpoint(),
			); err != nil {
				return err
			}

		case *operatorservice.ListNexusEndpointsResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetEndpoints(),
			); err != nil {
				return err
			}

		case *operatorservice.UpdateNexusEndpointRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetSpec(),
			); err != nil {
				return err
			}

		case *operatorservice.UpdateNexusEndpointResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetEndpoint(),
			); err != nil {
				return err
			}

		case []*protocol.Message:
			for _, x := range o {
				if err := visitPayloads(ctx, options, parent, x); err != nil {
					return err
				}
			}

		case *protocol.Message:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetBody(),
			); err != nil {
				return err
			}

		case map[string]*query.WorkflowQuery:
			for _, x := range o {
				if err := visitPayloads(ctx, options, parent, x); err != nil {
					return err
				}
			}

		case *query.WorkflowQuery:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetHeader(),
				o.GetQueryArgs(),
			); err != nil {
				return err
			}

		case map[string]*query.WorkflowQueryResult:
			for _, x := range o {
				if err := visitPayloads(ctx, options, parent, x); err != nil {
					return err
				}
			}

		case *query.WorkflowQueryResult:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetAnswer(),
			); err != nil {
				return err
			}

		case *schedule.Schedule:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetAction(),
			); err != nil {
				return err
			}

		case *schedule.ScheduleAction:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetStartWorkflow(),
			); err != nil {
				return err
			}

		case []*schedule.ScheduleListEntry:
			for _, x := range o {
				if err := visitPayloads(ctx, options, parent, x); err != nil {
					return err
				}
			}

		case *schedule.ScheduleListEntry:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetMemo(),
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *sdk.UserMetadata:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetDetails(),
				o.GetSummary(),
			); err != nil {
				return err
			}

		case *update.Input:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetArgs(),
				o.GetHeader(),
			); err != nil {
				return err
			}

		case *update.Outcome:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetFailure(),
				o.GetSuccess(),
			); err != nil {
				return err
			}

		case *update.Request:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetInput(),
			); err != nil {
				return err
			}

		case []*workflow.CallbackInfo:
			for _, x := range o {
				if err := visitPayloads(ctx, options, parent, x); err != nil {
					return err
				}
			}

		case *workflow.CallbackInfo:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetLastAttemptFailure(),
			); err != nil {
				return err
			}

		case *workflow.NewWorkflowExecutionInfo:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetHeader(),
				o.GetInput(),
				o.GetMemo(),
				o.GetSearchAttributes(),
				o.GetUserMetadata(),
			); err != nil {
				return err
			}

		case *workflow.NexusOperationCancellationInfo:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetLastAttemptFailure(),
			); err != nil {
				return err
			}

		case []*workflow.PendingActivityInfo:
			for _, x := range o {
				if err := visitPayloads(ctx, options, parent, x); err != nil {
					return err
				}
			}

		case *workflow.PendingActivityInfo:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetHeartbeatDetails(),
				o.GetLastFailure(),
			); err != nil {
				return err
			}

		case []*workflow.PendingNexusOperationInfo:
			for _, x := range o {
				if err := visitPayloads(ctx, options, parent, x); err != nil {
					return err
				}
			}

		case *workflow.PendingNexusOperationInfo:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetCancellationInfo(),
				o.GetLastAttemptFailure(),
			); err != nil {
				return err
			}

		case *workflow.WorkflowExecutionConfig:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetUserMetadata(),
			); err != nil {
				return err
			}

		case []*workflow.WorkflowExecutionInfo:
			for _, x := range o {
				if err := visitPayloads(ctx, options, parent, x); err != nil {
					return err
				}
			}

		case *workflow.WorkflowExecutionInfo:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetMemo(),
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *workflowservice.CountWorkflowExecutionsResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetGroups(),
			); err != nil {
				return err
			}

		case []*workflowservice.CountWorkflowExecutionsResponse_AggregationGroup:
			for _, x := range o {
				if err := visitPayloads(ctx, options, parent, x); err != nil {
					return err
				}
			}

		case *workflowservice.CountWorkflowExecutionsResponse_AggregationGroup:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetGroupValues(),
			); err != nil {
				return err
			}

		case *workflowservice.CreateScheduleRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetMemo(),
				o.GetSchedule(),
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *workflowservice.DescribeDeploymentResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetDeploymentInfo(),
			); err != nil {
				return err
			}

		case *workflowservice.DescribeScheduleResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetMemo(),
				o.GetSchedule(),
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *workflowservice.DescribeWorkflowExecutionResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetCallbacks(),
				o.GetExecutionConfig(),
				o.GetPendingActivities(),
				o.GetPendingNexusOperations(),
				o.GetWorkflowExecutionInfo(),
			); err != nil {
				return err
			}

		case *workflowservice.ExecuteMultiOperationRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetOperations(),
			); err != nil {
				return err
			}

		case []*workflowservice.ExecuteMultiOperationRequest_Operation:
			for _, x := range o {
				if err := visitPayloads(ctx, options, parent, x); err != nil {
					return err
				}
			}

		case *workflowservice.ExecuteMultiOperationRequest_Operation:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetStartWorkflow(),
				o.GetUpdateWorkflow(),
			); err != nil {
				return err
			}

		case *workflowservice.ExecuteMultiOperationResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetResponses(),
			); err != nil {
				return err
			}

		case []*workflowservice.ExecuteMultiOperationResponse_Response:
			for _, x := range o {
				if err := visitPayloads(ctx, options, parent, x); err != nil {
					return err
				}
			}

		case *workflowservice.ExecuteMultiOperationResponse_Response:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetStartWorkflow(),
				o.GetUpdateWorkflow(),
			); err != nil {
				return err
			}

		case *workflowservice.GetCurrentDeploymentResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetCurrentDeploymentInfo(),
			); err != nil {
				return err
			}

		case *workflowservice.GetDeploymentReachabilityResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetDeploymentInfo(),
			); err != nil {
				return err
			}

		case *workflowservice.GetWorkflowExecutionHistoryResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetHistory(),
			); err != nil {
				return err
			}

		case *workflowservice.GetWorkflowExecutionHistoryReverseResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetHistory(),
			); err != nil {
				return err
			}

		case *workflowservice.ListArchivedWorkflowExecutionsResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetExecutions(),
			); err != nil {
				return err
			}

		case *workflowservice.ListClosedWorkflowExecutionsResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetExecutions(),
			); err != nil {
				return err
			}

		case *workflowservice.ListOpenWorkflowExecutionsResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetExecutions(),
			); err != nil {
				return err
			}

		case *workflowservice.ListSchedulesResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetSchedules(),
			); err != nil {
				return err
			}

		case *workflowservice.ListWorkflowExecutionsResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetExecutions(),
			); err != nil {
				return err
			}

		case []*workflowservice.PollActivityTaskQueueResponse:
			for _, x := range o {
				if err := visitPayloads(ctx, options, parent, x); err != nil {
					return err
				}
			}

		case *workflowservice.PollActivityTaskQueueResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetHeader(),
				o.GetHeartbeatDetails(),
				o.GetInput(),
			); err != nil {
				return err
			}

		case *workflowservice.PollNexusTaskQueueResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetRequest(),
			); err != nil {
				return err
			}

		case *workflowservice.PollWorkflowExecutionUpdateResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetOutcome(),
			); err != nil {
				return err
			}

		case *workflowservice.PollWorkflowTaskQueueResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetHistory(),
				o.GetMessages(),
				o.GetQueries(),
				o.GetQuery(),
			); err != nil {
				return err
			}

		case *workflowservice.QueryWorkflowRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetQuery(),
			); err != nil {
				return err
			}

		case *workflowservice.QueryWorkflowResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetQueryResult(),
			); err != nil {
				return err
			}

		case *workflowservice.RecordActivityTaskHeartbeatByIdRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case *workflowservice.RecordActivityTaskHeartbeatRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondActivityTaskCanceledByIdRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondActivityTaskCanceledRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondActivityTaskCompletedByIdRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetResult(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondActivityTaskCompletedRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetResult(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondActivityTaskFailedByIdRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetFailure(),
				o.GetLastHeartbeatDetails(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondActivityTaskFailedByIdResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetFailures(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondActivityTaskFailedRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetFailure(),
				o.GetLastHeartbeatDetails(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondActivityTaskFailedResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetFailures(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondNexusTaskCompletedRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetResponse(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondQueryTaskCompletedRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetQueryResult(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondWorkflowTaskCompletedRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetCommands(),
				o.GetMessages(),
				o.GetQueryResults(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondWorkflowTaskCompletedResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetActivityTasks(),
				o.GetWorkflowTask(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondWorkflowTaskFailedRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetFailure(),
				o.GetMessages(),
			); err != nil {
				return err
			}

		case *workflowservice.ScanWorkflowExecutionsResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetExecutions(),
			); err != nil {
				return err
			}

		case *workflowservice.SetCurrentDeploymentRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetUpdateMetadata(),
			); err != nil {
				return err
			}

		case *workflowservice.SetCurrentDeploymentResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetCurrentDeploymentInfo(),
				o.GetPreviousDeploymentInfo(),
			); err != nil {
				return err
			}

		case *workflowservice.SignalWithStartWorkflowExecutionRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetHeader(),
				o.GetInput(),
				o.GetMemo(),
				o.GetSearchAttributes(),
				o.GetSignalInput(),
				o.GetUserMetadata(),
			); err != nil {
				return err
			}

		case *workflowservice.SignalWorkflowExecutionRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetHeader(),
				o.GetInput(),
			); err != nil {
				return err
			}

		case *workflowservice.StartBatchOperationRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetSignalOperation(),
				o.GetTerminationOperation(),
			); err != nil {
				return err
			}

		case *workflowservice.StartWorkflowExecutionRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetContinuedFailure(),
				o.GetHeader(),
				o.GetInput(),
				o.GetLastCompletionResult(),
				o.GetMemo(),
				o.GetSearchAttributes(),
				o.GetUserMetadata(),
			); err != nil {
				return err
			}

		case *workflowservice.StartWorkflowExecutionResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetEagerWorkflowTask(),
			); err != nil {
				return err
			}

		case *workflowservice.TerminateWorkflowExecutionRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case *workflowservice.UpdateScheduleRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetSchedule(),
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *workflowservice.UpdateWorkflowExecutionRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetRequest(),
			); err != nil {
				return err
			}

		case *workflowservice.UpdateWorkflowExecutionResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetOutcome(),
			); err != nil {
				return err
			}

		}
	}

	return nil
}

func visitFailures(ctx *VisitFailuresContext, options *VisitFailuresOptions, objs ...interface{}) error {
	for _, obj := range objs {
		switch o := obj.(type) {
		case *failure.Failure:
			if o == nil {
				continue
			}
			if err := options.Visitor(ctx, o); err != nil {
				return err
			}
			if err := visitFailures(ctx, options, o.GetCause()); err != nil {
				return err
			}

		case []*command.Command:
			for _, x := range o {
				if err := visitFailures(ctx, options, x); err != nil {
					return err
				}
			}

		case *command.Command:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetContinueAsNewWorkflowExecutionCommandAttributes(),
				o.GetFailWorkflowExecutionCommandAttributes(),
				o.GetRecordMarkerCommandAttributes(),
			); err != nil {
				return err
			}

		case *command.ContinueAsNewWorkflowExecutionCommandAttributes:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *command.FailWorkflowExecutionCommandAttributes:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *command.RecordMarkerCommandAttributes:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case []*export.WorkflowExecution:
			for _, x := range o {
				if err := visitFailures(ctx, options, x); err != nil {
					return err
				}
			}

		case *export.WorkflowExecution:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetHistory(),
			); err != nil {
				return err
			}

		case *export.WorkflowExecutions:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetItems(),
			); err != nil {
				return err
			}

		case *history.ActivityTaskFailedEventAttributes:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *history.ActivityTaskStartedEventAttributes:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetLastFailure(),
			); err != nil {
				return err
			}

		case *history.ActivityTaskTimedOutEventAttributes:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *history.ChildWorkflowExecutionFailedEventAttributes:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *history.History:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetEvents(),
			); err != nil {
				return err
			}

		case []*history.HistoryEvent:
			for _, x := range o {
				if err := visitFailures(ctx, options, x); err != nil {
					return err
				}
			}

		case *history.HistoryEvent:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetActivityTaskFailedEventAttributes(),
				o.GetActivityTaskStartedEventAttributes(),
				o.GetActivityTaskTimedOutEventAttributes(),
				o.GetChildWorkflowExecutionFailedEventAttributes(),
				o.GetMarkerRecordedEventAttributes(),
				o.GetNexusOperationCanceledEventAttributes(),
				o.GetNexusOperationFailedEventAttributes(),
				o.GetNexusOperationTimedOutEventAttributes(),
				o.GetWorkflowExecutionContinuedAsNewEventAttributes(),
				o.GetWorkflowExecutionFailedEventAttributes(),
				o.GetWorkflowExecutionStartedEventAttributes(),
				o.GetWorkflowExecutionUpdateCompletedEventAttributes(),
				o.GetWorkflowExecutionUpdateRejectedEventAttributes(),
				o.GetWorkflowTaskFailedEventAttributes(),
			); err != nil {
				return err
			}

		case *history.MarkerRecordedEventAttributes:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *history.NexusOperationCanceledEventAttributes:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *history.NexusOperationFailedEventAttributes:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *history.NexusOperationTimedOutEventAttributes:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *history.WorkflowExecutionContinuedAsNewEventAttributes:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *history.WorkflowExecutionFailedEventAttributes:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *history.WorkflowExecutionStartedEventAttributes:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetContinuedFailure(),
			); err != nil {
				return err
			}

		case *history.WorkflowExecutionUpdateCompletedEventAttributes:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetOutcome(),
			); err != nil {
				return err
			}

		case *history.WorkflowExecutionUpdateRejectedEventAttributes:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *history.WorkflowTaskFailedEventAttributes:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *update.Outcome:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case []*workflow.CallbackInfo:
			for _, x := range o {
				if err := visitFailures(ctx, options, x); err != nil {
					return err
				}
			}

		case *workflow.CallbackInfo:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetLastAttemptFailure(),
			); err != nil {
				return err
			}

		case *workflow.NexusOperationCancellationInfo:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetLastAttemptFailure(),
			); err != nil {
				return err
			}

		case []*workflow.PendingActivityInfo:
			for _, x := range o {
				if err := visitFailures(ctx, options, x); err != nil {
					return err
				}
			}

		case *workflow.PendingActivityInfo:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetLastFailure(),
			); err != nil {
				return err
			}

		case []*workflow.PendingNexusOperationInfo:
			for _, x := range o {
				if err := visitFailures(ctx, options, x); err != nil {
					return err
				}
			}

		case *workflow.PendingNexusOperationInfo:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetCancellationInfo(),
				o.GetLastAttemptFailure(),
			); err != nil {
				return err
			}

		case *workflowservice.DescribeWorkflowExecutionResponse:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetCallbacks(),
				o.GetPendingActivities(),
				o.GetPendingNexusOperations(),
			); err != nil {
				return err
			}

		case *workflowservice.ExecuteMultiOperationRequest:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetOperations(),
			); err != nil {
				return err
			}

		case []*workflowservice.ExecuteMultiOperationRequest_Operation:
			for _, x := range o {
				if err := visitFailures(ctx, options, x); err != nil {
					return err
				}
			}

		case *workflowservice.ExecuteMultiOperationRequest_Operation:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetStartWorkflow(),
			); err != nil {
				return err
			}

		case *workflowservice.ExecuteMultiOperationResponse:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetResponses(),
			); err != nil {
				return err
			}

		case []*workflowservice.ExecuteMultiOperationResponse_Response:
			for _, x := range o {
				if err := visitFailures(ctx, options, x); err != nil {
					return err
				}
			}

		case *workflowservice.ExecuteMultiOperationResponse_Response:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetStartWorkflow(),
				o.GetUpdateWorkflow(),
			); err != nil {
				return err
			}

		case *workflowservice.GetWorkflowExecutionHistoryResponse:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetHistory(),
			); err != nil {
				return err
			}

		case *workflowservice.GetWorkflowExecutionHistoryReverseResponse:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetHistory(),
			); err != nil {
				return err
			}

		case *workflowservice.PollWorkflowExecutionUpdateResponse:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetOutcome(),
			); err != nil {
				return err
			}

		case *workflowservice.PollWorkflowTaskQueueResponse:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetHistory(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondActivityTaskFailedByIdRequest:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondActivityTaskFailedByIdResponse:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailures(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondActivityTaskFailedRequest:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondActivityTaskFailedResponse:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailures(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondWorkflowTaskCompletedRequest:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetCommands(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondWorkflowTaskCompletedResponse:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetWorkflowTask(),
			); err != nil {
				return err
			}

		case *workflowservice.RespondWorkflowTaskFailedRequest:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *workflowservice.StartWorkflowExecutionRequest:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetContinuedFailure(),
			); err != nil {
				return err
			}

		case *workflowservice.StartWorkflowExecutionResponse:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetEagerWorkflowTask(),
			); err != nil {
				return err
			}

		case *workflowservice.UpdateWorkflowExecutionResponse:
			if o == nil {
				continue
			}
			ctx.Parent = o
			if err := visitFailures(
				ctx,
				options,
				o.GetOutcome(),
			); err != nil {
				return err
			}

		}
	}

	return nil
}
