// The MIT License
//
// Copyright (c) 2020 Temporal Technologies Inc.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// (-- api-linter: core::0203::optional=disabled
//     aip.dev/not-precedent: field_behavior annotation not available in our gogo fork --)
// (-- api-linter: core::0203::input-only=disabled
//     aip.dev/not-precedent: field_behavior annotation not available in our gogo fork --)

// Code generated by protoc-gen-go. DO NOT EDIT.
// plugins:
// 	protoc-gen-go
// 	protoc
// source: temporal/api/schedule/v1/message.proto

package schedule

import (
	reflect "reflect"
	sync "sync"

	v12 "go.temporal.io/api/common/v1"
	v1 "go.temporal.io/api/enums/v1"
	v11 "go.temporal.io/api/workflow/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// CalendarSpec describes an event specification relative to the calendar,
// similar to a traditional cron specification, but with labeled fields. Each
// field can be one of:
//
//	*: matches always
//	x: matches when the field equals x
//	x/y : matches when the field equals x+n*y where n is an integer
//	x-z: matches when the field is between x and z inclusive
//	w,x,y,...: matches when the field is one of the listed values
//
// Each x, y, z, ... is either a decimal integer, or a month or day of week name
// or abbreviation (in the appropriate fields).
// A timestamp matches if all fields match.
// Note that fields have different default values, for convenience.
// Note that the special case that some cron implementations have for treating
// day_of_month and day_of_week as "or" instead of "and" when both are set is
// not implemented.
// day_of_week can accept 0 or 7 as Sunday
// CalendarSpec gets compiled into StructuredCalendarSpec, which is what will be
// returned if you describe the schedule.
type CalendarSpec struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Expression to match seconds. Default: 0
	Second string `protobuf:"bytes,1,opt,name=second,proto3" json:"second,omitempty"`
	// Expression to match minutes. Default: 0
	Minute string `protobuf:"bytes,2,opt,name=minute,proto3" json:"minute,omitempty"`
	// Expression to match hours. Default: 0
	Hour string `protobuf:"bytes,3,opt,name=hour,proto3" json:"hour,omitempty"`
	// Expression to match days of the month. Default: *
	// (-- api-linter: core::0140::prepositions=disabled
	//
	//	aip.dev/not-precedent: standard name of field --)
	DayOfMonth string `protobuf:"bytes,4,opt,name=day_of_month,json=dayOfMonth,proto3" json:"day_of_month,omitempty"`
	// Expression to match months. Default: *
	Month string `protobuf:"bytes,5,opt,name=month,proto3" json:"month,omitempty"`
	// Expression to match years. Default: *
	Year string `protobuf:"bytes,6,opt,name=year,proto3" json:"year,omitempty"`
	// Expression to match days of the week. Default: *
	DayOfWeek string `protobuf:"bytes,7,opt,name=day_of_week,json=dayOfWeek,proto3" json:"day_of_week,omitempty"`
	// Free-form comment describing the intention of this spec.
	Comment string `protobuf:"bytes,8,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (x *CalendarSpec) Reset() {
	*x = CalendarSpec{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CalendarSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CalendarSpec) ProtoMessage() {}

func (x *CalendarSpec) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CalendarSpec.ProtoReflect.Descriptor instead.
func (*CalendarSpec) Descriptor() ([]byte, []int) {
	return file_temporal_api_schedule_v1_message_proto_rawDescGZIP(), []int{0}
}

func (x *CalendarSpec) GetSecond() string {
	if x != nil {
		return x.Second
	}
	return ""
}

func (x *CalendarSpec) GetMinute() string {
	if x != nil {
		return x.Minute
	}
	return ""
}

func (x *CalendarSpec) GetHour() string {
	if x != nil {
		return x.Hour
	}
	return ""
}

func (x *CalendarSpec) GetDayOfMonth() string {
	if x != nil {
		return x.DayOfMonth
	}
	return ""
}

func (x *CalendarSpec) GetMonth() string {
	if x != nil {
		return x.Month
	}
	return ""
}

func (x *CalendarSpec) GetYear() string {
	if x != nil {
		return x.Year
	}
	return ""
}

func (x *CalendarSpec) GetDayOfWeek() string {
	if x != nil {
		return x.DayOfWeek
	}
	return ""
}

func (x *CalendarSpec) GetComment() string {
	if x != nil {
		return x.Comment
	}
	return ""
}

// Range represents a set of integer values, used to match fields of a calendar
// time in StructuredCalendarSpec. If end < start, then end is interpreted as
// equal to start. This means you can use a Range with start set to a value, and
// end and step unset (defaulting to 0) to represent a single value.
type Range struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Start of range (inclusive).
	Start int32 `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	// End of range (inclusive).
	End int32 `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	// Step (optional, default 1).
	Step int32 `protobuf:"varint,3,opt,name=step,proto3" json:"step,omitempty"`
}

func (x *Range) Reset() {
	*x = Range{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Range) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Range) ProtoMessage() {}

func (x *Range) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Range.ProtoReflect.Descriptor instead.
func (*Range) Descriptor() ([]byte, []int) {
	return file_temporal_api_schedule_v1_message_proto_rawDescGZIP(), []int{1}
}

func (x *Range) GetStart() int32 {
	if x != nil {
		return x.Start
	}
	return 0
}

func (x *Range) GetEnd() int32 {
	if x != nil {
		return x.End
	}
	return 0
}

func (x *Range) GetStep() int32 {
	if x != nil {
		return x.Step
	}
	return 0
}

// StructuredCalendarSpec describes an event specification relative to the
// calendar, in a form that's easy to work with programmatically. Each field can
// be one or more ranges.
// A timestamp matches if at least one range of each field matches the
// corresponding fields of the timestamp, except for year: if year is missing,
// that means all years match. For all fields besides year, at least one Range
// must be present to match anything.
// TODO: add relative-to-end-of-month
// TODO: add nth day-of-week in month
type StructuredCalendarSpec struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Match seconds (0-59)
	Second []*Range `protobuf:"bytes,1,rep,name=second,proto3" json:"second,omitempty"`
	// Match minutes (0-59)
	Minute []*Range `protobuf:"bytes,2,rep,name=minute,proto3" json:"minute,omitempty"`
	// Match hours (0-23)
	Hour []*Range `protobuf:"bytes,3,rep,name=hour,proto3" json:"hour,omitempty"`
	// Match days of the month (1-31)
	// (-- api-linter: core::0140::prepositions=disabled
	//
	//	aip.dev/not-precedent: standard name of field --)
	DayOfMonth []*Range `protobuf:"bytes,4,rep,name=day_of_month,json=dayOfMonth,proto3" json:"day_of_month,omitempty"`
	// Match months (1-12)
	Month []*Range `protobuf:"bytes,5,rep,name=month,proto3" json:"month,omitempty"`
	// Match years.
	Year []*Range `protobuf:"bytes,6,rep,name=year,proto3" json:"year,omitempty"`
	// Match days of the week (0-6; 0 is Sunday).
	DayOfWeek []*Range `protobuf:"bytes,7,rep,name=day_of_week,json=dayOfWeek,proto3" json:"day_of_week,omitempty"`
	// Free-form comment describing the intention of this spec.
	Comment string `protobuf:"bytes,8,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (x *StructuredCalendarSpec) Reset() {
	*x = StructuredCalendarSpec{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StructuredCalendarSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StructuredCalendarSpec) ProtoMessage() {}

func (x *StructuredCalendarSpec) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StructuredCalendarSpec.ProtoReflect.Descriptor instead.
func (*StructuredCalendarSpec) Descriptor() ([]byte, []int) {
	return file_temporal_api_schedule_v1_message_proto_rawDescGZIP(), []int{2}
}

func (x *StructuredCalendarSpec) GetSecond() []*Range {
	if x != nil {
		return x.Second
	}
	return nil
}

func (x *StructuredCalendarSpec) GetMinute() []*Range {
	if x != nil {
		return x.Minute
	}
	return nil
}

func (x *StructuredCalendarSpec) GetHour() []*Range {
	if x != nil {
		return x.Hour
	}
	return nil
}

func (x *StructuredCalendarSpec) GetDayOfMonth() []*Range {
	if x != nil {
		return x.DayOfMonth
	}
	return nil
}

func (x *StructuredCalendarSpec) GetMonth() []*Range {
	if x != nil {
		return x.Month
	}
	return nil
}

func (x *StructuredCalendarSpec) GetYear() []*Range {
	if x != nil {
		return x.Year
	}
	return nil
}

func (x *StructuredCalendarSpec) GetDayOfWeek() []*Range {
	if x != nil {
		return x.DayOfWeek
	}
	return nil
}

func (x *StructuredCalendarSpec) GetComment() string {
	if x != nil {
		return x.Comment
	}
	return ""
}

// IntervalSpec matches times that can be expressed as:
// epoch + n * interval + phase
// where n is an integer.
// phase defaults to zero if missing. interval is required.
// Both interval and phase must be non-negative and are truncated to the nearest
// second before any calculations.
// For example, an interval of 1 hour with phase of zero would match every hour,
// on the hour. The same interval but a phase of 19 minutes would match every
// xx:19:00. An interval of 28 days with phase zero would match
// 2022-02-17T00:00:00Z (among other times). The same interval with a phase of 3
// days, 5 hours, and 23 minutes would match 2022-02-20T05:23:00Z instead.
type IntervalSpec struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Interval *durationpb.Duration `protobuf:"bytes,1,opt,name=interval,proto3" json:"interval,omitempty"`
	Phase    *durationpb.Duration `protobuf:"bytes,2,opt,name=phase,proto3" json:"phase,omitempty"`
}

func (x *IntervalSpec) Reset() {
	*x = IntervalSpec{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IntervalSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IntervalSpec) ProtoMessage() {}

func (x *IntervalSpec) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IntervalSpec.ProtoReflect.Descriptor instead.
func (*IntervalSpec) Descriptor() ([]byte, []int) {
	return file_temporal_api_schedule_v1_message_proto_rawDescGZIP(), []int{3}
}

func (x *IntervalSpec) GetInterval() *durationpb.Duration {
	if x != nil {
		return x.Interval
	}
	return nil
}

func (x *IntervalSpec) GetPhase() *durationpb.Duration {
	if x != nil {
		return x.Phase
	}
	return nil
}

// ScheduleSpec is a complete description of a set of absolute timestamps
// (possibly infinite) that an action should occur at. The meaning of a
// ScheduleSpec depends only on its contents and never changes, except that the
// definition of a time zone can change over time (most commonly, when daylight
// saving time policy changes for an area). To create a totally self-contained
// ScheduleSpec, use UTC or include timezone_data.
//
// For input, you can provide zero or more of: structured_calendar, calendar,
// cron_string, interval, and exclude_structured_calendar, and all of them will
// be used (the schedule will take action at the union of all of their times,
// minus the ones that match exclude_structured_calendar).
//
// On input, calendar and cron_string fields will be compiled into
// structured_calendar (and maybe interval and timezone_name), so if you
// Describe a schedule, you'll see only structured_calendar, interval, etc.
//
// If a spec has no matching times after the current time, then the schedule
// will be subject to automatic deletion (after several days).
type ScheduleSpec struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Calendar-based specifications of times.
	StructuredCalendar []*StructuredCalendarSpec `protobuf:"bytes,7,rep,name=structured_calendar,json=structuredCalendar,proto3" json:"structured_calendar,omitempty"`
	// cron_string holds a traditional cron specification as a string. It
	// accepts 5, 6, or 7 fields, separated by spaces, and interprets them the
	// same way as CalendarSpec.
	// 5 fields:         minute, hour, day_of_month, month, day_of_week
	// 6 fields:         minute, hour, day_of_month, month, day_of_week, year
	// 7 fields: second, minute, hour, day_of_month, month, day_of_week, year
	// If year is not given, it defaults to *. If second is not given, it
	// defaults to 0.
	// Shorthands @yearly, @monthly, @weekly, @daily, and @hourly are also
	// accepted instead of the 5-7 time fields.
	// Optionally, the string can be preceded by CRON_TZ=<timezone name> or
	// TZ=<timezone name>, which will get copied to timezone_name. (There must
	// not also be a timezone_name present.)
	// Optionally "#" followed by a comment can appear at the end of the string.
	// Note that the special case that some cron implementations have for
	// treating day_of_month and day_of_week as "or" instead of "and" when both
	// are set is not implemented.
	// @every <interval>[/<phase>] is accepted and gets compiled into an
	// IntervalSpec instead. <interval> and <phase> should be a decimal integer
	// with a unit suffix s, m, h, or d.
	CronString []string `protobuf:"bytes,8,rep,name=cron_string,json=cronString,proto3" json:"cron_string,omitempty"`
	// Calendar-based specifications of times.
	Calendar []*CalendarSpec `protobuf:"bytes,1,rep,name=calendar,proto3" json:"calendar,omitempty"`
	// Interval-based specifications of times.
	Interval []*IntervalSpec `protobuf:"bytes,2,rep,name=interval,proto3" json:"interval,omitempty"`
	// Any timestamps matching any of exclude_* will be skipped.
	//
	// Deprecated: Marked as deprecated in temporal/api/schedule/v1/message.proto.
	ExcludeCalendar           []*CalendarSpec           `protobuf:"bytes,3,rep,name=exclude_calendar,json=excludeCalendar,proto3" json:"exclude_calendar,omitempty"` // use exclude_structured_calendar
	ExcludeStructuredCalendar []*StructuredCalendarSpec `protobuf:"bytes,9,rep,name=exclude_structured_calendar,json=excludeStructuredCalendar,proto3" json:"exclude_structured_calendar,omitempty"`
	// If start_time is set, any timestamps before start_time will be skipped.
	// (Together, start_time and end_time make an inclusive interval.)
	StartTime *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// If end_time is set, any timestamps after end_time will be skipped.
	EndTime *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// All timestamps will be incremented by a random value from 0 to this
	// amount of jitter. Default: 0
	Jitter *durationpb.Duration `protobuf:"bytes,6,opt,name=jitter,proto3" json:"jitter,omitempty"`
	// Time zone to interpret all calendar-based specs in.
	//
	// If unset, defaults to UTC. We recommend using UTC for your application if
	// at all possible, to avoid various surprising properties of time zones.
	//
	// Time zones may be provided by name, corresponding to names in the IANA
	// time zone database (see https://www.iana.org/time-zones). The definition
	// will be loaded by the Temporal server from the environment it runs in.
	//
	// If your application requires more control over the time zone definition
	// used, it may pass in a complete definition in the form of a TZif file
	// from the time zone database. If present, this will be used instead of
	// loading anything from the environment. You are then responsible for
	// updating timezone_data when the definition changes.
	//
	// Calendar spec matching is based on literal matching of the clock time
	// with no special handling of DST: if you write a calendar spec that fires
	// at 2:30am and specify a time zone that follows DST, that action will not
	// be triggered on the day that has no 2:30am. Similarly, an action that
	// fires at 1:30am will be triggered twice on the day that has two 1:30s.
	//
	// Also note that no actions are taken on leap-seconds (e.g. 23:59:60 UTC).
	TimezoneName string `protobuf:"bytes,10,opt,name=timezone_name,json=timezoneName,proto3" json:"timezone_name,omitempty"`
	TimezoneData []byte `protobuf:"bytes,11,opt,name=timezone_data,json=timezoneData,proto3" json:"timezone_data,omitempty"`
}

func (x *ScheduleSpec) Reset() {
	*x = ScheduleSpec{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScheduleSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScheduleSpec) ProtoMessage() {}

func (x *ScheduleSpec) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScheduleSpec.ProtoReflect.Descriptor instead.
func (*ScheduleSpec) Descriptor() ([]byte, []int) {
	return file_temporal_api_schedule_v1_message_proto_rawDescGZIP(), []int{4}
}

func (x *ScheduleSpec) GetStructuredCalendar() []*StructuredCalendarSpec {
	if x != nil {
		return x.StructuredCalendar
	}
	return nil
}

func (x *ScheduleSpec) GetCronString() []string {
	if x != nil {
		return x.CronString
	}
	return nil
}

func (x *ScheduleSpec) GetCalendar() []*CalendarSpec {
	if x != nil {
		return x.Calendar
	}
	return nil
}

func (x *ScheduleSpec) GetInterval() []*IntervalSpec {
	if x != nil {
		return x.Interval
	}
	return nil
}

// Deprecated: Marked as deprecated in temporal/api/schedule/v1/message.proto.
func (x *ScheduleSpec) GetExcludeCalendar() []*CalendarSpec {
	if x != nil {
		return x.ExcludeCalendar
	}
	return nil
}

func (x *ScheduleSpec) GetExcludeStructuredCalendar() []*StructuredCalendarSpec {
	if x != nil {
		return x.ExcludeStructuredCalendar
	}
	return nil
}

func (x *ScheduleSpec) GetStartTime() *timestamppb.Timestamp {
	if x != nil {
		return x.StartTime
	}
	return nil
}

func (x *ScheduleSpec) GetEndTime() *timestamppb.Timestamp {
	if x != nil {
		return x.EndTime
	}
	return nil
}

func (x *ScheduleSpec) GetJitter() *durationpb.Duration {
	if x != nil {
		return x.Jitter
	}
	return nil
}

func (x *ScheduleSpec) GetTimezoneName() string {
	if x != nil {
		return x.TimezoneName
	}
	return ""
}

func (x *ScheduleSpec) GetTimezoneData() []byte {
	if x != nil {
		return x.TimezoneData
	}
	return nil
}

type SchedulePolicies struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Policy for overlaps.
	// Note that this can be changed after a schedule has taken some actions,
	// and some changes might produce unintuitive results. In general, the later
	// policy overrides the earlier policy.
	OverlapPolicy v1.ScheduleOverlapPolicy `protobuf:"varint,1,opt,name=overlap_policy,json=overlapPolicy,proto3,enum=temporal.api.enums.v1.ScheduleOverlapPolicy" json:"overlap_policy,omitempty"`
	// Policy for catchups:
	// If the Temporal server misses an action due to one or more components
	// being down, and comes back up, the action will be run if the scheduled
	// time is within this window from the current time.
	// This value defaults to one year, and can't be less than 10 seconds.
	CatchupWindow *durationpb.Duration `protobuf:"bytes,2,opt,name=catchup_window,json=catchupWindow,proto3" json:"catchup_window,omitempty"`
	// If true, and a workflow run fails or times out, turn on "paused".
	// This applies after retry policies: the full chain of retries must fail to
	// trigger a pause here.
	PauseOnFailure bool `protobuf:"varint,3,opt,name=pause_on_failure,json=pauseOnFailure,proto3" json:"pause_on_failure,omitempty"`
	// If true, and the action would start a workflow, a timestamp will not be
	// appended to the scheduled workflow id.
	KeepOriginalWorkflowId bool `protobuf:"varint,4,opt,name=keep_original_workflow_id,json=keepOriginalWorkflowId,proto3" json:"keep_original_workflow_id,omitempty"`
}

func (x *SchedulePolicies) Reset() {
	*x = SchedulePolicies{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SchedulePolicies) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SchedulePolicies) ProtoMessage() {}

func (x *SchedulePolicies) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SchedulePolicies.ProtoReflect.Descriptor instead.
func (*SchedulePolicies) Descriptor() ([]byte, []int) {
	return file_temporal_api_schedule_v1_message_proto_rawDescGZIP(), []int{5}
}

func (x *SchedulePolicies) GetOverlapPolicy() v1.ScheduleOverlapPolicy {
	if x != nil {
		return x.OverlapPolicy
	}
	return v1.ScheduleOverlapPolicy(0)
}

func (x *SchedulePolicies) GetCatchupWindow() *durationpb.Duration {
	if x != nil {
		return x.CatchupWindow
	}
	return nil
}

func (x *SchedulePolicies) GetPauseOnFailure() bool {
	if x != nil {
		return x.PauseOnFailure
	}
	return false
}

func (x *SchedulePolicies) GetKeepOriginalWorkflowId() bool {
	if x != nil {
		return x.KeepOriginalWorkflowId
	}
	return false
}

type ScheduleAction struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Action:
	//
	//	*ScheduleAction_StartWorkflow
	Action isScheduleAction_Action `protobuf_oneof:"action"`
}

func (x *ScheduleAction) Reset() {
	*x = ScheduleAction{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScheduleAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScheduleAction) ProtoMessage() {}

func (x *ScheduleAction) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScheduleAction.ProtoReflect.Descriptor instead.
func (*ScheduleAction) Descriptor() ([]byte, []int) {
	return file_temporal_api_schedule_v1_message_proto_rawDescGZIP(), []int{6}
}

func (m *ScheduleAction) GetAction() isScheduleAction_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (x *ScheduleAction) GetStartWorkflow() *v11.NewWorkflowExecutionInfo {
	if x, ok := x.GetAction().(*ScheduleAction_StartWorkflow); ok {
		return x.StartWorkflow
	}
	return nil
}

type isScheduleAction_Action interface {
	isScheduleAction_Action()
}

type ScheduleAction_StartWorkflow struct {
	// All fields of NewWorkflowExecutionInfo are valid except for:
	// - workflow_id_reuse_policy
	// - cron_schedule
	// The workflow id of the started workflow may not match this exactly,
	// it may have a timestamp appended for uniqueness.
	StartWorkflow *v11.NewWorkflowExecutionInfo `protobuf:"bytes,1,opt,name=start_workflow,json=startWorkflow,proto3,oneof"`
}

func (*ScheduleAction_StartWorkflow) isScheduleAction_Action() {}

type ScheduleActionResult struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Time that the action was taken (according to the schedule, including jitter).
	ScheduleTime *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=schedule_time,json=scheduleTime,proto3" json:"schedule_time,omitempty"`
	// Time that the action was taken (real time).
	ActualTime *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=actual_time,json=actualTime,proto3" json:"actual_time,omitempty"`
	// If action was start_workflow:
	StartWorkflowResult *v12.WorkflowExecution `protobuf:"bytes,11,opt,name=start_workflow_result,json=startWorkflowResult,proto3" json:"start_workflow_result,omitempty"`
	// If the action was start_workflow, this field will reflect an
	// eventually-consistent view of the started workflow's status.
	StartWorkflowStatus v1.WorkflowExecutionStatus `protobuf:"varint,12,opt,name=start_workflow_status,json=startWorkflowStatus,proto3,enum=temporal.api.enums.v1.WorkflowExecutionStatus" json:"start_workflow_status,omitempty"`
}

func (x *ScheduleActionResult) Reset() {
	*x = ScheduleActionResult{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScheduleActionResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScheduleActionResult) ProtoMessage() {}

func (x *ScheduleActionResult) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScheduleActionResult.ProtoReflect.Descriptor instead.
func (*ScheduleActionResult) Descriptor() ([]byte, []int) {
	return file_temporal_api_schedule_v1_message_proto_rawDescGZIP(), []int{7}
}

func (x *ScheduleActionResult) GetScheduleTime() *timestamppb.Timestamp {
	if x != nil {
		return x.ScheduleTime
	}
	return nil
}

func (x *ScheduleActionResult) GetActualTime() *timestamppb.Timestamp {
	if x != nil {
		return x.ActualTime
	}
	return nil
}

func (x *ScheduleActionResult) GetStartWorkflowResult() *v12.WorkflowExecution {
	if x != nil {
		return x.StartWorkflowResult
	}
	return nil
}

func (x *ScheduleActionResult) GetStartWorkflowStatus() v1.WorkflowExecutionStatus {
	if x != nil {
		return x.StartWorkflowStatus
	}
	return v1.WorkflowExecutionStatus(0)
}

type ScheduleState struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Informative human-readable message with contextual notes, e.g. the reason
	// a schedule is paused. The system may overwrite this message on certain
	// conditions, e.g. when pause-on-failure happens.
	Notes string `protobuf:"bytes,1,opt,name=notes,proto3" json:"notes,omitempty"`
	// If true, do not take any actions based on the schedule spec.
	Paused bool `protobuf:"varint,2,opt,name=paused,proto3" json:"paused,omitempty"`
	// If limited_actions is true, decrement remaining_actions after each
	// action, and do not take any more scheduled actions if remaining_actions
	// is zero. Actions may still be taken by explicit request (i.e. trigger
	// immediately or backfill). Skipped actions (due to overlap policy) do not
	// count against remaining actions.
	// If a schedule has no more remaining actions, then the schedule will be
	// subject to automatic deletion (after several days).
	LimitedActions   bool  `protobuf:"varint,3,opt,name=limited_actions,json=limitedActions,proto3" json:"limited_actions,omitempty"`
	RemainingActions int64 `protobuf:"varint,4,opt,name=remaining_actions,json=remainingActions,proto3" json:"remaining_actions,omitempty"`
}

func (x *ScheduleState) Reset() {
	*x = ScheduleState{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScheduleState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScheduleState) ProtoMessage() {}

func (x *ScheduleState) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScheduleState.ProtoReflect.Descriptor instead.
func (*ScheduleState) Descriptor() ([]byte, []int) {
	return file_temporal_api_schedule_v1_message_proto_rawDescGZIP(), []int{8}
}

func (x *ScheduleState) GetNotes() string {
	if x != nil {
		return x.Notes
	}
	return ""
}

func (x *ScheduleState) GetPaused() bool {
	if x != nil {
		return x.Paused
	}
	return false
}

func (x *ScheduleState) GetLimitedActions() bool {
	if x != nil {
		return x.LimitedActions
	}
	return false
}

func (x *ScheduleState) GetRemainingActions() int64 {
	if x != nil {
		return x.RemainingActions
	}
	return 0
}

type TriggerImmediatelyRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// If set, override overlap policy for this one request.
	OverlapPolicy v1.ScheduleOverlapPolicy `protobuf:"varint,1,opt,name=overlap_policy,json=overlapPolicy,proto3,enum=temporal.api.enums.v1.ScheduleOverlapPolicy" json:"overlap_policy,omitempty"`
}

func (x *TriggerImmediatelyRequest) Reset() {
	*x = TriggerImmediatelyRequest{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TriggerImmediatelyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TriggerImmediatelyRequest) ProtoMessage() {}

func (x *TriggerImmediatelyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TriggerImmediatelyRequest.ProtoReflect.Descriptor instead.
func (*TriggerImmediatelyRequest) Descriptor() ([]byte, []int) {
	return file_temporal_api_schedule_v1_message_proto_rawDescGZIP(), []int{9}
}

func (x *TriggerImmediatelyRequest) GetOverlapPolicy() v1.ScheduleOverlapPolicy {
	if x != nil {
		return x.OverlapPolicy
	}
	return v1.ScheduleOverlapPolicy(0)
}

type BackfillRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Time range to evaluate schedule in. Currently, this time range is
	// exclusive on start_time and inclusive on end_time. (This is admittedly
	// counterintuitive and it may change in the future, so to be safe, use a
	// start time strictly before a scheduled time.) Also note that an action
	// nominally scheduled in the interval but with jitter that pushes it after
	// end_time will not be included.
	StartTime *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	EndTime   *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// If set, override overlap policy for this request.
	OverlapPolicy v1.ScheduleOverlapPolicy `protobuf:"varint,3,opt,name=overlap_policy,json=overlapPolicy,proto3,enum=temporal.api.enums.v1.ScheduleOverlapPolicy" json:"overlap_policy,omitempty"`
}

func (x *BackfillRequest) Reset() {
	*x = BackfillRequest{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BackfillRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BackfillRequest) ProtoMessage() {}

func (x *BackfillRequest) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BackfillRequest.ProtoReflect.Descriptor instead.
func (*BackfillRequest) Descriptor() ([]byte, []int) {
	return file_temporal_api_schedule_v1_message_proto_rawDescGZIP(), []int{10}
}

func (x *BackfillRequest) GetStartTime() *timestamppb.Timestamp {
	if x != nil {
		return x.StartTime
	}
	return nil
}

func (x *BackfillRequest) GetEndTime() *timestamppb.Timestamp {
	if x != nil {
		return x.EndTime
	}
	return nil
}

func (x *BackfillRequest) GetOverlapPolicy() v1.ScheduleOverlapPolicy {
	if x != nil {
		return x.OverlapPolicy
	}
	return v1.ScheduleOverlapPolicy(0)
}

type SchedulePatch struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// If set, trigger one action immediately.
	TriggerImmediately *TriggerImmediatelyRequest `protobuf:"bytes,1,opt,name=trigger_immediately,json=triggerImmediately,proto3" json:"trigger_immediately,omitempty"`
	// If set, runs though the specified time period(s) and takes actions as if that time
	// passed by right now, all at once. The overlap policy can be overridden for the
	// scope of the backfill.
	BackfillRequest []*BackfillRequest `protobuf:"bytes,2,rep,name=backfill_request,json=backfillRequest,proto3" json:"backfill_request,omitempty"`
	// If set, change the state to paused or unpaused (respectively) and set the
	// notes field to the value of the string.
	Pause   string `protobuf:"bytes,3,opt,name=pause,proto3" json:"pause,omitempty"`
	Unpause string `protobuf:"bytes,4,opt,name=unpause,proto3" json:"unpause,omitempty"`
}

func (x *SchedulePatch) Reset() {
	*x = SchedulePatch{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SchedulePatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SchedulePatch) ProtoMessage() {}

func (x *SchedulePatch) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SchedulePatch.ProtoReflect.Descriptor instead.
func (*SchedulePatch) Descriptor() ([]byte, []int) {
	return file_temporal_api_schedule_v1_message_proto_rawDescGZIP(), []int{11}
}

func (x *SchedulePatch) GetTriggerImmediately() *TriggerImmediatelyRequest {
	if x != nil {
		return x.TriggerImmediately
	}
	return nil
}

func (x *SchedulePatch) GetBackfillRequest() []*BackfillRequest {
	if x != nil {
		return x.BackfillRequest
	}
	return nil
}

func (x *SchedulePatch) GetPause() string {
	if x != nil {
		return x.Pause
	}
	return ""
}

func (x *SchedulePatch) GetUnpause() string {
	if x != nil {
		return x.Unpause
	}
	return ""
}

type ScheduleInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Number of actions taken so far.
	ActionCount int64 `protobuf:"varint,1,opt,name=action_count,json=actionCount,proto3" json:"action_count,omitempty"`
	// Number of times a scheduled action was skipped due to missing the catchup window.
	MissedCatchupWindow int64 `protobuf:"varint,2,opt,name=missed_catchup_window,json=missedCatchupWindow,proto3" json:"missed_catchup_window,omitempty"`
	// Number of skipped actions due to overlap.
	OverlapSkipped int64 `protobuf:"varint,3,opt,name=overlap_skipped,json=overlapSkipped,proto3" json:"overlap_skipped,omitempty"`
	// Number of dropped actions due to buffer limit.
	BufferDropped int64 `protobuf:"varint,10,opt,name=buffer_dropped,json=bufferDropped,proto3" json:"buffer_dropped,omitempty"`
	// Number of actions in the buffer. The buffer holds the actions that cannot
	// be immediately triggered (due to the overlap policy). These actions can be a result of
	// the normal schedule or a backfill.
	BufferSize int64 `protobuf:"varint,11,opt,name=buffer_size,json=bufferSize,proto3" json:"buffer_size,omitempty"`
	// Currently-running workflows started by this schedule. (There might be
	// more than one if the overlap policy allows overlaps.)
	// Note that the run_ids in here are the original execution run ids as
	// started by the schedule. If the workflows retried, did continue-as-new,
	// or were reset, they might still be running but with a different run_id.
	RunningWorkflows []*v12.WorkflowExecution `protobuf:"bytes,9,rep,name=running_workflows,json=runningWorkflows,proto3" json:"running_workflows,omitempty"`
	// Most recent ten actual action times (including manual triggers).
	RecentActions []*ScheduleActionResult `protobuf:"bytes,4,rep,name=recent_actions,json=recentActions,proto3" json:"recent_actions,omitempty"`
	// Next ten scheduled action times.
	FutureActionTimes []*timestamppb.Timestamp `protobuf:"bytes,5,rep,name=future_action_times,json=futureActionTimes,proto3" json:"future_action_times,omitempty"`
	// Timestamps of schedule creation and last update.
	CreateTime *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	UpdateTime *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=update_time,json=updateTime,proto3" json:"update_time,omitempty"`
	// Deprecated: Marked as deprecated in temporal/api/schedule/v1/message.proto.
	InvalidScheduleError string `protobuf:"bytes,8,opt,name=invalid_schedule_error,json=invalidScheduleError,proto3" json:"invalid_schedule_error,omitempty"`
}

func (x *ScheduleInfo) Reset() {
	*x = ScheduleInfo{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScheduleInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScheduleInfo) ProtoMessage() {}

func (x *ScheduleInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScheduleInfo.ProtoReflect.Descriptor instead.
func (*ScheduleInfo) Descriptor() ([]byte, []int) {
	return file_temporal_api_schedule_v1_message_proto_rawDescGZIP(), []int{12}
}

func (x *ScheduleInfo) GetActionCount() int64 {
	if x != nil {
		return x.ActionCount
	}
	return 0
}

func (x *ScheduleInfo) GetMissedCatchupWindow() int64 {
	if x != nil {
		return x.MissedCatchupWindow
	}
	return 0
}

func (x *ScheduleInfo) GetOverlapSkipped() int64 {
	if x != nil {
		return x.OverlapSkipped
	}
	return 0
}

func (x *ScheduleInfo) GetBufferDropped() int64 {
	if x != nil {
		return x.BufferDropped
	}
	return 0
}

func (x *ScheduleInfo) GetBufferSize() int64 {
	if x != nil {
		return x.BufferSize
	}
	return 0
}

func (x *ScheduleInfo) GetRunningWorkflows() []*v12.WorkflowExecution {
	if x != nil {
		return x.RunningWorkflows
	}
	return nil
}

func (x *ScheduleInfo) GetRecentActions() []*ScheduleActionResult {
	if x != nil {
		return x.RecentActions
	}
	return nil
}

func (x *ScheduleInfo) GetFutureActionTimes() []*timestamppb.Timestamp {
	if x != nil {
		return x.FutureActionTimes
	}
	return nil
}

func (x *ScheduleInfo) GetCreateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.CreateTime
	}
	return nil
}

func (x *ScheduleInfo) GetUpdateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdateTime
	}
	return nil
}

// Deprecated: Marked as deprecated in temporal/api/schedule/v1/message.proto.
func (x *ScheduleInfo) GetInvalidScheduleError() string {
	if x != nil {
		return x.InvalidScheduleError
	}
	return ""
}

type Schedule struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Spec     *ScheduleSpec     `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
	Action   *ScheduleAction   `protobuf:"bytes,2,opt,name=action,proto3" json:"action,omitempty"`
	Policies *SchedulePolicies `protobuf:"bytes,3,opt,name=policies,proto3" json:"policies,omitempty"`
	State    *ScheduleState    `protobuf:"bytes,4,opt,name=state,proto3" json:"state,omitempty"`
}

func (x *Schedule) Reset() {
	*x = Schedule{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Schedule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Schedule) ProtoMessage() {}

func (x *Schedule) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Schedule.ProtoReflect.Descriptor instead.
func (*Schedule) Descriptor() ([]byte, []int) {
	return file_temporal_api_schedule_v1_message_proto_rawDescGZIP(), []int{13}
}

func (x *Schedule) GetSpec() *ScheduleSpec {
	if x != nil {
		return x.Spec
	}
	return nil
}

func (x *Schedule) GetAction() *ScheduleAction {
	if x != nil {
		return x.Action
	}
	return nil
}

func (x *Schedule) GetPolicies() *SchedulePolicies {
	if x != nil {
		return x.Policies
	}
	return nil
}

func (x *Schedule) GetState() *ScheduleState {
	if x != nil {
		return x.State
	}
	return nil
}

// ScheduleListInfo is an abbreviated set of values from Schedule and ScheduleInfo
// that's returned in ListSchedules.
type ScheduleListInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// From spec:
	// Some fields are dropped from this copy of spec: timezone_data
	Spec *ScheduleSpec `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
	// From action:
	// Action is a oneof field, but we need to encode this in JSON and oneof fields don't work
	// well with JSON. If action is start_workflow, this is set:
	WorkflowType *v12.WorkflowType `protobuf:"bytes,2,opt,name=workflow_type,json=workflowType,proto3" json:"workflow_type,omitempty"`
	// From state:
	Notes  string `protobuf:"bytes,3,opt,name=notes,proto3" json:"notes,omitempty"`
	Paused bool   `protobuf:"varint,4,opt,name=paused,proto3" json:"paused,omitempty"`
	// From info (maybe fewer entries):
	RecentActions     []*ScheduleActionResult  `protobuf:"bytes,5,rep,name=recent_actions,json=recentActions,proto3" json:"recent_actions,omitempty"`
	FutureActionTimes []*timestamppb.Timestamp `protobuf:"bytes,6,rep,name=future_action_times,json=futureActionTimes,proto3" json:"future_action_times,omitempty"`
}

func (x *ScheduleListInfo) Reset() {
	*x = ScheduleListInfo{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScheduleListInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScheduleListInfo) ProtoMessage() {}

func (x *ScheduleListInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScheduleListInfo.ProtoReflect.Descriptor instead.
func (*ScheduleListInfo) Descriptor() ([]byte, []int) {
	return file_temporal_api_schedule_v1_message_proto_rawDescGZIP(), []int{14}
}

func (x *ScheduleListInfo) GetSpec() *ScheduleSpec {
	if x != nil {
		return x.Spec
	}
	return nil
}

func (x *ScheduleListInfo) GetWorkflowType() *v12.WorkflowType {
	if x != nil {
		return x.WorkflowType
	}
	return nil
}

func (x *ScheduleListInfo) GetNotes() string {
	if x != nil {
		return x.Notes
	}
	return ""
}

func (x *ScheduleListInfo) GetPaused() bool {
	if x != nil {
		return x.Paused
	}
	return false
}

func (x *ScheduleListInfo) GetRecentActions() []*ScheduleActionResult {
	if x != nil {
		return x.RecentActions
	}
	return nil
}

func (x *ScheduleListInfo) GetFutureActionTimes() []*timestamppb.Timestamp {
	if x != nil {
		return x.FutureActionTimes
	}
	return nil
}

// ScheduleListEntry is returned by ListSchedules.
type ScheduleListEntry struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	ScheduleId       string                `protobuf:"bytes,1,opt,name=schedule_id,json=scheduleId,proto3" json:"schedule_id,omitempty"`
	Memo             *v12.Memo             `protobuf:"bytes,2,opt,name=memo,proto3" json:"memo,omitempty"`
	SearchAttributes *v12.SearchAttributes `protobuf:"bytes,3,opt,name=search_attributes,json=searchAttributes,proto3" json:"search_attributes,omitempty"`
	Info             *ScheduleListInfo     `protobuf:"bytes,4,opt,name=info,proto3" json:"info,omitempty"`
}

func (x *ScheduleListEntry) Reset() {
	*x = ScheduleListEntry{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScheduleListEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScheduleListEntry) ProtoMessage() {}

func (x *ScheduleListEntry) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScheduleListEntry.ProtoReflect.Descriptor instead.
func (*ScheduleListEntry) Descriptor() ([]byte, []int) {
	return file_temporal_api_schedule_v1_message_proto_rawDescGZIP(), []int{15}
}

func (x *ScheduleListEntry) GetScheduleId() string {
	if x != nil {
		return x.ScheduleId
	}
	return ""
}

func (x *ScheduleListEntry) GetMemo() *v12.Memo {
	if x != nil {
		return x.Memo
	}
	return nil
}

func (x *ScheduleListEntry) GetSearchAttributes() *v12.SearchAttributes {
	if x != nil {
		return x.SearchAttributes
	}
	return nil
}

func (x *ScheduleListEntry) GetInfo() *ScheduleListInfo {
	if x != nil {
		return x.Info
	}
	return nil
}

var File_temporal_api_schedule_v1_message_proto protoreflect.FileDescriptor

var file_temporal_api_schedule_v1_message_proto_rawDesc = []byte{
	0x0a, 0x26, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x61, 0x6c, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x73, 0x63,
	0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x2f, 0x76, 0x31, 0x2f, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x18, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x61, 0x6c, 0x2e,
	0x61, 0x70, 0x69, 0x2e, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x1a, 0x1e,
	0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x64,
	0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1f, 0x67, 0x6f,
	0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d,
	0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x24, 0x74, 0x65, 0x6d,
	0x70, 0x6f, 0x72, 0x61, 0x6c, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2f,
	0x76, 0x31, 0x2f, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a,
	0x24, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x61, 0x6c, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x65, 0x6e, 0x75,
	0x6d, 0x73, 0x2f, 0x76, 0x31, 0x2f, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x1a, 0x24, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x61, 0x6c, 0x2f, 0x61, 0x70, 0x69,
	0x2f, 0x65, 0x6e, 0x75, 0x6d, 0x73, 0x2f, 0x76, 0x31, 0x2f, 0x77, 0x6f, 0x72, 0x6b, 0x66, 0x6c, 0x6f,
	0x77, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x26, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x61, 0x6c,
	0x2f, 0x61, 0x70, 0x69, 0x2f, 0x77, 0x6f, 0x72, 0x6b, 0x66, 0x6c, 0x6f, 0x77, 0x2f, 0x76, 0x31, 0x2f,
	0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xf8, 0x01, 0x0a,
	0x0c, 0x43, 0x61, 0x6c, 0x65, 0x6e, 0x64, 0x61, 0x72, 0x53, 0x70, 0x65, 0x63, 0x12, 0x1a, 0x0a, 0x06,
	0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73, 0x65, 0x63,
	0x6f, 0x6e, 0x64, 0x42, 0x02, 0x68, 0x00, 0x12, 0x1a, 0x0a, 0x06, 0x6d, 0x69, 0x6e, 0x75, 0x74, 0x65,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x6d, 0x69, 0x6e, 0x75, 0x74, 0x65, 0x42, 0x02, 0x68,
	0x00, 0x12, 0x16, 0x0a, 0x04, 0x68, 0x6f, 0x75, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04,
	0x68, 0x6f, 0x75, 0x72, 0x42, 0x02, 0x68, 0x00, 0x12, 0x24, 0x0a, 0x0c, 0x64, 0x61, 0x79, 0x5f, 0x6f,
	0x66, 0x5f, 0x6d, 0x6f, 0x6e, 0x74, 0x68, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x64, 0x61,
	0x79, 0x4f, 0x66, 0x4d, 0x6f, 0x6e, 0x74, 0x68, 0x42, 0x02, 0x68, 0x00, 0x12, 0x18, 0x0a, 0x05, 0x6d,
	0x6f, 0x6e, 0x74, 0x68, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6d, 0x6f, 0x6e, 0x74, 0x68,
	0x42, 0x02, 0x68, 0x00, 0x12, 0x16, 0x0a, 0x04, 0x79, 0x65, 0x61, 0x72, 0x18, 0x06, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x04, 0x79, 0x65, 0x61, 0x72, 0x42, 0x02, 0x68, 0x00, 0x12, 0x22, 0x0a, 0x0b, 0x64, 0x61,
	0x79, 0x5f, 0x6f, 0x66, 0x5f, 0x77, 0x65, 0x65, 0x6b, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09,
	0x64, 0x61, 0x79, 0x4f, 0x66, 0x57, 0x65, 0x65, 0x6b, 0x42, 0x02, 0x68, 0x00, 0x12, 0x1c, 0x0a, 0x07,
	0x63, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x63, 0x6f,
	0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x42, 0x02, 0x68, 0x00, 0x22, 0x4f, 0x0a, 0x05, 0x52, 0x61, 0x6e, 0x67,
	0x65, 0x12, 0x18, 0x0a, 0x05, 0x73, 0x74, 0x61, 0x72, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52,
	0x05, 0x73, 0x74, 0x61, 0x72, 0x74, 0x42, 0x02, 0x68, 0x00, 0x12, 0x14, 0x0a, 0x03, 0x65, 0x6e, 0x64,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x03, 0x65, 0x6e, 0x64, 0x42, 0x02, 0x68, 0x00, 0x12, 0x16,
	0x0a, 0x04, 0x73, 0x74, 0x65, 0x70, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x04, 0x73, 0x74, 0x65,
	0x70, 0x42, 0x02, 0x68, 0x00, 0x22, 0xe9, 0x03, 0x0a, 0x16, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75,
	0x72, 0x65, 0x64, 0x43, 0x61, 0x6c, 0x65, 0x6e, 0x64, 0x61, 0x72, 0x53, 0x70, 0x65, 0x63, 0x12, 0x3b,
	0x0a, 0x06, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1f, 0x2e,
	0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x61, 0x6c, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x73, 0x63, 0x68,
	0x65, 0x64, 0x75, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x52, 0x06, 0x73,
	0x65, 0x63, 0x6f, 0x6e, 0x64, 0x42, 0x02, 0x68, 0x00, 0x12, 0x3b, 0x0a, 0x06, 0x6d, 0x69, 0x6e, 0x75,
	0x74, 0x65, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72,
	0x61, 0x6c, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x2e, 0x76,
	0x31, 0x2e, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x52, 0x06, 0x6d, 0x69, 0x6e, 0x75, 0x74, 0x65, 0x42, 0x02,
	0x68, 0x00, 0x12, 0x37, 0x0a, 0x04, 0x68, 0x6f, 0x75, 0x72, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32,
	0x1f, 0x2e, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x61, 0x6c, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x73, 0x63,
	0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x52, 0x04,
	0x68, 0x6f, 0x75, 0x72, 0x42, 0x02, 0x68, 0x00, 0x12, 0x45, 0x0a, 0x0c, 0x64, 0x61, 0x79, 0x5f, 0x6f,
	0x66, 0x5f, 0x6d, 0x6f, 0x6e, 0x74, 0x68, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x74,
	0x65, 0x6d, 0x70, 0x6f, 0x72, 0x61, 0x6c, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x73, 0x63, 0x68, 0x65, 0x64,
	0x75, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x52, 0x0a, 0x64, 0x61, 0x79,
	0x4f, 0x66, 0x4d, 0x6f, 0x6e, 0x74, 0x68, 0x42, 0x02, 0x68, 0x00, 0x12, 0x39, 0x0a, 0x05, 0x6d, 0x6f,
	0x6e, 0x74, 0x68, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x74, 0x65, 0x6d, 0x70, 0x6f,
	0x72, 0x61, 0x6c, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x2e,
	0x76, 0x31, 0x2e, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x52, 0x05, 0x6d, 0x6f, 0x6e, 0x74, 0x68, 0x42, 0x02,
	0x68, 0x00, 0x12, 0x37, 0x0a, 0x04, 0x79, 0x65, 0x61, 0x72, 0x18, 0x06, 0x20, 0x03, 0x28, 0x0b, 0x32,
	0x1f, 0x2e, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x61, 0x6c, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x73, 0x63,
	0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x52, 0x04,
	0x79, 0x65, 0x61, 0x72, 0x42, 0x02, 0x68, 0x00, 0x12, 0x43, 0x0a, 0x0b, 0x64, 0x61, 0x79, 0x5f, 0x6f,
	0x66, 0x5f, 0x77, 0x65, 0x65, 0x6b, 0x18, 0x07, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x74, 0x65,
	0x6d, 0x70, 0x6f, 0x72, 0x61, 0x6c, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75,
	0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x52, 0x09, 0x64, 0x61, 0x79, 0x4f,
	0x66, 0x57, 0x65, 0x65, 0x6b, 0x42, 0x02, 0x68, 0x00, 0x12, 0x1c, 0x0a, 0x07, 0x63, 0x6f, 0x6d, 0x6d,
	0x65, 0x6e, 0x74, 0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x63, 0x6f, 0x6d, 0x6d, 0x65, 0x6e,
	0x74, 0x42, 0x02, 0x68, 0x00, 0x22, 0x7e, 0x0a, 0x0c, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c,
	0x53, 0x70, 0x65, 0x63, 0x12, 0x39, 0x0a, 0x08, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x08,
	0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x42, 0x02, 0x68, 0x00, 0x12, 0x33, 0x0a, 0x05, 0x70,
	0x68, 0x61, 0x73, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67,
	0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x52, 0x05, 0x70, 0x68, 0x61, 0x73, 0x65, 0x42, 0x02, 0x68, 0x00, 0x22, 0xfc, 0x05,
	0x0a, 0x0c, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x53, 0x70, 0x65, 0x63, 0x12, 0x65, 0x0a,
	0x13, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x64, 0x5f, 0x63, 0x61, 0x6c, 0x65, 0x6e,
	0x64, 0x61, 0x72, 0x18, 0x07, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x30, 0x2e, 0x74, 0x65, 0x6d, 0x70, 0x6f,
	0x72, 0x61, 0x6c, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x2e,
	0x76, 0x31, 0x2e, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x64, 0x43, 0x61, 0x6c, 0x65,
	0x6e, 0x64, 0x61, 0x72, 0x53, 0x70, 0x65, 0x63, 0x52, 0x12, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75,
	0x72, 0x65, 0x64, 0x43, 0x61, 0x6c, 0x65, 0x6e, 0x64, 0x61, 0x72, 0x42, 0x02, 0x68, 0x00, 0x12,
	0x23, 0x0a, 0x0b, 0x63, 0x72, 0x6f, 0x6e, 0x5f, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x18, 0x08, 0x20,
	0x03, 0x28, 0x09, 0x52, 0x0a, 0x63, 0x72, 0x6f, 0x6e, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x42, 0x02,
	0x68, 0x00, 0x12, 0x46, 0x0a, 0x08, 0x63, 0x61, 0x6c, 0x65, 0x6e, 0x64, 0x61, 0x72, 0x18, 0x01, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x61, 0x6c, 0x2e, 0x61, 0x70,
	0x69, 0x2e, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x61, 0x6c,
	0x65, 0x6e, 0x64, 0x61, 0x72, 0x53, 0x70, 0x65, 0x63, 0x52, 0x08, 0x63, 0x61, 0x6c, 0x65, 0x6e, 0x64,
	0x61, 0x72, 0x42, 0x02, 0x68, 0x00, 0x12, 0x46, 0x0a, 0x08, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61,
	0x6c, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x61,
	0x6c, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x2e, 0x76, 0x31,
	0x2e, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x53, 0x70, 0x65, 0x63, 0x52, 0x08, 0x69, 0x6e,
	0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x42, 0x02, 0x68, 0x00, 0x12, 0x57, 0x0a, 0x10, 0x65, 0x78, 0x63,
	0x6c, 0x75, 0x64, 0x65, 0x5f, 0x63, 0x61, 0x6c, 0x65, 0x6e, 0x64, 0x61, 0x72, 0x18, 0x03, 0x20, 0x03,
	0x28, 0x0b, 0x32, 0x26, 0x2e, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x61, 0x6c, 0x2e, 0x61, 0x70, 0x69,
	0x2e, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x61, 0x6c, 0x65,
	0x6e, 0x64, 0x61, 0x72, 0x53, 0x70, 0x65, 0x63, 0x42, 0x04, 0x18, 0x01, 0x68, 0x00, 0x52, 0x0f, 0x65,
	0x78, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x43, 0x61, 0x6c, 0x65, 0x6e, 0x64, 0x61, 0x72, 0x12, 0x74, 0x0a,
	0x1b, 0x65, 0x78, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x5f, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72,
	0x65, 0x64, 0x5f, 0x63, 0x61, 0x6c, 0x65, 0x6e, 0x64, 0x61, 0x72, 0x18, 0x09, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x30, 0x2e, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x61, 0x6c, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x73,
	0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74,
	0x75, 0x72, 0x65, 0x64, 0x43, 0x61, 0x6c, 0x65, 0x6e, 0x64, 0x61, 0x72, 0x53, 0x70, 0x65, 0x63, 0x52,
	0x19, 0x65, 0x78, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65,
	0x64, 0x43, 0x61, 0x6c, 0x65, 0x6e, 0x64, 0x61, 0x72, 0x42, 0x02, 0x68, 0x00, 0x12, 0x3d, 0x0a, 0x0a,
	0x73, 0x74, 0x61, 0x72, 0x74, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
	0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x73, 0x74, 0x61, 0x72, 0x74,
	0x54, 0x69, 0x6d, 0x65, 0x42, 0x02, 0x68, 0x00, 0x12, 0x39, 0x0a, 0x08, 0x65, 0x6e, 0x64, 0x5f, 0x74,
	0x69, 0x6d, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
	0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74,
	0x61, 0x6d, 0x70, 0x52, 0x07, 0x65, 0x6e, 0x64, 0x54, 0x69, 0x6d, 0x65, 0x42, 0x02, 0x68, 0x00, 0x12,
	0x35, 0x0a, 0x06, 0x6a, 0x69, 0x74, 0x74, 0x65, 0x72, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19,
	0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e,
	0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x06, 0x6a, 0x69, 0x74, 0x74, 0x65, 0x72, 0x42,
	0x02, 0x68, 0x00, 0x12, 0x27, 0x0a, 0x0d, 0x74, 0x69, 0x6d, 0x65, 0x7a, 0x6f, 0x6e, 0x65, 0x5f, 0x6e,
	0x61, 0x6d, 0x65, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x74, 0x69, 0x6d, 0x65, 0x7a, 0x6f,
	0x6e, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x42, 0x02, 0x68, 0x00, 0x12, 0x27, 0x0a, 0x0d, 0x74, 0x69, 0x6d,
	0x65, 0x7a, 0x6f, 0x6e, 0x65, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0c, 0x52,
	0x0c, 0x74, 0x69, 0x6d, 0x65, 0x7a, 0x6f, 0x6e, 0x65, 0x44, 0x61, 0x74, 0x61, 0x42, 0x02, 0x68, 0x00,
	0x22, 0x9e, 0x02, 0x0a, 0x10, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x50, 0x6f, 0x6c, 0x69,
	0x63, 0x69, 0x65, 0x73, 0x12, 0x57, 0x0a, 0x0e, 0x6f, 0x76, 0x65, 0x72, 0x6c, 0x61, 0x70, 0x5f,
	0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x2c, 0x2e, 0x74, 0x65,
	0x6d, 0x70, 0x6f, 0x72, 0x61, 0x6c, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x65, 0x6e, 0x75, 0x6d, 0x73, 0x2e,
	0x76, 0x31, 0x2e, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x4f, 0x76, 0x65, 0x72, 0x6c, 0x61,
	0x70, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x0d, 0x6f, 0x76, 0x65, 0x72, 0x6c, 0x61, 0x70, 0x50,
	0x6f, 0x6c, 0x69, 0x63, 0x79, 0x42, 0x02, 0x68, 0x00, 0x12, 0x44, 0x0a, 0x0e, 0x63, 0x61, 0x74, 0x63,
	0x68, 0x75, 0x70, 0x5f, 0x77, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
	0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0d, 0x63, 0x61, 0x74, 0x63, 0x68, 0x75,
	0x70, 0x57, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x42, 0x02, 0x68, 0x00, 0x12, 0x2c, 0x0a, 0x10, 0x70, 0x61,
	0x75, 0x73, 0x65, 0x5f, 0x6f, 0x6e, 0x5f, 0x66, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x08, 0x52, 0x0e, 0x70, 0x61, 0x75, 0x73, 0x65, 0x4f, 0x6e, 0x46, 0x61, 0x69, 0x6c, 0x75,
	0x72, 0x65, 0x42, 0x02, 0x68, 0x00, 0x12, 0x3d, 0x0a, 0x19, 0x6b, 0x65, 0x65, 0x70, 0x5f, 0x6f, 0x72,
	0x69, 0x67, 0x69, 0x6e, 0x61, 0x6c, 0x5f, 0x77, 0x6f, 0x72, 0x6b, 0x66, 0x6c, 0x6f, 0x77, 0x5f, 0x69,
	0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x16, 0x6b, 0x65, 0x65, 0x70, 0x4f, 0x72, 0x69, 0x67,
	0x69, 0x6e, 0x61, 0x6c, 0x57, 0x6f, 0x72, 0x6b, 0x66, 0x6c, 0x6f, 0x77, 0x49, 0x64, 0x42, 0x02, 0x68,
	0x00, 0x22, 0x7b, 0x0a, 0x0e, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x41, 0x63, 0x74, 0x69,
	0x6f, 0x6e, 0x12, 0x5f, 0x0a, 0x0e, 0x73, 0x74, 0x61, 0x72, 0x74, 0x5f, 0x77, 0x6f, 0x72, 0x6b, 0x66,
	0x6c, 0x6f, 0x77, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x32, 0x2e, 0x74, 0x65, 0x6d, 0x70, 0x6f,
	0x72, 0x61, 0x6c, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x77, 0x6f, 0x72, 0x6b, 0x66, 0x6c, 0x6f, 0x77, 0x2e,
	0x76, 0x31, 0x2e, 0x4e, 0x65, 0x77, 0x57, 0x6f, 0x72, 0x6b, 0x66, 0x6c, 0x6f, 0x77, 0x45, 0x78, 0x65,
	0x63, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x6e, 0x66, 0x6f, 0x48, 0x00, 0x52, 0x0d, 0x73, 0x74, 0x61,
	0x72, 0x74, 0x57, 0x6f, 0x72, 0x6b, 0x66, 0x6c, 0x6f, 0x77, 0x42, 0x02, 0x68, 0x00, 0x42, 0x08, 0x0a,
	0x06, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0xe7, 0x02, 0x0a, 0x14, 0x53, 0x63, 0x68, 0x65, 0x64,
	0x75, 0x6c, 0x65, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x12, 0x43,
	0x0a, 0x0d, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x0c,
	0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x54, 0x69, 0x6d, 0x65, 0x42, 0x02, 0x68, 0x00, 0x12,
	0x3f, 0x0a, 0x0b, 0x61, 0x63, 0x74, 0x75, 0x61, 0x6c, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x0a, 0x61,
	0x63, 0x74, 0x75, 0x61, 0x6c, 0x54, 0x69, 0x6d, 0x65, 0x42, 0x02, 0x68, 0x00, 0x12, 0x61, 0x0a, 0x15,
	0x73, 0x74, 0x61, 0x72, 0x74, 0x5f, 0x77, 0x6f, 0x72, 0x6b, 0x66, 0x6c, 0x6f, 0x77, 0x5f, 0x72, 0x65,
	0x73, 0x75, 0x6c, 0x74, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x74, 0x65, 0x6d, 0x70,
	0x6f, 0x72, 0x61, 0x6c, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76,
	0x31, 0x2e, 0x57, 0x6f, 0x72, 0x6b, 0x66, 0x6c, 0x6f, 0x77, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69,
	0x6f, 0x6e, 0x52, 0x13, 0x73, 0x74, 0x61, 0x72, 0x74, 0x57, 0x6f, 0x72, 0x6b, 0x66, 0x6c, 0x6f, 0x77,
	0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x42, 0x02, 0x68, 0x00, 0x12, 0x66, 0x0a, 0x15, 0x73, 0x74, 0x61,
	0x72, 0x74, 0x5f, 0x77, 0x6f, 0x72, 0x6b, 0x66, 0x6c, 0x6f, 0x77, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x75,
	0x73, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x2e, 0x2e, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72,
	0x61, 0x6c, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x65, 0x6e, 0x75, 0x6d, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x57,
	0x6f, 0x72, 0x6b, 0x66, 0x6c, 0x6f, 0x77, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x53,
	0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x13, 0x73, 0x74, 0x61, 0x72, 0x74, 0x57, 0x6f, 0x72, 0x6b, 0x66,
	0x6c, 0x6f, 0x77, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x42, 0x02, 0x68, 0x00, 0x22, 0xa3, 0x01, 0x0a,
	0x0d, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x53, 0x74, 0x61, 0x74, 0x65, 0x12, 0x18, 0x0a,
	0x05, 0x6e, 0x6f, 0x74, 0x65, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6e, 0x6f, 0x74,
	0x65, 0x73, 0x42, 0x02, 0x68, 0x00, 0x12, 0x1a, 0x0a, 0x06, 0x70, 0x61, 0x75, 0x73, 0x65, 0x64, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x70, 0x61, 0x75, 0x73, 0x65, 0x64, 0x42, 0x02, 0x68, 0x00,
	0x12, 0x2b, 0x0a, 0x0f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x63, 0x74, 0x69, 0x6f,
	0x6e, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0e, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64,
	0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x42, 0x02, 0x68, 0x00, 0x12, 0x2f, 0x0a, 0x11, 0x72, 0x65,
	0x6d, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x5f, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x03, 0x52, 0x10, 0x72, 0x65, 0x6d, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x41, 0x63,
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0x42, 0x02, 0x68, 0x00, 0x22, 0x74, 0x0a, 0x19, 0x54, 0x72, 0x69, 0x67,
	0x67, 0x65, 0x72, 0x49, 0x6d, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x74, 0x65, 0x6c, 0x79, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x12, 0x57, 0x0a, 0x0e, 0x6f, 0x76, 0x65, 0x72, 0x6c, 0x61, 0x70, 0x5f, 0x70,
	0x6f, 0x6c, 0x69, 0x63, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x2c, 0x2e, 0x74, 0x65, 0x6d,
	0x70, 0x6f, 0x72, 0x61, 0x6c, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x65, 0x6e, 0x75, 0x6d, 0x73, 0x2e, 0x76,
	0x31, 0x2e, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x4f, 0x76, 0x65, 0x72, 0x6c, 0x61, 0x70,
	0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x0d, 0x6f, 0x76, 0x65, 0x72, 0x6c, 0x61, 0x70, 0x50, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x42, 0x02, 0x68, 0x00, 0x22, 0xe4, 0x01, 0x0a, 0x0f, 0x42, 0x61, 0x63, 0x6b,
	0x66, 0x69, 0x6c, 0x6c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x3d, 0x0a, 0x0a, 0x73, 0x74,
	0x61, 0x72, 0x74, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e,
	0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54,
	0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69,
	0x6d, 0x65, 0x42, 0x02, 0x68, 0x00, 0x12, 0x39, 0x0a, 0x08, 0x65, 0x6e, 0x64, 0x5f, 0x74, 0x69, 0x6d,
	0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d,
	0x70, 0x52, 0x07, 0x65, 0x6e, 0x64, 0x54, 0x69, 0x6d, 0x65, 0x42, 0x02, 0x68, 0x00, 0x12, 0x57, 0x0a,
	0x0e, 0x6f, 0x76, 0x65, 0x72, 0x6c, 0x61, 0x70, 0x5f, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x0e, 0x32, 0x2c, 0x2e, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x61, 0x6c, 0x2e, 0x61,
	0x70, 0x69, 0x2e, 0x65, 0x6e, 0x75, 0x6d, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x63, 0x68, 0x65, 0x64,
	0x75, 0x6c, 0x65, 0x4f, 0x76, 0x65, 0x72, 0x6c, 0x61, 0x70, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52,
	0x0d, 0x6f, 0x76, 0x65, 0x72, 0x6c, 0x61, 0x70, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x42, 0x02, 0x68,
	0x00, 0x22, 0x8b, 0x02, 0x0a, 0x0d, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x50, 0x61, 0x74,
	0x63, 0x68, 0x12, 0x68, 0x0a, 0x13, 0x74, 0x72, 0x69, 0x67, 0x67, 0x65, 0x72, 0x5f, 0x69, 0x6d, 0x6d,
	0x65, 0x64, 0x69, 0x61, 0x74, 0x65, 0x6c, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x33, 0x2e,
	0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x61, 0x6c, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x73, 0x63, 0x68, 0x65,
	0x64, 0x75, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x54, 0x72, 0x69, 0x67, 0x67, 0x65, 0x72, 0x49, 0x6d,
	0x6d, 0x65, 0x64, 0x69, 0x61, 0x74, 0x65, 0x6c, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
	0x52, 0x12, 0x74, 0x72, 0x69, 0x67, 0x67, 0x65, 0x72, 0x49, 0x6d, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x74,
	0x65, 0x6c, 0x79, 0x42, 0x02, 0x68, 0x00, 0x12, 0x58, 0x0a, 0x10, 0x62, 0x61, 0x63, 0x6b, 0x66, 0x69,
	0x6c, 0x6c, 0x5f, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32,
	0x29, 0x2e, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x61, 0x6c, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x73, 0x63,
	0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x42, 0x61, 0x63, 0x6b, 0x66, 0x69, 0x6c,
	0x6c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x52, 0x0f, 0x62, 0x61, 0x63, 0x6b, 0x66, 0x69, 0x6c,
	0x6c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x42, 0x02, 0x68, 0x00, 0x12, 0x18, 0x0a, 0x05, 0x70,
	0x61, 0x75, 0x73, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x70, 0x61, 0x75, 0x73, 0x65,
	0x42, 0x02, 0x68, 0x00, 0x12, 0x1c, 0x0a, 0x07, 0x75, 0x6e, 0x70, 0x61, 0x75, 0x73, 0x65, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x75, 0x6e, 0x70, 0x61, 0x75, 0x73, 0x65, 0x42, 0x02, 0x68, 0x00,
	0x22, 0xaf, 0x05, 0x0a, 0x0c, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x49, 0x6e, 0x66, 0x6f,
	0x12, 0x25, 0x0a, 0x0c, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0b, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x75, 0x6e,
	0x74, 0x42, 0x02, 0x68, 0x00, 0x12, 0x36, 0x0a, 0x15, 0x6d, 0x69, 0x73, 0x73, 0x65, 0x64, 0x5f, 0x63,
	0x61, 0x74, 0x63, 0x68, 0x75, 0x70, 0x5f, 0x77, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x03, 0x52, 0x13, 0x6d, 0x69, 0x73, 0x73, 0x65, 0x64, 0x43, 0x61, 0x74, 0x63, 0x68, 0x75, 0x70,
	0x57, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x42, 0x02, 0x68, 0x00, 0x12, 0x2b, 0x0a, 0x0f, 0x6f, 0x76, 0x65,
	0x72, 0x6c, 0x61, 0x70, 0x5f, 0x73, 0x6b, 0x69, 0x70, 0x70, 0x65, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x03, 0x52, 0x0e, 0x6f, 0x76, 0x65, 0x72, 0x6c, 0x61, 0x70, 0x53, 0x6b, 0x69, 0x70, 0x70, 0x65, 0x64,
	0x42, 0x02, 0x68, 0x00, 0x12, 0x29, 0x0a, 0x0e, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x5f, 0x64, 0x72,
	0x6f, 0x70, 0x70, 0x65, 0x64, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0d, 0x62, 0x75, 0x66, 0x66,
	0x65, 0x72, 0x44, 0x72, 0x6f, 0x70, 0x70, 0x65, 0x64, 0x42, 0x02, 0x68, 0x00, 0x12, 0x23, 0x0a, 0x0b,
	0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x03,
	0x52, 0x0a, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x53, 0x69, 0x7a, 0x65, 0x42, 0x02, 0x68, 0x00, 0x12,
	0x5a, 0x0a, 0x11, 0x72, 0x75, 0x6e, 0x6e, 0x69, 0x6e, 0x67, 0x5f, 0x77, 0x6f, 0x72, 0x6b, 0x66, 0x6c,
	0x6f, 0x77, 0x73, 0x18, 0x09, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x74, 0x65, 0x6d, 0x70, 0x6f,
	0x72, 0x61, 0x6c, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31,
	0x2e, 0x57, 0x6f, 0x72, 0x6b, 0x66, 0x6c, 0x6f, 0x77, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6f,
	0x6e, 0x52, 0x10, 0x72, 0x75, 0x6e, 0x6e, 0x69, 0x6e, 0x67, 0x57, 0x6f, 0x72, 0x6b, 0x66, 0x6c, 0x6f,
	0x77, 0x73, 0x42, 0x02, 0x68, 0x00, 0x12, 0x59, 0x0a, 0x0e, 0x72, 0x65, 0x63, 0x65, 0x6e, 0x74, 0x5f,
	0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2e, 0x2e, 0x74,
	0x65, 0x6d, 0x70, 0x6f, 0x72, 0x61, 0x6c, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x73, 0x63, 0x68, 0x65, 0x64,
	0x75, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x41, 0x63,
	0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x52, 0x0d, 0x72, 0x65, 0x63, 0x65, 0x6e,
	0x74, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x42, 0x02, 0x68, 0x00, 0x12, 0x4e, 0x0a, 0x13, 0x66,
	0x75, 0x74, 0x75, 0x72, 0x65, 0x5f, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x74, 0x69, 0x6d, 0x65,
	0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d,
	0x70, 0x52, 0x11, 0x66, 0x75, 0x74, 0x75, 0x72, 0x65, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x54,
	0x69, 0x6d, 0x65, 0x73, 0x42, 0x02, 0x68, 0x00, 0x12, 0x3f, 0x0a, 0x0b, 0x63, 0x72, 0x65, 0x61, 0x74,
	0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f,
	0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d,
	0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x0a, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x54, 0x69, 0x6d,
	0x65, 0x42, 0x02, 0x68, 0x00, 0x12, 0x3f, 0x0a, 0x0b, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x5f, 0x74,
	0x69, 0x6d, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
	0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74,
	0x61, 0x6d, 0x70, 0x52, 0x0a, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x54, 0x69, 0x6d, 0x65, 0x42, 0x02,
	0x68, 0x00, 0x12, 0x3a, 0x0a, 0x16, 0x69, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x5f, 0x73, 0x63, 0x68,
	0x65, 0x64, 0x75, 0x6c, 0x65, 0x5f, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x18, 0x08, 0x20, 0x01, 0x28, 0x09,
	0x42, 0x04, 0x18, 0x01, 0x68, 0x00, 0x52, 0x14, 0x69, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x53, 0x63,
	0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x22, 0x9f, 0x02, 0x0a, 0x08, 0x53,
	0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x12, 0x3e, 0x0a, 0x04, 0x73, 0x70, 0x65, 0x63, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x61, 0x6c, 0x2e, 0x61,
	0x70, 0x69, 0x2e, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x63,
	0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x53, 0x70, 0x65, 0x63, 0x52, 0x04, 0x73, 0x70, 0x65, 0x63, 0x42,
	0x02, 0x68, 0x00, 0x12, 0x44, 0x0a, 0x06, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x28, 0x2e, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x61, 0x6c, 0x2e, 0x61, 0x70, 0x69,
	0x2e, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x63, 0x68, 0x65,
	0x64, 0x75, 0x6c, 0x65, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x06, 0x61, 0x63, 0x74, 0x69, 0x6f,
	0x6e, 0x42, 0x02, 0x68, 0x00, 0x12, 0x4a, 0x0a, 0x08, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x69, 0x65, 0x73,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x61, 0x6c,
	0x2e, 0x61, 0x70, 0x69, 0x2e, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e,
	0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x69, 0x65, 0x73, 0x52,
	0x08, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x69, 0x65, 0x73, 0x42, 0x02, 0x68, 0x00, 0x12, 0x41, 0x0a, 0x05,
	0x73, 0x74, 0x61, 0x74, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x27, 0x2e, 0x74, 0x65, 0x6d,
	0x70, 0x6f, 0x72, 0x61, 0x6c, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c,
	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x53, 0x74, 0x61, 0x74,
	0x65, 0x52, 0x05, 0x73, 0x74, 0x61, 0x74, 0x65, 0x42, 0x02, 0x68, 0x00, 0x22, 0x82, 0x03, 0x0a, 0x10,
	0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x4c, 0x69, 0x73, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x12,
	0x3e, 0x0a, 0x04, 0x73, 0x70, 0x65, 0x63, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x74,
	0x65, 0x6d, 0x70, 0x6f, 0x72, 0x61, 0x6c, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x73, 0x63, 0x68, 0x65, 0x64,
	0x75, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x53, 0x70,
	0x65, 0x63, 0x52, 0x04, 0x73, 0x70, 0x65, 0x63, 0x42, 0x02, 0x68, 0x00, 0x12, 0x4d, 0x0a, 0x0d, 0x77,
	0x6f, 0x72, 0x6b, 0x66, 0x6c, 0x6f, 0x77, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x24, 0x2e, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x61, 0x6c, 0x2e, 0x61, 0x70, 0x69, 0x2e,
	0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x57, 0x6f, 0x72, 0x6b, 0x66, 0x6c, 0x6f,
	0x77, 0x54, 0x79, 0x70, 0x65, 0x52, 0x0c, 0x77, 0x6f, 0x72, 0x6b, 0x66, 0x6c, 0x6f, 0x77, 0x54, 0x79,
	0x70, 0x65, 0x42, 0x02, 0x68, 0x00, 0x12, 0x18, 0x0a, 0x05, 0x6e, 0x6f, 0x74, 0x65, 0x73, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6e, 0x6f, 0x74, 0x65, 0x73, 0x42, 0x02, 0x68, 0x00, 0x12,
	0x1a, 0x0a, 0x06, 0x70, 0x61, 0x75, 0x73, 0x65, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06,
	0x70, 0x61, 0x75, 0x73, 0x65, 0x64, 0x42, 0x02, 0x68, 0x00, 0x12, 0x59, 0x0a, 0x0e, 0x72, 0x65, 0x63,
	0x65, 0x6e, 0x74, 0x5f, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x2e, 0x2e, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x61, 0x6c, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x73,
	0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75,
	0x6c, 0x65, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x52, 0x0d, 0x72,
	0x65, 0x63, 0x65, 0x6e, 0x74, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x42, 0x02, 0x68, 0x00, 0x12,
	0x4e, 0x0a, 0x13, 0x66, 0x75, 0x74, 0x75, 0x72, 0x65, 0x5f, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f,
	0x74, 0x69, 0x6d, 0x65, 0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f,
	0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65,
	0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x11, 0x66, 0x75, 0x74, 0x75, 0x72, 0x65, 0x41, 0x63, 0x74, 0x69,
	0x6f, 0x6e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x42, 0x02, 0x68, 0x00, 0x22, 0x8d, 0x02, 0x0a, 0x11, 0x53,
	0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x4c, 0x69, 0x73, 0x74, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12,
	0x23, 0x0a, 0x0b, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x0a, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x49, 0x64, 0x42, 0x02,
	0x68, 0x00, 0x12, 0x34, 0x0a, 0x04, 0x6d, 0x65, 0x6d, 0x6f, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x1c, 0x2e, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x61, 0x6c, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f,
	0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x65, 0x6d, 0x6f, 0x52, 0x04, 0x6d, 0x65, 0x6d,
	0x6f, 0x42, 0x02, 0x68, 0x00, 0x12, 0x59, 0x0a, 0x11, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x5f, 0x61,
	0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x28,
	0x2e, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x61, 0x6c, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x6d,
	0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x41, 0x74, 0x74, 0x72,
	0x69, 0x62, 0x75, 0x74, 0x65, 0x73, 0x52, 0x10, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x41, 0x74, 0x74,
	0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x73, 0x42, 0x02, 0x68, 0x00, 0x12, 0x42, 0x0a, 0x04, 0x69, 0x6e,
	0x66, 0x6f, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72,
	0x61, 0x6c, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x2e, 0x76,
	0x31, 0x2e, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x4c, 0x69, 0x73, 0x74, 0x49, 0x6e, 0x66,
	0x6f, 0x52, 0x04, 0x69, 0x6e, 0x66, 0x6f, 0x42, 0x02, 0x68, 0x00, 0x42, 0x93, 0x01, 0x0a, 0x1b, 0x69,
	0x6f, 0x2e, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x61, 0x6c, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x73, 0x63,
	0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x42, 0x0c, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67,
	0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x50, 0x01, 0x5a, 0x27, 0x67, 0x6f, 0x2e, 0x74, 0x65, 0x6d, 0x70,
	0x6f, 0x72, 0x61, 0x6c, 0x2e, 0x69, 0x6f, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x73, 0x63, 0x68, 0x65, 0x64,
	0x75, 0x6c, 0x65, 0x2f, 0x76, 0x31, 0x3b, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0xaa, 0x02,
	0x1a, 0x54, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x61, 0x6c, 0x69, 0x6f, 0x2e, 0x41, 0x70, 0x69, 0x2e, 0x53,
	0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x2e, 0x56, 0x31, 0xea, 0x02, 0x1d, 0x54, 0x65, 0x6d, 0x70,
	0x6f, 0x72, 0x61, 0x6c, 0x69, 0x6f, 0x3a, 0x3a, 0x41, 0x70, 0x69, 0x3a, 0x3a, 0x53, 0x63, 0x68, 0x65,
	0x64, 0x75, 0x6c, 0x65, 0x3a, 0x3a, 0x56, 0x31, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_temporal_api_schedule_v1_message_proto_rawDescOnce sync.Once
	file_temporal_api_schedule_v1_message_proto_rawDescData = file_temporal_api_schedule_v1_message_proto_rawDesc
)

func file_temporal_api_schedule_v1_message_proto_rawDescGZIP() []byte {
	file_temporal_api_schedule_v1_message_proto_rawDescOnce.Do(func() {
		file_temporal_api_schedule_v1_message_proto_rawDescData = protoimpl.X.CompressGZIP(file_temporal_api_schedule_v1_message_proto_rawDescData)
	})
	return file_temporal_api_schedule_v1_message_proto_rawDescData
}

var file_temporal_api_schedule_v1_message_proto_msgTypes = make([]protoimpl.MessageInfo, 16)
var file_temporal_api_schedule_v1_message_proto_goTypes = []any{
	(*CalendarSpec)(nil),                 // 0: temporal.api.schedule.v1.CalendarSpec
	(*Range)(nil),                        // 1: temporal.api.schedule.v1.Range
	(*StructuredCalendarSpec)(nil),       // 2: temporal.api.schedule.v1.StructuredCalendarSpec
	(*IntervalSpec)(nil),                 // 3: temporal.api.schedule.v1.IntervalSpec
	(*ScheduleSpec)(nil),                 // 4: temporal.api.schedule.v1.ScheduleSpec
	(*SchedulePolicies)(nil),             // 5: temporal.api.schedule.v1.SchedulePolicies
	(*ScheduleAction)(nil),               // 6: temporal.api.schedule.v1.ScheduleAction
	(*ScheduleActionResult)(nil),         // 7: temporal.api.schedule.v1.ScheduleActionResult
	(*ScheduleState)(nil),                // 8: temporal.api.schedule.v1.ScheduleState
	(*TriggerImmediatelyRequest)(nil),    // 9: temporal.api.schedule.v1.TriggerImmediatelyRequest
	(*BackfillRequest)(nil),              // 10: temporal.api.schedule.v1.BackfillRequest
	(*SchedulePatch)(nil),                // 11: temporal.api.schedule.v1.SchedulePatch
	(*ScheduleInfo)(nil),                 // 12: temporal.api.schedule.v1.ScheduleInfo
	(*Schedule)(nil),                     // 13: temporal.api.schedule.v1.Schedule
	(*ScheduleListInfo)(nil),             // 14: temporal.api.schedule.v1.ScheduleListInfo
	(*ScheduleListEntry)(nil),            // 15: temporal.api.schedule.v1.ScheduleListEntry
	(*durationpb.Duration)(nil),          // 16: google.protobuf.Duration
	(*timestamppb.Timestamp)(nil),        // 17: google.protobuf.Timestamp
	(v1.ScheduleOverlapPolicy)(0),        // 18: temporal.api.enums.v1.ScheduleOverlapPolicy
	(*v11.NewWorkflowExecutionInfo)(nil), // 19: temporal.api.workflow.v1.NewWorkflowExecutionInfo
	(*v12.WorkflowExecution)(nil),        // 20: temporal.api.common.v1.WorkflowExecution
	(v1.WorkflowExecutionStatus)(0),      // 21: temporal.api.enums.v1.WorkflowExecutionStatus
	(*v12.WorkflowType)(nil),             // 22: temporal.api.common.v1.WorkflowType
	(*v12.Memo)(nil),                     // 23: temporal.api.common.v1.Memo
	(*v12.SearchAttributes)(nil),         // 24: temporal.api.common.v1.SearchAttributes
}
var file_temporal_api_schedule_v1_message_proto_depIdxs = []int32{
	1,  // 0: temporal.api.schedule.v1.StructuredCalendarSpec.second:type_name -> temporal.api.schedule.v1.Range
	1,  // 1: temporal.api.schedule.v1.StructuredCalendarSpec.minute:type_name -> temporal.api.schedule.v1.Range
	1,  // 2: temporal.api.schedule.v1.StructuredCalendarSpec.hour:type_name -> temporal.api.schedule.v1.Range
	1,  // 3: temporal.api.schedule.v1.StructuredCalendarSpec.day_of_month:type_name -> temporal.api.schedule.v1.Range
	1,  // 4: temporal.api.schedule.v1.StructuredCalendarSpec.month:type_name -> temporal.api.schedule.v1.Range
	1,  // 5: temporal.api.schedule.v1.StructuredCalendarSpec.year:type_name -> temporal.api.schedule.v1.Range
	1,  // 6: temporal.api.schedule.v1.StructuredCalendarSpec.day_of_week:type_name -> temporal.api.schedule.v1.Range
	16, // 7: temporal.api.schedule.v1.IntervalSpec.interval:type_name -> google.protobuf.Duration
	16, // 8: temporal.api.schedule.v1.IntervalSpec.phase:type_name -> google.protobuf.Duration
	2,  // 9: temporal.api.schedule.v1.ScheduleSpec.structured_calendar:type_name -> temporal.api.schedule.v1.StructuredCalendarSpec
	0,  // 10: temporal.api.schedule.v1.ScheduleSpec.calendar:type_name -> temporal.api.schedule.v1.CalendarSpec
	3,  // 11: temporal.api.schedule.v1.ScheduleSpec.interval:type_name -> temporal.api.schedule.v1.IntervalSpec
	0,  // 12: temporal.api.schedule.v1.ScheduleSpec.exclude_calendar:type_name -> temporal.api.schedule.v1.CalendarSpec
	2,  // 13: temporal.api.schedule.v1.ScheduleSpec.exclude_structured_calendar:type_name -> temporal.api.schedule.v1.StructuredCalendarSpec
	17, // 14: temporal.api.schedule.v1.ScheduleSpec.start_time:type_name -> google.protobuf.Timestamp
	17, // 15: temporal.api.schedule.v1.ScheduleSpec.end_time:type_name -> google.protobuf.Timestamp
	16, // 16: temporal.api.schedule.v1.ScheduleSpec.jitter:type_name -> google.protobuf.Duration
	18, // 17: temporal.api.schedule.v1.SchedulePolicies.overlap_policy:type_name -> temporal.api.enums.v1.ScheduleOverlapPolicy
	16, // 18: temporal.api.schedule.v1.SchedulePolicies.catchup_window:type_name -> google.protobuf.Duration
	19, // 19: temporal.api.schedule.v1.ScheduleAction.start_workflow:type_name -> temporal.api.workflow.v1.NewWorkflowExecutionInfo
	17, // 20: temporal.api.schedule.v1.ScheduleActionResult.schedule_time:type_name -> google.protobuf.Timestamp
	17, // 21: temporal.api.schedule.v1.ScheduleActionResult.actual_time:type_name -> google.protobuf.Timestamp
	20, // 22: temporal.api.schedule.v1.ScheduleActionResult.start_workflow_result:type_name -> temporal.api.common.v1.WorkflowExecution
	21, // 23: temporal.api.schedule.v1.ScheduleActionResult.start_workflow_status:type_name -> temporal.api.enums.v1.WorkflowExecutionStatus
	18, // 24: temporal.api.schedule.v1.TriggerImmediatelyRequest.overlap_policy:type_name -> temporal.api.enums.v1.ScheduleOverlapPolicy
	17, // 25: temporal.api.schedule.v1.BackfillRequest.start_time:type_name -> google.protobuf.Timestamp
	17, // 26: temporal.api.schedule.v1.BackfillRequest.end_time:type_name -> google.protobuf.Timestamp
	18, // 27: temporal.api.schedule.v1.BackfillRequest.overlap_policy:type_name -> temporal.api.enums.v1.ScheduleOverlapPolicy
	9,  // 28: temporal.api.schedule.v1.SchedulePatch.trigger_immediately:type_name -> temporal.api.schedule.v1.TriggerImmediatelyRequest
	10, // 29: temporal.api.schedule.v1.SchedulePatch.backfill_request:type_name -> temporal.api.schedule.v1.BackfillRequest
	20, // 30: temporal.api.schedule.v1.ScheduleInfo.running_workflows:type_name -> temporal.api.common.v1.WorkflowExecution
	7,  // 31: temporal.api.schedule.v1.ScheduleInfo.recent_actions:type_name -> temporal.api.schedule.v1.ScheduleActionResult
	17, // 32: temporal.api.schedule.v1.ScheduleInfo.future_action_times:type_name -> google.protobuf.Timestamp
	17, // 33: temporal.api.schedule.v1.ScheduleInfo.create_time:type_name -> google.protobuf.Timestamp
	17, // 34: temporal.api.schedule.v1.ScheduleInfo.update_time:type_name -> google.protobuf.Timestamp
	4,  // 35: temporal.api.schedule.v1.Schedule.spec:type_name -> temporal.api.schedule.v1.ScheduleSpec
	6,  // 36: temporal.api.schedule.v1.Schedule.action:type_name -> temporal.api.schedule.v1.ScheduleAction
	5,  // 37: temporal.api.schedule.v1.Schedule.policies:type_name -> temporal.api.schedule.v1.SchedulePolicies
	8,  // 38: temporal.api.schedule.v1.Schedule.state:type_name -> temporal.api.schedule.v1.ScheduleState
	4,  // 39: temporal.api.schedule.v1.ScheduleListInfo.spec:type_name -> temporal.api.schedule.v1.ScheduleSpec
	22, // 40: temporal.api.schedule.v1.ScheduleListInfo.workflow_type:type_name -> temporal.api.common.v1.WorkflowType
	7,  // 41: temporal.api.schedule.v1.ScheduleListInfo.recent_actions:type_name -> temporal.api.schedule.v1.ScheduleActionResult
	17, // 42: temporal.api.schedule.v1.ScheduleListInfo.future_action_times:type_name -> google.protobuf.Timestamp
	23, // 43: temporal.api.schedule.v1.ScheduleListEntry.memo:type_name -> temporal.api.common.v1.Memo
	24, // 44: temporal.api.schedule.v1.ScheduleListEntry.search_attributes:type_name -> temporal.api.common.v1.SearchAttributes
	14, // 45: temporal.api.schedule.v1.ScheduleListEntry.info:type_name -> temporal.api.schedule.v1.ScheduleListInfo
	46, // [46:46] is the sub-list for method output_type
	46, // [46:46] is the sub-list for method input_type
	46, // [46:46] is the sub-list for extension type_name
	46, // [46:46] is the sub-list for extension extendee
	0,  // [0:46] is the sub-list for field type_name
}

func init() { file_temporal_api_schedule_v1_message_proto_init() }
func file_temporal_api_schedule_v1_message_proto_init() {
	if File_temporal_api_schedule_v1_message_proto != nil {
		return
	}
	file_temporal_api_schedule_v1_message_proto_msgTypes[6].OneofWrappers = []any{
		(*ScheduleAction_StartWorkflow)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_temporal_api_schedule_v1_message_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   16,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_temporal_api_schedule_v1_message_proto_goTypes,
		DependencyIndexes: file_temporal_api_schedule_v1_message_proto_depIdxs,
		MessageInfos:      file_temporal_api_schedule_v1_message_proto_msgTypes,
	}.Build()
	File_temporal_api_schedule_v1_message_proto = out.File
	file_temporal_api_schedule_v1_message_proto_rawDesc = nil
	file_temporal_api_schedule_v1_message_proto_goTypes = nil
	file_temporal_api_schedule_v1_message_proto_depIdxs = nil
}
