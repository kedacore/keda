// The MIT License
//
// Copyright (c) 2022 Temporal Technologies Inc.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: temporal/api/schedule/v1/message.proto

package schedule

import (
	bytes "bytes"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
	time "time"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	v12 "go.temporal.io/api/common/v1"
	v1 "go.temporal.io/api/enums/v1"
	v11 "go.temporal.io/api/workflow/v1"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// CalendarSpec describes an event specification relative to the calendar,
// similar to a traditional cron specification, but with labeled fields. Each
// field can be one of:
//   *: matches always
//   x: matches when the field equals x
//   x/y : matches when the field equals x+n*y where n is an integer
//   x-z: matches when the field is between x and z inclusive
//   w,x,y,...: matches when the field is one of the listed values
// Each x, y, z, ... is either a decimal integer, or a month or day of week name
// or abbreviation (in the appropriate fields).
// A timestamp matches if all fields match.
// Note that fields have different default values, for convenience.
// Note that the special case that some cron implementations have for treating
// day_of_month and day_of_week as "or" instead of "and" when both are set is
// not implemented.
// day_of_week can accept 0 or 7 as Sunday
// CalendarSpec gets compiled into StructuredCalendarSpec, which is what will be
// returned if you describe the schedule.
type CalendarSpec struct {
	// Expression to match seconds. Default: 0
	Second string `protobuf:"bytes,1,opt,name=second,proto3" json:"second,omitempty"`
	// Expression to match minutes. Default: 0
	Minute string `protobuf:"bytes,2,opt,name=minute,proto3" json:"minute,omitempty"`
	// Expression to match hours. Default: 0
	Hour string `protobuf:"bytes,3,opt,name=hour,proto3" json:"hour,omitempty"`
	// Expression to match days of the month. Default: *
	// (-- api-linter: core::0140::prepositions=disabled
	//     aip.dev/not-precedent: standard name of field --)
	DayOfMonth string `protobuf:"bytes,4,opt,name=day_of_month,json=dayOfMonth,proto3" json:"day_of_month,omitempty"`
	// Expression to match months. Default: *
	Month string `protobuf:"bytes,5,opt,name=month,proto3" json:"month,omitempty"`
	// Expression to match years. Default: *
	Year string `protobuf:"bytes,6,opt,name=year,proto3" json:"year,omitempty"`
	// Expression to match days of the week. Default: *
	DayOfWeek string `protobuf:"bytes,7,opt,name=day_of_week,json=dayOfWeek,proto3" json:"day_of_week,omitempty"`
	// Free-form comment describing the intention of this spec.
	Comment string `protobuf:"bytes,8,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *CalendarSpec) Reset()      { *m = CalendarSpec{} }
func (*CalendarSpec) ProtoMessage() {}
func (*CalendarSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6aeef3f4b308dee, []int{0}
}
func (m *CalendarSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CalendarSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CalendarSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CalendarSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CalendarSpec.Merge(m, src)
}
func (m *CalendarSpec) XXX_Size() int {
	return m.Size()
}
func (m *CalendarSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CalendarSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CalendarSpec proto.InternalMessageInfo

func (m *CalendarSpec) GetSecond() string {
	if m != nil {
		return m.Second
	}
	return ""
}

func (m *CalendarSpec) GetMinute() string {
	if m != nil {
		return m.Minute
	}
	return ""
}

func (m *CalendarSpec) GetHour() string {
	if m != nil {
		return m.Hour
	}
	return ""
}

func (m *CalendarSpec) GetDayOfMonth() string {
	if m != nil {
		return m.DayOfMonth
	}
	return ""
}

func (m *CalendarSpec) GetMonth() string {
	if m != nil {
		return m.Month
	}
	return ""
}

func (m *CalendarSpec) GetYear() string {
	if m != nil {
		return m.Year
	}
	return ""
}

func (m *CalendarSpec) GetDayOfWeek() string {
	if m != nil {
		return m.DayOfWeek
	}
	return ""
}

func (m *CalendarSpec) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

// Range represents a set of integer values, used to match fields of a calendar
// time in StructuredCalendarSpec. If end < start, then end is interpreted as
// equal to start. This means you can use a Range with start set to a value, and
// end and step unset (defaulting to 0) to represent a single value.
type Range struct {
	// Start of range (inclusive).
	Start int32 `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	// End of range (inclusive).
	End int32 `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	// Step (optional, default 1).
	Step int32 `protobuf:"varint,3,opt,name=step,proto3" json:"step,omitempty"`
}

func (m *Range) Reset()      { *m = Range{} }
func (*Range) ProtoMessage() {}
func (*Range) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6aeef3f4b308dee, []int{1}
}
func (m *Range) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Range.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Range) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Range.Merge(m, src)
}
func (m *Range) XXX_Size() int {
	return m.Size()
}
func (m *Range) XXX_DiscardUnknown() {
	xxx_messageInfo_Range.DiscardUnknown(m)
}

var xxx_messageInfo_Range proto.InternalMessageInfo

func (m *Range) GetStart() int32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *Range) GetEnd() int32 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *Range) GetStep() int32 {
	if m != nil {
		return m.Step
	}
	return 0
}

// StructuredCalendarSpec describes an event specification relative to the
// calendar, in a form that's easy to work with programmatically. Each field can
// be one or more ranges.
// A timestamp matches if at least one range of each field matches the
// corresponding fields of the timestamp, except for year: if year is missing,
// that means all years match. For all fields besides year, at least one Range
// must be present to match anything.
// TODO: add relative-to-end-of-month
// TODO: add nth day-of-week in month
type StructuredCalendarSpec struct {
	// Match seconds (0-59)
	Second []*Range `protobuf:"bytes,1,rep,name=second,proto3" json:"second,omitempty"`
	// Match minutes (0-59)
	Minute []*Range `protobuf:"bytes,2,rep,name=minute,proto3" json:"minute,omitempty"`
	// Match hours (0-23)
	Hour []*Range `protobuf:"bytes,3,rep,name=hour,proto3" json:"hour,omitempty"`
	// Match days of the month (1-31)
	// (-- api-linter: core::0140::prepositions=disabled
	//     aip.dev/not-precedent: standard name of field --)
	DayOfMonth []*Range `protobuf:"bytes,4,rep,name=day_of_month,json=dayOfMonth,proto3" json:"day_of_month,omitempty"`
	// Match months (1-12)
	Month []*Range `protobuf:"bytes,5,rep,name=month,proto3" json:"month,omitempty"`
	// Match years.
	Year []*Range `protobuf:"bytes,6,rep,name=year,proto3" json:"year,omitempty"`
	// Match days of the week (0-6; 0 is Sunday).
	DayOfWeek []*Range `protobuf:"bytes,7,rep,name=day_of_week,json=dayOfWeek,proto3" json:"day_of_week,omitempty"`
	// Free-form comment describing the intention of this spec.
	Comment string `protobuf:"bytes,8,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *StructuredCalendarSpec) Reset()      { *m = StructuredCalendarSpec{} }
func (*StructuredCalendarSpec) ProtoMessage() {}
func (*StructuredCalendarSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6aeef3f4b308dee, []int{2}
}
func (m *StructuredCalendarSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StructuredCalendarSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StructuredCalendarSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StructuredCalendarSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StructuredCalendarSpec.Merge(m, src)
}
func (m *StructuredCalendarSpec) XXX_Size() int {
	return m.Size()
}
func (m *StructuredCalendarSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_StructuredCalendarSpec.DiscardUnknown(m)
}

var xxx_messageInfo_StructuredCalendarSpec proto.InternalMessageInfo

func (m *StructuredCalendarSpec) GetSecond() []*Range {
	if m != nil {
		return m.Second
	}
	return nil
}

func (m *StructuredCalendarSpec) GetMinute() []*Range {
	if m != nil {
		return m.Minute
	}
	return nil
}

func (m *StructuredCalendarSpec) GetHour() []*Range {
	if m != nil {
		return m.Hour
	}
	return nil
}

func (m *StructuredCalendarSpec) GetDayOfMonth() []*Range {
	if m != nil {
		return m.DayOfMonth
	}
	return nil
}

func (m *StructuredCalendarSpec) GetMonth() []*Range {
	if m != nil {
		return m.Month
	}
	return nil
}

func (m *StructuredCalendarSpec) GetYear() []*Range {
	if m != nil {
		return m.Year
	}
	return nil
}

func (m *StructuredCalendarSpec) GetDayOfWeek() []*Range {
	if m != nil {
		return m.DayOfWeek
	}
	return nil
}

func (m *StructuredCalendarSpec) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

// IntervalSpec matches times that can be expressed as:
// epoch + n * interval + phase
// where n is an integer.
// phase defaults to zero if missing. interval is required.
// Both interval and phase must be non-negative and are truncated to the nearest
// second before any calculations.
// For example, an interval of 1 hour with phase of zero would match every hour,
// on the hour. The same interval but a phase of 19 minutes would match every
// xx:19:00. An interval of 28 days with phase zero would match
// 2022-02-17T00:00:00Z (among other times). The same interval with a phase of 3
// days, 5 hours, and 23 minutes would match 2022-02-20T05:23:00Z instead.
type IntervalSpec struct {
	Interval *time.Duration `protobuf:"bytes,1,opt,name=interval,proto3,stdduration" json:"interval,omitempty"`
	Phase    *time.Duration `protobuf:"bytes,2,opt,name=phase,proto3,stdduration" json:"phase,omitempty"`
}

func (m *IntervalSpec) Reset()      { *m = IntervalSpec{} }
func (*IntervalSpec) ProtoMessage() {}
func (*IntervalSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6aeef3f4b308dee, []int{3}
}
func (m *IntervalSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IntervalSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IntervalSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IntervalSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IntervalSpec.Merge(m, src)
}
func (m *IntervalSpec) XXX_Size() int {
	return m.Size()
}
func (m *IntervalSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_IntervalSpec.DiscardUnknown(m)
}

var xxx_messageInfo_IntervalSpec proto.InternalMessageInfo

func (m *IntervalSpec) GetInterval() *time.Duration {
	if m != nil {
		return m.Interval
	}
	return nil
}

func (m *IntervalSpec) GetPhase() *time.Duration {
	if m != nil {
		return m.Phase
	}
	return nil
}

// ScheduleSpec is a complete description of a set of absolute timestamps
// (possibly infinite) that an action should occur at. The meaning of a
// ScheduleSpec depends only on its contents and never changes, except that the
// definition of a time zone can change over time (most commonly, when daylight
// saving time policy changes for an area). To create a totally self-contained
// ScheduleSpec, use UTC or include timezone_data.
//
// For input, you can provide zero or more of: structured_calendar, calendar,
// cron_string, interval, and exclude_structured_calendar, and all of them will
// be used (the schedule will take action at the union of all of their times,
// minus the ones that match exclude_structured_calendar).
//
// On input, calendar and cron_string fields will be compiled into
// structured_calendar (and maybe interval and timezone_name), so if you
// Describe a schedule, you'll see only structured_calendar, interval, etc.
type ScheduleSpec struct {
	// Calendar-based specifications of times.
	StructuredCalendar []*StructuredCalendarSpec `protobuf:"bytes,7,rep,name=structured_calendar,json=structuredCalendar,proto3" json:"structured_calendar,omitempty"`
	// cron_string holds a traditional cron specification as a string. It
	// accepts 5, 6, or 7 fields, separated by spaces, and interprets them the
	// same way as CalendarSpec.
	// 5 fields:         minute, hour, day_of_month, month, day_of_week
	// 6 fields:         minute, hour, day_of_month, month, day_of_week, year
	// 7 fields: second, minute, hour, day_of_month, month, day_of_week, year
	// If year is not given, it defaults to *. If second is not given, it
	// defaults to 0.
	// Shorthands @yearly, @monthly, @weekly, @daily, and @hourly are also
	// accepted instead of the 5-7 time fields.
	// Optionally, the string can be preceded by CRON_TZ=<timezone name> or
	// TZ=<timezone name>, which will get copied to timezone_name. (There must
	// not also be a timezone_name present.)
	// Optionally "#" followed by a comment can appear at the end of the string.
	// Note that the special case that some cron implementations have for
	// treating day_of_month and day_of_week as "or" instead of "and" when both
	// are set is not implemented.
	// @every <interval>[/<phase>] is accepted and gets compiled into an
	// IntervalSpec instead. <interval> and <phase> should be a decimal integer
	// with a unit suffix s, m, h, or d.
	CronString []string `protobuf:"bytes,8,rep,name=cron_string,json=cronString,proto3" json:"cron_string,omitempty"`
	// Calendar-based specifications of times.
	Calendar []*CalendarSpec `protobuf:"bytes,1,rep,name=calendar,proto3" json:"calendar,omitempty"`
	// Interval-based specifications of times.
	Interval []*IntervalSpec `protobuf:"bytes,2,rep,name=interval,proto3" json:"interval,omitempty"`
	// Any timestamps matching any of exclude_* will be skipped.
	ExcludeCalendar           []*CalendarSpec           `protobuf:"bytes,3,rep,name=exclude_calendar,json=excludeCalendar,proto3" json:"exclude_calendar,omitempty"` // Deprecated: Do not use.
	ExcludeStructuredCalendar []*StructuredCalendarSpec `protobuf:"bytes,9,rep,name=exclude_structured_calendar,json=excludeStructuredCalendar,proto3" json:"exclude_structured_calendar,omitempty"`
	// If start_time is set, any timestamps before start_time will be skipped.
	// (Together, start_time and end_time make an inclusive interval.)
	StartTime *time.Time `protobuf:"bytes,4,opt,name=start_time,json=startTime,proto3,stdtime" json:"start_time,omitempty"`
	// If end_time is set, any timestamps after end_time will be skipped.
	EndTime *time.Time `protobuf:"bytes,5,opt,name=end_time,json=endTime,proto3,stdtime" json:"end_time,omitempty"`
	// All timestamps will be incremented by a random value from 0 to this
	// amount of jitter. Default: 0
	Jitter *time.Duration `protobuf:"bytes,6,opt,name=jitter,proto3,stdduration" json:"jitter,omitempty"`
	// Time zone to interpret all calendar-based specs in.
	//
	// If unset, defaults to UTC. We recommend using UTC for your application if
	// at all possible, to avoid various surprising properties of time zones.
	//
	// Time zones may be provided by name, corresponding to names in the IANA
	// time zone database (see https://www.iana.org/time-zones). The definition
	// will be loaded by the Temporal server from the environment it runs in.
	//
	// If your application requires more control over the time zone definition
	// used, it may pass in a complete definition in the form of a TZif file
	// from the time zone database. If present, this will be used instead of
	// loading anything from the environment. You are then responsible for
	// updating timezone_data when the definition changes.
	//
	// Calendar spec matching is based on literal matching of the clock time
	// with no special handling of DST: if you write a calendar spec that fires
	// at 2:30am and specify a time zone that follows DST, that action will not
	// be triggered on the day that has no 2:30am. Similarly, an action that
	// fires at 1:30am will be triggered twice on the day that has two 1:30s.
	//
	// Also note that no actions are taken on leap-seconds (e.g. 23:59:60 UTC).
	TimezoneName string `protobuf:"bytes,10,opt,name=timezone_name,json=timezoneName,proto3" json:"timezone_name,omitempty"`
	TimezoneData []byte `protobuf:"bytes,11,opt,name=timezone_data,json=timezoneData,proto3" json:"timezone_data,omitempty"`
}

func (m *ScheduleSpec) Reset()      { *m = ScheduleSpec{} }
func (*ScheduleSpec) ProtoMessage() {}
func (*ScheduleSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6aeef3f4b308dee, []int{4}
}
func (m *ScheduleSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScheduleSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScheduleSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScheduleSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScheduleSpec.Merge(m, src)
}
func (m *ScheduleSpec) XXX_Size() int {
	return m.Size()
}
func (m *ScheduleSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ScheduleSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ScheduleSpec proto.InternalMessageInfo

func (m *ScheduleSpec) GetStructuredCalendar() []*StructuredCalendarSpec {
	if m != nil {
		return m.StructuredCalendar
	}
	return nil
}

func (m *ScheduleSpec) GetCronString() []string {
	if m != nil {
		return m.CronString
	}
	return nil
}

func (m *ScheduleSpec) GetCalendar() []*CalendarSpec {
	if m != nil {
		return m.Calendar
	}
	return nil
}

func (m *ScheduleSpec) GetInterval() []*IntervalSpec {
	if m != nil {
		return m.Interval
	}
	return nil
}

// Deprecated: Do not use.
func (m *ScheduleSpec) GetExcludeCalendar() []*CalendarSpec {
	if m != nil {
		return m.ExcludeCalendar
	}
	return nil
}

func (m *ScheduleSpec) GetExcludeStructuredCalendar() []*StructuredCalendarSpec {
	if m != nil {
		return m.ExcludeStructuredCalendar
	}
	return nil
}

func (m *ScheduleSpec) GetStartTime() *time.Time {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *ScheduleSpec) GetEndTime() *time.Time {
	if m != nil {
		return m.EndTime
	}
	return nil
}

func (m *ScheduleSpec) GetJitter() *time.Duration {
	if m != nil {
		return m.Jitter
	}
	return nil
}

func (m *ScheduleSpec) GetTimezoneName() string {
	if m != nil {
		return m.TimezoneName
	}
	return ""
}

func (m *ScheduleSpec) GetTimezoneData() []byte {
	if m != nil {
		return m.TimezoneData
	}
	return nil
}

type SchedulePolicies struct {
	// Policy for overlaps.
	// Note that this can be changed after a schedule has taken some actions,
	// and some changes might produce unintuitive results. In general, the later
	// policy overrides the earlier policy.
	OverlapPolicy v1.ScheduleOverlapPolicy `protobuf:"varint,1,opt,name=overlap_policy,json=overlapPolicy,proto3,enum=temporal.api.enums.v1.ScheduleOverlapPolicy" json:"overlap_policy,omitempty"`
	// Policy for catchups:
	// If the Temporal server misses an action due to one or more components
	// being down, and comes back up, the action will be run if the scheduled
	// time is within this window from the current time.
	// This value defaults to 60 seconds, and can't be less than 10 seconds.
	CatchupWindow *time.Duration `protobuf:"bytes,2,opt,name=catchup_window,json=catchupWindow,proto3,stdduration" json:"catchup_window,omitempty"`
	// If true, and a workflow run fails or times out, turn on "paused".
	// This applies after retry policies: the full chain of retries must fail to
	// trigger a pause here.
	PauseOnFailure bool `protobuf:"varint,3,opt,name=pause_on_failure,json=pauseOnFailure,proto3" json:"pause_on_failure,omitempty"`
}

func (m *SchedulePolicies) Reset()      { *m = SchedulePolicies{} }
func (*SchedulePolicies) ProtoMessage() {}
func (*SchedulePolicies) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6aeef3f4b308dee, []int{5}
}
func (m *SchedulePolicies) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchedulePolicies) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchedulePolicies.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchedulePolicies) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchedulePolicies.Merge(m, src)
}
func (m *SchedulePolicies) XXX_Size() int {
	return m.Size()
}
func (m *SchedulePolicies) XXX_DiscardUnknown() {
	xxx_messageInfo_SchedulePolicies.DiscardUnknown(m)
}

var xxx_messageInfo_SchedulePolicies proto.InternalMessageInfo

func (m *SchedulePolicies) GetOverlapPolicy() v1.ScheduleOverlapPolicy {
	if m != nil {
		return m.OverlapPolicy
	}
	return v1.SCHEDULE_OVERLAP_POLICY_UNSPECIFIED
}

func (m *SchedulePolicies) GetCatchupWindow() *time.Duration {
	if m != nil {
		return m.CatchupWindow
	}
	return nil
}

func (m *SchedulePolicies) GetPauseOnFailure() bool {
	if m != nil {
		return m.PauseOnFailure
	}
	return false
}

type ScheduleAction struct {
	// Types that are valid to be assigned to Action:
	//	*ScheduleAction_StartWorkflow
	Action isScheduleAction_Action `protobuf_oneof:"action"`
}

func (m *ScheduleAction) Reset()      { *m = ScheduleAction{} }
func (*ScheduleAction) ProtoMessage() {}
func (*ScheduleAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6aeef3f4b308dee, []int{6}
}
func (m *ScheduleAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScheduleAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScheduleAction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScheduleAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScheduleAction.Merge(m, src)
}
func (m *ScheduleAction) XXX_Size() int {
	return m.Size()
}
func (m *ScheduleAction) XXX_DiscardUnknown() {
	xxx_messageInfo_ScheduleAction.DiscardUnknown(m)
}

var xxx_messageInfo_ScheduleAction proto.InternalMessageInfo

type isScheduleAction_Action interface {
	isScheduleAction_Action()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ScheduleAction_StartWorkflow struct {
	StartWorkflow *v11.NewWorkflowExecutionInfo `protobuf:"bytes,1,opt,name=start_workflow,json=startWorkflow,proto3,oneof" json:"start_workflow,omitempty"`
}

func (*ScheduleAction_StartWorkflow) isScheduleAction_Action() {}

func (m *ScheduleAction) GetAction() isScheduleAction_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *ScheduleAction) GetStartWorkflow() *v11.NewWorkflowExecutionInfo {
	if x, ok := m.GetAction().(*ScheduleAction_StartWorkflow); ok {
		return x.StartWorkflow
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ScheduleAction) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ScheduleAction_StartWorkflow)(nil),
	}
}

type ScheduleActionResult struct {
	// Time that the action was taken (according to the schedule, including jitter).
	ScheduleTime *time.Time `protobuf:"bytes,1,opt,name=schedule_time,json=scheduleTime,proto3,stdtime" json:"schedule_time,omitempty"`
	// Time that the action was taken (real time).
	ActualTime *time.Time `protobuf:"bytes,2,opt,name=actual_time,json=actualTime,proto3,stdtime" json:"actual_time,omitempty"`
	// If action was start_workflow:
	StartWorkflowResult *v12.WorkflowExecution `protobuf:"bytes,11,opt,name=start_workflow_result,json=startWorkflowResult,proto3" json:"start_workflow_result,omitempty"`
}

func (m *ScheduleActionResult) Reset()      { *m = ScheduleActionResult{} }
func (*ScheduleActionResult) ProtoMessage() {}
func (*ScheduleActionResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6aeef3f4b308dee, []int{7}
}
func (m *ScheduleActionResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScheduleActionResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScheduleActionResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScheduleActionResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScheduleActionResult.Merge(m, src)
}
func (m *ScheduleActionResult) XXX_Size() int {
	return m.Size()
}
func (m *ScheduleActionResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ScheduleActionResult.DiscardUnknown(m)
}

var xxx_messageInfo_ScheduleActionResult proto.InternalMessageInfo

func (m *ScheduleActionResult) GetScheduleTime() *time.Time {
	if m != nil {
		return m.ScheduleTime
	}
	return nil
}

func (m *ScheduleActionResult) GetActualTime() *time.Time {
	if m != nil {
		return m.ActualTime
	}
	return nil
}

func (m *ScheduleActionResult) GetStartWorkflowResult() *v12.WorkflowExecution {
	if m != nil {
		return m.StartWorkflowResult
	}
	return nil
}

type ScheduleState struct {
	// Informative human-readable message with contextual notes, e.g. the reason
	// a schedule is paused. The system may overwrite this message on certain
	// conditions, e.g. when pause-on-failure happens.
	Notes string `protobuf:"bytes,1,opt,name=notes,proto3" json:"notes,omitempty"`
	// If true, do not take any actions based on the schedule spec.
	Paused bool `protobuf:"varint,2,opt,name=paused,proto3" json:"paused,omitempty"`
	// If limited_actions is true, decrement remaining_actions after each
	// action, and do not take any more scheduled actions if remaining_actions
	// is zero. Actions may still be taken by explicit request (i.e. trigger
	// immediately or backfill). Skipped actions (due to overlap policy) do not
	// count against remaining actions.
	LimitedActions   bool  `protobuf:"varint,3,opt,name=limited_actions,json=limitedActions,proto3" json:"limited_actions,omitempty"`
	RemainingActions int64 `protobuf:"varint,4,opt,name=remaining_actions,json=remainingActions,proto3" json:"remaining_actions,omitempty"`
}

func (m *ScheduleState) Reset()      { *m = ScheduleState{} }
func (*ScheduleState) ProtoMessage() {}
func (*ScheduleState) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6aeef3f4b308dee, []int{8}
}
func (m *ScheduleState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScheduleState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScheduleState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScheduleState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScheduleState.Merge(m, src)
}
func (m *ScheduleState) XXX_Size() int {
	return m.Size()
}
func (m *ScheduleState) XXX_DiscardUnknown() {
	xxx_messageInfo_ScheduleState.DiscardUnknown(m)
}

var xxx_messageInfo_ScheduleState proto.InternalMessageInfo

func (m *ScheduleState) GetNotes() string {
	if m != nil {
		return m.Notes
	}
	return ""
}

func (m *ScheduleState) GetPaused() bool {
	if m != nil {
		return m.Paused
	}
	return false
}

func (m *ScheduleState) GetLimitedActions() bool {
	if m != nil {
		return m.LimitedActions
	}
	return false
}

func (m *ScheduleState) GetRemainingActions() int64 {
	if m != nil {
		return m.RemainingActions
	}
	return 0
}

type TriggerImmediatelyRequest struct {
	// Override overlap policy for this one request.
	OverlapPolicy v1.ScheduleOverlapPolicy `protobuf:"varint,1,opt,name=overlap_policy,json=overlapPolicy,proto3,enum=temporal.api.enums.v1.ScheduleOverlapPolicy" json:"overlap_policy,omitempty"`
}

func (m *TriggerImmediatelyRequest) Reset()      { *m = TriggerImmediatelyRequest{} }
func (*TriggerImmediatelyRequest) ProtoMessage() {}
func (*TriggerImmediatelyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6aeef3f4b308dee, []int{9}
}
func (m *TriggerImmediatelyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TriggerImmediatelyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TriggerImmediatelyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TriggerImmediatelyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TriggerImmediatelyRequest.Merge(m, src)
}
func (m *TriggerImmediatelyRequest) XXX_Size() int {
	return m.Size()
}
func (m *TriggerImmediatelyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TriggerImmediatelyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TriggerImmediatelyRequest proto.InternalMessageInfo

func (m *TriggerImmediatelyRequest) GetOverlapPolicy() v1.ScheduleOverlapPolicy {
	if m != nil {
		return m.OverlapPolicy
	}
	return v1.SCHEDULE_OVERLAP_POLICY_UNSPECIFIED
}

type BackfillRequest struct {
	// Time range to evaluate schedule in.
	StartTime *time.Time `protobuf:"bytes,1,opt,name=start_time,json=startTime,proto3,stdtime" json:"start_time,omitempty"`
	EndTime   *time.Time `protobuf:"bytes,2,opt,name=end_time,json=endTime,proto3,stdtime" json:"end_time,omitempty"`
	// Override overlap policy for this request.
	OverlapPolicy v1.ScheduleOverlapPolicy `protobuf:"varint,3,opt,name=overlap_policy,json=overlapPolicy,proto3,enum=temporal.api.enums.v1.ScheduleOverlapPolicy" json:"overlap_policy,omitempty"`
}

func (m *BackfillRequest) Reset()      { *m = BackfillRequest{} }
func (*BackfillRequest) ProtoMessage() {}
func (*BackfillRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6aeef3f4b308dee, []int{10}
}
func (m *BackfillRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackfillRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackfillRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BackfillRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackfillRequest.Merge(m, src)
}
func (m *BackfillRequest) XXX_Size() int {
	return m.Size()
}
func (m *BackfillRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BackfillRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BackfillRequest proto.InternalMessageInfo

func (m *BackfillRequest) GetStartTime() *time.Time {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *BackfillRequest) GetEndTime() *time.Time {
	if m != nil {
		return m.EndTime
	}
	return nil
}

func (m *BackfillRequest) GetOverlapPolicy() v1.ScheduleOverlapPolicy {
	if m != nil {
		return m.OverlapPolicy
	}
	return v1.SCHEDULE_OVERLAP_POLICY_UNSPECIFIED
}

type SchedulePatch struct {
	// If set, trigger one action immediately.
	TriggerImmediately *TriggerImmediatelyRequest `protobuf:"bytes,1,opt,name=trigger_immediately,json=triggerImmediately,proto3" json:"trigger_immediately,omitempty"`
	// If set, runs though the specified time period(s) and takes actions as if that time
	// passed by right now, all at once. The overlap policy can be overridden for the
	// scope of the backfill.
	BackfillRequest []*BackfillRequest `protobuf:"bytes,2,rep,name=backfill_request,json=backfillRequest,proto3" json:"backfill_request,omitempty"`
	// If set, change the state to paused or unpaused (respectively) and set the
	// notes field to the value of the string.
	Pause   string `protobuf:"bytes,3,opt,name=pause,proto3" json:"pause,omitempty"`
	Unpause string `protobuf:"bytes,4,opt,name=unpause,proto3" json:"unpause,omitempty"`
}

func (m *SchedulePatch) Reset()      { *m = SchedulePatch{} }
func (*SchedulePatch) ProtoMessage() {}
func (*SchedulePatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6aeef3f4b308dee, []int{11}
}
func (m *SchedulePatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchedulePatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchedulePatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchedulePatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchedulePatch.Merge(m, src)
}
func (m *SchedulePatch) XXX_Size() int {
	return m.Size()
}
func (m *SchedulePatch) XXX_DiscardUnknown() {
	xxx_messageInfo_SchedulePatch.DiscardUnknown(m)
}

var xxx_messageInfo_SchedulePatch proto.InternalMessageInfo

func (m *SchedulePatch) GetTriggerImmediately() *TriggerImmediatelyRequest {
	if m != nil {
		return m.TriggerImmediately
	}
	return nil
}

func (m *SchedulePatch) GetBackfillRequest() []*BackfillRequest {
	if m != nil {
		return m.BackfillRequest
	}
	return nil
}

func (m *SchedulePatch) GetPause() string {
	if m != nil {
		return m.Pause
	}
	return ""
}

func (m *SchedulePatch) GetUnpause() string {
	if m != nil {
		return m.Unpause
	}
	return ""
}

type ScheduleInfo struct {
	// Number of actions taken so far.
	ActionCount int64 `protobuf:"varint,1,opt,name=action_count,json=actionCount,proto3" json:"action_count,omitempty"`
	// Number of times a scheduled action was skipped due to missing the catchup window.
	MissedCatchupWindow int64 `protobuf:"varint,2,opt,name=missed_catchup_window,json=missedCatchupWindow,proto3" json:"missed_catchup_window,omitempty"`
	// Number of skipped actions due to overlap.
	OverlapSkipped int64 `protobuf:"varint,3,opt,name=overlap_skipped,json=overlapSkipped,proto3" json:"overlap_skipped,omitempty"`
	// Currently-running workflows started by this schedule. (There might be
	// more than one if the overlap policy allows overlaps.)
	// Note that the run_ids in here are the original execution run ids as
	// started by the schedule. If the workflows retried, did continue-as-new,
	// or were reset, they might still be running but with a different run_id.
	RunningWorkflows []*v12.WorkflowExecution `protobuf:"bytes,9,rep,name=running_workflows,json=runningWorkflows,proto3" json:"running_workflows,omitempty"`
	// Most recent ten actual action times (including manual triggers).
	RecentActions []*ScheduleActionResult `protobuf:"bytes,4,rep,name=recent_actions,json=recentActions,proto3" json:"recent_actions,omitempty"`
	// Next ten scheduled action times.
	FutureActionTimes []*time.Time `protobuf:"bytes,5,rep,name=future_action_times,json=futureActionTimes,proto3,stdtime" json:"future_action_times,omitempty"`
	// Timestamps of schedule creation and last update.
	CreateTime           *time.Time `protobuf:"bytes,6,opt,name=create_time,json=createTime,proto3,stdtime" json:"create_time,omitempty"`
	UpdateTime           *time.Time `protobuf:"bytes,7,opt,name=update_time,json=updateTime,proto3,stdtime" json:"update_time,omitempty"`
	InvalidScheduleError string     `protobuf:"bytes,8,opt,name=invalid_schedule_error,json=invalidScheduleError,proto3" json:"invalid_schedule_error,omitempty"` // Deprecated: Do not use.
}

func (m *ScheduleInfo) Reset()      { *m = ScheduleInfo{} }
func (*ScheduleInfo) ProtoMessage() {}
func (*ScheduleInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6aeef3f4b308dee, []int{12}
}
func (m *ScheduleInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScheduleInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScheduleInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScheduleInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScheduleInfo.Merge(m, src)
}
func (m *ScheduleInfo) XXX_Size() int {
	return m.Size()
}
func (m *ScheduleInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ScheduleInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ScheduleInfo proto.InternalMessageInfo

func (m *ScheduleInfo) GetActionCount() int64 {
	if m != nil {
		return m.ActionCount
	}
	return 0
}

func (m *ScheduleInfo) GetMissedCatchupWindow() int64 {
	if m != nil {
		return m.MissedCatchupWindow
	}
	return 0
}

func (m *ScheduleInfo) GetOverlapSkipped() int64 {
	if m != nil {
		return m.OverlapSkipped
	}
	return 0
}

func (m *ScheduleInfo) GetRunningWorkflows() []*v12.WorkflowExecution {
	if m != nil {
		return m.RunningWorkflows
	}
	return nil
}

func (m *ScheduleInfo) GetRecentActions() []*ScheduleActionResult {
	if m != nil {
		return m.RecentActions
	}
	return nil
}

func (m *ScheduleInfo) GetFutureActionTimes() []*time.Time {
	if m != nil {
		return m.FutureActionTimes
	}
	return nil
}

func (m *ScheduleInfo) GetCreateTime() *time.Time {
	if m != nil {
		return m.CreateTime
	}
	return nil
}

func (m *ScheduleInfo) GetUpdateTime() *time.Time {
	if m != nil {
		return m.UpdateTime
	}
	return nil
}

// Deprecated: Do not use.
func (m *ScheduleInfo) GetInvalidScheduleError() string {
	if m != nil {
		return m.InvalidScheduleError
	}
	return ""
}

type Schedule struct {
	Spec     *ScheduleSpec     `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
	Action   *ScheduleAction   `protobuf:"bytes,2,opt,name=action,proto3" json:"action,omitempty"`
	Policies *SchedulePolicies `protobuf:"bytes,3,opt,name=policies,proto3" json:"policies,omitempty"`
	State    *ScheduleState    `protobuf:"bytes,4,opt,name=state,proto3" json:"state,omitempty"`
}

func (m *Schedule) Reset()      { *m = Schedule{} }
func (*Schedule) ProtoMessage() {}
func (*Schedule) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6aeef3f4b308dee, []int{13}
}
func (m *Schedule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Schedule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Schedule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Schedule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Schedule.Merge(m, src)
}
func (m *Schedule) XXX_Size() int {
	return m.Size()
}
func (m *Schedule) XXX_DiscardUnknown() {
	xxx_messageInfo_Schedule.DiscardUnknown(m)
}

var xxx_messageInfo_Schedule proto.InternalMessageInfo

func (m *Schedule) GetSpec() *ScheduleSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Schedule) GetAction() *ScheduleAction {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *Schedule) GetPolicies() *SchedulePolicies {
	if m != nil {
		return m.Policies
	}
	return nil
}

func (m *Schedule) GetState() *ScheduleState {
	if m != nil {
		return m.State
	}
	return nil
}

// ScheduleListInfo is an abbreviated set of values from Schedule and ScheduleInfo
// that's returned in ListSchedules.
type ScheduleListInfo struct {
	// From spec:
	// Some fields are dropped from this copy of spec: timezone_data
	Spec *ScheduleSpec `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
	// From action:
	// Action is a oneof field, but we need to encode this in JSON and oneof fields don't work
	// well with JSON. If action is start_workflow, this is set:
	WorkflowType *v12.WorkflowType `protobuf:"bytes,2,opt,name=workflow_type,json=workflowType,proto3" json:"workflow_type,omitempty"`
	// From state:
	Notes  string `protobuf:"bytes,3,opt,name=notes,proto3" json:"notes,omitempty"`
	Paused bool   `protobuf:"varint,4,opt,name=paused,proto3" json:"paused,omitempty"`
	// From info (maybe fewer entries):
	RecentActions     []*ScheduleActionResult `protobuf:"bytes,5,rep,name=recent_actions,json=recentActions,proto3" json:"recent_actions,omitempty"`
	FutureActionTimes []*time.Time            `protobuf:"bytes,6,rep,name=future_action_times,json=futureActionTimes,proto3,stdtime" json:"future_action_times,omitempty"`
}

func (m *ScheduleListInfo) Reset()      { *m = ScheduleListInfo{} }
func (*ScheduleListInfo) ProtoMessage() {}
func (*ScheduleListInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6aeef3f4b308dee, []int{14}
}
func (m *ScheduleListInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScheduleListInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScheduleListInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScheduleListInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScheduleListInfo.Merge(m, src)
}
func (m *ScheduleListInfo) XXX_Size() int {
	return m.Size()
}
func (m *ScheduleListInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ScheduleListInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ScheduleListInfo proto.InternalMessageInfo

func (m *ScheduleListInfo) GetSpec() *ScheduleSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *ScheduleListInfo) GetWorkflowType() *v12.WorkflowType {
	if m != nil {
		return m.WorkflowType
	}
	return nil
}

func (m *ScheduleListInfo) GetNotes() string {
	if m != nil {
		return m.Notes
	}
	return ""
}

func (m *ScheduleListInfo) GetPaused() bool {
	if m != nil {
		return m.Paused
	}
	return false
}

func (m *ScheduleListInfo) GetRecentActions() []*ScheduleActionResult {
	if m != nil {
		return m.RecentActions
	}
	return nil
}

func (m *ScheduleListInfo) GetFutureActionTimes() []*time.Time {
	if m != nil {
		return m.FutureActionTimes
	}
	return nil
}

// ScheduleListEntry is returned by ListSchedules.
type ScheduleListEntry struct {
	ScheduleId       string                `protobuf:"bytes,1,opt,name=schedule_id,json=scheduleId,proto3" json:"schedule_id,omitempty"`
	Memo             *v12.Memo             `protobuf:"bytes,2,opt,name=memo,proto3" json:"memo,omitempty"`
	SearchAttributes *v12.SearchAttributes `protobuf:"bytes,3,opt,name=search_attributes,json=searchAttributes,proto3" json:"search_attributes,omitempty"`
	Info             *ScheduleListInfo     `protobuf:"bytes,4,opt,name=info,proto3" json:"info,omitempty"`
}

func (m *ScheduleListEntry) Reset()      { *m = ScheduleListEntry{} }
func (*ScheduleListEntry) ProtoMessage() {}
func (*ScheduleListEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6aeef3f4b308dee, []int{15}
}
func (m *ScheduleListEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScheduleListEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScheduleListEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScheduleListEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScheduleListEntry.Merge(m, src)
}
func (m *ScheduleListEntry) XXX_Size() int {
	return m.Size()
}
func (m *ScheduleListEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_ScheduleListEntry.DiscardUnknown(m)
}

var xxx_messageInfo_ScheduleListEntry proto.InternalMessageInfo

func (m *ScheduleListEntry) GetScheduleId() string {
	if m != nil {
		return m.ScheduleId
	}
	return ""
}

func (m *ScheduleListEntry) GetMemo() *v12.Memo {
	if m != nil {
		return m.Memo
	}
	return nil
}

func (m *ScheduleListEntry) GetSearchAttributes() *v12.SearchAttributes {
	if m != nil {
		return m.SearchAttributes
	}
	return nil
}

func (m *ScheduleListEntry) GetInfo() *ScheduleListInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func init() {
	proto.RegisterType((*CalendarSpec)(nil), "temporal.api.schedule.v1.CalendarSpec")
	proto.RegisterType((*Range)(nil), "temporal.api.schedule.v1.Range")
	proto.RegisterType((*StructuredCalendarSpec)(nil), "temporal.api.schedule.v1.StructuredCalendarSpec")
	proto.RegisterType((*IntervalSpec)(nil), "temporal.api.schedule.v1.IntervalSpec")
	proto.RegisterType((*ScheduleSpec)(nil), "temporal.api.schedule.v1.ScheduleSpec")
	proto.RegisterType((*SchedulePolicies)(nil), "temporal.api.schedule.v1.SchedulePolicies")
	proto.RegisterType((*ScheduleAction)(nil), "temporal.api.schedule.v1.ScheduleAction")
	proto.RegisterType((*ScheduleActionResult)(nil), "temporal.api.schedule.v1.ScheduleActionResult")
	proto.RegisterType((*ScheduleState)(nil), "temporal.api.schedule.v1.ScheduleState")
	proto.RegisterType((*TriggerImmediatelyRequest)(nil), "temporal.api.schedule.v1.TriggerImmediatelyRequest")
	proto.RegisterType((*BackfillRequest)(nil), "temporal.api.schedule.v1.BackfillRequest")
	proto.RegisterType((*SchedulePatch)(nil), "temporal.api.schedule.v1.SchedulePatch")
	proto.RegisterType((*ScheduleInfo)(nil), "temporal.api.schedule.v1.ScheduleInfo")
	proto.RegisterType((*Schedule)(nil), "temporal.api.schedule.v1.Schedule")
	proto.RegisterType((*ScheduleListInfo)(nil), "temporal.api.schedule.v1.ScheduleListInfo")
	proto.RegisterType((*ScheduleListEntry)(nil), "temporal.api.schedule.v1.ScheduleListEntry")
}

func init() {
	proto.RegisterFile("temporal/api/schedule/v1/message.proto", fileDescriptor_e6aeef3f4b308dee)
}

var fileDescriptor_e6aeef3f4b308dee = []byte{
	// 1651 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0x5b, 0x6f, 0x1b, 0x4b,
	0x1d, 0xcf, 0xfa, 0x92, 0x38, 0x63, 0x3b, 0x71, 0x26, 0x39, 0x95, 0x9b, 0x03, 0x4e, 0x8e, 0x39,
	0x6a, 0x72, 0x00, 0x39, 0x27, 0x8e, 0x50, 0x51, 0x8e, 0xe0, 0x10, 0xa7, 0xa9, 0x88, 0x44, 0xdb,
	0x68, 0x93, 0xb6, 0x12, 0x08, 0xad, 0x26, 0xbb, 0x63, 0x67, 0xc8, 0xee, 0xcc, 0xb2, 0x3b, 0x1b,
	0xd7, 0x3c, 0x21, 0xbe, 0x00, 0x95, 0x78, 0xe1, 0x23, 0x20, 0xbe, 0x08, 0xf0, 0x44, 0x1f, 0xcb,
	0x13, 0x34, 0xed, 0x03, 0xe2, 0xa9, 0xef, 0x08, 0x81, 0xe6, 0xb6, 0xb6, 0xe3, 0x98, 0x6c, 0x5b,
	0xf5, 0x6d, 0xe7, 0x7f, 0x9b, 0xf9, 0xff, 0xfe, 0x57, 0x1b, 0xdc, 0xe1, 0x38, 0x08, 0x59, 0x84,
	0xfc, 0x2d, 0x14, 0x92, 0xad, 0xd8, 0x3d, 0xc3, 0x5e, 0xe2, 0xe3, 0xad, 0x8b, 0xed, 0xad, 0x00,
	0xc7, 0x31, 0xea, 0xe1, 0x56, 0x18, 0x31, 0xce, 0x60, 0xdd, 0xc8, 0xb5, 0x50, 0x48, 0x5a, 0x46,
	0xae, 0x75, 0xb1, 0xbd, 0xda, 0xe8, 0x31, 0xd6, 0xf3, 0xf1, 0x96, 0x94, 0x3b, 0x4d, 0xba, 0x5b,
	0x5e, 0x12, 0x21, 0x4e, 0x18, 0x55, 0x9a, 0xab, 0x6b, 0x57, 0xf9, 0x9c, 0x04, 0x38, 0xe6, 0x28,
	0x08, 0xb5, 0xc0, 0x67, 0x1e, 0x0e, 0x31, 0xf5, 0x30, 0x75, 0x09, 0x8e, 0xb7, 0x7a, 0xac, 0xc7,
	0x24, 0x5d, 0x7e, 0x69, 0x91, 0xcf, 0xc7, 0x5e, 0xe9, 0xb2, 0x20, 0x60, 0x74, 0xe2, 0x8d, 0x57,
	0xa4, 0x30, 0x4d, 0x82, 0x58, 0x08, 0xa5, 0x8f, 0x55, 0x52, 0xe3, 0x1e, 0xf7, 0x59, 0x74, 0xde,
	0xf5, 0x59, 0x7f, 0xc2, 0x5a, 0xf3, 0xa5, 0x05, 0x2a, 0xfb, 0xc8, 0xc7, 0xd4, 0x43, 0xd1, 0x71,
	0x88, 0x5d, 0x78, 0x0b, 0xcc, 0xc6, 0xd8, 0x65, 0xd4, 0xab, 0x5b, 0xeb, 0xd6, 0xe6, 0xbc, 0xad,
	0x4f, 0x82, 0x1e, 0x10, 0x9a, 0x70, 0x5c, 0xcf, 0x29, 0xba, 0x3a, 0x41, 0x08, 0x0a, 0x67, 0x2c,
	0x89, 0xea, 0x79, 0x49, 0x95, 0xdf, 0x70, 0x1d, 0x54, 0x3c, 0x34, 0x70, 0x58, 0xd7, 0x09, 0x18,
	0xe5, 0x67, 0xf5, 0x82, 0xe4, 0x01, 0x0f, 0x0d, 0x1e, 0x75, 0x1f, 0x08, 0x0a, 0x5c, 0x01, 0x45,
	0xc5, 0x2a, 0x4a, 0x96, 0x3a, 0x08, 0x5b, 0x03, 0x8c, 0xa2, 0xfa, 0xac, 0xb2, 0x25, 0xbe, 0x61,
	0x03, 0x94, 0xb5, 0xad, 0x3e, 0xc6, 0xe7, 0xf5, 0x39, 0xc9, 0x9a, 0x97, 0xa6, 0x9e, 0x62, 0x7c,
	0x0e, 0xeb, 0x60, 0x4e, 0x20, 0x85, 0x29, 0xaf, 0x97, 0x24, 0xcf, 0x1c, 0x9b, 0xfb, 0xa0, 0x68,
	0x23, 0xda, 0xc3, 0xe2, 0xb2, 0x98, 0xa3, 0x88, 0x4b, 0x8f, 0x8a, 0xb6, 0x3a, 0xc0, 0x1a, 0xc8,
	0x63, 0xea, 0x49, 0x6f, 0x8a, 0xb6, 0xf8, 0x14, 0xd7, 0xc7, 0x1c, 0x87, 0xd2, 0x95, 0xa2, 0x2d,
	0xbf, 0x9b, 0x7f, 0xc9, 0x83, 0x5b, 0xc7, 0x3c, 0x4a, 0x5c, 0x9e, 0x44, 0xd8, 0x1b, 0x43, 0xea,
	0xee, 0x08, 0x52, 0xf9, 0xcd, 0x72, 0x7b, 0xad, 0x35, 0x2d, 0x7b, 0x5a, 0xf2, 0x1d, 0x29, 0x94,
	0x77, 0x47, 0xa0, 0xcc, 0xa6, 0xa8, 0xb1, 0xde, 0x49, 0xb1, 0xce, 0xa4, 0xa6, 0x82, 0xb1, 0x37,
	0x11, 0x8c, 0x4c, 0xca, 0xa3, 0xd1, 0xfa, 0xde, 0x30, 0x5a, 0x99, 0x74, 0x75, 0x38, 0x77, 0xd2,
	0x70, 0x66, 0x7b, 0xae, 0x8c, 0xf7, 0xd7, 0x57, 0xe3, 0x9d, 0x49, 0x37, 0x53, 0x42, 0xfc, 0xc6,
	0x02, 0x95, 0x43, 0xca, 0x71, 0x74, 0x81, 0x7c, 0x19, 0xc1, 0xaf, 0x40, 0x89, 0xe8, 0xb3, 0xcc,
	0x8d, 0x72, 0xfb, 0x76, 0x4b, 0xd5, 0x71, 0xcb, 0xd4, 0x71, 0xeb, 0x9e, 0xae, 0xf3, 0x4e, 0xe1,
	0xf7, 0x7f, 0x5f, 0xb3, 0xec, 0x54, 0x41, 0x80, 0x12, 0x9e, 0xa1, 0x58, 0xd5, 0x43, 0x06, 0x4d,
	0x25, 0xdd, 0x7c, 0x53, 0x04, 0x95, 0x63, 0xfd, 0x7e, 0xf9, 0x08, 0x04, 0x96, 0xe3, 0x34, 0xc1,
	0x1c, 0x57, 0x67, 0x98, 0x76, 0xfc, 0xcb, 0xe9, 0x8e, 0x5f, 0x9f, 0x95, 0x36, 0x8c, 0x27, 0xe8,
	0x70, 0x0d, 0x94, 0xdd, 0x88, 0x51, 0x27, 0xe6, 0x11, 0xa1, 0xbd, 0x7a, 0x69, 0x3d, 0x2f, 0xca,
	0x51, 0x90, 0x8e, 0x25, 0x05, 0x76, 0x40, 0x29, 0xbd, 0x58, 0x25, 0xf3, 0x9d, 0xe9, 0x17, 0x8f,
	0x5d, 0x97, 0xea, 0x09, 0x1b, 0x29, 0x98, 0xb9, 0x9b, 0x6c, 0x8c, 0x86, 0x61, 0x04, 0xd3, 0xc7,
	0xa0, 0x86, 0x9f, 0xb9, 0x7e, 0xe2, 0xe1, 0x21, 0x10, 0xf9, 0x77, 0x79, 0x4f, 0x27, 0x57, 0xb7,
	0xec, 0x45, 0x6d, 0x23, 0xf5, 0x3f, 0x04, 0x9f, 0x1a, 0xb3, 0xd7, 0x41, 0x3d, 0xff, 0x9e, 0x50,
	0xdf, 0xd6, 0x46, 0x27, 0xd9, 0xf0, 0x6b, 0x00, 0x64, 0x97, 0x71, 0xc4, 0x18, 0x90, 0xfd, 0xaf,
	0xdc, 0x5e, 0x9d, 0xc8, 0x90, 0x13, 0x33, 0x23, 0x3a, 0x85, 0xe7, 0x22, 0x45, 0xe6, 0xa5, 0x8e,
	0xa0, 0x8a, 0xd4, 0xc4, 0xd4, 0x53, 0xea, 0xc5, 0x8c, 0xea, 0x73, 0x98, 0x7a, 0x52, 0xf9, 0x2e,
	0x98, 0xfd, 0x05, 0xe1, 0x1c, 0xab, 0x4e, 0x9a, 0x21, 0x37, 0xb5, 0x38, 0xfc, 0x16, 0xa8, 0x8a,
	0x1b, 0x7f, 0xc5, 0x28, 0x76, 0x28, 0x0a, 0x70, 0x1d, 0xc8, 0x0a, 0xaa, 0x18, 0xe2, 0x43, 0x14,
	0xe0, 0x31, 0x21, 0x0f, 0x71, 0x54, 0x2f, 0xaf, 0x5b, 0x9b, 0x95, 0xa1, 0xd0, 0x3d, 0xc4, 0x51,
	0xf3, 0x6f, 0x16, 0xa8, 0x99, 0x34, 0x3f, 0x62, 0x3e, 0x11, 0x53, 0x0f, 0x1e, 0x83, 0x05, 0x76,
	0x81, 0x23, 0x1f, 0x85, 0x4e, 0x28, 0x68, 0x03, 0x59, 0x75, 0x0b, 0xed, 0xef, 0x8e, 0x43, 0x2f,
	0x67, 0x9a, 0xc4, 0x5d, 0x1b, 0x78, 0xa4, 0x94, 0xa4, 0x9d, 0x81, 0x5d, 0x65, 0xa3, 0x47, 0x78,
	0x1f, 0x2c, 0xb8, 0x88, 0xbb, 0x67, 0x49, 0xe8, 0xf4, 0x09, 0xf5, 0x58, 0x3f, 0x6b, 0x41, 0x56,
	0xb5, 0xda, 0x53, 0xa9, 0x05, 0x37, 0x41, 0x2d, 0x44, 0x49, 0x8c, 0x1d, 0x46, 0x9d, 0x2e, 0x22,
	0x7e, 0x12, 0x61, 0x39, 0x09, 0x4a, 0xf6, 0x82, 0xa4, 0x3f, 0xa2, 0xf7, 0x15, 0xb5, 0xd9, 0x07,
	0x0b, 0xe6, 0x65, 0x7b, 0xae, 0x30, 0x08, 0x7f, 0x06, 0x16, 0x54, 0xb8, 0xcd, 0xa0, 0xd5, 0xed,
	0xa4, 0x3d, 0xee, 0x98, 0xe1, 0x0a, 0xdf, 0x1e, 0xe2, 0xfe, 0x53, 0x7d, 0x3c, 0x78, 0x86, 0xdd,
	0x44, 0xd8, 0x39, 0xa4, 0x5d, 0xf6, 0xe3, 0x19, 0xbb, 0x2a, 0x6d, 0x19, 0x6e, 0xa7, 0x04, 0x66,
	0x91, 0xbc, 0xa6, 0xf9, 0x5f, 0x0b, 0xac, 0x8c, 0xdf, 0x6c, 0xe3, 0x38, 0xf1, 0x39, 0x3c, 0x00,
	0x55, 0x93, 0xaf, 0x2a, 0x65, 0xac, 0x8c, 0x29, 0x53, 0x31, 0x6a, 0x32, 0x6f, 0xf6, 0x40, 0x19,
	0xb9, 0x3c, 0x41, 0xbe, 0x32, 0x92, 0xcb, 0x68, 0x04, 0x28, 0x25, 0x69, 0xe2, 0xe7, 0xe0, 0x93,
	0x71, 0x24, 0x9c, 0x48, 0x3e, 0x51, 0x26, 0x49, 0xb9, 0xfd, 0xc5, 0x38, 0x20, 0x6a, 0xc7, 0x11,
	0x70, 0x4c, 0x60, 0x61, 0x2f, 0x8f, 0xa1, 0xa0, 0x1c, 0x6d, 0xfe, 0xce, 0x02, 0xd5, 0xb4, 0x7b,
	0x72, 0xc4, 0xe5, 0x70, 0xa7, 0x8c, 0xe3, 0x58, 0xaf, 0x2b, 0xea, 0x20, 0xb6, 0x15, 0x19, 0x34,
	0x35, 0xdf, 0x4b, 0xb6, 0x3e, 0xc1, 0x0d, 0xb0, 0xe8, 0x93, 0x80, 0x70, 0xec, 0x39, 0x0a, 0xd3,
	0xd8, 0xc4, 0x58, 0x93, 0x15, 0xac, 0x31, 0xfc, 0x0e, 0x58, 0x8a, 0x70, 0x80, 0x08, 0x25, 0xb4,
	0x97, 0x8a, 0x8a, 0x3a, 0xce, 0xdb, 0xb5, 0x94, 0xa1, 0x85, 0x9b, 0x21, 0xb8, 0x7d, 0x12, 0x91,
	0x5e, 0x0f, 0x47, 0x87, 0x41, 0x80, 0x3d, 0x82, 0x38, 0xf6, 0x07, 0x36, 0xfe, 0x65, 0x82, 0x63,
	0xfe, 0x51, 0x92, 0xbe, 0xf9, 0xc6, 0x02, 0x8b, 0x1d, 0xe4, 0x9e, 0x77, 0x89, 0xef, 0x9b, 0x8b,
	0xc6, 0x7b, 0x8e, 0xf5, 0x61, 0x3d, 0x27, 0xf7, 0xae, 0x3d, 0x67, 0xd2, 0xcd, 0xfc, 0x87, 0xbb,
	0xf9, 0xef, 0x91, 0x70, 0x1f, 0x89, 0x6a, 0x85, 0x1e, 0x58, 0xe6, 0x0a, 0x6a, 0x87, 0x0c, 0xb1,
	0xd6, 0xde, 0xee, 0x4c, 0x6f, 0xe1, 0x53, 0xe3, 0x63, 0x43, 0x3e, 0xc1, 0x82, 0x27, 0xa0, 0x76,
	0xaa, 0xd1, 0x75, 0x22, 0x25, 0xa7, 0x67, 0xda, 0x17, 0xd3, 0xaf, 0xb8, 0x12, 0x0f, 0x7b, 0xf1,
	0xf4, 0x4a, 0x80, 0x56, 0x40, 0x51, 0xa6, 0xa1, 0xde, 0x95, 0xd5, 0x41, 0xec, 0x2b, 0x09, 0x55,
	0x74, 0xb5, 0x27, 0x9b, 0x63, 0xf3, 0xaf, 0x85, 0xe1, 0xaa, 0x20, 0x5a, 0x03, 0xfc, 0x0c, 0x54,
	0x54, 0x2a, 0x3a, 0x2e, 0x4b, 0xa8, 0xda, 0x67, 0xf3, 0x76, 0x59, 0xd1, 0xf6, 0x05, 0x09, 0xb6,
	0xc1, 0x27, 0x01, 0x89, 0x63, 0x39, 0xde, 0x26, 0x9a, 0x62, 0xde, 0x5e, 0x56, 0xcc, 0xfd, 0xb1,
	0xce, 0xb7, 0x01, 0x16, 0x4d, 0xe8, 0xe2, 0x73, 0x12, 0x86, 0xd8, 0x93, 0x2f, 0xcc, 0xdb, 0x26,
	0xa2, 0xc7, 0x8a, 0x0a, 0x9f, 0x80, 0xa5, 0x28, 0xa1, 0xb2, 0x24, 0x4c, 0x79, 0xc7, 0x7a, 0x7a,
	0xbe, 0x43, 0x61, 0xd7, 0xb4, 0x0d, 0xc3, 0x89, 0xe1, 0x63, 0xb0, 0x10, 0x61, 0x17, 0x53, 0x3e,
	0x52, 0x69, 0xc2, 0x68, 0xeb, 0xff, 0x8c, 0xe4, 0x6b, 0xda, 0xa0, 0x5d, 0x55, 0x56, 0x4c, 0x0d,
	0x1f, 0x81, 0xe5, 0x6e, 0x22, 0xe6, 0xb2, 0x36, 0x2b, 0x33, 0x3b, 0xd6, 0x4b, 0xec, 0xcd, 0xa9,
	0xbd, 0xa4, 0x94, 0x95, 0x35, 0xc9, 0x14, 0x0d, 0xd2, 0x8d, 0x30, 0xe2, 0xba, 0xcb, 0xce, 0x66,
	0x6d, 0x90, 0x4a, 0xc9, 0xf4, 0xd8, 0x24, 0xf4, 0x52, 0x13, 0x73, 0x59, 0x4d, 0x28, 0x25, 0x69,
	0xe2, 0xfb, 0xe0, 0x16, 0xa1, 0x17, 0xc8, 0x27, 0x9e, 0x93, 0x76, 0x7d, 0x1c, 0x45, 0x2c, 0x52,
	0x0b, 0xaf, 0xdc, 0x81, 0x56, 0xb4, 0x84, 0xc1, 0xe9, 0x40, 0xf0, 0x9b, 0xbf, 0xcd, 0x81, 0x92,
	0xa1, 0xc0, 0x5d, 0x50, 0x88, 0x43, 0xec, 0xea, 0xda, 0xb9, 0x73, 0x33, 0xd6, 0x72, 0xe9, 0x91,
	0x3a, 0xf0, 0x47, 0x66, 0x26, 0xe9, 0x46, 0xb1, 0x99, 0x39, 0x52, 0x5a, 0x0f, 0xde, 0x07, 0xa5,
	0x50, 0xef, 0x05, 0x32, 0xdb, 0xca, 0xed, 0x6f, 0xdf, 0x6c, 0xc3, 0x6c, 0x12, 0x76, 0xaa, 0x0b,
	0x7f, 0x20, 0x7f, 0xdc, 0x71, 0xb3, 0x64, 0x6d, 0x64, 0x70, 0x43, 0x88, 0xdb, 0x4a, 0xab, 0xf9,
	0x36, 0x37, 0xdc, 0x53, 0x7e, 0x42, 0x62, 0x2e, 0xeb, 0xec, 0x43, 0x90, 0x39, 0x04, 0xd5, 0x74,
	0xf4, 0xf1, 0x41, 0x68, 0x3a, 0xe9, 0xe7, 0x37, 0xd5, 0xc7, 0xc9, 0x20, 0xc4, 0x76, 0xa5, 0x3f,
	0x72, 0x1a, 0x8e, 0xb6, 0xfc, 0xf5, 0xa3, 0xad, 0x30, 0x36, 0xda, 0x26, 0x8b, 0xa8, 0xf8, 0x11,
	0x8b, 0x68, 0xf6, 0xbd, 0x8b, 0xa8, 0xf9, 0x1f, 0x0b, 0x2c, 0x8d, 0x42, 0x7e, 0x40, 0x79, 0x34,
	0x10, 0xbf, 0x51, 0xd2, 0x64, 0x26, 0xe6, 0xcf, 0x07, 0x60, 0x48, 0x87, 0x1e, 0xfc, 0x12, 0x14,
	0x02, 0x1c, 0x30, 0x8d, 0xe7, 0x37, 0xa6, 0xe1, 0xf9, 0x00, 0x07, 0xcc, 0x96, 0x92, 0xf0, 0x31,
	0x58, 0x8a, 0x31, 0x8a, 0xdc, 0x33, 0x07, 0x71, 0x1e, 0x91, 0xd3, 0x84, 0xa7, 0xb9, 0xb6, 0x39,
	0x4d, 0xfd, 0x58, 0x2a, 0xec, 0xa5, 0xf2, 0x76, 0x2d, 0xbe, 0x42, 0x81, 0x3f, 0x04, 0x05, 0x42,
	0xbb, 0x4c, 0x27, 0x5c, 0x86, 0xac, 0x35, 0x79, 0x65, 0x4b, 0xbd, 0xce, 0x9f, 0xac, 0x17, 0xaf,
	0x1a, 0x33, 0x2f, 0x5f, 0x35, 0x66, 0xde, 0xbe, 0x6a, 0x58, 0xbf, 0xbe, 0x6c, 0x58, 0x7f, 0xb8,
	0x6c, 0x58, 0x7f, 0xbe, 0x6c, 0x58, 0x2f, 0x2e, 0x1b, 0xd6, 0x3f, 0x2e, 0x1b, 0xd6, 0x3f, 0x2f,
	0x1b, 0x33, 0x6f, 0x2f, 0x1b, 0xd6, 0xf3, 0xd7, 0x8d, 0x99, 0x17, 0xaf, 0x1b, 0x33, 0x2f, 0x5f,
	0x37, 0x66, 0xc0, 0xa7, 0x84, 0x4d, 0xbd, 0xaa, 0x53, 0x79, 0xa0, 0xfe, 0xd5, 0x39, 0x12, 0x71,
	0x38, 0xb2, 0x7e, 0xba, 0xd1, 0x1b, 0x11, 0x26, 0xec, 0xea, 0xdf, 0x5e, 0x5f, 0x99, 0xef, 0x3f,
	0xe6, 0x56, 0x4f, 0xb4, 0x18, 0x61, 0xad, 0xbd, 0x90, 0xa4, 0x8f, 0x6e, 0x3d, 0xd9, 0xfe, 0x57,
	0xee, 0x9b, 0x43, 0xe6, 0xee, 0xee, 0x5e, 0x48, 0x76, 0x77, 0x0d, 0x7b, 0x77, 0xf7, 0xc9, 0xf6,
	0xe9, 0xac, 0x0c, 0xfb, 0xce, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0x29, 0xe3, 0x0c, 0x77, 0x5f,
	0x13, 0x00, 0x00,
}

func (this *CalendarSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CalendarSpec)
	if !ok {
		that2, ok := that.(CalendarSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Second != that1.Second {
		return false
	}
	if this.Minute != that1.Minute {
		return false
	}
	if this.Hour != that1.Hour {
		return false
	}
	if this.DayOfMonth != that1.DayOfMonth {
		return false
	}
	if this.Month != that1.Month {
		return false
	}
	if this.Year != that1.Year {
		return false
	}
	if this.DayOfWeek != that1.DayOfWeek {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	return true
}
func (this *Range) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Range)
	if !ok {
		that2, ok := that.(Range)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Start != that1.Start {
		return false
	}
	if this.End != that1.End {
		return false
	}
	if this.Step != that1.Step {
		return false
	}
	return true
}
func (this *StructuredCalendarSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StructuredCalendarSpec)
	if !ok {
		that2, ok := that.(StructuredCalendarSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Second) != len(that1.Second) {
		return false
	}
	for i := range this.Second {
		if !this.Second[i].Equal(that1.Second[i]) {
			return false
		}
	}
	if len(this.Minute) != len(that1.Minute) {
		return false
	}
	for i := range this.Minute {
		if !this.Minute[i].Equal(that1.Minute[i]) {
			return false
		}
	}
	if len(this.Hour) != len(that1.Hour) {
		return false
	}
	for i := range this.Hour {
		if !this.Hour[i].Equal(that1.Hour[i]) {
			return false
		}
	}
	if len(this.DayOfMonth) != len(that1.DayOfMonth) {
		return false
	}
	for i := range this.DayOfMonth {
		if !this.DayOfMonth[i].Equal(that1.DayOfMonth[i]) {
			return false
		}
	}
	if len(this.Month) != len(that1.Month) {
		return false
	}
	for i := range this.Month {
		if !this.Month[i].Equal(that1.Month[i]) {
			return false
		}
	}
	if len(this.Year) != len(that1.Year) {
		return false
	}
	for i := range this.Year {
		if !this.Year[i].Equal(that1.Year[i]) {
			return false
		}
	}
	if len(this.DayOfWeek) != len(that1.DayOfWeek) {
		return false
	}
	for i := range this.DayOfWeek {
		if !this.DayOfWeek[i].Equal(that1.DayOfWeek[i]) {
			return false
		}
	}
	if this.Comment != that1.Comment {
		return false
	}
	return true
}
func (this *IntervalSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IntervalSpec)
	if !ok {
		that2, ok := that.(IntervalSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Interval != nil && that1.Interval != nil {
		if *this.Interval != *that1.Interval {
			return false
		}
	} else if this.Interval != nil {
		return false
	} else if that1.Interval != nil {
		return false
	}
	if this.Phase != nil && that1.Phase != nil {
		if *this.Phase != *that1.Phase {
			return false
		}
	} else if this.Phase != nil {
		return false
	} else if that1.Phase != nil {
		return false
	}
	return true
}
func (this *ScheduleSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScheduleSpec)
	if !ok {
		that2, ok := that.(ScheduleSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.StructuredCalendar) != len(that1.StructuredCalendar) {
		return false
	}
	for i := range this.StructuredCalendar {
		if !this.StructuredCalendar[i].Equal(that1.StructuredCalendar[i]) {
			return false
		}
	}
	if len(this.CronString) != len(that1.CronString) {
		return false
	}
	for i := range this.CronString {
		if this.CronString[i] != that1.CronString[i] {
			return false
		}
	}
	if len(this.Calendar) != len(that1.Calendar) {
		return false
	}
	for i := range this.Calendar {
		if !this.Calendar[i].Equal(that1.Calendar[i]) {
			return false
		}
	}
	if len(this.Interval) != len(that1.Interval) {
		return false
	}
	for i := range this.Interval {
		if !this.Interval[i].Equal(that1.Interval[i]) {
			return false
		}
	}
	if len(this.ExcludeCalendar) != len(that1.ExcludeCalendar) {
		return false
	}
	for i := range this.ExcludeCalendar {
		if !this.ExcludeCalendar[i].Equal(that1.ExcludeCalendar[i]) {
			return false
		}
	}
	if len(this.ExcludeStructuredCalendar) != len(that1.ExcludeStructuredCalendar) {
		return false
	}
	for i := range this.ExcludeStructuredCalendar {
		if !this.ExcludeStructuredCalendar[i].Equal(that1.ExcludeStructuredCalendar[i]) {
			return false
		}
	}
	if that1.StartTime == nil {
		if this.StartTime != nil {
			return false
		}
	} else if !this.StartTime.Equal(*that1.StartTime) {
		return false
	}
	if that1.EndTime == nil {
		if this.EndTime != nil {
			return false
		}
	} else if !this.EndTime.Equal(*that1.EndTime) {
		return false
	}
	if this.Jitter != nil && that1.Jitter != nil {
		if *this.Jitter != *that1.Jitter {
			return false
		}
	} else if this.Jitter != nil {
		return false
	} else if that1.Jitter != nil {
		return false
	}
	if this.TimezoneName != that1.TimezoneName {
		return false
	}
	if !bytes.Equal(this.TimezoneData, that1.TimezoneData) {
		return false
	}
	return true
}
func (this *SchedulePolicies) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SchedulePolicies)
	if !ok {
		that2, ok := that.(SchedulePolicies)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OverlapPolicy != that1.OverlapPolicy {
		return false
	}
	if this.CatchupWindow != nil && that1.CatchupWindow != nil {
		if *this.CatchupWindow != *that1.CatchupWindow {
			return false
		}
	} else if this.CatchupWindow != nil {
		return false
	} else if that1.CatchupWindow != nil {
		return false
	}
	if this.PauseOnFailure != that1.PauseOnFailure {
		return false
	}
	return true
}
func (this *ScheduleAction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScheduleAction)
	if !ok {
		that2, ok := that.(ScheduleAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Action == nil {
		if this.Action != nil {
			return false
		}
	} else if this.Action == nil {
		return false
	} else if !this.Action.Equal(that1.Action) {
		return false
	}
	return true
}
func (this *ScheduleAction_StartWorkflow) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScheduleAction_StartWorkflow)
	if !ok {
		that2, ok := that.(ScheduleAction_StartWorkflow)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StartWorkflow.Equal(that1.StartWorkflow) {
		return false
	}
	return true
}
func (this *ScheduleActionResult) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScheduleActionResult)
	if !ok {
		that2, ok := that.(ScheduleActionResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ScheduleTime == nil {
		if this.ScheduleTime != nil {
			return false
		}
	} else if !this.ScheduleTime.Equal(*that1.ScheduleTime) {
		return false
	}
	if that1.ActualTime == nil {
		if this.ActualTime != nil {
			return false
		}
	} else if !this.ActualTime.Equal(*that1.ActualTime) {
		return false
	}
	if !this.StartWorkflowResult.Equal(that1.StartWorkflowResult) {
		return false
	}
	return true
}
func (this *ScheduleState) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScheduleState)
	if !ok {
		that2, ok := that.(ScheduleState)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Notes != that1.Notes {
		return false
	}
	if this.Paused != that1.Paused {
		return false
	}
	if this.LimitedActions != that1.LimitedActions {
		return false
	}
	if this.RemainingActions != that1.RemainingActions {
		return false
	}
	return true
}
func (this *TriggerImmediatelyRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TriggerImmediatelyRequest)
	if !ok {
		that2, ok := that.(TriggerImmediatelyRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OverlapPolicy != that1.OverlapPolicy {
		return false
	}
	return true
}
func (this *BackfillRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BackfillRequest)
	if !ok {
		that2, ok := that.(BackfillRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.StartTime == nil {
		if this.StartTime != nil {
			return false
		}
	} else if !this.StartTime.Equal(*that1.StartTime) {
		return false
	}
	if that1.EndTime == nil {
		if this.EndTime != nil {
			return false
		}
	} else if !this.EndTime.Equal(*that1.EndTime) {
		return false
	}
	if this.OverlapPolicy != that1.OverlapPolicy {
		return false
	}
	return true
}
func (this *SchedulePatch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SchedulePatch)
	if !ok {
		that2, ok := that.(SchedulePatch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TriggerImmediately.Equal(that1.TriggerImmediately) {
		return false
	}
	if len(this.BackfillRequest) != len(that1.BackfillRequest) {
		return false
	}
	for i := range this.BackfillRequest {
		if !this.BackfillRequest[i].Equal(that1.BackfillRequest[i]) {
			return false
		}
	}
	if this.Pause != that1.Pause {
		return false
	}
	if this.Unpause != that1.Unpause {
		return false
	}
	return true
}
func (this *ScheduleInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScheduleInfo)
	if !ok {
		that2, ok := that.(ScheduleInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ActionCount != that1.ActionCount {
		return false
	}
	if this.MissedCatchupWindow != that1.MissedCatchupWindow {
		return false
	}
	if this.OverlapSkipped != that1.OverlapSkipped {
		return false
	}
	if len(this.RunningWorkflows) != len(that1.RunningWorkflows) {
		return false
	}
	for i := range this.RunningWorkflows {
		if !this.RunningWorkflows[i].Equal(that1.RunningWorkflows[i]) {
			return false
		}
	}
	if len(this.RecentActions) != len(that1.RecentActions) {
		return false
	}
	for i := range this.RecentActions {
		if !this.RecentActions[i].Equal(that1.RecentActions[i]) {
			return false
		}
	}
	if len(this.FutureActionTimes) != len(that1.FutureActionTimes) {
		return false
	}
	for i := range this.FutureActionTimes {
		if !this.FutureActionTimes[i].Equal(*that1.FutureActionTimes[i]) {
			return false
		}
	}
	if that1.CreateTime == nil {
		if this.CreateTime != nil {
			return false
		}
	} else if !this.CreateTime.Equal(*that1.CreateTime) {
		return false
	}
	if that1.UpdateTime == nil {
		if this.UpdateTime != nil {
			return false
		}
	} else if !this.UpdateTime.Equal(*that1.UpdateTime) {
		return false
	}
	if this.InvalidScheduleError != that1.InvalidScheduleError {
		return false
	}
	return true
}
func (this *Schedule) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Schedule)
	if !ok {
		that2, ok := that.(Schedule)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Spec.Equal(that1.Spec) {
		return false
	}
	if !this.Action.Equal(that1.Action) {
		return false
	}
	if !this.Policies.Equal(that1.Policies) {
		return false
	}
	if !this.State.Equal(that1.State) {
		return false
	}
	return true
}
func (this *ScheduleListInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScheduleListInfo)
	if !ok {
		that2, ok := that.(ScheduleListInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Spec.Equal(that1.Spec) {
		return false
	}
	if !this.WorkflowType.Equal(that1.WorkflowType) {
		return false
	}
	if this.Notes != that1.Notes {
		return false
	}
	if this.Paused != that1.Paused {
		return false
	}
	if len(this.RecentActions) != len(that1.RecentActions) {
		return false
	}
	for i := range this.RecentActions {
		if !this.RecentActions[i].Equal(that1.RecentActions[i]) {
			return false
		}
	}
	if len(this.FutureActionTimes) != len(that1.FutureActionTimes) {
		return false
	}
	for i := range this.FutureActionTimes {
		if !this.FutureActionTimes[i].Equal(*that1.FutureActionTimes[i]) {
			return false
		}
	}
	return true
}
func (this *ScheduleListEntry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScheduleListEntry)
	if !ok {
		that2, ok := that.(ScheduleListEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ScheduleId != that1.ScheduleId {
		return false
	}
	if !this.Memo.Equal(that1.Memo) {
		return false
	}
	if !this.SearchAttributes.Equal(that1.SearchAttributes) {
		return false
	}
	if !this.Info.Equal(that1.Info) {
		return false
	}
	return true
}
func (this *CalendarSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&schedule.CalendarSpec{")
	s = append(s, "Second: "+fmt.Sprintf("%#v", this.Second)+",\n")
	s = append(s, "Minute: "+fmt.Sprintf("%#v", this.Minute)+",\n")
	s = append(s, "Hour: "+fmt.Sprintf("%#v", this.Hour)+",\n")
	s = append(s, "DayOfMonth: "+fmt.Sprintf("%#v", this.DayOfMonth)+",\n")
	s = append(s, "Month: "+fmt.Sprintf("%#v", this.Month)+",\n")
	s = append(s, "Year: "+fmt.Sprintf("%#v", this.Year)+",\n")
	s = append(s, "DayOfWeek: "+fmt.Sprintf("%#v", this.DayOfWeek)+",\n")
	s = append(s, "Comment: "+fmt.Sprintf("%#v", this.Comment)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Range) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schedule.Range{")
	s = append(s, "Start: "+fmt.Sprintf("%#v", this.Start)+",\n")
	s = append(s, "End: "+fmt.Sprintf("%#v", this.End)+",\n")
	s = append(s, "Step: "+fmt.Sprintf("%#v", this.Step)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StructuredCalendarSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&schedule.StructuredCalendarSpec{")
	if this.Second != nil {
		s = append(s, "Second: "+fmt.Sprintf("%#v", this.Second)+",\n")
	}
	if this.Minute != nil {
		s = append(s, "Minute: "+fmt.Sprintf("%#v", this.Minute)+",\n")
	}
	if this.Hour != nil {
		s = append(s, "Hour: "+fmt.Sprintf("%#v", this.Hour)+",\n")
	}
	if this.DayOfMonth != nil {
		s = append(s, "DayOfMonth: "+fmt.Sprintf("%#v", this.DayOfMonth)+",\n")
	}
	if this.Month != nil {
		s = append(s, "Month: "+fmt.Sprintf("%#v", this.Month)+",\n")
	}
	if this.Year != nil {
		s = append(s, "Year: "+fmt.Sprintf("%#v", this.Year)+",\n")
	}
	if this.DayOfWeek != nil {
		s = append(s, "DayOfWeek: "+fmt.Sprintf("%#v", this.DayOfWeek)+",\n")
	}
	s = append(s, "Comment: "+fmt.Sprintf("%#v", this.Comment)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IntervalSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schedule.IntervalSpec{")
	s = append(s, "Interval: "+fmt.Sprintf("%#v", this.Interval)+",\n")
	s = append(s, "Phase: "+fmt.Sprintf("%#v", this.Phase)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ScheduleSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&schedule.ScheduleSpec{")
	if this.StructuredCalendar != nil {
		s = append(s, "StructuredCalendar: "+fmt.Sprintf("%#v", this.StructuredCalendar)+",\n")
	}
	s = append(s, "CronString: "+fmt.Sprintf("%#v", this.CronString)+",\n")
	if this.Calendar != nil {
		s = append(s, "Calendar: "+fmt.Sprintf("%#v", this.Calendar)+",\n")
	}
	if this.Interval != nil {
		s = append(s, "Interval: "+fmt.Sprintf("%#v", this.Interval)+",\n")
	}
	if this.ExcludeCalendar != nil {
		s = append(s, "ExcludeCalendar: "+fmt.Sprintf("%#v", this.ExcludeCalendar)+",\n")
	}
	if this.ExcludeStructuredCalendar != nil {
		s = append(s, "ExcludeStructuredCalendar: "+fmt.Sprintf("%#v", this.ExcludeStructuredCalendar)+",\n")
	}
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "EndTime: "+fmt.Sprintf("%#v", this.EndTime)+",\n")
	s = append(s, "Jitter: "+fmt.Sprintf("%#v", this.Jitter)+",\n")
	s = append(s, "TimezoneName: "+fmt.Sprintf("%#v", this.TimezoneName)+",\n")
	s = append(s, "TimezoneData: "+fmt.Sprintf("%#v", this.TimezoneData)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SchedulePolicies) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schedule.SchedulePolicies{")
	s = append(s, "OverlapPolicy: "+fmt.Sprintf("%#v", this.OverlapPolicy)+",\n")
	s = append(s, "CatchupWindow: "+fmt.Sprintf("%#v", this.CatchupWindow)+",\n")
	s = append(s, "PauseOnFailure: "+fmt.Sprintf("%#v", this.PauseOnFailure)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ScheduleAction) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schedule.ScheduleAction{")
	if this.Action != nil {
		s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ScheduleAction_StartWorkflow) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schedule.ScheduleAction_StartWorkflow{` +
		`StartWorkflow:` + fmt.Sprintf("%#v", this.StartWorkflow) + `}`}, ", ")
	return s
}
func (this *ScheduleActionResult) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schedule.ScheduleActionResult{")
	s = append(s, "ScheduleTime: "+fmt.Sprintf("%#v", this.ScheduleTime)+",\n")
	s = append(s, "ActualTime: "+fmt.Sprintf("%#v", this.ActualTime)+",\n")
	if this.StartWorkflowResult != nil {
		s = append(s, "StartWorkflowResult: "+fmt.Sprintf("%#v", this.StartWorkflowResult)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ScheduleState) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schedule.ScheduleState{")
	s = append(s, "Notes: "+fmt.Sprintf("%#v", this.Notes)+",\n")
	s = append(s, "Paused: "+fmt.Sprintf("%#v", this.Paused)+",\n")
	s = append(s, "LimitedActions: "+fmt.Sprintf("%#v", this.LimitedActions)+",\n")
	s = append(s, "RemainingActions: "+fmt.Sprintf("%#v", this.RemainingActions)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TriggerImmediatelyRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schedule.TriggerImmediatelyRequest{")
	s = append(s, "OverlapPolicy: "+fmt.Sprintf("%#v", this.OverlapPolicy)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BackfillRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schedule.BackfillRequest{")
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "EndTime: "+fmt.Sprintf("%#v", this.EndTime)+",\n")
	s = append(s, "OverlapPolicy: "+fmt.Sprintf("%#v", this.OverlapPolicy)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SchedulePatch) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schedule.SchedulePatch{")
	if this.TriggerImmediately != nil {
		s = append(s, "TriggerImmediately: "+fmt.Sprintf("%#v", this.TriggerImmediately)+",\n")
	}
	if this.BackfillRequest != nil {
		s = append(s, "BackfillRequest: "+fmt.Sprintf("%#v", this.BackfillRequest)+",\n")
	}
	s = append(s, "Pause: "+fmt.Sprintf("%#v", this.Pause)+",\n")
	s = append(s, "Unpause: "+fmt.Sprintf("%#v", this.Unpause)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ScheduleInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&schedule.ScheduleInfo{")
	s = append(s, "ActionCount: "+fmt.Sprintf("%#v", this.ActionCount)+",\n")
	s = append(s, "MissedCatchupWindow: "+fmt.Sprintf("%#v", this.MissedCatchupWindow)+",\n")
	s = append(s, "OverlapSkipped: "+fmt.Sprintf("%#v", this.OverlapSkipped)+",\n")
	if this.RunningWorkflows != nil {
		s = append(s, "RunningWorkflows: "+fmt.Sprintf("%#v", this.RunningWorkflows)+",\n")
	}
	if this.RecentActions != nil {
		s = append(s, "RecentActions: "+fmt.Sprintf("%#v", this.RecentActions)+",\n")
	}
	s = append(s, "FutureActionTimes: "+fmt.Sprintf("%#v", this.FutureActionTimes)+",\n")
	s = append(s, "CreateTime: "+fmt.Sprintf("%#v", this.CreateTime)+",\n")
	s = append(s, "UpdateTime: "+fmt.Sprintf("%#v", this.UpdateTime)+",\n")
	s = append(s, "InvalidScheduleError: "+fmt.Sprintf("%#v", this.InvalidScheduleError)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Schedule) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schedule.Schedule{")
	if this.Spec != nil {
		s = append(s, "Spec: "+fmt.Sprintf("%#v", this.Spec)+",\n")
	}
	if this.Action != nil {
		s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	}
	if this.Policies != nil {
		s = append(s, "Policies: "+fmt.Sprintf("%#v", this.Policies)+",\n")
	}
	if this.State != nil {
		s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ScheduleListInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&schedule.ScheduleListInfo{")
	if this.Spec != nil {
		s = append(s, "Spec: "+fmt.Sprintf("%#v", this.Spec)+",\n")
	}
	if this.WorkflowType != nil {
		s = append(s, "WorkflowType: "+fmt.Sprintf("%#v", this.WorkflowType)+",\n")
	}
	s = append(s, "Notes: "+fmt.Sprintf("%#v", this.Notes)+",\n")
	s = append(s, "Paused: "+fmt.Sprintf("%#v", this.Paused)+",\n")
	if this.RecentActions != nil {
		s = append(s, "RecentActions: "+fmt.Sprintf("%#v", this.RecentActions)+",\n")
	}
	s = append(s, "FutureActionTimes: "+fmt.Sprintf("%#v", this.FutureActionTimes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ScheduleListEntry) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schedule.ScheduleListEntry{")
	s = append(s, "ScheduleId: "+fmt.Sprintf("%#v", this.ScheduleId)+",\n")
	if this.Memo != nil {
		s = append(s, "Memo: "+fmt.Sprintf("%#v", this.Memo)+",\n")
	}
	if this.SearchAttributes != nil {
		s = append(s, "SearchAttributes: "+fmt.Sprintf("%#v", this.SearchAttributes)+",\n")
	}
	if this.Info != nil {
		s = append(s, "Info: "+fmt.Sprintf("%#v", this.Info)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringMessage(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *CalendarSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CalendarSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CalendarSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.DayOfWeek) > 0 {
		i -= len(m.DayOfWeek)
		copy(dAtA[i:], m.DayOfWeek)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.DayOfWeek)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Year) > 0 {
		i -= len(m.Year)
		copy(dAtA[i:], m.Year)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Year)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Month) > 0 {
		i -= len(m.Month)
		copy(dAtA[i:], m.Month)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Month)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DayOfMonth) > 0 {
		i -= len(m.DayOfMonth)
		copy(dAtA[i:], m.DayOfMonth)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.DayOfMonth)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Hour) > 0 {
		i -= len(m.Hour)
		copy(dAtA[i:], m.Hour)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Hour)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Minute) > 0 {
		i -= len(m.Minute)
		copy(dAtA[i:], m.Minute)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Minute)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Second) > 0 {
		i -= len(m.Second)
		copy(dAtA[i:], m.Second)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Second)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Range) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Range) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Range) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Step != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Step))
		i--
		dAtA[i] = 0x18
	}
	if m.End != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x10
	}
	if m.Start != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StructuredCalendarSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StructuredCalendarSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StructuredCalendarSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.DayOfWeek) > 0 {
		for iNdEx := len(m.DayOfWeek) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DayOfWeek[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Year) > 0 {
		for iNdEx := len(m.Year) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Year[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Month) > 0 {
		for iNdEx := len(m.Month) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Month[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.DayOfMonth) > 0 {
		for iNdEx := len(m.DayOfMonth) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DayOfMonth[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Hour) > 0 {
		for iNdEx := len(m.Hour) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Hour[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Minute) > 0 {
		for iNdEx := len(m.Minute) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Minute[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Second) > 0 {
		for iNdEx := len(m.Second) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Second[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *IntervalSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IntervalSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IntervalSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Phase != nil {
		n1, err1 := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.Phase, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(*m.Phase):])
		if err1 != nil {
			return 0, err1
		}
		i -= n1
		i = encodeVarintMessage(dAtA, i, uint64(n1))
		i--
		dAtA[i] = 0x12
	}
	if m.Interval != nil {
		n2, err2 := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.Interval, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(*m.Interval):])
		if err2 != nil {
			return 0, err2
		}
		i -= n2
		i = encodeVarintMessage(dAtA, i, uint64(n2))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScheduleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScheduleSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScheduleSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TimezoneData) > 0 {
		i -= len(m.TimezoneData)
		copy(dAtA[i:], m.TimezoneData)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.TimezoneData)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.TimezoneName) > 0 {
		i -= len(m.TimezoneName)
		copy(dAtA[i:], m.TimezoneName)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.TimezoneName)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.ExcludeStructuredCalendar) > 0 {
		for iNdEx := len(m.ExcludeStructuredCalendar) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExcludeStructuredCalendar[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.CronString) > 0 {
		for iNdEx := len(m.CronString) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CronString[iNdEx])
			copy(dAtA[i:], m.CronString[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(m.CronString[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.StructuredCalendar) > 0 {
		for iNdEx := len(m.StructuredCalendar) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StructuredCalendar[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Jitter != nil {
		n3, err3 := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.Jitter, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(*m.Jitter):])
		if err3 != nil {
			return 0, err3
		}
		i -= n3
		i = encodeVarintMessage(dAtA, i, uint64(n3))
		i--
		dAtA[i] = 0x32
	}
	if m.EndTime != nil {
		n4, err4 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.EndTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.EndTime):])
		if err4 != nil {
			return 0, err4
		}
		i -= n4
		i = encodeVarintMessage(dAtA, i, uint64(n4))
		i--
		dAtA[i] = 0x2a
	}
	if m.StartTime != nil {
		n5, err5 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.StartTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.StartTime):])
		if err5 != nil {
			return 0, err5
		}
		i -= n5
		i = encodeVarintMessage(dAtA, i, uint64(n5))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ExcludeCalendar) > 0 {
		for iNdEx := len(m.ExcludeCalendar) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExcludeCalendar[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Interval) > 0 {
		for iNdEx := len(m.Interval) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Interval[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Calendar) > 0 {
		for iNdEx := len(m.Calendar) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Calendar[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SchedulePolicies) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchedulePolicies) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchedulePolicies) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PauseOnFailure {
		i--
		if m.PauseOnFailure {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.CatchupWindow != nil {
		n6, err6 := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.CatchupWindow, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(*m.CatchupWindow):])
		if err6 != nil {
			return 0, err6
		}
		i -= n6
		i = encodeVarintMessage(dAtA, i, uint64(n6))
		i--
		dAtA[i] = 0x12
	}
	if m.OverlapPolicy != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.OverlapPolicy))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ScheduleAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScheduleAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScheduleAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Action != nil {
		{
			size := m.Action.Size()
			i -= size
			if _, err := m.Action.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ScheduleAction_StartWorkflow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScheduleAction_StartWorkflow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StartWorkflow != nil {
		{
			size, err := m.StartWorkflow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ScheduleActionResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScheduleActionResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScheduleActionResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StartWorkflowResult != nil {
		{
			size, err := m.StartWorkflowResult.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.ActualTime != nil {
		n9, err9 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.ActualTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.ActualTime):])
		if err9 != nil {
			return 0, err9
		}
		i -= n9
		i = encodeVarintMessage(dAtA, i, uint64(n9))
		i--
		dAtA[i] = 0x12
	}
	if m.ScheduleTime != nil {
		n10, err10 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.ScheduleTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.ScheduleTime):])
		if err10 != nil {
			return 0, err10
		}
		i -= n10
		i = encodeVarintMessage(dAtA, i, uint64(n10))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScheduleState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScheduleState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScheduleState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RemainingActions != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.RemainingActions))
		i--
		dAtA[i] = 0x20
	}
	if m.LimitedActions {
		i--
		if m.LimitedActions {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Paused {
		i--
		if m.Paused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Notes) > 0 {
		i -= len(m.Notes)
		copy(dAtA[i:], m.Notes)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Notes)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TriggerImmediatelyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TriggerImmediatelyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TriggerImmediatelyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OverlapPolicy != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.OverlapPolicy))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BackfillRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackfillRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BackfillRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OverlapPolicy != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.OverlapPolicy))
		i--
		dAtA[i] = 0x18
	}
	if m.EndTime != nil {
		n11, err11 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.EndTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.EndTime):])
		if err11 != nil {
			return 0, err11
		}
		i -= n11
		i = encodeVarintMessage(dAtA, i, uint64(n11))
		i--
		dAtA[i] = 0x12
	}
	if m.StartTime != nil {
		n12, err12 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.StartTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.StartTime):])
		if err12 != nil {
			return 0, err12
		}
		i -= n12
		i = encodeVarintMessage(dAtA, i, uint64(n12))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SchedulePatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchedulePatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchedulePatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Unpause) > 0 {
		i -= len(m.Unpause)
		copy(dAtA[i:], m.Unpause)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Unpause)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Pause) > 0 {
		i -= len(m.Pause)
		copy(dAtA[i:], m.Pause)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Pause)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BackfillRequest) > 0 {
		for iNdEx := len(m.BackfillRequest) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BackfillRequest[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.TriggerImmediately != nil {
		{
			size, err := m.TriggerImmediately.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScheduleInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScheduleInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScheduleInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RunningWorkflows) > 0 {
		for iNdEx := len(m.RunningWorkflows) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RunningWorkflows[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.InvalidScheduleError) > 0 {
		i -= len(m.InvalidScheduleError)
		copy(dAtA[i:], m.InvalidScheduleError)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.InvalidScheduleError)))
		i--
		dAtA[i] = 0x42
	}
	if m.UpdateTime != nil {
		n14, err14 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.UpdateTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.UpdateTime):])
		if err14 != nil {
			return 0, err14
		}
		i -= n14
		i = encodeVarintMessage(dAtA, i, uint64(n14))
		i--
		dAtA[i] = 0x3a
	}
	if m.CreateTime != nil {
		n15, err15 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.CreateTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.CreateTime):])
		if err15 != nil {
			return 0, err15
		}
		i -= n15
		i = encodeVarintMessage(dAtA, i, uint64(n15))
		i--
		dAtA[i] = 0x32
	}
	if len(m.FutureActionTimes) > 0 {
		for iNdEx := len(m.FutureActionTimes) - 1; iNdEx >= 0; iNdEx-- {
			n, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.FutureActionTimes[iNdEx], dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.FutureActionTimes[iNdEx]):])
			if err != nil {
				return 0, err
			}
			i -= n
			i = encodeVarintMessage(dAtA, i, uint64(n))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.RecentActions) > 0 {
		for iNdEx := len(m.RecentActions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RecentActions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.OverlapSkipped != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.OverlapSkipped))
		i--
		dAtA[i] = 0x18
	}
	if m.MissedCatchupWindow != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.MissedCatchupWindow))
		i--
		dAtA[i] = 0x10
	}
	if m.ActionCount != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.ActionCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Schedule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Schedule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Schedule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Policies != nil {
		{
			size, err := m.Policies.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Action != nil {
		{
			size, err := m.Action.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScheduleListInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScheduleListInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScheduleListInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FutureActionTimes) > 0 {
		for iNdEx := len(m.FutureActionTimes) - 1; iNdEx >= 0; iNdEx-- {
			n, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.FutureActionTimes[iNdEx], dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.FutureActionTimes[iNdEx]):])
			if err != nil {
				return 0, err
			}
			i -= n
			i = encodeVarintMessage(dAtA, i, uint64(n))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.RecentActions) > 0 {
		for iNdEx := len(m.RecentActions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RecentActions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Paused {
		i--
		if m.Paused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Notes) > 0 {
		i -= len(m.Notes)
		copy(dAtA[i:], m.Notes)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Notes)))
		i--
		dAtA[i] = 0x1a
	}
	if m.WorkflowType != nil {
		{
			size, err := m.WorkflowType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScheduleListEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScheduleListEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScheduleListEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.SearchAttributes != nil {
		{
			size, err := m.SearchAttributes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Memo != nil {
		{
			size, err := m.Memo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ScheduleId) > 0 {
		i -= len(m.ScheduleId)
		copy(dAtA[i:], m.ScheduleId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.ScheduleId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMessage(dAtA []byte, offset int, v uint64) int {
	offset -= sovMessage(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CalendarSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Second)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Minute)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Hour)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.DayOfMonth)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Month)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Year)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.DayOfWeek)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *Range) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovMessage(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovMessage(uint64(m.End))
	}
	if m.Step != 0 {
		n += 1 + sovMessage(uint64(m.Step))
	}
	return n
}

func (m *StructuredCalendarSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Second) > 0 {
		for _, e := range m.Second {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if len(m.Minute) > 0 {
		for _, e := range m.Minute {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if len(m.Hour) > 0 {
		for _, e := range m.Hour {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if len(m.DayOfMonth) > 0 {
		for _, e := range m.DayOfMonth {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if len(m.Month) > 0 {
		for _, e := range m.Month {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if len(m.Year) > 0 {
		for _, e := range m.Year {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if len(m.DayOfWeek) > 0 {
		for _, e := range m.DayOfWeek {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *IntervalSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Interval != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.Interval)
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Phase != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.Phase)
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *ScheduleSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Calendar) > 0 {
		for _, e := range m.Calendar {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if len(m.Interval) > 0 {
		for _, e := range m.Interval {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if len(m.ExcludeCalendar) > 0 {
		for _, e := range m.ExcludeCalendar {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.StartTime != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.StartTime)
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.EndTime != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.EndTime)
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Jitter != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.Jitter)
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.StructuredCalendar) > 0 {
		for _, e := range m.StructuredCalendar {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if len(m.CronString) > 0 {
		for _, s := range m.CronString {
			l = len(s)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if len(m.ExcludeStructuredCalendar) > 0 {
		for _, e := range m.ExcludeStructuredCalendar {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	l = len(m.TimezoneName)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.TimezoneData)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *SchedulePolicies) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OverlapPolicy != 0 {
		n += 1 + sovMessage(uint64(m.OverlapPolicy))
	}
	if m.CatchupWindow != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.CatchupWindow)
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.PauseOnFailure {
		n += 2
	}
	return n
}

func (m *ScheduleAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != nil {
		n += m.Action.Size()
	}
	return n
}

func (m *ScheduleAction_StartWorkflow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartWorkflow != nil {
		l = m.StartWorkflow.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}
func (m *ScheduleActionResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ScheduleTime != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.ScheduleTime)
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.ActualTime != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.ActualTime)
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.StartWorkflowResult != nil {
		l = m.StartWorkflowResult.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *ScheduleState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Notes)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Paused {
		n += 2
	}
	if m.LimitedActions {
		n += 2
	}
	if m.RemainingActions != 0 {
		n += 1 + sovMessage(uint64(m.RemainingActions))
	}
	return n
}

func (m *TriggerImmediatelyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OverlapPolicy != 0 {
		n += 1 + sovMessage(uint64(m.OverlapPolicy))
	}
	return n
}

func (m *BackfillRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartTime != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.StartTime)
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.EndTime != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.EndTime)
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.OverlapPolicy != 0 {
		n += 1 + sovMessage(uint64(m.OverlapPolicy))
	}
	return n
}

func (m *SchedulePatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TriggerImmediately != nil {
		l = m.TriggerImmediately.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.BackfillRequest) > 0 {
		for _, e := range m.BackfillRequest {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	l = len(m.Pause)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Unpause)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *ScheduleInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ActionCount != 0 {
		n += 1 + sovMessage(uint64(m.ActionCount))
	}
	if m.MissedCatchupWindow != 0 {
		n += 1 + sovMessage(uint64(m.MissedCatchupWindow))
	}
	if m.OverlapSkipped != 0 {
		n += 1 + sovMessage(uint64(m.OverlapSkipped))
	}
	if len(m.RecentActions) > 0 {
		for _, e := range m.RecentActions {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if len(m.FutureActionTimes) > 0 {
		for _, e := range m.FutureActionTimes {
			l = github_com_gogo_protobuf_types.SizeOfStdTime(*e)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.CreateTime != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.CreateTime)
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.UpdateTime != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.UpdateTime)
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.InvalidScheduleError)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.RunningWorkflows) > 0 {
		for _, e := range m.RunningWorkflows {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	return n
}

func (m *Schedule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Action != nil {
		l = m.Action.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Policies != nil {
		l = m.Policies.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *ScheduleListInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.WorkflowType != nil {
		l = m.WorkflowType.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Notes)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Paused {
		n += 2
	}
	if len(m.RecentActions) > 0 {
		for _, e := range m.RecentActions {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if len(m.FutureActionTimes) > 0 {
		for _, e := range m.FutureActionTimes {
			l = github_com_gogo_protobuf_types.SizeOfStdTime(*e)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	return n
}

func (m *ScheduleListEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ScheduleId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Memo != nil {
		l = m.Memo.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.SearchAttributes != nil {
		l = m.SearchAttributes.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func sovMessage(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMessage(x uint64) (n int) {
	return sovMessage(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *CalendarSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CalendarSpec{`,
		`Second:` + fmt.Sprintf("%v", this.Second) + `,`,
		`Minute:` + fmt.Sprintf("%v", this.Minute) + `,`,
		`Hour:` + fmt.Sprintf("%v", this.Hour) + `,`,
		`DayOfMonth:` + fmt.Sprintf("%v", this.DayOfMonth) + `,`,
		`Month:` + fmt.Sprintf("%v", this.Month) + `,`,
		`Year:` + fmt.Sprintf("%v", this.Year) + `,`,
		`DayOfWeek:` + fmt.Sprintf("%v", this.DayOfWeek) + `,`,
		`Comment:` + fmt.Sprintf("%v", this.Comment) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Range) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Range{`,
		`Start:` + fmt.Sprintf("%v", this.Start) + `,`,
		`End:` + fmt.Sprintf("%v", this.End) + `,`,
		`Step:` + fmt.Sprintf("%v", this.Step) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StructuredCalendarSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSecond := "[]*Range{"
	for _, f := range this.Second {
		repeatedStringForSecond += strings.Replace(f.String(), "Range", "Range", 1) + ","
	}
	repeatedStringForSecond += "}"
	repeatedStringForMinute := "[]*Range{"
	for _, f := range this.Minute {
		repeatedStringForMinute += strings.Replace(f.String(), "Range", "Range", 1) + ","
	}
	repeatedStringForMinute += "}"
	repeatedStringForHour := "[]*Range{"
	for _, f := range this.Hour {
		repeatedStringForHour += strings.Replace(f.String(), "Range", "Range", 1) + ","
	}
	repeatedStringForHour += "}"
	repeatedStringForDayOfMonth := "[]*Range{"
	for _, f := range this.DayOfMonth {
		repeatedStringForDayOfMonth += strings.Replace(f.String(), "Range", "Range", 1) + ","
	}
	repeatedStringForDayOfMonth += "}"
	repeatedStringForMonth := "[]*Range{"
	for _, f := range this.Month {
		repeatedStringForMonth += strings.Replace(f.String(), "Range", "Range", 1) + ","
	}
	repeatedStringForMonth += "}"
	repeatedStringForYear := "[]*Range{"
	for _, f := range this.Year {
		repeatedStringForYear += strings.Replace(f.String(), "Range", "Range", 1) + ","
	}
	repeatedStringForYear += "}"
	repeatedStringForDayOfWeek := "[]*Range{"
	for _, f := range this.DayOfWeek {
		repeatedStringForDayOfWeek += strings.Replace(f.String(), "Range", "Range", 1) + ","
	}
	repeatedStringForDayOfWeek += "}"
	s := strings.Join([]string{`&StructuredCalendarSpec{`,
		`Second:` + repeatedStringForSecond + `,`,
		`Minute:` + repeatedStringForMinute + `,`,
		`Hour:` + repeatedStringForHour + `,`,
		`DayOfMonth:` + repeatedStringForDayOfMonth + `,`,
		`Month:` + repeatedStringForMonth + `,`,
		`Year:` + repeatedStringForYear + `,`,
		`DayOfWeek:` + repeatedStringForDayOfWeek + `,`,
		`Comment:` + fmt.Sprintf("%v", this.Comment) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IntervalSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IntervalSpec{`,
		`Interval:` + strings.Replace(fmt.Sprintf("%v", this.Interval), "Duration", "types.Duration", 1) + `,`,
		`Phase:` + strings.Replace(fmt.Sprintf("%v", this.Phase), "Duration", "types.Duration", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScheduleSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCalendar := "[]*CalendarSpec{"
	for _, f := range this.Calendar {
		repeatedStringForCalendar += strings.Replace(f.String(), "CalendarSpec", "CalendarSpec", 1) + ","
	}
	repeatedStringForCalendar += "}"
	repeatedStringForInterval := "[]*IntervalSpec{"
	for _, f := range this.Interval {
		repeatedStringForInterval += strings.Replace(f.String(), "IntervalSpec", "IntervalSpec", 1) + ","
	}
	repeatedStringForInterval += "}"
	repeatedStringForExcludeCalendar := "[]*CalendarSpec{"
	for _, f := range this.ExcludeCalendar {
		repeatedStringForExcludeCalendar += strings.Replace(f.String(), "CalendarSpec", "CalendarSpec", 1) + ","
	}
	repeatedStringForExcludeCalendar += "}"
	repeatedStringForStructuredCalendar := "[]*StructuredCalendarSpec{"
	for _, f := range this.StructuredCalendar {
		repeatedStringForStructuredCalendar += strings.Replace(f.String(), "StructuredCalendarSpec", "StructuredCalendarSpec", 1) + ","
	}
	repeatedStringForStructuredCalendar += "}"
	repeatedStringForExcludeStructuredCalendar := "[]*StructuredCalendarSpec{"
	for _, f := range this.ExcludeStructuredCalendar {
		repeatedStringForExcludeStructuredCalendar += strings.Replace(f.String(), "StructuredCalendarSpec", "StructuredCalendarSpec", 1) + ","
	}
	repeatedStringForExcludeStructuredCalendar += "}"
	s := strings.Join([]string{`&ScheduleSpec{`,
		`Calendar:` + repeatedStringForCalendar + `,`,
		`Interval:` + repeatedStringForInterval + `,`,
		`ExcludeCalendar:` + repeatedStringForExcludeCalendar + `,`,
		`StartTime:` + strings.Replace(fmt.Sprintf("%v", this.StartTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`EndTime:` + strings.Replace(fmt.Sprintf("%v", this.EndTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`Jitter:` + strings.Replace(fmt.Sprintf("%v", this.Jitter), "Duration", "types.Duration", 1) + `,`,
		`StructuredCalendar:` + repeatedStringForStructuredCalendar + `,`,
		`CronString:` + fmt.Sprintf("%v", this.CronString) + `,`,
		`ExcludeStructuredCalendar:` + repeatedStringForExcludeStructuredCalendar + `,`,
		`TimezoneName:` + fmt.Sprintf("%v", this.TimezoneName) + `,`,
		`TimezoneData:` + fmt.Sprintf("%v", this.TimezoneData) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SchedulePolicies) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SchedulePolicies{`,
		`OverlapPolicy:` + fmt.Sprintf("%v", this.OverlapPolicy) + `,`,
		`CatchupWindow:` + strings.Replace(fmt.Sprintf("%v", this.CatchupWindow), "Duration", "types.Duration", 1) + `,`,
		`PauseOnFailure:` + fmt.Sprintf("%v", this.PauseOnFailure) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScheduleAction) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ScheduleAction{`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScheduleAction_StartWorkflow) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ScheduleAction_StartWorkflow{`,
		`StartWorkflow:` + strings.Replace(fmt.Sprintf("%v", this.StartWorkflow), "NewWorkflowExecutionInfo", "v11.NewWorkflowExecutionInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScheduleActionResult) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ScheduleActionResult{`,
		`ScheduleTime:` + strings.Replace(fmt.Sprintf("%v", this.ScheduleTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`ActualTime:` + strings.Replace(fmt.Sprintf("%v", this.ActualTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`StartWorkflowResult:` + strings.Replace(fmt.Sprintf("%v", this.StartWorkflowResult), "WorkflowExecution", "v12.WorkflowExecution", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScheduleState) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ScheduleState{`,
		`Notes:` + fmt.Sprintf("%v", this.Notes) + `,`,
		`Paused:` + fmt.Sprintf("%v", this.Paused) + `,`,
		`LimitedActions:` + fmt.Sprintf("%v", this.LimitedActions) + `,`,
		`RemainingActions:` + fmt.Sprintf("%v", this.RemainingActions) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TriggerImmediatelyRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TriggerImmediatelyRequest{`,
		`OverlapPolicy:` + fmt.Sprintf("%v", this.OverlapPolicy) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BackfillRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BackfillRequest{`,
		`StartTime:` + strings.Replace(fmt.Sprintf("%v", this.StartTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`EndTime:` + strings.Replace(fmt.Sprintf("%v", this.EndTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`OverlapPolicy:` + fmt.Sprintf("%v", this.OverlapPolicy) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SchedulePatch) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForBackfillRequest := "[]*BackfillRequest{"
	for _, f := range this.BackfillRequest {
		repeatedStringForBackfillRequest += strings.Replace(f.String(), "BackfillRequest", "BackfillRequest", 1) + ","
	}
	repeatedStringForBackfillRequest += "}"
	s := strings.Join([]string{`&SchedulePatch{`,
		`TriggerImmediately:` + strings.Replace(this.TriggerImmediately.String(), "TriggerImmediatelyRequest", "TriggerImmediatelyRequest", 1) + `,`,
		`BackfillRequest:` + repeatedStringForBackfillRequest + `,`,
		`Pause:` + fmt.Sprintf("%v", this.Pause) + `,`,
		`Unpause:` + fmt.Sprintf("%v", this.Unpause) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScheduleInfo) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRecentActions := "[]*ScheduleActionResult{"
	for _, f := range this.RecentActions {
		repeatedStringForRecentActions += strings.Replace(f.String(), "ScheduleActionResult", "ScheduleActionResult", 1) + ","
	}
	repeatedStringForRecentActions += "}"
	repeatedStringForFutureActionTimes := "[]*Timestamp{"
	for _, f := range this.FutureActionTimes {
		repeatedStringForFutureActionTimes += strings.Replace(fmt.Sprintf("%v", f), "Timestamp", "types.Timestamp", 1) + ","
	}
	repeatedStringForFutureActionTimes += "}"
	repeatedStringForRunningWorkflows := "[]*WorkflowExecution{"
	for _, f := range this.RunningWorkflows {
		repeatedStringForRunningWorkflows += strings.Replace(fmt.Sprintf("%v", f), "WorkflowExecution", "v12.WorkflowExecution", 1) + ","
	}
	repeatedStringForRunningWorkflows += "}"
	s := strings.Join([]string{`&ScheduleInfo{`,
		`ActionCount:` + fmt.Sprintf("%v", this.ActionCount) + `,`,
		`MissedCatchupWindow:` + fmt.Sprintf("%v", this.MissedCatchupWindow) + `,`,
		`OverlapSkipped:` + fmt.Sprintf("%v", this.OverlapSkipped) + `,`,
		`RecentActions:` + repeatedStringForRecentActions + `,`,
		`FutureActionTimes:` + repeatedStringForFutureActionTimes + `,`,
		`CreateTime:` + strings.Replace(fmt.Sprintf("%v", this.CreateTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`UpdateTime:` + strings.Replace(fmt.Sprintf("%v", this.UpdateTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`InvalidScheduleError:` + fmt.Sprintf("%v", this.InvalidScheduleError) + `,`,
		`RunningWorkflows:` + repeatedStringForRunningWorkflows + `,`,
		`}`,
	}, "")
	return s
}
func (this *Schedule) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Schedule{`,
		`Spec:` + strings.Replace(this.Spec.String(), "ScheduleSpec", "ScheduleSpec", 1) + `,`,
		`Action:` + strings.Replace(this.Action.String(), "ScheduleAction", "ScheduleAction", 1) + `,`,
		`Policies:` + strings.Replace(this.Policies.String(), "SchedulePolicies", "SchedulePolicies", 1) + `,`,
		`State:` + strings.Replace(this.State.String(), "ScheduleState", "ScheduleState", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScheduleListInfo) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRecentActions := "[]*ScheduleActionResult{"
	for _, f := range this.RecentActions {
		repeatedStringForRecentActions += strings.Replace(f.String(), "ScheduleActionResult", "ScheduleActionResult", 1) + ","
	}
	repeatedStringForRecentActions += "}"
	repeatedStringForFutureActionTimes := "[]*Timestamp{"
	for _, f := range this.FutureActionTimes {
		repeatedStringForFutureActionTimes += strings.Replace(fmt.Sprintf("%v", f), "Timestamp", "types.Timestamp", 1) + ","
	}
	repeatedStringForFutureActionTimes += "}"
	s := strings.Join([]string{`&ScheduleListInfo{`,
		`Spec:` + strings.Replace(this.Spec.String(), "ScheduleSpec", "ScheduleSpec", 1) + `,`,
		`WorkflowType:` + strings.Replace(fmt.Sprintf("%v", this.WorkflowType), "WorkflowType", "v12.WorkflowType", 1) + `,`,
		`Notes:` + fmt.Sprintf("%v", this.Notes) + `,`,
		`Paused:` + fmt.Sprintf("%v", this.Paused) + `,`,
		`RecentActions:` + repeatedStringForRecentActions + `,`,
		`FutureActionTimes:` + repeatedStringForFutureActionTimes + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScheduleListEntry) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ScheduleListEntry{`,
		`ScheduleId:` + fmt.Sprintf("%v", this.ScheduleId) + `,`,
		`Memo:` + strings.Replace(fmt.Sprintf("%v", this.Memo), "Memo", "v12.Memo", 1) + `,`,
		`SearchAttributes:` + strings.Replace(fmt.Sprintf("%v", this.SearchAttributes), "SearchAttributes", "v12.SearchAttributes", 1) + `,`,
		`Info:` + strings.Replace(this.Info.String(), "ScheduleListInfo", "ScheduleListInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringMessage(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *CalendarSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CalendarSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CalendarSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Second", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Second = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minute", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Minute = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hour", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hour = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DayOfMonth", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DayOfMonth = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Month", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Month = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Year", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Year = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DayOfWeek", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DayOfWeek = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Range) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			m.Step = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Step |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StructuredCalendarSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StructuredCalendarSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StructuredCalendarSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Second", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Second = append(m.Second, &Range{})
			if err := m.Second[len(m.Second)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minute", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Minute = append(m.Minute, &Range{})
			if err := m.Minute[len(m.Minute)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hour", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hour = append(m.Hour, &Range{})
			if err := m.Hour[len(m.Hour)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DayOfMonth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DayOfMonth = append(m.DayOfMonth, &Range{})
			if err := m.DayOfMonth[len(m.DayOfMonth)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Month", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Month = append(m.Month, &Range{})
			if err := m.Month[len(m.Month)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Year", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Year = append(m.Year, &Range{})
			if err := m.Year[len(m.Year)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DayOfWeek", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DayOfWeek = append(m.DayOfWeek, &Range{})
			if err := m.DayOfWeek[len(m.DayOfWeek)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IntervalSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IntervalSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IntervalSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Interval == nil {
				m.Interval = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.Interval, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Phase == nil {
				m.Phase = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.Phase, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScheduleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScheduleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScheduleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Calendar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Calendar = append(m.Calendar, &CalendarSpec{})
			if err := m.Calendar[len(m.Calendar)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interval = append(m.Interval, &IntervalSpec{})
			if err := m.Interval[len(m.Interval)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeCalendar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExcludeCalendar = append(m.ExcludeCalendar, &CalendarSpec{})
			if err := m.ExcludeCalendar[len(m.ExcludeCalendar)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.StartTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndTime == nil {
				m.EndTime = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.EndTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jitter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Jitter == nil {
				m.Jitter = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.Jitter, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StructuredCalendar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StructuredCalendar = append(m.StructuredCalendar, &StructuredCalendarSpec{})
			if err := m.StructuredCalendar[len(m.StructuredCalendar)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CronString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CronString = append(m.CronString, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeStructuredCalendar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExcludeStructuredCalendar = append(m.ExcludeStructuredCalendar, &StructuredCalendarSpec{})
			if err := m.ExcludeStructuredCalendar[len(m.ExcludeStructuredCalendar)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimezoneName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimezoneName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimezoneData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimezoneData = append(m.TimezoneData[:0], dAtA[iNdEx:postIndex]...)
			if m.TimezoneData == nil {
				m.TimezoneData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchedulePolicies) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchedulePolicies: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchedulePolicies: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverlapPolicy", wireType)
			}
			m.OverlapPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverlapPolicy |= v1.ScheduleOverlapPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CatchupWindow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CatchupWindow == nil {
				m.CatchupWindow = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.CatchupWindow, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PauseOnFailure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PauseOnFailure = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScheduleAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScheduleAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScheduleAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartWorkflow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v11.NewWorkflowExecutionInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ScheduleAction_StartWorkflow{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScheduleActionResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScheduleActionResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScheduleActionResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScheduleTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScheduleTime == nil {
				m.ScheduleTime = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.ScheduleTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActualTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActualTime == nil {
				m.ActualTime = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.ActualTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartWorkflowResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartWorkflowResult == nil {
				m.StartWorkflowResult = &v12.WorkflowExecution{}
			}
			if err := m.StartWorkflowResult.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScheduleState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScheduleState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScheduleState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Paused = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitedActions", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LimitedActions = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainingActions", wireType)
			}
			m.RemainingActions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemainingActions |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TriggerImmediatelyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TriggerImmediatelyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TriggerImmediatelyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverlapPolicy", wireType)
			}
			m.OverlapPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverlapPolicy |= v1.ScheduleOverlapPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackfillRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackfillRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackfillRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.StartTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndTime == nil {
				m.EndTime = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.EndTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverlapPolicy", wireType)
			}
			m.OverlapPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverlapPolicy |= v1.ScheduleOverlapPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchedulePatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchedulePatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchedulePatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerImmediately", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TriggerImmediately == nil {
				m.TriggerImmediately = &TriggerImmediatelyRequest{}
			}
			if err := m.TriggerImmediately.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackfillRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackfillRequest = append(m.BackfillRequest, &BackfillRequest{})
			if err := m.BackfillRequest[len(m.BackfillRequest)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pause", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pause = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unpause", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unpause = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScheduleInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScheduleInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScheduleInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionCount", wireType)
			}
			m.ActionCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActionCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissedCatchupWindow", wireType)
			}
			m.MissedCatchupWindow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MissedCatchupWindow |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverlapSkipped", wireType)
			}
			m.OverlapSkipped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverlapSkipped |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecentActions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecentActions = append(m.RecentActions, &ScheduleActionResult{})
			if err := m.RecentActions[len(m.RecentActions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FutureActionTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FutureActionTimes = append(m.FutureActionTimes, new(time.Time))
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.FutureActionTimes[len(m.FutureActionTimes)-1], dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateTime == nil {
				m.CreateTime = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.CreateTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateTime == nil {
				m.UpdateTime = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.UpdateTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvalidScheduleError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvalidScheduleError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunningWorkflows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RunningWorkflows = append(m.RunningWorkflows, &v12.WorkflowExecution{})
			if err := m.RunningWorkflows[len(m.RunningWorkflows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Schedule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Schedule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Schedule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &ScheduleSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Action == nil {
				m.Action = &ScheduleAction{}
			}
			if err := m.Action.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policies == nil {
				m.Policies = &SchedulePolicies{}
			}
			if err := m.Policies.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &ScheduleState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScheduleListInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScheduleListInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScheduleListInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &ScheduleSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkflowType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WorkflowType == nil {
				m.WorkflowType = &v12.WorkflowType{}
			}
			if err := m.WorkflowType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Paused = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecentActions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecentActions = append(m.RecentActions, &ScheduleActionResult{})
			if err := m.RecentActions[len(m.RecentActions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FutureActionTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FutureActionTimes = append(m.FutureActionTimes, new(time.Time))
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.FutureActionTimes[len(m.FutureActionTimes)-1], dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScheduleListEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScheduleListEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScheduleListEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScheduleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScheduleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Memo == nil {
				m.Memo = &v12.Memo{}
			}
			if err := m.Memo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchAttributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SearchAttributes == nil {
				m.SearchAttributes = &v12.SearchAttributes{}
			}
			if err := m.SearchAttributes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &ScheduleListInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMessage(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMessage
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMessage
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMessage
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMessage        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMessage          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMessage = fmt.Errorf("proto: unexpected end of group")
)
