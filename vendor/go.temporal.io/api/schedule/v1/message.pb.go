// (-- api-linter: core::0203::optional=disabled
//     aip.dev/not-precedent: field_behavior annotation not available in our gogo fork --)
// (-- api-linter: core::0203::input-only=disabled
//     aip.dev/not-precedent: field_behavior annotation not available in our gogo fork --)

// Code generated by protoc-gen-go. DO NOT EDIT.
// plugins:
// 	protoc-gen-go
// 	protoc
// source: temporal/api/schedule/v1/message.proto

package schedule

import (
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"

	v12 "go.temporal.io/api/common/v1"
	v1 "go.temporal.io/api/enums/v1"
	v11 "go.temporal.io/api/workflow/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// CalendarSpec describes an event specification relative to the calendar,
// similar to a traditional cron specification, but with labeled fields. Each
// field can be one of:
//
//	*: matches always
//	x: matches when the field equals x
//	x/y : matches when the field equals x+n*y where n is an integer
//	x-z: matches when the field is between x and z inclusive
//	w,x,y,...: matches when the field is one of the listed values
//
// Each x, y, z, ... is either a decimal integer, or a month or day of week name
// or abbreviation (in the appropriate fields).
// A timestamp matches if all fields match.
// Note that fields have different default values, for convenience.
// Note that the special case that some cron implementations have for treating
// day_of_month and day_of_week as "or" instead of "and" when both are set is
// not implemented.
// day_of_week can accept 0 or 7 as Sunday
// CalendarSpec gets compiled into StructuredCalendarSpec, which is what will be
// returned if you describe the schedule.
type CalendarSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Expression to match seconds. Default: 0
	Second string `protobuf:"bytes,1,opt,name=second,proto3" json:"second,omitempty"`
	// Expression to match minutes. Default: 0
	Minute string `protobuf:"bytes,2,opt,name=minute,proto3" json:"minute,omitempty"`
	// Expression to match hours. Default: 0
	Hour string `protobuf:"bytes,3,opt,name=hour,proto3" json:"hour,omitempty"`
	// Expression to match days of the month. Default: *
	// (-- api-linter: core::0140::prepositions=disabled
	//
	//	aip.dev/not-precedent: standard name of field --)
	DayOfMonth string `protobuf:"bytes,4,opt,name=day_of_month,json=dayOfMonth,proto3" json:"day_of_month,omitempty"`
	// Expression to match months. Default: *
	Month string `protobuf:"bytes,5,opt,name=month,proto3" json:"month,omitempty"`
	// Expression to match years. Default: *
	Year string `protobuf:"bytes,6,opt,name=year,proto3" json:"year,omitempty"`
	// Expression to match days of the week. Default: *
	DayOfWeek string `protobuf:"bytes,7,opt,name=day_of_week,json=dayOfWeek,proto3" json:"day_of_week,omitempty"`
	// Free-form comment describing the intention of this spec.
	Comment       string `protobuf:"bytes,8,opt,name=comment,proto3" json:"comment,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CalendarSpec) Reset() {
	*x = CalendarSpec{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CalendarSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CalendarSpec) ProtoMessage() {}

func (x *CalendarSpec) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CalendarSpec.ProtoReflect.Descriptor instead.
func (*CalendarSpec) Descriptor() ([]byte, []int) {
	return file_temporal_api_schedule_v1_message_proto_rawDescGZIP(), []int{0}
}

func (x *CalendarSpec) GetSecond() string {
	if x != nil {
		return x.Second
	}
	return ""
}

func (x *CalendarSpec) GetMinute() string {
	if x != nil {
		return x.Minute
	}
	return ""
}

func (x *CalendarSpec) GetHour() string {
	if x != nil {
		return x.Hour
	}
	return ""
}

func (x *CalendarSpec) GetDayOfMonth() string {
	if x != nil {
		return x.DayOfMonth
	}
	return ""
}

func (x *CalendarSpec) GetMonth() string {
	if x != nil {
		return x.Month
	}
	return ""
}

func (x *CalendarSpec) GetYear() string {
	if x != nil {
		return x.Year
	}
	return ""
}

func (x *CalendarSpec) GetDayOfWeek() string {
	if x != nil {
		return x.DayOfWeek
	}
	return ""
}

func (x *CalendarSpec) GetComment() string {
	if x != nil {
		return x.Comment
	}
	return ""
}

// Range represents a set of integer values, used to match fields of a calendar
// time in StructuredCalendarSpec. If end < start, then end is interpreted as
// equal to start. This means you can use a Range with start set to a value, and
// end and step unset (defaulting to 0) to represent a single value.
type Range struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Start of range (inclusive).
	Start int32 `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	// End of range (inclusive).
	End int32 `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	// Step (optional, default 1).
	Step          int32 `protobuf:"varint,3,opt,name=step,proto3" json:"step,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Range) Reset() {
	*x = Range{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Range) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Range) ProtoMessage() {}

func (x *Range) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Range.ProtoReflect.Descriptor instead.
func (*Range) Descriptor() ([]byte, []int) {
	return file_temporal_api_schedule_v1_message_proto_rawDescGZIP(), []int{1}
}

func (x *Range) GetStart() int32 {
	if x != nil {
		return x.Start
	}
	return 0
}

func (x *Range) GetEnd() int32 {
	if x != nil {
		return x.End
	}
	return 0
}

func (x *Range) GetStep() int32 {
	if x != nil {
		return x.Step
	}
	return 0
}

// StructuredCalendarSpec describes an event specification relative to the
// calendar, in a form that's easy to work with programmatically. Each field can
// be one or more ranges.
// A timestamp matches if at least one range of each field matches the
// corresponding fields of the timestamp, except for year: if year is missing,
// that means all years match. For all fields besides year, at least one Range
// must be present to match anything.
// TODO: add relative-to-end-of-month
// TODO: add nth day-of-week in month
type StructuredCalendarSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Match seconds (0-59)
	Second []*Range `protobuf:"bytes,1,rep,name=second,proto3" json:"second,omitempty"`
	// Match minutes (0-59)
	Minute []*Range `protobuf:"bytes,2,rep,name=minute,proto3" json:"minute,omitempty"`
	// Match hours (0-23)
	Hour []*Range `protobuf:"bytes,3,rep,name=hour,proto3" json:"hour,omitempty"`
	// Match days of the month (1-31)
	// (-- api-linter: core::0140::prepositions=disabled
	//
	//	aip.dev/not-precedent: standard name of field --)
	DayOfMonth []*Range `protobuf:"bytes,4,rep,name=day_of_month,json=dayOfMonth,proto3" json:"day_of_month,omitempty"`
	// Match months (1-12)
	Month []*Range `protobuf:"bytes,5,rep,name=month,proto3" json:"month,omitempty"`
	// Match years.
	Year []*Range `protobuf:"bytes,6,rep,name=year,proto3" json:"year,omitempty"`
	// Match days of the week (0-6; 0 is Sunday).
	DayOfWeek []*Range `protobuf:"bytes,7,rep,name=day_of_week,json=dayOfWeek,proto3" json:"day_of_week,omitempty"`
	// Free-form comment describing the intention of this spec.
	Comment       string `protobuf:"bytes,8,opt,name=comment,proto3" json:"comment,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StructuredCalendarSpec) Reset() {
	*x = StructuredCalendarSpec{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StructuredCalendarSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StructuredCalendarSpec) ProtoMessage() {}

func (x *StructuredCalendarSpec) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StructuredCalendarSpec.ProtoReflect.Descriptor instead.
func (*StructuredCalendarSpec) Descriptor() ([]byte, []int) {
	return file_temporal_api_schedule_v1_message_proto_rawDescGZIP(), []int{2}
}

func (x *StructuredCalendarSpec) GetSecond() []*Range {
	if x != nil {
		return x.Second
	}
	return nil
}

func (x *StructuredCalendarSpec) GetMinute() []*Range {
	if x != nil {
		return x.Minute
	}
	return nil
}

func (x *StructuredCalendarSpec) GetHour() []*Range {
	if x != nil {
		return x.Hour
	}
	return nil
}

func (x *StructuredCalendarSpec) GetDayOfMonth() []*Range {
	if x != nil {
		return x.DayOfMonth
	}
	return nil
}

func (x *StructuredCalendarSpec) GetMonth() []*Range {
	if x != nil {
		return x.Month
	}
	return nil
}

func (x *StructuredCalendarSpec) GetYear() []*Range {
	if x != nil {
		return x.Year
	}
	return nil
}

func (x *StructuredCalendarSpec) GetDayOfWeek() []*Range {
	if x != nil {
		return x.DayOfWeek
	}
	return nil
}

func (x *StructuredCalendarSpec) GetComment() string {
	if x != nil {
		return x.Comment
	}
	return ""
}

// IntervalSpec matches times that can be expressed as:
// epoch + n * interval + phase
// where n is an integer.
// phase defaults to zero if missing. interval is required.
// Both interval and phase must be non-negative and are truncated to the nearest
// second before any calculations.
// For example, an interval of 1 hour with phase of zero would match every hour,
// on the hour. The same interval but a phase of 19 minutes would match every
// xx:19:00. An interval of 28 days with phase zero would match
// 2022-02-17T00:00:00Z (among other times). The same interval with a phase of 3
// days, 5 hours, and 23 minutes would match 2022-02-20T05:23:00Z instead.
type IntervalSpec struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Interval      *durationpb.Duration   `protobuf:"bytes,1,opt,name=interval,proto3" json:"interval,omitempty"`
	Phase         *durationpb.Duration   `protobuf:"bytes,2,opt,name=phase,proto3" json:"phase,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IntervalSpec) Reset() {
	*x = IntervalSpec{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IntervalSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IntervalSpec) ProtoMessage() {}

func (x *IntervalSpec) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IntervalSpec.ProtoReflect.Descriptor instead.
func (*IntervalSpec) Descriptor() ([]byte, []int) {
	return file_temporal_api_schedule_v1_message_proto_rawDescGZIP(), []int{3}
}

func (x *IntervalSpec) GetInterval() *durationpb.Duration {
	if x != nil {
		return x.Interval
	}
	return nil
}

func (x *IntervalSpec) GetPhase() *durationpb.Duration {
	if x != nil {
		return x.Phase
	}
	return nil
}

// ScheduleSpec is a complete description of a set of absolute timestamps
// (possibly infinite) that an action should occur at. The meaning of a
// ScheduleSpec depends only on its contents and never changes, except that the
// definition of a time zone can change over time (most commonly, when daylight
// saving time policy changes for an area). To create a totally self-contained
// ScheduleSpec, use UTC or include timezone_data.
//
// For input, you can provide zero or more of: structured_calendar, calendar,
// cron_string, interval, and exclude_structured_calendar, and all of them will
// be used (the schedule will take action at the union of all of their times,
// minus the ones that match exclude_structured_calendar).
//
// On input, calendar and cron_string fields will be compiled into
// structured_calendar (and maybe interval and timezone_name), so if you
// Describe a schedule, you'll see only structured_calendar, interval, etc.
//
// If a spec has no matching times after the current time, then the schedule
// will be subject to automatic deletion (after several days).
type ScheduleSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Calendar-based specifications of times.
	StructuredCalendar []*StructuredCalendarSpec `protobuf:"bytes,7,rep,name=structured_calendar,json=structuredCalendar,proto3" json:"structured_calendar,omitempty"`
	// cron_string holds a traditional cron specification as a string. It
	// accepts 5, 6, or 7 fields, separated by spaces, and interprets them the
	// same way as CalendarSpec.
	// 5 fields:         minute, hour, day_of_month, month, day_of_week
	// 6 fields:         minute, hour, day_of_month, month, day_of_week, year
	// 7 fields: second, minute, hour, day_of_month, month, day_of_week, year
	// If year is not given, it defaults to *. If second is not given, it
	// defaults to 0.
	// Shorthands @yearly, @monthly, @weekly, @daily, and @hourly are also
	// accepted instead of the 5-7 time fields.
	// Optionally, the string can be preceded by CRON_TZ=<timezone name> or
	// TZ=<timezone name>, which will get copied to timezone_name. (There must
	// not also be a timezone_name present.)
	// Optionally "#" followed by a comment can appear at the end of the string.
	// Note that the special case that some cron implementations have for
	// treating day_of_month and day_of_week as "or" instead of "and" when both
	// are set is not implemented.
	// @every <interval>[/<phase>] is accepted and gets compiled into an
	// IntervalSpec instead. <interval> and <phase> should be a decimal integer
	// with a unit suffix s, m, h, or d.
	CronString []string `protobuf:"bytes,8,rep,name=cron_string,json=cronString,proto3" json:"cron_string,omitempty"`
	// Calendar-based specifications of times.
	Calendar []*CalendarSpec `protobuf:"bytes,1,rep,name=calendar,proto3" json:"calendar,omitempty"`
	// Interval-based specifications of times.
	Interval []*IntervalSpec `protobuf:"bytes,2,rep,name=interval,proto3" json:"interval,omitempty"`
	// Any timestamps matching any of exclude_* will be skipped.
	// Deprecated. Use exclude_structured_calendar.
	//
	// Deprecated: Marked as deprecated in temporal/api/schedule/v1/message.proto.
	ExcludeCalendar           []*CalendarSpec           `protobuf:"bytes,3,rep,name=exclude_calendar,json=excludeCalendar,proto3" json:"exclude_calendar,omitempty"`
	ExcludeStructuredCalendar []*StructuredCalendarSpec `protobuf:"bytes,9,rep,name=exclude_structured_calendar,json=excludeStructuredCalendar,proto3" json:"exclude_structured_calendar,omitempty"`
	// If start_time is set, any timestamps before start_time will be skipped.
	// (Together, start_time and end_time make an inclusive interval.)
	StartTime *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// If end_time is set, any timestamps after end_time will be skipped.
	EndTime *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// All timestamps will be incremented by a random value from 0 to this
	// amount of jitter. Default: 0
	Jitter *durationpb.Duration `protobuf:"bytes,6,opt,name=jitter,proto3" json:"jitter,omitempty"`
	// Time zone to interpret all calendar-based specs in.
	//
	// If unset, defaults to UTC. We recommend using UTC for your application if
	// at all possible, to avoid various surprising properties of time zones.
	//
	// Time zones may be provided by name, corresponding to names in the IANA
	// time zone database (see https://www.iana.org/time-zones). The definition
	// will be loaded by the Temporal server from the environment it runs in.
	//
	// If your application requires more control over the time zone definition
	// used, it may pass in a complete definition in the form of a TZif file
	// from the time zone database. If present, this will be used instead of
	// loading anything from the environment. You are then responsible for
	// updating timezone_data when the definition changes.
	//
	// Calendar spec matching is based on literal matching of the clock time
	// with no special handling of DST: if you write a calendar spec that fires
	// at 2:30am and specify a time zone that follows DST, that action will not
	// be triggered on the day that has no 2:30am. Similarly, an action that
	// fires at 1:30am will be triggered twice on the day that has two 1:30s.
	//
	// Also note that no actions are taken on leap-seconds (e.g. 23:59:60 UTC).
	TimezoneName  string `protobuf:"bytes,10,opt,name=timezone_name,json=timezoneName,proto3" json:"timezone_name,omitempty"`
	TimezoneData  []byte `protobuf:"bytes,11,opt,name=timezone_data,json=timezoneData,proto3" json:"timezone_data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ScheduleSpec) Reset() {
	*x = ScheduleSpec{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScheduleSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScheduleSpec) ProtoMessage() {}

func (x *ScheduleSpec) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScheduleSpec.ProtoReflect.Descriptor instead.
func (*ScheduleSpec) Descriptor() ([]byte, []int) {
	return file_temporal_api_schedule_v1_message_proto_rawDescGZIP(), []int{4}
}

func (x *ScheduleSpec) GetStructuredCalendar() []*StructuredCalendarSpec {
	if x != nil {
		return x.StructuredCalendar
	}
	return nil
}

func (x *ScheduleSpec) GetCronString() []string {
	if x != nil {
		return x.CronString
	}
	return nil
}

func (x *ScheduleSpec) GetCalendar() []*CalendarSpec {
	if x != nil {
		return x.Calendar
	}
	return nil
}

func (x *ScheduleSpec) GetInterval() []*IntervalSpec {
	if x != nil {
		return x.Interval
	}
	return nil
}

// Deprecated: Marked as deprecated in temporal/api/schedule/v1/message.proto.
func (x *ScheduleSpec) GetExcludeCalendar() []*CalendarSpec {
	if x != nil {
		return x.ExcludeCalendar
	}
	return nil
}

func (x *ScheduleSpec) GetExcludeStructuredCalendar() []*StructuredCalendarSpec {
	if x != nil {
		return x.ExcludeStructuredCalendar
	}
	return nil
}

func (x *ScheduleSpec) GetStartTime() *timestamppb.Timestamp {
	if x != nil {
		return x.StartTime
	}
	return nil
}

func (x *ScheduleSpec) GetEndTime() *timestamppb.Timestamp {
	if x != nil {
		return x.EndTime
	}
	return nil
}

func (x *ScheduleSpec) GetJitter() *durationpb.Duration {
	if x != nil {
		return x.Jitter
	}
	return nil
}

func (x *ScheduleSpec) GetTimezoneName() string {
	if x != nil {
		return x.TimezoneName
	}
	return ""
}

func (x *ScheduleSpec) GetTimezoneData() []byte {
	if x != nil {
		return x.TimezoneData
	}
	return nil
}

type SchedulePolicies struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Policy for overlaps.
	// Note that this can be changed after a schedule has taken some actions,
	// and some changes might produce unintuitive results. In general, the later
	// policy overrides the earlier policy.
	OverlapPolicy v1.ScheduleOverlapPolicy `protobuf:"varint,1,opt,name=overlap_policy,json=overlapPolicy,proto3,enum=temporal.api.enums.v1.ScheduleOverlapPolicy" json:"overlap_policy,omitempty"`
	// Policy for catchups:
	// If the Temporal server misses an action due to one or more components
	// being down, and comes back up, the action will be run if the scheduled
	// time is within this window from the current time.
	// This value defaults to one year, and can't be less than 10 seconds.
	CatchupWindow *durationpb.Duration `protobuf:"bytes,2,opt,name=catchup_window,json=catchupWindow,proto3" json:"catchup_window,omitempty"`
	// If true, and a workflow run fails or times out, turn on "paused".
	// This applies after retry policies: the full chain of retries must fail to
	// trigger a pause here.
	PauseOnFailure bool `protobuf:"varint,3,opt,name=pause_on_failure,json=pauseOnFailure,proto3" json:"pause_on_failure,omitempty"`
	// If true, and the action would start a workflow, a timestamp will not be
	// appended to the scheduled workflow id.
	KeepOriginalWorkflowId bool `protobuf:"varint,4,opt,name=keep_original_workflow_id,json=keepOriginalWorkflowId,proto3" json:"keep_original_workflow_id,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *SchedulePolicies) Reset() {
	*x = SchedulePolicies{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SchedulePolicies) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SchedulePolicies) ProtoMessage() {}

func (x *SchedulePolicies) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SchedulePolicies.ProtoReflect.Descriptor instead.
func (*SchedulePolicies) Descriptor() ([]byte, []int) {
	return file_temporal_api_schedule_v1_message_proto_rawDescGZIP(), []int{5}
}

func (x *SchedulePolicies) GetOverlapPolicy() v1.ScheduleOverlapPolicy {
	if x != nil {
		return x.OverlapPolicy
	}
	return v1.ScheduleOverlapPolicy(0)
}

func (x *SchedulePolicies) GetCatchupWindow() *durationpb.Duration {
	if x != nil {
		return x.CatchupWindow
	}
	return nil
}

func (x *SchedulePolicies) GetPauseOnFailure() bool {
	if x != nil {
		return x.PauseOnFailure
	}
	return false
}

func (x *SchedulePolicies) GetKeepOriginalWorkflowId() bool {
	if x != nil {
		return x.KeepOriginalWorkflowId
	}
	return false
}

type ScheduleAction struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Action:
	//
	//	*ScheduleAction_StartWorkflow
	Action        isScheduleAction_Action `protobuf_oneof:"action"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ScheduleAction) Reset() {
	*x = ScheduleAction{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScheduleAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScheduleAction) ProtoMessage() {}

func (x *ScheduleAction) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScheduleAction.ProtoReflect.Descriptor instead.
func (*ScheduleAction) Descriptor() ([]byte, []int) {
	return file_temporal_api_schedule_v1_message_proto_rawDescGZIP(), []int{6}
}

func (x *ScheduleAction) GetAction() isScheduleAction_Action {
	if x != nil {
		return x.Action
	}
	return nil
}

func (x *ScheduleAction) GetStartWorkflow() *v11.NewWorkflowExecutionInfo {
	if x != nil {
		if x, ok := x.Action.(*ScheduleAction_StartWorkflow); ok {
			return x.StartWorkflow
		}
	}
	return nil
}

type isScheduleAction_Action interface {
	isScheduleAction_Action()
}

type ScheduleAction_StartWorkflow struct {
	// All fields of NewWorkflowExecutionInfo are valid except for:
	// - workflow_id_reuse_policy
	// - cron_schedule
	// The workflow id of the started workflow may not match this exactly,
	// it may have a timestamp appended for uniqueness.
	StartWorkflow *v11.NewWorkflowExecutionInfo `protobuf:"bytes,1,opt,name=start_workflow,json=startWorkflow,proto3,oneof"`
}

func (*ScheduleAction_StartWorkflow) isScheduleAction_Action() {}

type ScheduleActionResult struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Time that the action was taken (according to the schedule, including jitter).
	ScheduleTime *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=schedule_time,json=scheduleTime,proto3" json:"schedule_time,omitempty"`
	// Time that the action was taken (real time).
	ActualTime *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=actual_time,json=actualTime,proto3" json:"actual_time,omitempty"`
	// If action was start_workflow:
	StartWorkflowResult *v12.WorkflowExecution `protobuf:"bytes,11,opt,name=start_workflow_result,json=startWorkflowResult,proto3" json:"start_workflow_result,omitempty"`
	// If the action was start_workflow, this field will reflect an
	// eventually-consistent view of the started workflow's status.
	StartWorkflowStatus v1.WorkflowExecutionStatus `protobuf:"varint,12,opt,name=start_workflow_status,json=startWorkflowStatus,proto3,enum=temporal.api.enums.v1.WorkflowExecutionStatus" json:"start_workflow_status,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *ScheduleActionResult) Reset() {
	*x = ScheduleActionResult{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScheduleActionResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScheduleActionResult) ProtoMessage() {}

func (x *ScheduleActionResult) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScheduleActionResult.ProtoReflect.Descriptor instead.
func (*ScheduleActionResult) Descriptor() ([]byte, []int) {
	return file_temporal_api_schedule_v1_message_proto_rawDescGZIP(), []int{7}
}

func (x *ScheduleActionResult) GetScheduleTime() *timestamppb.Timestamp {
	if x != nil {
		return x.ScheduleTime
	}
	return nil
}

func (x *ScheduleActionResult) GetActualTime() *timestamppb.Timestamp {
	if x != nil {
		return x.ActualTime
	}
	return nil
}

func (x *ScheduleActionResult) GetStartWorkflowResult() *v12.WorkflowExecution {
	if x != nil {
		return x.StartWorkflowResult
	}
	return nil
}

func (x *ScheduleActionResult) GetStartWorkflowStatus() v1.WorkflowExecutionStatus {
	if x != nil {
		return x.StartWorkflowStatus
	}
	return v1.WorkflowExecutionStatus(0)
}

type ScheduleState struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Informative human-readable message with contextual notes, e.g. the reason
	// a schedule is paused. The system may overwrite this message on certain
	// conditions, e.g. when pause-on-failure happens.
	Notes string `protobuf:"bytes,1,opt,name=notes,proto3" json:"notes,omitempty"`
	// If true, do not take any actions based on the schedule spec.
	Paused bool `protobuf:"varint,2,opt,name=paused,proto3" json:"paused,omitempty"`
	// If limited_actions is true, decrement remaining_actions after each
	// action, and do not take any more scheduled actions if remaining_actions
	// is zero. Actions may still be taken by explicit request (i.e. trigger
	// immediately or backfill). Skipped actions (due to overlap policy) do not
	// count against remaining actions.
	// If a schedule has no more remaining actions, then the schedule will be
	// subject to automatic deletion (after several days).
	LimitedActions   bool  `protobuf:"varint,3,opt,name=limited_actions,json=limitedActions,proto3" json:"limited_actions,omitempty"`
	RemainingActions int64 `protobuf:"varint,4,opt,name=remaining_actions,json=remainingActions,proto3" json:"remaining_actions,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *ScheduleState) Reset() {
	*x = ScheduleState{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScheduleState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScheduleState) ProtoMessage() {}

func (x *ScheduleState) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScheduleState.ProtoReflect.Descriptor instead.
func (*ScheduleState) Descriptor() ([]byte, []int) {
	return file_temporal_api_schedule_v1_message_proto_rawDescGZIP(), []int{8}
}

func (x *ScheduleState) GetNotes() string {
	if x != nil {
		return x.Notes
	}
	return ""
}

func (x *ScheduleState) GetPaused() bool {
	if x != nil {
		return x.Paused
	}
	return false
}

func (x *ScheduleState) GetLimitedActions() bool {
	if x != nil {
		return x.LimitedActions
	}
	return false
}

func (x *ScheduleState) GetRemainingActions() int64 {
	if x != nil {
		return x.RemainingActions
	}
	return 0
}

type TriggerImmediatelyRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If set, override overlap policy for this one request.
	OverlapPolicy v1.ScheduleOverlapPolicy `protobuf:"varint,1,opt,name=overlap_policy,json=overlapPolicy,proto3,enum=temporal.api.enums.v1.ScheduleOverlapPolicy" json:"overlap_policy,omitempty"`
	// Timestamp used for the identity of the target workflow.
	// If not set the default value is the current time.
	ScheduledTime *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=scheduled_time,json=scheduledTime,proto3" json:"scheduled_time,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TriggerImmediatelyRequest) Reset() {
	*x = TriggerImmediatelyRequest{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TriggerImmediatelyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TriggerImmediatelyRequest) ProtoMessage() {}

func (x *TriggerImmediatelyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TriggerImmediatelyRequest.ProtoReflect.Descriptor instead.
func (*TriggerImmediatelyRequest) Descriptor() ([]byte, []int) {
	return file_temporal_api_schedule_v1_message_proto_rawDescGZIP(), []int{9}
}

func (x *TriggerImmediatelyRequest) GetOverlapPolicy() v1.ScheduleOverlapPolicy {
	if x != nil {
		return x.OverlapPolicy
	}
	return v1.ScheduleOverlapPolicy(0)
}

func (x *TriggerImmediatelyRequest) GetScheduledTime() *timestamppb.Timestamp {
	if x != nil {
		return x.ScheduledTime
	}
	return nil
}

type BackfillRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Time range to evaluate schedule in. Currently, this time range is
	// exclusive on start_time and inclusive on end_time. (This is admittedly
	// counterintuitive and it may change in the future, so to be safe, use a
	// start time strictly before a scheduled time.) Also note that an action
	// nominally scheduled in the interval but with jitter that pushes it after
	// end_time will not be included.
	StartTime *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	EndTime   *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// If set, override overlap policy for this request.
	OverlapPolicy v1.ScheduleOverlapPolicy `protobuf:"varint,3,opt,name=overlap_policy,json=overlapPolicy,proto3,enum=temporal.api.enums.v1.ScheduleOverlapPolicy" json:"overlap_policy,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BackfillRequest) Reset() {
	*x = BackfillRequest{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BackfillRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BackfillRequest) ProtoMessage() {}

func (x *BackfillRequest) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BackfillRequest.ProtoReflect.Descriptor instead.
func (*BackfillRequest) Descriptor() ([]byte, []int) {
	return file_temporal_api_schedule_v1_message_proto_rawDescGZIP(), []int{10}
}

func (x *BackfillRequest) GetStartTime() *timestamppb.Timestamp {
	if x != nil {
		return x.StartTime
	}
	return nil
}

func (x *BackfillRequest) GetEndTime() *timestamppb.Timestamp {
	if x != nil {
		return x.EndTime
	}
	return nil
}

func (x *BackfillRequest) GetOverlapPolicy() v1.ScheduleOverlapPolicy {
	if x != nil {
		return x.OverlapPolicy
	}
	return v1.ScheduleOverlapPolicy(0)
}

type SchedulePatch struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If set, trigger one action immediately.
	TriggerImmediately *TriggerImmediatelyRequest `protobuf:"bytes,1,opt,name=trigger_immediately,json=triggerImmediately,proto3" json:"trigger_immediately,omitempty"`
	// If set, runs though the specified time period(s) and takes actions as if that time
	// passed by right now, all at once. The overlap policy can be overridden for the
	// scope of the backfill.
	BackfillRequest []*BackfillRequest `protobuf:"bytes,2,rep,name=backfill_request,json=backfillRequest,proto3" json:"backfill_request,omitempty"`
	// If set, change the state to paused or unpaused (respectively) and set the
	// notes field to the value of the string.
	Pause         string `protobuf:"bytes,3,opt,name=pause,proto3" json:"pause,omitempty"`
	Unpause       string `protobuf:"bytes,4,opt,name=unpause,proto3" json:"unpause,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SchedulePatch) Reset() {
	*x = SchedulePatch{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SchedulePatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SchedulePatch) ProtoMessage() {}

func (x *SchedulePatch) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SchedulePatch.ProtoReflect.Descriptor instead.
func (*SchedulePatch) Descriptor() ([]byte, []int) {
	return file_temporal_api_schedule_v1_message_proto_rawDescGZIP(), []int{11}
}

func (x *SchedulePatch) GetTriggerImmediately() *TriggerImmediatelyRequest {
	if x != nil {
		return x.TriggerImmediately
	}
	return nil
}

func (x *SchedulePatch) GetBackfillRequest() []*BackfillRequest {
	if x != nil {
		return x.BackfillRequest
	}
	return nil
}

func (x *SchedulePatch) GetPause() string {
	if x != nil {
		return x.Pause
	}
	return ""
}

func (x *SchedulePatch) GetUnpause() string {
	if x != nil {
		return x.Unpause
	}
	return ""
}

type ScheduleInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Number of actions taken so far.
	ActionCount int64 `protobuf:"varint,1,opt,name=action_count,json=actionCount,proto3" json:"action_count,omitempty"`
	// Number of times a scheduled action was skipped due to missing the catchup window.
	MissedCatchupWindow int64 `protobuf:"varint,2,opt,name=missed_catchup_window,json=missedCatchupWindow,proto3" json:"missed_catchup_window,omitempty"`
	// Number of skipped actions due to overlap.
	OverlapSkipped int64 `protobuf:"varint,3,opt,name=overlap_skipped,json=overlapSkipped,proto3" json:"overlap_skipped,omitempty"`
	// Number of dropped actions due to buffer limit.
	BufferDropped int64 `protobuf:"varint,10,opt,name=buffer_dropped,json=bufferDropped,proto3" json:"buffer_dropped,omitempty"`
	// Number of actions in the buffer. The buffer holds the actions that cannot
	// be immediately triggered (due to the overlap policy). These actions can be a result of
	// the normal schedule or a backfill.
	BufferSize int64 `protobuf:"varint,11,opt,name=buffer_size,json=bufferSize,proto3" json:"buffer_size,omitempty"`
	// Currently-running workflows started by this schedule. (There might be
	// more than one if the overlap policy allows overlaps.)
	// Note that the run_ids in here are the original execution run ids as
	// started by the schedule. If the workflows retried, did continue-as-new,
	// or were reset, they might still be running but with a different run_id.
	RunningWorkflows []*v12.WorkflowExecution `protobuf:"bytes,9,rep,name=running_workflows,json=runningWorkflows,proto3" json:"running_workflows,omitempty"`
	// Most recent ten actual action times (including manual triggers).
	RecentActions []*ScheduleActionResult `protobuf:"bytes,4,rep,name=recent_actions,json=recentActions,proto3" json:"recent_actions,omitempty"`
	// Next ten scheduled action times.
	FutureActionTimes []*timestamppb.Timestamp `protobuf:"bytes,5,rep,name=future_action_times,json=futureActionTimes,proto3" json:"future_action_times,omitempty"`
	// Timestamps of schedule creation and last update.
	CreateTime *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	UpdateTime *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=update_time,json=updateTime,proto3" json:"update_time,omitempty"`
	// Deprecated.
	//
	// Deprecated: Marked as deprecated in temporal/api/schedule/v1/message.proto.
	InvalidScheduleError string `protobuf:"bytes,8,opt,name=invalid_schedule_error,json=invalidScheduleError,proto3" json:"invalid_schedule_error,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *ScheduleInfo) Reset() {
	*x = ScheduleInfo{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScheduleInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScheduleInfo) ProtoMessage() {}

func (x *ScheduleInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScheduleInfo.ProtoReflect.Descriptor instead.
func (*ScheduleInfo) Descriptor() ([]byte, []int) {
	return file_temporal_api_schedule_v1_message_proto_rawDescGZIP(), []int{12}
}

func (x *ScheduleInfo) GetActionCount() int64 {
	if x != nil {
		return x.ActionCount
	}
	return 0
}

func (x *ScheduleInfo) GetMissedCatchupWindow() int64 {
	if x != nil {
		return x.MissedCatchupWindow
	}
	return 0
}

func (x *ScheduleInfo) GetOverlapSkipped() int64 {
	if x != nil {
		return x.OverlapSkipped
	}
	return 0
}

func (x *ScheduleInfo) GetBufferDropped() int64 {
	if x != nil {
		return x.BufferDropped
	}
	return 0
}

func (x *ScheduleInfo) GetBufferSize() int64 {
	if x != nil {
		return x.BufferSize
	}
	return 0
}

func (x *ScheduleInfo) GetRunningWorkflows() []*v12.WorkflowExecution {
	if x != nil {
		return x.RunningWorkflows
	}
	return nil
}

func (x *ScheduleInfo) GetRecentActions() []*ScheduleActionResult {
	if x != nil {
		return x.RecentActions
	}
	return nil
}

func (x *ScheduleInfo) GetFutureActionTimes() []*timestamppb.Timestamp {
	if x != nil {
		return x.FutureActionTimes
	}
	return nil
}

func (x *ScheduleInfo) GetCreateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.CreateTime
	}
	return nil
}

func (x *ScheduleInfo) GetUpdateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdateTime
	}
	return nil
}

// Deprecated: Marked as deprecated in temporal/api/schedule/v1/message.proto.
func (x *ScheduleInfo) GetInvalidScheduleError() string {
	if x != nil {
		return x.InvalidScheduleError
	}
	return ""
}

type Schedule struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Spec          *ScheduleSpec          `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
	Action        *ScheduleAction        `protobuf:"bytes,2,opt,name=action,proto3" json:"action,omitempty"`
	Policies      *SchedulePolicies      `protobuf:"bytes,3,opt,name=policies,proto3" json:"policies,omitempty"`
	State         *ScheduleState         `protobuf:"bytes,4,opt,name=state,proto3" json:"state,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Schedule) Reset() {
	*x = Schedule{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Schedule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Schedule) ProtoMessage() {}

func (x *Schedule) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Schedule.ProtoReflect.Descriptor instead.
func (*Schedule) Descriptor() ([]byte, []int) {
	return file_temporal_api_schedule_v1_message_proto_rawDescGZIP(), []int{13}
}

func (x *Schedule) GetSpec() *ScheduleSpec {
	if x != nil {
		return x.Spec
	}
	return nil
}

func (x *Schedule) GetAction() *ScheduleAction {
	if x != nil {
		return x.Action
	}
	return nil
}

func (x *Schedule) GetPolicies() *SchedulePolicies {
	if x != nil {
		return x.Policies
	}
	return nil
}

func (x *Schedule) GetState() *ScheduleState {
	if x != nil {
		return x.State
	}
	return nil
}

// ScheduleListInfo is an abbreviated set of values from Schedule and ScheduleInfo
// that's returned in ListSchedules.
type ScheduleListInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// From spec:
	// Some fields are dropped from this copy of spec: timezone_data
	Spec *ScheduleSpec `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
	// From action:
	// Action is a oneof field, but we need to encode this in JSON and oneof fields don't work
	// well with JSON. If action is start_workflow, this is set:
	WorkflowType *v12.WorkflowType `protobuf:"bytes,2,opt,name=workflow_type,json=workflowType,proto3" json:"workflow_type,omitempty"`
	// From state:
	Notes  string `protobuf:"bytes,3,opt,name=notes,proto3" json:"notes,omitempty"`
	Paused bool   `protobuf:"varint,4,opt,name=paused,proto3" json:"paused,omitempty"`
	// From info (maybe fewer entries):
	RecentActions     []*ScheduleActionResult  `protobuf:"bytes,5,rep,name=recent_actions,json=recentActions,proto3" json:"recent_actions,omitempty"`
	FutureActionTimes []*timestamppb.Timestamp `protobuf:"bytes,6,rep,name=future_action_times,json=futureActionTimes,proto3" json:"future_action_times,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *ScheduleListInfo) Reset() {
	*x = ScheduleListInfo{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScheduleListInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScheduleListInfo) ProtoMessage() {}

func (x *ScheduleListInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScheduleListInfo.ProtoReflect.Descriptor instead.
func (*ScheduleListInfo) Descriptor() ([]byte, []int) {
	return file_temporal_api_schedule_v1_message_proto_rawDescGZIP(), []int{14}
}

func (x *ScheduleListInfo) GetSpec() *ScheduleSpec {
	if x != nil {
		return x.Spec
	}
	return nil
}

func (x *ScheduleListInfo) GetWorkflowType() *v12.WorkflowType {
	if x != nil {
		return x.WorkflowType
	}
	return nil
}

func (x *ScheduleListInfo) GetNotes() string {
	if x != nil {
		return x.Notes
	}
	return ""
}

func (x *ScheduleListInfo) GetPaused() bool {
	if x != nil {
		return x.Paused
	}
	return false
}

func (x *ScheduleListInfo) GetRecentActions() []*ScheduleActionResult {
	if x != nil {
		return x.RecentActions
	}
	return nil
}

func (x *ScheduleListInfo) GetFutureActionTimes() []*timestamppb.Timestamp {
	if x != nil {
		return x.FutureActionTimes
	}
	return nil
}

// ScheduleListEntry is returned by ListSchedules.
type ScheduleListEntry struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	ScheduleId       string                 `protobuf:"bytes,1,opt,name=schedule_id,json=scheduleId,proto3" json:"schedule_id,omitempty"`
	Memo             *v12.Memo              `protobuf:"bytes,2,opt,name=memo,proto3" json:"memo,omitempty"`
	SearchAttributes *v12.SearchAttributes  `protobuf:"bytes,3,opt,name=search_attributes,json=searchAttributes,proto3" json:"search_attributes,omitempty"`
	Info             *ScheduleListInfo      `protobuf:"bytes,4,opt,name=info,proto3" json:"info,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *ScheduleListEntry) Reset() {
	*x = ScheduleListEntry{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScheduleListEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScheduleListEntry) ProtoMessage() {}

func (x *ScheduleListEntry) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScheduleListEntry.ProtoReflect.Descriptor instead.
func (*ScheduleListEntry) Descriptor() ([]byte, []int) {
	return file_temporal_api_schedule_v1_message_proto_rawDescGZIP(), []int{15}
}

func (x *ScheduleListEntry) GetScheduleId() string {
	if x != nil {
		return x.ScheduleId
	}
	return ""
}

func (x *ScheduleListEntry) GetMemo() *v12.Memo {
	if x != nil {
		return x.Memo
	}
	return nil
}

func (x *ScheduleListEntry) GetSearchAttributes() *v12.SearchAttributes {
	if x != nil {
		return x.SearchAttributes
	}
	return nil
}

func (x *ScheduleListEntry) GetInfo() *ScheduleListInfo {
	if x != nil {
		return x.Info
	}
	return nil
}

var File_temporal_api_schedule_v1_message_proto protoreflect.FileDescriptor

const file_temporal_api_schedule_v1_message_proto_rawDesc = "" +
	"\n" +
	"&temporal/api/schedule/v1/message.proto\x12\x18temporal.api.schedule.v1\x1a\x1egoogle/protobuf/duration.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a$temporal/api/common/v1/message.proto\x1a$temporal/api/enums/v1/schedule.proto\x1a$temporal/api/enums/v1/workflow.proto\x1a&temporal/api/workflow/v1/message.proto\"\xd8\x01\n" +
	"\fCalendarSpec\x12\x16\n" +
	"\x06second\x18\x01 \x01(\tR\x06second\x12\x16\n" +
	"\x06minute\x18\x02 \x01(\tR\x06minute\x12\x12\n" +
	"\x04hour\x18\x03 \x01(\tR\x04hour\x12 \n" +
	"\fday_of_month\x18\x04 \x01(\tR\n" +
	"dayOfMonth\x12\x14\n" +
	"\x05month\x18\x05 \x01(\tR\x05month\x12\x12\n" +
	"\x04year\x18\x06 \x01(\tR\x04year\x12\x1e\n" +
	"\vday_of_week\x18\a \x01(\tR\tdayOfWeek\x12\x18\n" +
	"\acomment\x18\b \x01(\tR\acomment\"C\n" +
	"\x05Range\x12\x14\n" +
	"\x05start\x18\x01 \x01(\x05R\x05start\x12\x10\n" +
	"\x03end\x18\x02 \x01(\x05R\x03end\x12\x12\n" +
	"\x04step\x18\x03 \x01(\x05R\x04step\"\xc9\x03\n" +
	"\x16StructuredCalendarSpec\x127\n" +
	"\x06second\x18\x01 \x03(\v2\x1f.temporal.api.schedule.v1.RangeR\x06second\x127\n" +
	"\x06minute\x18\x02 \x03(\v2\x1f.temporal.api.schedule.v1.RangeR\x06minute\x123\n" +
	"\x04hour\x18\x03 \x03(\v2\x1f.temporal.api.schedule.v1.RangeR\x04hour\x12A\n" +
	"\fday_of_month\x18\x04 \x03(\v2\x1f.temporal.api.schedule.v1.RangeR\n" +
	"dayOfMonth\x125\n" +
	"\x05month\x18\x05 \x03(\v2\x1f.temporal.api.schedule.v1.RangeR\x05month\x123\n" +
	"\x04year\x18\x06 \x03(\v2\x1f.temporal.api.schedule.v1.RangeR\x04year\x12?\n" +
	"\vday_of_week\x18\a \x03(\v2\x1f.temporal.api.schedule.v1.RangeR\tdayOfWeek\x12\x18\n" +
	"\acomment\x18\b \x01(\tR\acomment\"v\n" +
	"\fIntervalSpec\x125\n" +
	"\binterval\x18\x01 \x01(\v2\x19.google.protobuf.DurationR\binterval\x12/\n" +
	"\x05phase\x18\x02 \x01(\v2\x19.google.protobuf.DurationR\x05phase\"\xd2\x05\n" +
	"\fScheduleSpec\x12a\n" +
	"\x13structured_calendar\x18\a \x03(\v20.temporal.api.schedule.v1.StructuredCalendarSpecR\x12structuredCalendar\x12\x1f\n" +
	"\vcron_string\x18\b \x03(\tR\n" +
	"cronString\x12B\n" +
	"\bcalendar\x18\x01 \x03(\v2&.temporal.api.schedule.v1.CalendarSpecR\bcalendar\x12B\n" +
	"\binterval\x18\x02 \x03(\v2&.temporal.api.schedule.v1.IntervalSpecR\binterval\x12U\n" +
	"\x10exclude_calendar\x18\x03 \x03(\v2&.temporal.api.schedule.v1.CalendarSpecB\x02\x18\x01R\x0fexcludeCalendar\x12p\n" +
	"\x1bexclude_structured_calendar\x18\t \x03(\v20.temporal.api.schedule.v1.StructuredCalendarSpecR\x19excludeStructuredCalendar\x129\n" +
	"\n" +
	"start_time\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\tstartTime\x125\n" +
	"\bend_time\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\aendTime\x121\n" +
	"\x06jitter\x18\x06 \x01(\v2\x19.google.protobuf.DurationR\x06jitter\x12#\n" +
	"\rtimezone_name\x18\n" +
	" \x01(\tR\ftimezoneName\x12#\n" +
	"\rtimezone_data\x18\v \x01(\fR\ftimezoneData\"\x8e\x02\n" +
	"\x10SchedulePolicies\x12S\n" +
	"\x0eoverlap_policy\x18\x01 \x01(\x0e2,.temporal.api.enums.v1.ScheduleOverlapPolicyR\roverlapPolicy\x12@\n" +
	"\x0ecatchup_window\x18\x02 \x01(\v2\x19.google.protobuf.DurationR\rcatchupWindow\x12(\n" +
	"\x10pause_on_failure\x18\x03 \x01(\bR\x0epauseOnFailure\x129\n" +
	"\x19keep_original_workflow_id\x18\x04 \x01(\bR\x16keepOriginalWorkflowId\"w\n" +
	"\x0eScheduleAction\x12[\n" +
	"\x0estart_workflow\x18\x01 \x01(\v22.temporal.api.workflow.v1.NewWorkflowExecutionInfoH\x00R\rstartWorkflowB\b\n" +
	"\x06action\"\xd7\x02\n" +
	"\x14ScheduleActionResult\x12?\n" +
	"\rschedule_time\x18\x01 \x01(\v2\x1a.google.protobuf.TimestampR\fscheduleTime\x12;\n" +
	"\vactual_time\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"actualTime\x12]\n" +
	"\x15start_workflow_result\x18\v \x01(\v2).temporal.api.common.v1.WorkflowExecutionR\x13startWorkflowResult\x12b\n" +
	"\x15start_workflow_status\x18\f \x01(\x0e2..temporal.api.enums.v1.WorkflowExecutionStatusR\x13startWorkflowStatus\"\x93\x01\n" +
	"\rScheduleState\x12\x14\n" +
	"\x05notes\x18\x01 \x01(\tR\x05notes\x12\x16\n" +
	"\x06paused\x18\x02 \x01(\bR\x06paused\x12'\n" +
	"\x0flimited_actions\x18\x03 \x01(\bR\x0elimitedActions\x12+\n" +
	"\x11remaining_actions\x18\x04 \x01(\x03R\x10remainingActions\"\xb3\x01\n" +
	"\x19TriggerImmediatelyRequest\x12S\n" +
	"\x0eoverlap_policy\x18\x01 \x01(\x0e2,.temporal.api.enums.v1.ScheduleOverlapPolicyR\roverlapPolicy\x12A\n" +
	"\x0escheduled_time\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\rscheduledTime\"\xd8\x01\n" +
	"\x0fBackfillRequest\x129\n" +
	"\n" +
	"start_time\x18\x01 \x01(\v2\x1a.google.protobuf.TimestampR\tstartTime\x125\n" +
	"\bend_time\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\aendTime\x12S\n" +
	"\x0eoverlap_policy\x18\x03 \x01(\x0e2,.temporal.api.enums.v1.ScheduleOverlapPolicyR\roverlapPolicy\"\xfb\x01\n" +
	"\rSchedulePatch\x12d\n" +
	"\x13trigger_immediately\x18\x01 \x01(\v23.temporal.api.schedule.v1.TriggerImmediatelyRequestR\x12triggerImmediately\x12T\n" +
	"\x10backfill_request\x18\x02 \x03(\v2).temporal.api.schedule.v1.BackfillRequestR\x0fbackfillRequest\x12\x14\n" +
	"\x05pause\x18\x03 \x01(\tR\x05pause\x12\x18\n" +
	"\aunpause\x18\x04 \x01(\tR\aunpause\"\x85\x05\n" +
	"\fScheduleInfo\x12!\n" +
	"\faction_count\x18\x01 \x01(\x03R\vactionCount\x122\n" +
	"\x15missed_catchup_window\x18\x02 \x01(\x03R\x13missedCatchupWindow\x12'\n" +
	"\x0foverlap_skipped\x18\x03 \x01(\x03R\x0eoverlapSkipped\x12%\n" +
	"\x0ebuffer_dropped\x18\n" +
	" \x01(\x03R\rbufferDropped\x12\x1f\n" +
	"\vbuffer_size\x18\v \x01(\x03R\n" +
	"bufferSize\x12V\n" +
	"\x11running_workflows\x18\t \x03(\v2).temporal.api.common.v1.WorkflowExecutionR\x10runningWorkflows\x12U\n" +
	"\x0erecent_actions\x18\x04 \x03(\v2..temporal.api.schedule.v1.ScheduleActionResultR\rrecentActions\x12J\n" +
	"\x13future_action_times\x18\x05 \x03(\v2\x1a.google.protobuf.TimestampR\x11futureActionTimes\x12;\n" +
	"\vcreate_time\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"createTime\x12;\n" +
	"\vupdate_time\x18\a \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"updateTime\x128\n" +
	"\x16invalid_schedule_error\x18\b \x01(\tB\x02\x18\x01R\x14invalidScheduleError\"\x8f\x02\n" +
	"\bSchedule\x12:\n" +
	"\x04spec\x18\x01 \x01(\v2&.temporal.api.schedule.v1.ScheduleSpecR\x04spec\x12@\n" +
	"\x06action\x18\x02 \x01(\v2(.temporal.api.schedule.v1.ScheduleActionR\x06action\x12F\n" +
	"\bpolicies\x18\x03 \x01(\v2*.temporal.api.schedule.v1.SchedulePoliciesR\bpolicies\x12=\n" +
	"\x05state\x18\x04 \x01(\v2'.temporal.api.schedule.v1.ScheduleStateR\x05state\"\xea\x02\n" +
	"\x10ScheduleListInfo\x12:\n" +
	"\x04spec\x18\x01 \x01(\v2&.temporal.api.schedule.v1.ScheduleSpecR\x04spec\x12I\n" +
	"\rworkflow_type\x18\x02 \x01(\v2$.temporal.api.common.v1.WorkflowTypeR\fworkflowType\x12\x14\n" +
	"\x05notes\x18\x03 \x01(\tR\x05notes\x12\x16\n" +
	"\x06paused\x18\x04 \x01(\bR\x06paused\x12U\n" +
	"\x0erecent_actions\x18\x05 \x03(\v2..temporal.api.schedule.v1.ScheduleActionResultR\rrecentActions\x12J\n" +
	"\x13future_action_times\x18\x06 \x03(\v2\x1a.google.protobuf.TimestampR\x11futureActionTimes\"\xfd\x01\n" +
	"\x11ScheduleListEntry\x12\x1f\n" +
	"\vschedule_id\x18\x01 \x01(\tR\n" +
	"scheduleId\x120\n" +
	"\x04memo\x18\x02 \x01(\v2\x1c.temporal.api.common.v1.MemoR\x04memo\x12U\n" +
	"\x11search_attributes\x18\x03 \x01(\v2(.temporal.api.common.v1.SearchAttributesR\x10searchAttributes\x12>\n" +
	"\x04info\x18\x04 \x01(\v2*.temporal.api.schedule.v1.ScheduleListInfoR\x04infoB\x93\x01\n" +
	"\x1bio.temporal.api.schedule.v1B\fMessageProtoP\x01Z'go.temporal.io/api/schedule/v1;schedule\xaa\x02\x1aTemporalio.Api.Schedule.V1\xea\x02\x1dTemporalio::Api::Schedule::V1b\x06proto3"

var (
	file_temporal_api_schedule_v1_message_proto_rawDescOnce sync.Once
	file_temporal_api_schedule_v1_message_proto_rawDescData []byte
)

func file_temporal_api_schedule_v1_message_proto_rawDescGZIP() []byte {
	file_temporal_api_schedule_v1_message_proto_rawDescOnce.Do(func() {
		file_temporal_api_schedule_v1_message_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_temporal_api_schedule_v1_message_proto_rawDesc), len(file_temporal_api_schedule_v1_message_proto_rawDesc)))
	})
	return file_temporal_api_schedule_v1_message_proto_rawDescData
}

var file_temporal_api_schedule_v1_message_proto_msgTypes = make([]protoimpl.MessageInfo, 16)
var file_temporal_api_schedule_v1_message_proto_goTypes = []any{
	(*CalendarSpec)(nil),                 // 0: temporal.api.schedule.v1.CalendarSpec
	(*Range)(nil),                        // 1: temporal.api.schedule.v1.Range
	(*StructuredCalendarSpec)(nil),       // 2: temporal.api.schedule.v1.StructuredCalendarSpec
	(*IntervalSpec)(nil),                 // 3: temporal.api.schedule.v1.IntervalSpec
	(*ScheduleSpec)(nil),                 // 4: temporal.api.schedule.v1.ScheduleSpec
	(*SchedulePolicies)(nil),             // 5: temporal.api.schedule.v1.SchedulePolicies
	(*ScheduleAction)(nil),               // 6: temporal.api.schedule.v1.ScheduleAction
	(*ScheduleActionResult)(nil),         // 7: temporal.api.schedule.v1.ScheduleActionResult
	(*ScheduleState)(nil),                // 8: temporal.api.schedule.v1.ScheduleState
	(*TriggerImmediatelyRequest)(nil),    // 9: temporal.api.schedule.v1.TriggerImmediatelyRequest
	(*BackfillRequest)(nil),              // 10: temporal.api.schedule.v1.BackfillRequest
	(*SchedulePatch)(nil),                // 11: temporal.api.schedule.v1.SchedulePatch
	(*ScheduleInfo)(nil),                 // 12: temporal.api.schedule.v1.ScheduleInfo
	(*Schedule)(nil),                     // 13: temporal.api.schedule.v1.Schedule
	(*ScheduleListInfo)(nil),             // 14: temporal.api.schedule.v1.ScheduleListInfo
	(*ScheduleListEntry)(nil),            // 15: temporal.api.schedule.v1.ScheduleListEntry
	(*durationpb.Duration)(nil),          // 16: google.protobuf.Duration
	(*timestamppb.Timestamp)(nil),        // 17: google.protobuf.Timestamp
	(v1.ScheduleOverlapPolicy)(0),        // 18: temporal.api.enums.v1.ScheduleOverlapPolicy
	(*v11.NewWorkflowExecutionInfo)(nil), // 19: temporal.api.workflow.v1.NewWorkflowExecutionInfo
	(*v12.WorkflowExecution)(nil),        // 20: temporal.api.common.v1.WorkflowExecution
	(v1.WorkflowExecutionStatus)(0),      // 21: temporal.api.enums.v1.WorkflowExecutionStatus
	(*v12.WorkflowType)(nil),             // 22: temporal.api.common.v1.WorkflowType
	(*v12.Memo)(nil),                     // 23: temporal.api.common.v1.Memo
	(*v12.SearchAttributes)(nil),         // 24: temporal.api.common.v1.SearchAttributes
}
var file_temporal_api_schedule_v1_message_proto_depIdxs = []int32{
	1,  // 0: temporal.api.schedule.v1.StructuredCalendarSpec.second:type_name -> temporal.api.schedule.v1.Range
	1,  // 1: temporal.api.schedule.v1.StructuredCalendarSpec.minute:type_name -> temporal.api.schedule.v1.Range
	1,  // 2: temporal.api.schedule.v1.StructuredCalendarSpec.hour:type_name -> temporal.api.schedule.v1.Range
	1,  // 3: temporal.api.schedule.v1.StructuredCalendarSpec.day_of_month:type_name -> temporal.api.schedule.v1.Range
	1,  // 4: temporal.api.schedule.v1.StructuredCalendarSpec.month:type_name -> temporal.api.schedule.v1.Range
	1,  // 5: temporal.api.schedule.v1.StructuredCalendarSpec.year:type_name -> temporal.api.schedule.v1.Range
	1,  // 6: temporal.api.schedule.v1.StructuredCalendarSpec.day_of_week:type_name -> temporal.api.schedule.v1.Range
	16, // 7: temporal.api.schedule.v1.IntervalSpec.interval:type_name -> google.protobuf.Duration
	16, // 8: temporal.api.schedule.v1.IntervalSpec.phase:type_name -> google.protobuf.Duration
	2,  // 9: temporal.api.schedule.v1.ScheduleSpec.structured_calendar:type_name -> temporal.api.schedule.v1.StructuredCalendarSpec
	0,  // 10: temporal.api.schedule.v1.ScheduleSpec.calendar:type_name -> temporal.api.schedule.v1.CalendarSpec
	3,  // 11: temporal.api.schedule.v1.ScheduleSpec.interval:type_name -> temporal.api.schedule.v1.IntervalSpec
	0,  // 12: temporal.api.schedule.v1.ScheduleSpec.exclude_calendar:type_name -> temporal.api.schedule.v1.CalendarSpec
	2,  // 13: temporal.api.schedule.v1.ScheduleSpec.exclude_structured_calendar:type_name -> temporal.api.schedule.v1.StructuredCalendarSpec
	17, // 14: temporal.api.schedule.v1.ScheduleSpec.start_time:type_name -> google.protobuf.Timestamp
	17, // 15: temporal.api.schedule.v1.ScheduleSpec.end_time:type_name -> google.protobuf.Timestamp
	16, // 16: temporal.api.schedule.v1.ScheduleSpec.jitter:type_name -> google.protobuf.Duration
	18, // 17: temporal.api.schedule.v1.SchedulePolicies.overlap_policy:type_name -> temporal.api.enums.v1.ScheduleOverlapPolicy
	16, // 18: temporal.api.schedule.v1.SchedulePolicies.catchup_window:type_name -> google.protobuf.Duration
	19, // 19: temporal.api.schedule.v1.ScheduleAction.start_workflow:type_name -> temporal.api.workflow.v1.NewWorkflowExecutionInfo
	17, // 20: temporal.api.schedule.v1.ScheduleActionResult.schedule_time:type_name -> google.protobuf.Timestamp
	17, // 21: temporal.api.schedule.v1.ScheduleActionResult.actual_time:type_name -> google.protobuf.Timestamp
	20, // 22: temporal.api.schedule.v1.ScheduleActionResult.start_workflow_result:type_name -> temporal.api.common.v1.WorkflowExecution
	21, // 23: temporal.api.schedule.v1.ScheduleActionResult.start_workflow_status:type_name -> temporal.api.enums.v1.WorkflowExecutionStatus
	18, // 24: temporal.api.schedule.v1.TriggerImmediatelyRequest.overlap_policy:type_name -> temporal.api.enums.v1.ScheduleOverlapPolicy
	17, // 25: temporal.api.schedule.v1.TriggerImmediatelyRequest.scheduled_time:type_name -> google.protobuf.Timestamp
	17, // 26: temporal.api.schedule.v1.BackfillRequest.start_time:type_name -> google.protobuf.Timestamp
	17, // 27: temporal.api.schedule.v1.BackfillRequest.end_time:type_name -> google.protobuf.Timestamp
	18, // 28: temporal.api.schedule.v1.BackfillRequest.overlap_policy:type_name -> temporal.api.enums.v1.ScheduleOverlapPolicy
	9,  // 29: temporal.api.schedule.v1.SchedulePatch.trigger_immediately:type_name -> temporal.api.schedule.v1.TriggerImmediatelyRequest
	10, // 30: temporal.api.schedule.v1.SchedulePatch.backfill_request:type_name -> temporal.api.schedule.v1.BackfillRequest
	20, // 31: temporal.api.schedule.v1.ScheduleInfo.running_workflows:type_name -> temporal.api.common.v1.WorkflowExecution
	7,  // 32: temporal.api.schedule.v1.ScheduleInfo.recent_actions:type_name -> temporal.api.schedule.v1.ScheduleActionResult
	17, // 33: temporal.api.schedule.v1.ScheduleInfo.future_action_times:type_name -> google.protobuf.Timestamp
	17, // 34: temporal.api.schedule.v1.ScheduleInfo.create_time:type_name -> google.protobuf.Timestamp
	17, // 35: temporal.api.schedule.v1.ScheduleInfo.update_time:type_name -> google.protobuf.Timestamp
	4,  // 36: temporal.api.schedule.v1.Schedule.spec:type_name -> temporal.api.schedule.v1.ScheduleSpec
	6,  // 37: temporal.api.schedule.v1.Schedule.action:type_name -> temporal.api.schedule.v1.ScheduleAction
	5,  // 38: temporal.api.schedule.v1.Schedule.policies:type_name -> temporal.api.schedule.v1.SchedulePolicies
	8,  // 39: temporal.api.schedule.v1.Schedule.state:type_name -> temporal.api.schedule.v1.ScheduleState
	4,  // 40: temporal.api.schedule.v1.ScheduleListInfo.spec:type_name -> temporal.api.schedule.v1.ScheduleSpec
	22, // 41: temporal.api.schedule.v1.ScheduleListInfo.workflow_type:type_name -> temporal.api.common.v1.WorkflowType
	7,  // 42: temporal.api.schedule.v1.ScheduleListInfo.recent_actions:type_name -> temporal.api.schedule.v1.ScheduleActionResult
	17, // 43: temporal.api.schedule.v1.ScheduleListInfo.future_action_times:type_name -> google.protobuf.Timestamp
	23, // 44: temporal.api.schedule.v1.ScheduleListEntry.memo:type_name -> temporal.api.common.v1.Memo
	24, // 45: temporal.api.schedule.v1.ScheduleListEntry.search_attributes:type_name -> temporal.api.common.v1.SearchAttributes
	14, // 46: temporal.api.schedule.v1.ScheduleListEntry.info:type_name -> temporal.api.schedule.v1.ScheduleListInfo
	47, // [47:47] is the sub-list for method output_type
	47, // [47:47] is the sub-list for method input_type
	47, // [47:47] is the sub-list for extension type_name
	47, // [47:47] is the sub-list for extension extendee
	0,  // [0:47] is the sub-list for field type_name
}

func init() { file_temporal_api_schedule_v1_message_proto_init() }
func file_temporal_api_schedule_v1_message_proto_init() {
	if File_temporal_api_schedule_v1_message_proto != nil {
		return
	}
	file_temporal_api_schedule_v1_message_proto_msgTypes[6].OneofWrappers = []any{
		(*ScheduleAction_StartWorkflow)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_temporal_api_schedule_v1_message_proto_rawDesc), len(file_temporal_api_schedule_v1_message_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   16,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_temporal_api_schedule_v1_message_proto_goTypes,
		DependencyIndexes: file_temporal_api_schedule_v1_message_proto_depIdxs,
		MessageInfos:      file_temporal_api_schedule_v1_message_proto_msgTypes,
	}.Build()
	File_temporal_api_schedule_v1_message_proto = out.File
	file_temporal_api_schedule_v1_message_proto_goTypes = nil
	file_temporal_api_schedule_v1_message_proto_depIdxs = nil
}
