// The MIT License
//
// Copyright (c) 2022 Temporal Technologies Inc.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: temporal/api/workflowservice/v1/service.proto

package workflowservice

import (
	context "context"
	fmt "fmt"
	math "math"

	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

func init() {
	proto.RegisterFile("temporal/api/workflowservice/v1/service.proto", fileDescriptor_bded41be6e20a31f)
}

var fileDescriptor_bded41be6e20a31f = []byte{
	// 1447 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x9a, 0xcd, 0x8b, 0x1c, 0xc5,
	0x1b, 0xc7, 0xa7, 0x72, 0xf8, 0x1d, 0x9a, 0x9f, 0x46, 0xdb, 0x37, 0x8c, 0xda, 0xd1, 0xe0, 0xd5,
	0x59, 0x56, 0xc9, 0x9a, 0xcc, 0x26, 0xbb, 0xce, 0xcb, 0xee, 0xec, 0xfa, 0x96, 0xcd, 0xce, 0x1a,
	0xc1, 0x8b, 0xf4, 0xf6, 0x3c, 0xd9, 0x29, 0x76, 0x66, 0xba, 0xad, 0xae, 0x99, 0xb8, 0xb7, 0x80,
	0x20, 0x08, 0x82, 0x22, 0x08, 0x82, 0xe0, 0x49, 0x51, 0x02, 0x82, 0x20, 0x08, 0x9e, 0xbc, 0x7a,
	0xdc, 0x63, 0x8e, 0xee, 0xec, 0x45, 0x72, 0xca, 0x9f, 0x20, 0x3d, 0x33, 0x55, 0x3b, 0xd5, 0x5d,
	0xd5, 0xfd, 0x74, 0x77, 0x6e, 0x49, 0xe6, 0xf9, 0x7c, 0xeb, 0x9b, 0xe7, 0xa9, 0x7a, 0xaa, 0xab,
	0xba, 0xad, 0xd7, 0x38, 0x0c, 0x02, 0x9f, 0xb9, 0xfd, 0x25, 0x37, 0xa0, 0x4b, 0x77, 0x7c, 0x76,
	0x78, 0xbb, 0xef, 0xdf, 0x09, 0x81, 0x8d, 0xa9, 0x07, 0x4b, 0xe3, 0xe5, 0xa5, 0xf9, 0x1f, 0xab,
	0x01, 0xf3, 0xb9, 0x6f, 0x5f, 0x14, 0xe1, 0x55, 0x37, 0xa0, 0xd5, 0x58, 0x78, 0x75, 0xbc, 0x7c,
	0x61, 0x25, 0x4b, 0x8f, 0xc1, 0x27, 0x23, 0x08, 0xf9, 0xc7, 0x0c, 0xc2, 0xc0, 0x1f, 0x86, 0x73,
	0xe1, 0xd7, 0x7f, 0x6a, 0x5b, 0xe7, 0x3f, 0x9c, 0x47, 0x77, 0x66, 0xd1, 0xf6, 0x97, 0xc4, 0x7a,
	0x72, 0x17, 0x0e, 0x68, 0xc8, 0x81, 0xbd, 0xef, 0x0e, 0x20, 0x0c, 0x5c, 0x0f, 0xec, 0xab, 0xd5,
	0x0c, 0x0f, 0xd5, 0x04, 0xb3, 0x3b, 0x1b, 0xf3, 0x42, 0xad, 0x08, 0x3a, 0xb3, 0x79, 0xa9, 0x32,
	0xb5, 0xd3, 0x82, 0xd0, 0x63, 0x74, 0x1f, 0xf2, 0xd8, 0x49, 0x30, 0x78, 0x3b, 0x1a, 0x54, 0xda,
	0xf9, 0x8c, 0x58, 0x8f, 0xbf, 0x4b, 0x43, 0x2e, 0x7f, 0x0b, 0xed, 0x95, 0x4c, 0x41, 0x15, 0x10,
	0x46, 0xde, 0xcc, 0xcd, 0x49, 0x17, 0x9f, 0x13, 0xeb, 0xfc, 0x07, 0x41, 0xd7, 0xe5, 0x0b, 0x29,
	0xc9, 0x96, 0x8b, 0x11, 0xc2, 0xc7, 0x95, 0xfc, 0xa0, 0x34, 0xf2, 0x15, 0xb1, 0xec, 0x16, 0x04,
	0x0c, 0x3c, 0xc5, 0x0b, 0x26, 0xc7, 0x71, 0x48, 0xd8, 0x59, 0x2d, 0xc4, 0x4a, 0x47, 0xdf, 0x13,
	0xeb, 0xd9, 0x0e, 0x77, 0x19, 0x17, 0xf3, 0x7a, 0xe3, 0x53, 0xf0, 0x46, 0x9c, 0xfa, 0x43, 0x7b,
	0x2d, 0x53, 0x59, 0x0f, 0x0a, 0x67, 0xeb, 0x85, 0x79, 0xe9, 0xee, 0x1e, 0xb1, 0x5e, 0x68, 0x43,
	0x32, 0x64, 0x8b, 0x86, 0xdc, 0x67, 0x47, 0x76, 0x33, 0x73, 0x88, 0x14, 0x5a, 0xf8, 0x6c, 0x95,
	0x13, 0x91, 0x66, 0xff, 0x22, 0xd6, 0xa5, 0xd4, 0xc8, 0x31, 0xb0, 0x10, 0xec, 0xb7, 0xcb, 0x0d,
	0x37, 0x15, 0x11, 0xd6, 0xdf, 0x79, 0x24, 0x5a, 0xf2, 0x7f, 0xf0, 0x1d, 0xb1, 0x9e, 0xd9, 0xf1,
	0xfb, 0x7d, 0x41, 0xec, 0xb9, 0xe1, 0xe1, 0xcd, 0x11, 0x8c, 0xc0, 0xbe, 0x9e, 0x39, 0x90, 0x96,
	0x13, 0x3e, 0xd7, 0x8a, 0xe2, 0xd2, 0xda, 0xaf, 0xc4, 0x7a, 0x71, 0xf6, 0xd7, 0xee, 0x62, 0x58,
	0xd3, 0x1f, 0x04, 0x7d, 0xe0, 0xd0, 0xb5, 0x5b, 0x88, 0xb6, 0x69, 0xc6, 0x85, 0xd1, 0x8d, 0x92,
	0x2a, 0xd2, 0xef, 0x8f, 0xc4, 0x7a, 0x5e, 0x13, 0xba, 0xe9, 0xd2, 0x3e, 0x74, 0xed, 0x7a, 0x91,
	0x61, 0x66, 0xac, 0x70, 0xda, 0x28, 0x23, 0x91, 0xa8, 0x78, 0xdd, 0xe3, 0x74, 0x4c, 0xf9, 0x51,
	0xde, 0x8a, 0x27, 0xb8, 0x7c, 0x15, 0xd7, 0xe0, 0xca, 0xda, 0xdf, 0x05, 0xcf, 0x67, 0xdd, 0xc5,
	0xa8, 0x2d, 0x70, 0x19, 0xdf, 0x07, 0x97, 0x23, 0xd6, 0x7e, 0x0a, 0x8d, 0x5f, 0xfb, 0xa9, 0x22,
	0xd2, 0xec, 0x1f, 0xc4, 0xba, 0x98, 0x12, 0xd9, 0x38, 0xda, 0xee, 0xda, 0xed, 0x32, 0x63, 0x45,
	0x0a, 0xc2, 0xf4, 0x56, 0x79, 0x21, 0xdd, 0xba, 0x5a, 0x0c, 0x2f, 0xb0, 0xae, 0xb4, 0x78, 0xee,
	0x75, 0x65, 0x50, 0x91, 0x7e, 0xff, 0x24, 0xd6, 0xcb, 0x69, 0xa1, 0xd3, 0x4c, 0x6f, 0x95, 0x1a,
	0x6d, 0x31, 0xd5, 0xdb, 0x8f, 0x40, 0x49, 0xd7, 0x13, 0x16, 0xc3, 0xf3, 0xf6, 0x84, 0x24, 0x9b,
	0xbb, 0x27, 0xe8, 0x24, 0xa4, 0xcd, 0xdf, 0x88, 0xf5, 0x92, 0x31, 0x6e, 0x9a, 0xdf, 0x8d, 0xe2,
	0xe3, 0x2c, 0x26, 0x77, 0xb3, 0xac, 0x4c, 0xac, 0x57, 0x24, 0x0b, 0xe1, 0x0e, 0x3d, 0x88, 0x72,
	0xdb, 0x2c, 0x54, 0xc6, 0x39, 0x9d, 0xa7, 0x57, 0xa4, 0x88, 0xc4, 0x7a, 0x85, 0x31, 0x12, 0xdd,
	0x2b, 0x52, 0x15, 0xf2, 0xf4, 0x8a, 0x0c, 0x21, 0x69, 0xfc, 0x77, 0x62, 0x39, 0x73, 0xdd, 0x59,
	0x44, 0xf2, 0x99, 0x11, 0x53, 0xd2, 0x34, 0x01, 0x61, 0xbb, 0x5d, 0x5a, 0x47, 0xba, 0xfe, 0x81,
	0x58, 0xcf, 0x75, 0xe8, 0xc1, 0xd0, 0xd5, 0xd8, 0x45, 0x3c, 0xa2, 0xea, 0x49, 0xe1, 0xf3, 0xad,
	0xe2, 0x02, 0x4a, 0x4b, 0x9b, 0x47, 0x51, 0xde, 0x33, 0x3c, 0x8c, 0x6f, 0x61, 0x07, 0x32, 0x4a,
	0xe0, 0x5b, 0x5a, 0xb6, 0x92, 0x72, 0x7c, 0xd8, 0x85, 0x10, 0x0a, 0x1d, 0x1f, 0xf4, 0x20, 0xfe,
	0xf8, 0x60, 0xe2, 0xa5, 0xbb, 0x9f, 0x89, 0x75, 0x61, 0x0f, 0xd8, 0x80, 0x0e, 0x5d, 0x0e, 0x49,
	0x87, 0xd9, 0xed, 0xd2, 0x0c, 0x0b, 0x97, 0xcd, 0x52, 0x1a, 0xca, 0x24, 0x6d, 0x41, 0xb4, 0x69,
	0x14, 0x99, 0xa4, 0x06, 0x12, 0x3f, 0x49, 0x8d, 0x02, 0x4a, 0x2a, 0xa3, 0xf3, 0xf5, 0x8d, 0x00,
	0x86, 0x89, 0xb8, 0x10, 0x91, 0x4a, 0x33, 0x8c, 0x4f, 0x65, 0x9a, 0x86, 0xf2, 0x44, 0x13, 0x05,
	0x36, 0xfb, 0x7e, 0x08, 0x5d, 0x8d, 0xd7, 0x16, 0x6a, 0x1c, 0x13, 0x8e, 0x7f, 0xa2, 0x49, 0x57,
	0x51, 0x96, 0x50, 0x14, 0xaa, 0x71, 0xba, 0x86, 0x1a, 0xc3, 0xec, 0x71, 0xbd, 0x30, 0xaf, 0xf4,
	0xfc, 0x28, 0xa8, 0xce, 0xbc, 0x1e, 0x1d, 0x6b, 0xf3, 0xb9, 0x89, 0x1a, 0xc5, 0x2c, 0x80, 0xef,
	0xf9, 0x59, 0x3a, 0xea, 0xad, 0x86, 0xe7, 0x0e, 0x0b, 0xe5, 0x54, 0x0f, 0xe6, 0xb8, 0xd5, 0x30,
	0xf0, 0xca, 0x62, 0x6f, 0xfa, 0xa3, 0xa1, 0xae, 0xe4, 0xd9, 0xf2, 0x06, 0x12, 0xbf, 0xd8, 0x8d,
	0x02, 0xd2, 0xe0, 0x37, 0xc4, 0x7a, 0xaa, 0x0d, 0xbc, 0x03, 0x2e, 0xf3, 0x7a, 0x75, 0xce, 0x19,
	0xdd, 0x1f, 0x71, 0x08, 0xed, 0x55, 0xcc, 0x75, 0x43, 0x9c, 0x12, 0xc6, 0xae, 0x15, 0x83, 0x75,
	0x4f, 0xcf, 0x37, 0x47, 0xc0, 0x62, 0xc7, 0x14, 0xf4, 0xd3, 0x73, 0x92, 0xcd, 0xfd, 0xf4, 0xac,
	0x93, 0x90, 0x36, 0xbf, 0x25, 0xd6, 0xd3, 0xd3, 0x8d, 0xa9, 0xc3, 0xa9, 0x77, 0xb8, 0x70, 0xa0,
	0xbe, 0x86, 0xdb, 0xcf, 0x62, 0x98, 0x30, 0x77, 0xbd, 0x20, 0x2d, 0x7d, 0xdd, 0x25, 0xd6, 0x63,
	0x53, 0xe3, 0xa2, 0xf2, 0xf6, 0xe5, 0x4c, 0x49, 0x25, 0x5e, 0x38, 0x59, 0xc9, 0x8b, 0x29, 0x15,
	0x14, 0x97, 0xc5, 0xc9, 0x6d, 0xae, 0x8e, 0xbe, 0x68, 0x36, 0x6e, 0x74, 0x8d, 0x32, 0x12, 0xda,
	0x2b, 0xf4, 0xb3, 0xf2, 0xe1, 0xaf, 0xd0, 0x13, 0xb5, 0xab, 0x15, 0x41, 0x95, 0x2b, 0xf4, 0x36,
	0xf0, 0x66, 0x7f, 0x14, 0x72, 0x60, 0xdb, 0xc3, 0xdb, 0x3e, 0xe2, 0x0a, 0x5d, 0x05, 0xf0, 0x57,
	0xe8, 0x71, 0x4e, 0x99, 0x3e, 0xd1, 0xfa, 0x3c, 0x0a, 0x39, 0x0c, 0xa6, 0x26, 0x2e, 0xa3, 0xd6,
	0xb3, 0x8c, 0xc7, 0x4f, 0x9f, 0x18, 0xa6, 0xb4, 0xcd, 0x68, 0x07, 0x90, 0x49, 0xda, 0x71, 0x19,
	0xa7, 0xd8, 0xb6, 0x69, 0x20, 0xf1, 0x6d, 0xd3, 0x28, 0xa0, 0x54, 0xaa, 0xc9, 0xc0, 0xe5, 0xd0,
	0xf1, 0x7a, 0xd0, 0x1d, 0xf5, 0x01, 0x51, 0x29, 0x15, 0xc0, 0x57, 0x2a, 0xce, 0x49, 0x17, 0x5f,
	0x10, 0xeb, 0x09, 0x31, 0x9f, 0xa4, 0x8f, 0x2b, 0xe8, 0x29, 0x18, 0x77, 0x72, 0xb5, 0x00, 0xa9,
	0x64, 0x64, 0xf6, 0x36, 0x24, 0x47, 0x46, 0x54, 0x00, 0x9f, 0x91, 0x38, 0xa7, 0xcc, 0xdd, 0x1d,
	0x97, 0x7b, 0x3d, 0x69, 0x22, 0x7b, 0xee, 0x2a, 0xf1, 0xf8, 0xb9, 0x1b, 0xc3, 0x94, 0xd6, 0x17,
	0x4d, 0x20, 0xf1, 0xd3, 0x7b, 0x51, 0x1c, 0x1d, 0x1e, 0xec, 0xd1, 0x01, 0x84, 0x88, 0xd6, 0x67,
	0x64, 0xf1, 0xad, 0x2f, 0x45, 0x42, 0xa9, 0xd7, 0xec, 0x2c, 0x90, 0xa3, 0x5e, 0x2a, 0x80, 0xaf,
	0x57, 0x9c, 0x53, 0xea, 0xb5, 0xe8, 0x36, 0x44, 0xd4, 0x4b, 0x89, 0xc7, 0xd7, 0x2b, 0x86, 0x29,
	0x67, 0xf2, 0xd9, 0x7c, 0x8a, 0x76, 0x0a, 0x60, 0x8d, 0x11, 0xed, 0x77, 0xb7, 0xbb, 0xd1, 0x86,
	0xef, 0x72, 0xba, 0x4f, 0xfb, 0x94, 0x1f, 0x21, 0xce, 0xe4, 0x59, 0x12, 0xf8, 0x33, 0x79, 0xb6,
	0x92, 0x72, 0x7f, 0x37, 0x7f, 0xed, 0x63, 0x30, 0xbe, 0x81, 0x7d, 0x6d, 0x94, 0xee, 0x7a, 0xb3,
	0xac, 0x8c, 0xb2, 0x3c, 0x64, 0x6c, 0xd4, 0x64, 0x77, 0xc1, 0xf5, 0x7a, 0xee, 0xdc, 0x6e, 0x1d,
	0x3f, 0x4e, 0x9c, 0xc5, 0x2f, 0x8f, 0x14, 0x09, 0x65, 0x07, 0x3a, 0x2b, 0x44, 0xde, 0x53, 0xba,
	0x81, 0xc4, 0xef, 0x40, 0x46, 0x01, 0xe5, 0x1e, 0x74, 0xf1, 0x4d, 0x9a, 0x8c, 0x99, 0xa1, 0x88,
	0x7b, 0xd0, 0x14, 0x1a, 0x7f, 0x0f, 0x9a, 0x2a, 0xa2, 0x9c, 0x32, 0xa6, 0x17, 0x4c, 0x8d, 0xa8,
	0x1b, 0xdd, 0x08, 0x80, 0xb9, 0xd3, 0x4c, 0xae, 0xe2, 0xde, 0x1b, 0xab, 0x14, 0xfe, 0x94, 0xa1,
	0x85, 0x95, 0x37, 0xf4, 0x1d, 0xee, 0x07, 0x31, 0x4f, 0x35, 0x84, 0x6c, 0x1c, 0xc2, 0xbf, 0xa1,
	0xd7, 0xb1, 0xca, 0x59, 0x56, 0x6c, 0xb1, 0x31, 0x57, 0x6b, 0xe8, 0xbd, 0x59, 0xef, 0x6c, 0xbd,
	0x30, 0xaf, 0x14, 0x31, 0x6a, 0xa2, 0x6a, 0x00, 0xe6, 0xa8, 0xa8, 0xa1, 0xf0, 0x45, 0xd4, 0xc2,
	0xc2, 0x54, 0xe3, 0x01, 0x39, 0x3e, 0x71, 0x2a, 0xf7, 0x4f, 0x9c, 0xca, 0xc3, 0x13, 0x87, 0xdc,
	0x9d, 0x38, 0xe4, 0x97, 0x89, 0x43, 0xfe, 0x9e, 0x38, 0xe4, 0x78, 0xe2, 0x90, 0x7f, 0x26, 0x0e,
	0xf9, 0x77, 0xe2, 0x54, 0x1e, 0x4e, 0x1c, 0xf2, 0xf5, 0xa9, 0x53, 0x39, 0x3e, 0x75, 0x2a, 0xf7,
	0x4f, 0x9d, 0x8a, 0x75, 0x89, 0xfa, 0x59, 0x03, 0x37, 0xfe, 0x3f, 0xff, 0xee, 0x67, 0x87, 0xf9,
	0xdc, 0xdf, 0x21, 0x1f, 0x5d, 0x3e, 0x58, 0x60, 0xa8, 0x6f, 0xf8, 0xa0, 0x68, 0x35, 0xf6, 0x4f,
	0xf7, 0xce, 0xbd, 0xb2, 0x37, 0x87, 0xa8, 0x5f, 0xad, 0x07, 0xb4, 0x1a, 0xfb, 0xac, 0xa8, 0x7a,
	0x6b, 0xf9, 0xc1, 0xb9, 0x57, 0xcf, 0x62, 0x6a, 0xb5, 0x7a, 0x40, 0x6b, 0xb5, 0x58, 0x54, 0xad,
	0x76, 0x6b, 0x79, 0xff, 0x7f, 0xd3, 0x6f, 0x93, 0xde, 0xf8, 0x2f, 0x00, 0x00, 0xff, 0xff, 0x1b,
	0xe8, 0x9b, 0x71, 0x25, 0x25, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// WorkflowServiceClient is the client API for WorkflowService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type WorkflowServiceClient interface {
	// RegisterNamespace creates a new namespace which can be used as a container for all resources.
	//
	// A Namespace is a top level entity within Temporal, and is used as a container for resources
	// like workflow executions, task queues, etc. A Namespace acts as a sandbox and provides
	// isolation for all resources within the namespace. All resources belongs to exactly one
	// namespace.
	RegisterNamespace(ctx context.Context, in *RegisterNamespaceRequest, opts ...grpc.CallOption) (*RegisterNamespaceResponse, error)
	// DescribeNamespace returns the information and configuration for a registered namespace.
	DescribeNamespace(ctx context.Context, in *DescribeNamespaceRequest, opts ...grpc.CallOption) (*DescribeNamespaceResponse, error)
	// ListNamespaces returns the information and configuration for all namespaces.
	ListNamespaces(ctx context.Context, in *ListNamespacesRequest, opts ...grpc.CallOption) (*ListNamespacesResponse, error)
	// UpdateNamespace is used to update the information and configuration of a registered
	// namespace.
	//
	// (-- api-linter: core::0134::method-signature=disabled
	//     aip.dev/not-precedent: UpdateNamespace RPC doesn't follow Google API format. --)
	// (-- api-linter: core::0134::response-message-name=disabled
	//     aip.dev/not-precedent: UpdateNamespace RPC doesn't follow Google API format. --)
	UpdateNamespace(ctx context.Context, in *UpdateNamespaceRequest, opts ...grpc.CallOption) (*UpdateNamespaceResponse, error)
	// DeprecateNamespace is used to update the state of a registered namespace to DEPRECATED.
	//
	// Once the namespace is deprecated it cannot be used to start new workflow executions. Existing
	// workflow executions will continue to run on deprecated namespaces.
	// Deprecated.
	DeprecateNamespace(ctx context.Context, in *DeprecateNamespaceRequest, opts ...grpc.CallOption) (*DeprecateNamespaceResponse, error)
	// StartWorkflowExecution starts a new workflow execution.
	//
	// It will create the execution with a `WORKFLOW_EXECUTION_STARTED` event in its history and
	// also schedule the first workflow task. Returns `WorkflowExecutionAlreadyStarted`, if an
	// instance already exists with same workflow id.
	StartWorkflowExecution(ctx context.Context, in *StartWorkflowExecutionRequest, opts ...grpc.CallOption) (*StartWorkflowExecutionResponse, error)
	// GetWorkflowExecutionHistory returns the history of specified workflow execution. Fails with
	// `NotFound` if the specified workflow execution is unknown to the service.
	GetWorkflowExecutionHistory(ctx context.Context, in *GetWorkflowExecutionHistoryRequest, opts ...grpc.CallOption) (*GetWorkflowExecutionHistoryResponse, error)
	// GetWorkflowExecutionHistoryReverse returns the history of specified workflow execution in reverse
	// order (starting from last event). Fails with`NotFound` if the specified workflow execution is
	// unknown to the service.
	GetWorkflowExecutionHistoryReverse(ctx context.Context, in *GetWorkflowExecutionHistoryReverseRequest, opts ...grpc.CallOption) (*GetWorkflowExecutionHistoryReverseResponse, error)
	// PollWorkflowTaskQueue is called by workers to make progress on workflows.
	//
	// A WorkflowTask is dispatched to callers for active workflow executions with pending workflow
	// tasks. The worker is expected to call `RespondWorkflowTaskCompleted` when it is done
	// processing the task. The service will create a `WorkflowTaskStarted` event in the history for
	// this task before handing it to the worker.
	PollWorkflowTaskQueue(ctx context.Context, in *PollWorkflowTaskQueueRequest, opts ...grpc.CallOption) (*PollWorkflowTaskQueueResponse, error)
	// RespondWorkflowTaskCompleted is called by workers to successfully complete workflow tasks
	// they received from `PollWorkflowTaskQueue`.
	//
	// Completing a WorkflowTask will write a `WORKFLOW_TASK_COMPLETED` event to the workflow's
	// history, along with events corresponding to whatever commands the SDK generated while
	// executing the task (ex timer started, activity task scheduled, etc).
	RespondWorkflowTaskCompleted(ctx context.Context, in *RespondWorkflowTaskCompletedRequest, opts ...grpc.CallOption) (*RespondWorkflowTaskCompletedResponse, error)
	// RespondWorkflowTaskFailed is called by workers to indicate the processing of a workflow task
	// failed.
	//
	// This results in a `WORKFLOW_TASK_FAILED` event written to the history, and a new workflow
	// task will be scheduled. This API can be used to report unhandled failures resulting from
	// applying the workflow task.
	//
	// Temporal will only append first WorkflowTaskFailed event to the history of workflow execution
	// for consecutive failures.
	RespondWorkflowTaskFailed(ctx context.Context, in *RespondWorkflowTaskFailedRequest, opts ...grpc.CallOption) (*RespondWorkflowTaskFailedResponse, error)
	// PollActivityTaskQueue is called by workers to process activity tasks from a specific task
	// queue.
	//
	// The worker is expected to call one of the `RespondActivityTaskXXX` methods when it is done
	// processing the task.
	//
	// An activity task is dispatched whenever a `SCHEDULE_ACTIVITY_TASK` command is produced during
	// workflow execution. An in memory `ACTIVITY_TASK_STARTED` event is written to mutable state
	// before the task is dispatched to the worker. The started event, and the final event
	// (`ACTIVITY_TASK_COMPLETED` / `ACTIVITY_TASK_FAILED` / `ACTIVITY_TASK_TIMED_OUT`) will both be
	// written permanently to Workflow execution history when Activity is finished. This is done to
	// avoid writing many events in the case of a failure/retry loop.
	PollActivityTaskQueue(ctx context.Context, in *PollActivityTaskQueueRequest, opts ...grpc.CallOption) (*PollActivityTaskQueueResponse, error)
	// RecordActivityTaskHeartbeat is optionally called by workers while they execute activities.
	//
	// If worker fails to heartbeat within the `heartbeat_timeout` interval for the activity task,
	// then it will be marked as timed out and an `ACTIVITY_TASK_TIMED_OUT` event will be written to
	// the workflow history. Calling `RecordActivityTaskHeartbeat` will fail with `NotFound` in
	// such situations, in that event, the SDK should request cancellation of the activity.
	RecordActivityTaskHeartbeat(ctx context.Context, in *RecordActivityTaskHeartbeatRequest, opts ...grpc.CallOption) (*RecordActivityTaskHeartbeatResponse, error)
	// See `RecordActivityTaskHeartbeat`. This version allows clients to record heartbeats by
	// namespace/workflow id/activity id instead of task token.
	//
	// (-- api-linter: core::0136::prepositions=disabled
	//     aip.dev/not-precedent: "By" is used to indicate request type. --)
	RecordActivityTaskHeartbeatById(ctx context.Context, in *RecordActivityTaskHeartbeatByIdRequest, opts ...grpc.CallOption) (*RecordActivityTaskHeartbeatByIdResponse, error)
	// RespondActivityTaskCompleted is called by workers when they successfully complete an activity
	// task.
	//
	// This results in a new `ACTIVITY_TASK_COMPLETED` event being written to the workflow history
	// and a new workflow task created for the workflow. Fails with `NotFound` if the task token is
	// no longer valid due to activity timeout, already being completed, or never having existed.
	RespondActivityTaskCompleted(ctx context.Context, in *RespondActivityTaskCompletedRequest, opts ...grpc.CallOption) (*RespondActivityTaskCompletedResponse, error)
	// See `RecordActivityTaskCompleted`. This version allows clients to record completions by
	// namespace/workflow id/activity id instead of task token.
	//
	// (-- api-linter: core::0136::prepositions=disabled
	//     aip.dev/not-precedent: "By" is used to indicate request type. --)
	RespondActivityTaskCompletedById(ctx context.Context, in *RespondActivityTaskCompletedByIdRequest, opts ...grpc.CallOption) (*RespondActivityTaskCompletedByIdResponse, error)
	// RespondActivityTaskFailed is called by workers when processing an activity task fails.
	//
	// This results in a new `ACTIVITY_TASK_FAILED` event being written to the workflow history and
	// a new workflow task created for the workflow. Fails with `NotFound` if the task token is no
	// longer valid due to activity timeout, already being completed, or never having existed.
	RespondActivityTaskFailed(ctx context.Context, in *RespondActivityTaskFailedRequest, opts ...grpc.CallOption) (*RespondActivityTaskFailedResponse, error)
	// See `RecordActivityTaskFailed`. This version allows clients to record failures by
	// namespace/workflow id/activity id instead of task token.
	//
	// (-- api-linter: core::0136::prepositions=disabled
	//     aip.dev/not-precedent: "By" is used to indicate request type. --)
	RespondActivityTaskFailedById(ctx context.Context, in *RespondActivityTaskFailedByIdRequest, opts ...grpc.CallOption) (*RespondActivityTaskFailedByIdResponse, error)
	// RespondActivityTaskFailed is called by workers when processing an activity task fails.
	//
	// This results in a new `ACTIVITY_TASK_CANCELED` event being written to the workflow history
	// and a new workflow task created for the workflow. Fails with `NotFound` if the task token is
	// no longer valid due to activity timeout, already being completed, or never having existed.
	RespondActivityTaskCanceled(ctx context.Context, in *RespondActivityTaskCanceledRequest, opts ...grpc.CallOption) (*RespondActivityTaskCanceledResponse, error)
	// See `RecordActivityTaskCanceled`. This version allows clients to record failures by
	// namespace/workflow id/activity id instead of task token.
	//
	// (-- api-linter: core::0136::prepositions=disabled
	//     aip.dev/not-precedent: "By" is used to indicate request type. --)
	RespondActivityTaskCanceledById(ctx context.Context, in *RespondActivityTaskCanceledByIdRequest, opts ...grpc.CallOption) (*RespondActivityTaskCanceledByIdResponse, error)
	// RequestCancelWorkflowExecution is called by workers when they want to request cancellation of
	// a workflow execution.
	//
	// This results in a new `WORKFLOW_EXECUTION_CANCEL_REQUESTED` event being written to the
	// workflow history and a new workflow task created for the workflow. It returns success if the requested
	// workflow is already closed. It fails with 'NotFound' if the requested workflow doesn't exist.
	RequestCancelWorkflowExecution(ctx context.Context, in *RequestCancelWorkflowExecutionRequest, opts ...grpc.CallOption) (*RequestCancelWorkflowExecutionResponse, error)
	// SignalWorkflowExecution is used to send a signal to a running workflow execution.
	//
	// This results in a `WORKFLOW_EXECUTION_SIGNALED` event recorded in the history and a workflow
	// task being created for the execution.
	SignalWorkflowExecution(ctx context.Context, in *SignalWorkflowExecutionRequest, opts ...grpc.CallOption) (*SignalWorkflowExecutionResponse, error)
	// SignalWithStartWorkflowExecution is used to ensure a signal is sent to a workflow, even if
	// it isn't yet started.
	//
	// If the workflow is running, a `WORKFLOW_EXECUTION_SIGNALED` event is recorded in the history
	// and a workflow task is generated.
	//
	// If the workflow is not running or not found, then the workflow is created with
	// `WORKFLOW_EXECUTION_STARTED` and `WORKFLOW_EXECUTION_SIGNALED` events in its history, and a
	// workflow task is generated.
	//
	// (-- api-linter: core::0136::prepositions=disabled
	//     aip.dev/not-precedent: "With" is used to indicate combined operation. --)
	SignalWithStartWorkflowExecution(ctx context.Context, in *SignalWithStartWorkflowExecutionRequest, opts ...grpc.CallOption) (*SignalWithStartWorkflowExecutionResponse, error)
	// ResetWorkflowExecution will reset an existing workflow execution to a specified
	// `WORKFLOW_TASK_COMPLETED` event (exclusive). It will immediately terminate the current
	// execution instance.
	// TODO: Does exclusive here mean *just* the completed event, or also WFT started? Otherwise the task is doomed to time out?
	ResetWorkflowExecution(ctx context.Context, in *ResetWorkflowExecutionRequest, opts ...grpc.CallOption) (*ResetWorkflowExecutionResponse, error)
	// TerminateWorkflowExecution terminates an existing workflow execution by recording a
	// `WORKFLOW_EXECUTION_TERMINATED` event in the history and immediately terminating the
	// execution instance.
	TerminateWorkflowExecution(ctx context.Context, in *TerminateWorkflowExecutionRequest, opts ...grpc.CallOption) (*TerminateWorkflowExecutionResponse, error)
	// DeleteWorkflowExecution asynchronously deletes a specific Workflow Execution (when
	// WorkflowExecution.run_id is provided) or the latest Workflow Execution (when
	// WorkflowExecution.run_id is not provided). If the Workflow Execution is Running, it will be
	// terminated before deletion.
	// (-- api-linter: core::0135::method-signature=disabled
	//     aip.dev/not-precedent: DeleteNamespace RPC doesn't follow Google API format. --)
	// (-- api-linter: core::0135::response-message-name=disabled
	//     aip.dev/not-precedent: DeleteNamespace RPC doesn't follow Google API format. --)
	DeleteWorkflowExecution(ctx context.Context, in *DeleteWorkflowExecutionRequest, opts ...grpc.CallOption) (*DeleteWorkflowExecutionResponse, error)
	// ListOpenWorkflowExecutions is a visibility API to list the open executions in a specific namespace.
	ListOpenWorkflowExecutions(ctx context.Context, in *ListOpenWorkflowExecutionsRequest, opts ...grpc.CallOption) (*ListOpenWorkflowExecutionsResponse, error)
	// ListClosedWorkflowExecutions is a visibility API to list the closed executions in a specific namespace.
	ListClosedWorkflowExecutions(ctx context.Context, in *ListClosedWorkflowExecutionsRequest, opts ...grpc.CallOption) (*ListClosedWorkflowExecutionsResponse, error)
	// ListWorkflowExecutions is a visibility API to list workflow executions in a specific namespace.
	ListWorkflowExecutions(ctx context.Context, in *ListWorkflowExecutionsRequest, opts ...grpc.CallOption) (*ListWorkflowExecutionsResponse, error)
	// ListArchivedWorkflowExecutions is a visibility API to list archived workflow executions in a specific namespace.
	ListArchivedWorkflowExecutions(ctx context.Context, in *ListArchivedWorkflowExecutionsRequest, opts ...grpc.CallOption) (*ListArchivedWorkflowExecutionsResponse, error)
	// ScanWorkflowExecutions is a visibility API to list large amount of workflow executions in a specific namespace without order.
	ScanWorkflowExecutions(ctx context.Context, in *ScanWorkflowExecutionsRequest, opts ...grpc.CallOption) (*ScanWorkflowExecutionsResponse, error)
	// CountWorkflowExecutions is a visibility API to count of workflow executions in a specific namespace.
	CountWorkflowExecutions(ctx context.Context, in *CountWorkflowExecutionsRequest, opts ...grpc.CallOption) (*CountWorkflowExecutionsResponse, error)
	// GetSearchAttributes is a visibility API to get all legal keys that could be used in list APIs
	GetSearchAttributes(ctx context.Context, in *GetSearchAttributesRequest, opts ...grpc.CallOption) (*GetSearchAttributesResponse, error)
	// RespondQueryTaskCompleted is called by workers to complete queries which were delivered on
	// the `query` (not `queries`) field of a `PollWorkflowTaskQueueResponse`.
	//
	// Completing the query will unblock the corresponding client call to `QueryWorkflow` and return
	// the query result a response.
	RespondQueryTaskCompleted(ctx context.Context, in *RespondQueryTaskCompletedRequest, opts ...grpc.CallOption) (*RespondQueryTaskCompletedResponse, error)
	// ResetStickyTaskQueue resets the sticky task queue related information in the mutable state of
	// a given workflow. This is prudent for workers to perform if a workflow has been paged out of
	// their cache.
	//
	// Things cleared are:
	// 1. StickyTaskQueue
	// 2. StickyScheduleToStartTimeout
	ResetStickyTaskQueue(ctx context.Context, in *ResetStickyTaskQueueRequest, opts ...grpc.CallOption) (*ResetStickyTaskQueueResponse, error)
	// QueryWorkflow requests a query be executed for a specified workflow execution.
	QueryWorkflow(ctx context.Context, in *QueryWorkflowRequest, opts ...grpc.CallOption) (*QueryWorkflowResponse, error)
	// DescribeWorkflowExecution returns information about the specified workflow execution.
	DescribeWorkflowExecution(ctx context.Context, in *DescribeWorkflowExecutionRequest, opts ...grpc.CallOption) (*DescribeWorkflowExecutionResponse, error)
	// DescribeTaskQueue returns information about the target task queue.
	DescribeTaskQueue(ctx context.Context, in *DescribeTaskQueueRequest, opts ...grpc.CallOption) (*DescribeTaskQueueResponse, error)
	// GetClusterInfo returns information about temporal cluster
	GetClusterInfo(ctx context.Context, in *GetClusterInfoRequest, opts ...grpc.CallOption) (*GetClusterInfoResponse, error)
	// GetSystemInfo returns information about the system.
	GetSystemInfo(ctx context.Context, in *GetSystemInfoRequest, opts ...grpc.CallOption) (*GetSystemInfoResponse, error)
	ListTaskQueuePartitions(ctx context.Context, in *ListTaskQueuePartitionsRequest, opts ...grpc.CallOption) (*ListTaskQueuePartitionsResponse, error)
	// Creates a new schedule.
	// (-- api-linter: core::0133::method-signature=disabled
	//     aip.dev/not-precedent: CreateSchedule doesn't follow Google API format --)
	// (-- api-linter: core::0133::response-message-name=disabled
	//     aip.dev/not-precedent: CreateSchedule doesn't follow Google API format --)
	// (-- api-linter: core::0133::http-uri-parent=disabled
	//     aip.dev/not-precedent: CreateSchedule doesn't follow Google API format --)
	CreateSchedule(ctx context.Context, in *CreateScheduleRequest, opts ...grpc.CallOption) (*CreateScheduleResponse, error)
	// Returns the schedule description and current state of an existing schedule.
	DescribeSchedule(ctx context.Context, in *DescribeScheduleRequest, opts ...grpc.CallOption) (*DescribeScheduleResponse, error)
	// Changes the configuration or state of an existing schedule.
	// (-- api-linter: core::0134::response-message-name=disabled
	//     aip.dev/not-precedent: UpdateSchedule RPC doesn't follow Google API format. --)
	// (-- api-linter: core::0134::method-signature=disabled
	//     aip.dev/not-precedent: UpdateSchedule RPC doesn't follow Google API format. --)
	UpdateSchedule(ctx context.Context, in *UpdateScheduleRequest, opts ...grpc.CallOption) (*UpdateScheduleResponse, error)
	// Makes a specific change to a schedule or triggers an immediate action.
	// (-- api-linter: core::0134::synonyms=disabled
	//     aip.dev/not-precedent: we have both patch and update. --)
	PatchSchedule(ctx context.Context, in *PatchScheduleRequest, opts ...grpc.CallOption) (*PatchScheduleResponse, error)
	// Lists matching times within a range.
	ListScheduleMatchingTimes(ctx context.Context, in *ListScheduleMatchingTimesRequest, opts ...grpc.CallOption) (*ListScheduleMatchingTimesResponse, error)
	// Deletes a schedule, removing it from the system.
	// (-- api-linter: core::0135::method-signature=disabled
	//     aip.dev/not-precedent: DeleteSchedule doesn't follow Google API format --)
	// (-- api-linter: core::0135::response-message-name=disabled
	//     aip.dev/not-precedent: DeleteSchedule doesn't follow Google API format --)
	DeleteSchedule(ctx context.Context, in *DeleteScheduleRequest, opts ...grpc.CallOption) (*DeleteScheduleResponse, error)
	// List all schedules in a namespace.
	ListSchedules(ctx context.Context, in *ListSchedulesRequest, opts ...grpc.CallOption) (*ListSchedulesResponse, error)
	// Allows users to specify sets of worker build id versions on a per task queue basis. Versions
	// are ordered, and may be either compatible with some extant version, or a new incompatible
	// version, forming sets of ids which are incompatible with each other, but whose contained
	// members are compatible with one another.
	//
	// A single build id may be mapped to multiple task queues using this API for cases where a single process hosts
	// multiple workers.
	//
	// To query which workers can be retired, use the `GetWorkerTaskReachability` API.
	//
	// NOTE: The number of task queues mapped to a single build id is limited by the `limit.taskQueuesPerBuildId`
	// (default is 20), if this limit is exceeded this API will error with a FailedPrecondition.
	//
	// (-- api-linter: core::0134::response-message-name=disabled
	//     aip.dev/not-precedent: UpdateWorkerBuildIdCompatibility RPC doesn't follow Google API format. --)
	// (-- api-linter: core::0134::method-signature=disabled
	//     aip.dev/not-precedent: UpdateWorkerBuildIdCompatibility RPC doesn't follow Google API format. --)
	UpdateWorkerBuildIdCompatibility(ctx context.Context, in *UpdateWorkerBuildIdCompatibilityRequest, opts ...grpc.CallOption) (*UpdateWorkerBuildIdCompatibilityResponse, error)
	// Fetches the worker build id versioning sets for a task queue.
	GetWorkerBuildIdCompatibility(ctx context.Context, in *GetWorkerBuildIdCompatibilityRequest, opts ...grpc.CallOption) (*GetWorkerBuildIdCompatibilityResponse, error)
	// Fetches task reachability to determine whether a worker may be retired.
	// The request may specify task queues to query for or let the server fetch all task queues mapped to the given
	// build IDs.
	//
	// When requesting a large number of task queues or all task queues associated with the given build ids in a
	// namespace, all task queues will be listed in the response but some of them may not contain reachability
	// information due to a server enforced limit. When reaching the limit, task queues that reachability information
	// could not be retrieved for will be marked with a single TASK_REACHABILITY_UNSPECIFIED entry. The caller may issue
	// another call to get the reachability for those task queues.
	//
	// Open source users can adjust this limit by setting the server's dynamic config value for
	// `limit.reachabilityTaskQueueScan` with the caveat that this call can strain the visibility store.
	GetWorkerTaskReachability(ctx context.Context, in *GetWorkerTaskReachabilityRequest, opts ...grpc.CallOption) (*GetWorkerTaskReachabilityResponse, error)
	// Invokes the specified update function on user workflow code.
	// (-- api-linter: core::0134=disabled
	//     aip.dev/not-precedent: UpdateWorkflowExecution doesn't follow Google API format --)
	UpdateWorkflowExecution(ctx context.Context, in *UpdateWorkflowExecutionRequest, opts ...grpc.CallOption) (*UpdateWorkflowExecutionResponse, error)
	// Polls a workflow execution for the outcome of a workflow execution update
	// previously issued through the UpdateWorkflowExecution RPC. The effective
	// timeout on this call will be shorter of the the caller-supplied gRPC
	// timeout and the server's configured long-poll timeout.
	// (-- api-linter: core::0134=disabled
	//     aip.dev/not-precedent: UpdateWorkflowExecution doesn't follow Google API format --)
	PollWorkflowExecutionUpdate(ctx context.Context, in *PollWorkflowExecutionUpdateRequest, opts ...grpc.CallOption) (*PollWorkflowExecutionUpdateResponse, error)
	// StartBatchOperation starts a new batch operation
	StartBatchOperation(ctx context.Context, in *StartBatchOperationRequest, opts ...grpc.CallOption) (*StartBatchOperationResponse, error)
	// StopBatchOperation stops a batch operation
	StopBatchOperation(ctx context.Context, in *StopBatchOperationRequest, opts ...grpc.CallOption) (*StopBatchOperationResponse, error)
	// DescribeBatchOperation returns the information about a batch operation
	DescribeBatchOperation(ctx context.Context, in *DescribeBatchOperationRequest, opts ...grpc.CallOption) (*DescribeBatchOperationResponse, error)
	// ListBatchOperations returns a list of batch operations
	ListBatchOperations(ctx context.Context, in *ListBatchOperationsRequest, opts ...grpc.CallOption) (*ListBatchOperationsResponse, error)
}

type workflowServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewWorkflowServiceClient(cc grpc.ClientConnInterface) WorkflowServiceClient {
	return &workflowServiceClient{cc}
}

func (c *workflowServiceClient) RegisterNamespace(ctx context.Context, in *RegisterNamespaceRequest, opts ...grpc.CallOption) (*RegisterNamespaceResponse, error) {
	out := new(RegisterNamespaceResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/RegisterNamespace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) DescribeNamespace(ctx context.Context, in *DescribeNamespaceRequest, opts ...grpc.CallOption) (*DescribeNamespaceResponse, error) {
	out := new(DescribeNamespaceResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/DescribeNamespace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ListNamespaces(ctx context.Context, in *ListNamespacesRequest, opts ...grpc.CallOption) (*ListNamespacesResponse, error) {
	out := new(ListNamespacesResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/ListNamespaces", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) UpdateNamespace(ctx context.Context, in *UpdateNamespaceRequest, opts ...grpc.CallOption) (*UpdateNamespaceResponse, error) {
	out := new(UpdateNamespaceResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/UpdateNamespace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) DeprecateNamespace(ctx context.Context, in *DeprecateNamespaceRequest, opts ...grpc.CallOption) (*DeprecateNamespaceResponse, error) {
	out := new(DeprecateNamespaceResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/DeprecateNamespace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) StartWorkflowExecution(ctx context.Context, in *StartWorkflowExecutionRequest, opts ...grpc.CallOption) (*StartWorkflowExecutionResponse, error) {
	out := new(StartWorkflowExecutionResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/StartWorkflowExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) GetWorkflowExecutionHistory(ctx context.Context, in *GetWorkflowExecutionHistoryRequest, opts ...grpc.CallOption) (*GetWorkflowExecutionHistoryResponse, error) {
	out := new(GetWorkflowExecutionHistoryResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/GetWorkflowExecutionHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) GetWorkflowExecutionHistoryReverse(ctx context.Context, in *GetWorkflowExecutionHistoryReverseRequest, opts ...grpc.CallOption) (*GetWorkflowExecutionHistoryReverseResponse, error) {
	out := new(GetWorkflowExecutionHistoryReverseResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/GetWorkflowExecutionHistoryReverse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) PollWorkflowTaskQueue(ctx context.Context, in *PollWorkflowTaskQueueRequest, opts ...grpc.CallOption) (*PollWorkflowTaskQueueResponse, error) {
	out := new(PollWorkflowTaskQueueResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/PollWorkflowTaskQueue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RespondWorkflowTaskCompleted(ctx context.Context, in *RespondWorkflowTaskCompletedRequest, opts ...grpc.CallOption) (*RespondWorkflowTaskCompletedResponse, error) {
	out := new(RespondWorkflowTaskCompletedResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/RespondWorkflowTaskCompleted", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RespondWorkflowTaskFailed(ctx context.Context, in *RespondWorkflowTaskFailedRequest, opts ...grpc.CallOption) (*RespondWorkflowTaskFailedResponse, error) {
	out := new(RespondWorkflowTaskFailedResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/RespondWorkflowTaskFailed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) PollActivityTaskQueue(ctx context.Context, in *PollActivityTaskQueueRequest, opts ...grpc.CallOption) (*PollActivityTaskQueueResponse, error) {
	out := new(PollActivityTaskQueueResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/PollActivityTaskQueue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RecordActivityTaskHeartbeat(ctx context.Context, in *RecordActivityTaskHeartbeatRequest, opts ...grpc.CallOption) (*RecordActivityTaskHeartbeatResponse, error) {
	out := new(RecordActivityTaskHeartbeatResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/RecordActivityTaskHeartbeat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RecordActivityTaskHeartbeatById(ctx context.Context, in *RecordActivityTaskHeartbeatByIdRequest, opts ...grpc.CallOption) (*RecordActivityTaskHeartbeatByIdResponse, error) {
	out := new(RecordActivityTaskHeartbeatByIdResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/RecordActivityTaskHeartbeatById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RespondActivityTaskCompleted(ctx context.Context, in *RespondActivityTaskCompletedRequest, opts ...grpc.CallOption) (*RespondActivityTaskCompletedResponse, error) {
	out := new(RespondActivityTaskCompletedResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskCompleted", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RespondActivityTaskCompletedById(ctx context.Context, in *RespondActivityTaskCompletedByIdRequest, opts ...grpc.CallOption) (*RespondActivityTaskCompletedByIdResponse, error) {
	out := new(RespondActivityTaskCompletedByIdResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskCompletedById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RespondActivityTaskFailed(ctx context.Context, in *RespondActivityTaskFailedRequest, opts ...grpc.CallOption) (*RespondActivityTaskFailedResponse, error) {
	out := new(RespondActivityTaskFailedResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskFailed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RespondActivityTaskFailedById(ctx context.Context, in *RespondActivityTaskFailedByIdRequest, opts ...grpc.CallOption) (*RespondActivityTaskFailedByIdResponse, error) {
	out := new(RespondActivityTaskFailedByIdResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskFailedById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RespondActivityTaskCanceled(ctx context.Context, in *RespondActivityTaskCanceledRequest, opts ...grpc.CallOption) (*RespondActivityTaskCanceledResponse, error) {
	out := new(RespondActivityTaskCanceledResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskCanceled", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RespondActivityTaskCanceledById(ctx context.Context, in *RespondActivityTaskCanceledByIdRequest, opts ...grpc.CallOption) (*RespondActivityTaskCanceledByIdResponse, error) {
	out := new(RespondActivityTaskCanceledByIdResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskCanceledById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RequestCancelWorkflowExecution(ctx context.Context, in *RequestCancelWorkflowExecutionRequest, opts ...grpc.CallOption) (*RequestCancelWorkflowExecutionResponse, error) {
	out := new(RequestCancelWorkflowExecutionResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/RequestCancelWorkflowExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) SignalWorkflowExecution(ctx context.Context, in *SignalWorkflowExecutionRequest, opts ...grpc.CallOption) (*SignalWorkflowExecutionResponse, error) {
	out := new(SignalWorkflowExecutionResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/SignalWorkflowExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) SignalWithStartWorkflowExecution(ctx context.Context, in *SignalWithStartWorkflowExecutionRequest, opts ...grpc.CallOption) (*SignalWithStartWorkflowExecutionResponse, error) {
	out := new(SignalWithStartWorkflowExecutionResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/SignalWithStartWorkflowExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ResetWorkflowExecution(ctx context.Context, in *ResetWorkflowExecutionRequest, opts ...grpc.CallOption) (*ResetWorkflowExecutionResponse, error) {
	out := new(ResetWorkflowExecutionResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/ResetWorkflowExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) TerminateWorkflowExecution(ctx context.Context, in *TerminateWorkflowExecutionRequest, opts ...grpc.CallOption) (*TerminateWorkflowExecutionResponse, error) {
	out := new(TerminateWorkflowExecutionResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/TerminateWorkflowExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) DeleteWorkflowExecution(ctx context.Context, in *DeleteWorkflowExecutionRequest, opts ...grpc.CallOption) (*DeleteWorkflowExecutionResponse, error) {
	out := new(DeleteWorkflowExecutionResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/DeleteWorkflowExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ListOpenWorkflowExecutions(ctx context.Context, in *ListOpenWorkflowExecutionsRequest, opts ...grpc.CallOption) (*ListOpenWorkflowExecutionsResponse, error) {
	out := new(ListOpenWorkflowExecutionsResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/ListOpenWorkflowExecutions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ListClosedWorkflowExecutions(ctx context.Context, in *ListClosedWorkflowExecutionsRequest, opts ...grpc.CallOption) (*ListClosedWorkflowExecutionsResponse, error) {
	out := new(ListClosedWorkflowExecutionsResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/ListClosedWorkflowExecutions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ListWorkflowExecutions(ctx context.Context, in *ListWorkflowExecutionsRequest, opts ...grpc.CallOption) (*ListWorkflowExecutionsResponse, error) {
	out := new(ListWorkflowExecutionsResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/ListWorkflowExecutions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ListArchivedWorkflowExecutions(ctx context.Context, in *ListArchivedWorkflowExecutionsRequest, opts ...grpc.CallOption) (*ListArchivedWorkflowExecutionsResponse, error) {
	out := new(ListArchivedWorkflowExecutionsResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/ListArchivedWorkflowExecutions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ScanWorkflowExecutions(ctx context.Context, in *ScanWorkflowExecutionsRequest, opts ...grpc.CallOption) (*ScanWorkflowExecutionsResponse, error) {
	out := new(ScanWorkflowExecutionsResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/ScanWorkflowExecutions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) CountWorkflowExecutions(ctx context.Context, in *CountWorkflowExecutionsRequest, opts ...grpc.CallOption) (*CountWorkflowExecutionsResponse, error) {
	out := new(CountWorkflowExecutionsResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/CountWorkflowExecutions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) GetSearchAttributes(ctx context.Context, in *GetSearchAttributesRequest, opts ...grpc.CallOption) (*GetSearchAttributesResponse, error) {
	out := new(GetSearchAttributesResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/GetSearchAttributes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RespondQueryTaskCompleted(ctx context.Context, in *RespondQueryTaskCompletedRequest, opts ...grpc.CallOption) (*RespondQueryTaskCompletedResponse, error) {
	out := new(RespondQueryTaskCompletedResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/RespondQueryTaskCompleted", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ResetStickyTaskQueue(ctx context.Context, in *ResetStickyTaskQueueRequest, opts ...grpc.CallOption) (*ResetStickyTaskQueueResponse, error) {
	out := new(ResetStickyTaskQueueResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/ResetStickyTaskQueue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) QueryWorkflow(ctx context.Context, in *QueryWorkflowRequest, opts ...grpc.CallOption) (*QueryWorkflowResponse, error) {
	out := new(QueryWorkflowResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/QueryWorkflow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) DescribeWorkflowExecution(ctx context.Context, in *DescribeWorkflowExecutionRequest, opts ...grpc.CallOption) (*DescribeWorkflowExecutionResponse, error) {
	out := new(DescribeWorkflowExecutionResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/DescribeWorkflowExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) DescribeTaskQueue(ctx context.Context, in *DescribeTaskQueueRequest, opts ...grpc.CallOption) (*DescribeTaskQueueResponse, error) {
	out := new(DescribeTaskQueueResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/DescribeTaskQueue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) GetClusterInfo(ctx context.Context, in *GetClusterInfoRequest, opts ...grpc.CallOption) (*GetClusterInfoResponse, error) {
	out := new(GetClusterInfoResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/GetClusterInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) GetSystemInfo(ctx context.Context, in *GetSystemInfoRequest, opts ...grpc.CallOption) (*GetSystemInfoResponse, error) {
	out := new(GetSystemInfoResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/GetSystemInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ListTaskQueuePartitions(ctx context.Context, in *ListTaskQueuePartitionsRequest, opts ...grpc.CallOption) (*ListTaskQueuePartitionsResponse, error) {
	out := new(ListTaskQueuePartitionsResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/ListTaskQueuePartitions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) CreateSchedule(ctx context.Context, in *CreateScheduleRequest, opts ...grpc.CallOption) (*CreateScheduleResponse, error) {
	out := new(CreateScheduleResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/CreateSchedule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) DescribeSchedule(ctx context.Context, in *DescribeScheduleRequest, opts ...grpc.CallOption) (*DescribeScheduleResponse, error) {
	out := new(DescribeScheduleResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/DescribeSchedule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) UpdateSchedule(ctx context.Context, in *UpdateScheduleRequest, opts ...grpc.CallOption) (*UpdateScheduleResponse, error) {
	out := new(UpdateScheduleResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/UpdateSchedule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) PatchSchedule(ctx context.Context, in *PatchScheduleRequest, opts ...grpc.CallOption) (*PatchScheduleResponse, error) {
	out := new(PatchScheduleResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/PatchSchedule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ListScheduleMatchingTimes(ctx context.Context, in *ListScheduleMatchingTimesRequest, opts ...grpc.CallOption) (*ListScheduleMatchingTimesResponse, error) {
	out := new(ListScheduleMatchingTimesResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/ListScheduleMatchingTimes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) DeleteSchedule(ctx context.Context, in *DeleteScheduleRequest, opts ...grpc.CallOption) (*DeleteScheduleResponse, error) {
	out := new(DeleteScheduleResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/DeleteSchedule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ListSchedules(ctx context.Context, in *ListSchedulesRequest, opts ...grpc.CallOption) (*ListSchedulesResponse, error) {
	out := new(ListSchedulesResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/ListSchedules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) UpdateWorkerBuildIdCompatibility(ctx context.Context, in *UpdateWorkerBuildIdCompatibilityRequest, opts ...grpc.CallOption) (*UpdateWorkerBuildIdCompatibilityResponse, error) {
	out := new(UpdateWorkerBuildIdCompatibilityResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/UpdateWorkerBuildIdCompatibility", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) GetWorkerBuildIdCompatibility(ctx context.Context, in *GetWorkerBuildIdCompatibilityRequest, opts ...grpc.CallOption) (*GetWorkerBuildIdCompatibilityResponse, error) {
	out := new(GetWorkerBuildIdCompatibilityResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/GetWorkerBuildIdCompatibility", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) GetWorkerTaskReachability(ctx context.Context, in *GetWorkerTaskReachabilityRequest, opts ...grpc.CallOption) (*GetWorkerTaskReachabilityResponse, error) {
	out := new(GetWorkerTaskReachabilityResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/GetWorkerTaskReachability", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) UpdateWorkflowExecution(ctx context.Context, in *UpdateWorkflowExecutionRequest, opts ...grpc.CallOption) (*UpdateWorkflowExecutionResponse, error) {
	out := new(UpdateWorkflowExecutionResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/UpdateWorkflowExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) PollWorkflowExecutionUpdate(ctx context.Context, in *PollWorkflowExecutionUpdateRequest, opts ...grpc.CallOption) (*PollWorkflowExecutionUpdateResponse, error) {
	out := new(PollWorkflowExecutionUpdateResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/PollWorkflowExecutionUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) StartBatchOperation(ctx context.Context, in *StartBatchOperationRequest, opts ...grpc.CallOption) (*StartBatchOperationResponse, error) {
	out := new(StartBatchOperationResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/StartBatchOperation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) StopBatchOperation(ctx context.Context, in *StopBatchOperationRequest, opts ...grpc.CallOption) (*StopBatchOperationResponse, error) {
	out := new(StopBatchOperationResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/StopBatchOperation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) DescribeBatchOperation(ctx context.Context, in *DescribeBatchOperationRequest, opts ...grpc.CallOption) (*DescribeBatchOperationResponse, error) {
	out := new(DescribeBatchOperationResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/DescribeBatchOperation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ListBatchOperations(ctx context.Context, in *ListBatchOperationsRequest, opts ...grpc.CallOption) (*ListBatchOperationsResponse, error) {
	out := new(ListBatchOperationsResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/ListBatchOperations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WorkflowServiceServer is the server API for WorkflowService service.
type WorkflowServiceServer interface {
	// RegisterNamespace creates a new namespace which can be used as a container for all resources.
	//
	// A Namespace is a top level entity within Temporal, and is used as a container for resources
	// like workflow executions, task queues, etc. A Namespace acts as a sandbox and provides
	// isolation for all resources within the namespace. All resources belongs to exactly one
	// namespace.
	RegisterNamespace(context.Context, *RegisterNamespaceRequest) (*RegisterNamespaceResponse, error)
	// DescribeNamespace returns the information and configuration for a registered namespace.
	DescribeNamespace(context.Context, *DescribeNamespaceRequest) (*DescribeNamespaceResponse, error)
	// ListNamespaces returns the information and configuration for all namespaces.
	ListNamespaces(context.Context, *ListNamespacesRequest) (*ListNamespacesResponse, error)
	// UpdateNamespace is used to update the information and configuration of a registered
	// namespace.
	//
	// (-- api-linter: core::0134::method-signature=disabled
	//     aip.dev/not-precedent: UpdateNamespace RPC doesn't follow Google API format. --)
	// (-- api-linter: core::0134::response-message-name=disabled
	//     aip.dev/not-precedent: UpdateNamespace RPC doesn't follow Google API format. --)
	UpdateNamespace(context.Context, *UpdateNamespaceRequest) (*UpdateNamespaceResponse, error)
	// DeprecateNamespace is used to update the state of a registered namespace to DEPRECATED.
	//
	// Once the namespace is deprecated it cannot be used to start new workflow executions. Existing
	// workflow executions will continue to run on deprecated namespaces.
	// Deprecated.
	DeprecateNamespace(context.Context, *DeprecateNamespaceRequest) (*DeprecateNamespaceResponse, error)
	// StartWorkflowExecution starts a new workflow execution.
	//
	// It will create the execution with a `WORKFLOW_EXECUTION_STARTED` event in its history and
	// also schedule the first workflow task. Returns `WorkflowExecutionAlreadyStarted`, if an
	// instance already exists with same workflow id.
	StartWorkflowExecution(context.Context, *StartWorkflowExecutionRequest) (*StartWorkflowExecutionResponse, error)
	// GetWorkflowExecutionHistory returns the history of specified workflow execution. Fails with
	// `NotFound` if the specified workflow execution is unknown to the service.
	GetWorkflowExecutionHistory(context.Context, *GetWorkflowExecutionHistoryRequest) (*GetWorkflowExecutionHistoryResponse, error)
	// GetWorkflowExecutionHistoryReverse returns the history of specified workflow execution in reverse
	// order (starting from last event). Fails with`NotFound` if the specified workflow execution is
	// unknown to the service.
	GetWorkflowExecutionHistoryReverse(context.Context, *GetWorkflowExecutionHistoryReverseRequest) (*GetWorkflowExecutionHistoryReverseResponse, error)
	// PollWorkflowTaskQueue is called by workers to make progress on workflows.
	//
	// A WorkflowTask is dispatched to callers for active workflow executions with pending workflow
	// tasks. The worker is expected to call `RespondWorkflowTaskCompleted` when it is done
	// processing the task. The service will create a `WorkflowTaskStarted` event in the history for
	// this task before handing it to the worker.
	PollWorkflowTaskQueue(context.Context, *PollWorkflowTaskQueueRequest) (*PollWorkflowTaskQueueResponse, error)
	// RespondWorkflowTaskCompleted is called by workers to successfully complete workflow tasks
	// they received from `PollWorkflowTaskQueue`.
	//
	// Completing a WorkflowTask will write a `WORKFLOW_TASK_COMPLETED` event to the workflow's
	// history, along with events corresponding to whatever commands the SDK generated while
	// executing the task (ex timer started, activity task scheduled, etc).
	RespondWorkflowTaskCompleted(context.Context, *RespondWorkflowTaskCompletedRequest) (*RespondWorkflowTaskCompletedResponse, error)
	// RespondWorkflowTaskFailed is called by workers to indicate the processing of a workflow task
	// failed.
	//
	// This results in a `WORKFLOW_TASK_FAILED` event written to the history, and a new workflow
	// task will be scheduled. This API can be used to report unhandled failures resulting from
	// applying the workflow task.
	//
	// Temporal will only append first WorkflowTaskFailed event to the history of workflow execution
	// for consecutive failures.
	RespondWorkflowTaskFailed(context.Context, *RespondWorkflowTaskFailedRequest) (*RespondWorkflowTaskFailedResponse, error)
	// PollActivityTaskQueue is called by workers to process activity tasks from a specific task
	// queue.
	//
	// The worker is expected to call one of the `RespondActivityTaskXXX` methods when it is done
	// processing the task.
	//
	// An activity task is dispatched whenever a `SCHEDULE_ACTIVITY_TASK` command is produced during
	// workflow execution. An in memory `ACTIVITY_TASK_STARTED` event is written to mutable state
	// before the task is dispatched to the worker. The started event, and the final event
	// (`ACTIVITY_TASK_COMPLETED` / `ACTIVITY_TASK_FAILED` / `ACTIVITY_TASK_TIMED_OUT`) will both be
	// written permanently to Workflow execution history when Activity is finished. This is done to
	// avoid writing many events in the case of a failure/retry loop.
	PollActivityTaskQueue(context.Context, *PollActivityTaskQueueRequest) (*PollActivityTaskQueueResponse, error)
	// RecordActivityTaskHeartbeat is optionally called by workers while they execute activities.
	//
	// If worker fails to heartbeat within the `heartbeat_timeout` interval for the activity task,
	// then it will be marked as timed out and an `ACTIVITY_TASK_TIMED_OUT` event will be written to
	// the workflow history. Calling `RecordActivityTaskHeartbeat` will fail with `NotFound` in
	// such situations, in that event, the SDK should request cancellation of the activity.
	RecordActivityTaskHeartbeat(context.Context, *RecordActivityTaskHeartbeatRequest) (*RecordActivityTaskHeartbeatResponse, error)
	// See `RecordActivityTaskHeartbeat`. This version allows clients to record heartbeats by
	// namespace/workflow id/activity id instead of task token.
	//
	// (-- api-linter: core::0136::prepositions=disabled
	//     aip.dev/not-precedent: "By" is used to indicate request type. --)
	RecordActivityTaskHeartbeatById(context.Context, *RecordActivityTaskHeartbeatByIdRequest) (*RecordActivityTaskHeartbeatByIdResponse, error)
	// RespondActivityTaskCompleted is called by workers when they successfully complete an activity
	// task.
	//
	// This results in a new `ACTIVITY_TASK_COMPLETED` event being written to the workflow history
	// and a new workflow task created for the workflow. Fails with `NotFound` if the task token is
	// no longer valid due to activity timeout, already being completed, or never having existed.
	RespondActivityTaskCompleted(context.Context, *RespondActivityTaskCompletedRequest) (*RespondActivityTaskCompletedResponse, error)
	// See `RecordActivityTaskCompleted`. This version allows clients to record completions by
	// namespace/workflow id/activity id instead of task token.
	//
	// (-- api-linter: core::0136::prepositions=disabled
	//     aip.dev/not-precedent: "By" is used to indicate request type. --)
	RespondActivityTaskCompletedById(context.Context, *RespondActivityTaskCompletedByIdRequest) (*RespondActivityTaskCompletedByIdResponse, error)
	// RespondActivityTaskFailed is called by workers when processing an activity task fails.
	//
	// This results in a new `ACTIVITY_TASK_FAILED` event being written to the workflow history and
	// a new workflow task created for the workflow. Fails with `NotFound` if the task token is no
	// longer valid due to activity timeout, already being completed, or never having existed.
	RespondActivityTaskFailed(context.Context, *RespondActivityTaskFailedRequest) (*RespondActivityTaskFailedResponse, error)
	// See `RecordActivityTaskFailed`. This version allows clients to record failures by
	// namespace/workflow id/activity id instead of task token.
	//
	// (-- api-linter: core::0136::prepositions=disabled
	//     aip.dev/not-precedent: "By" is used to indicate request type. --)
	RespondActivityTaskFailedById(context.Context, *RespondActivityTaskFailedByIdRequest) (*RespondActivityTaskFailedByIdResponse, error)
	// RespondActivityTaskFailed is called by workers when processing an activity task fails.
	//
	// This results in a new `ACTIVITY_TASK_CANCELED` event being written to the workflow history
	// and a new workflow task created for the workflow. Fails with `NotFound` if the task token is
	// no longer valid due to activity timeout, already being completed, or never having existed.
	RespondActivityTaskCanceled(context.Context, *RespondActivityTaskCanceledRequest) (*RespondActivityTaskCanceledResponse, error)
	// See `RecordActivityTaskCanceled`. This version allows clients to record failures by
	// namespace/workflow id/activity id instead of task token.
	//
	// (-- api-linter: core::0136::prepositions=disabled
	//     aip.dev/not-precedent: "By" is used to indicate request type. --)
	RespondActivityTaskCanceledById(context.Context, *RespondActivityTaskCanceledByIdRequest) (*RespondActivityTaskCanceledByIdResponse, error)
	// RequestCancelWorkflowExecution is called by workers when they want to request cancellation of
	// a workflow execution.
	//
	// This results in a new `WORKFLOW_EXECUTION_CANCEL_REQUESTED` event being written to the
	// workflow history and a new workflow task created for the workflow. It returns success if the requested
	// workflow is already closed. It fails with 'NotFound' if the requested workflow doesn't exist.
	RequestCancelWorkflowExecution(context.Context, *RequestCancelWorkflowExecutionRequest) (*RequestCancelWorkflowExecutionResponse, error)
	// SignalWorkflowExecution is used to send a signal to a running workflow execution.
	//
	// This results in a `WORKFLOW_EXECUTION_SIGNALED` event recorded in the history and a workflow
	// task being created for the execution.
	SignalWorkflowExecution(context.Context, *SignalWorkflowExecutionRequest) (*SignalWorkflowExecutionResponse, error)
	// SignalWithStartWorkflowExecution is used to ensure a signal is sent to a workflow, even if
	// it isn't yet started.
	//
	// If the workflow is running, a `WORKFLOW_EXECUTION_SIGNALED` event is recorded in the history
	// and a workflow task is generated.
	//
	// If the workflow is not running or not found, then the workflow is created with
	// `WORKFLOW_EXECUTION_STARTED` and `WORKFLOW_EXECUTION_SIGNALED` events in its history, and a
	// workflow task is generated.
	//
	// (-- api-linter: core::0136::prepositions=disabled
	//     aip.dev/not-precedent: "With" is used to indicate combined operation. --)
	SignalWithStartWorkflowExecution(context.Context, *SignalWithStartWorkflowExecutionRequest) (*SignalWithStartWorkflowExecutionResponse, error)
	// ResetWorkflowExecution will reset an existing workflow execution to a specified
	// `WORKFLOW_TASK_COMPLETED` event (exclusive). It will immediately terminate the current
	// execution instance.
	// TODO: Does exclusive here mean *just* the completed event, or also WFT started? Otherwise the task is doomed to time out?
	ResetWorkflowExecution(context.Context, *ResetWorkflowExecutionRequest) (*ResetWorkflowExecutionResponse, error)
	// TerminateWorkflowExecution terminates an existing workflow execution by recording a
	// `WORKFLOW_EXECUTION_TERMINATED` event in the history and immediately terminating the
	// execution instance.
	TerminateWorkflowExecution(context.Context, *TerminateWorkflowExecutionRequest) (*TerminateWorkflowExecutionResponse, error)
	// DeleteWorkflowExecution asynchronously deletes a specific Workflow Execution (when
	// WorkflowExecution.run_id is provided) or the latest Workflow Execution (when
	// WorkflowExecution.run_id is not provided). If the Workflow Execution is Running, it will be
	// terminated before deletion.
	// (-- api-linter: core::0135::method-signature=disabled
	//     aip.dev/not-precedent: DeleteNamespace RPC doesn't follow Google API format. --)
	// (-- api-linter: core::0135::response-message-name=disabled
	//     aip.dev/not-precedent: DeleteNamespace RPC doesn't follow Google API format. --)
	DeleteWorkflowExecution(context.Context, *DeleteWorkflowExecutionRequest) (*DeleteWorkflowExecutionResponse, error)
	// ListOpenWorkflowExecutions is a visibility API to list the open executions in a specific namespace.
	ListOpenWorkflowExecutions(context.Context, *ListOpenWorkflowExecutionsRequest) (*ListOpenWorkflowExecutionsResponse, error)
	// ListClosedWorkflowExecutions is a visibility API to list the closed executions in a specific namespace.
	ListClosedWorkflowExecutions(context.Context, *ListClosedWorkflowExecutionsRequest) (*ListClosedWorkflowExecutionsResponse, error)
	// ListWorkflowExecutions is a visibility API to list workflow executions in a specific namespace.
	ListWorkflowExecutions(context.Context, *ListWorkflowExecutionsRequest) (*ListWorkflowExecutionsResponse, error)
	// ListArchivedWorkflowExecutions is a visibility API to list archived workflow executions in a specific namespace.
	ListArchivedWorkflowExecutions(context.Context, *ListArchivedWorkflowExecutionsRequest) (*ListArchivedWorkflowExecutionsResponse, error)
	// ScanWorkflowExecutions is a visibility API to list large amount of workflow executions in a specific namespace without order.
	ScanWorkflowExecutions(context.Context, *ScanWorkflowExecutionsRequest) (*ScanWorkflowExecutionsResponse, error)
	// CountWorkflowExecutions is a visibility API to count of workflow executions in a specific namespace.
	CountWorkflowExecutions(context.Context, *CountWorkflowExecutionsRequest) (*CountWorkflowExecutionsResponse, error)
	// GetSearchAttributes is a visibility API to get all legal keys that could be used in list APIs
	GetSearchAttributes(context.Context, *GetSearchAttributesRequest) (*GetSearchAttributesResponse, error)
	// RespondQueryTaskCompleted is called by workers to complete queries which were delivered on
	// the `query` (not `queries`) field of a `PollWorkflowTaskQueueResponse`.
	//
	// Completing the query will unblock the corresponding client call to `QueryWorkflow` and return
	// the query result a response.
	RespondQueryTaskCompleted(context.Context, *RespondQueryTaskCompletedRequest) (*RespondQueryTaskCompletedResponse, error)
	// ResetStickyTaskQueue resets the sticky task queue related information in the mutable state of
	// a given workflow. This is prudent for workers to perform if a workflow has been paged out of
	// their cache.
	//
	// Things cleared are:
	// 1. StickyTaskQueue
	// 2. StickyScheduleToStartTimeout
	ResetStickyTaskQueue(context.Context, *ResetStickyTaskQueueRequest) (*ResetStickyTaskQueueResponse, error)
	// QueryWorkflow requests a query be executed for a specified workflow execution.
	QueryWorkflow(context.Context, *QueryWorkflowRequest) (*QueryWorkflowResponse, error)
	// DescribeWorkflowExecution returns information about the specified workflow execution.
	DescribeWorkflowExecution(context.Context, *DescribeWorkflowExecutionRequest) (*DescribeWorkflowExecutionResponse, error)
	// DescribeTaskQueue returns information about the target task queue.
	DescribeTaskQueue(context.Context, *DescribeTaskQueueRequest) (*DescribeTaskQueueResponse, error)
	// GetClusterInfo returns information about temporal cluster
	GetClusterInfo(context.Context, *GetClusterInfoRequest) (*GetClusterInfoResponse, error)
	// GetSystemInfo returns information about the system.
	GetSystemInfo(context.Context, *GetSystemInfoRequest) (*GetSystemInfoResponse, error)
	ListTaskQueuePartitions(context.Context, *ListTaskQueuePartitionsRequest) (*ListTaskQueuePartitionsResponse, error)
	// Creates a new schedule.
	// (-- api-linter: core::0133::method-signature=disabled
	//     aip.dev/not-precedent: CreateSchedule doesn't follow Google API format --)
	// (-- api-linter: core::0133::response-message-name=disabled
	//     aip.dev/not-precedent: CreateSchedule doesn't follow Google API format --)
	// (-- api-linter: core::0133::http-uri-parent=disabled
	//     aip.dev/not-precedent: CreateSchedule doesn't follow Google API format --)
	CreateSchedule(context.Context, *CreateScheduleRequest) (*CreateScheduleResponse, error)
	// Returns the schedule description and current state of an existing schedule.
	DescribeSchedule(context.Context, *DescribeScheduleRequest) (*DescribeScheduleResponse, error)
	// Changes the configuration or state of an existing schedule.
	// (-- api-linter: core::0134::response-message-name=disabled
	//     aip.dev/not-precedent: UpdateSchedule RPC doesn't follow Google API format. --)
	// (-- api-linter: core::0134::method-signature=disabled
	//     aip.dev/not-precedent: UpdateSchedule RPC doesn't follow Google API format. --)
	UpdateSchedule(context.Context, *UpdateScheduleRequest) (*UpdateScheduleResponse, error)
	// Makes a specific change to a schedule or triggers an immediate action.
	// (-- api-linter: core::0134::synonyms=disabled
	//     aip.dev/not-precedent: we have both patch and update. --)
	PatchSchedule(context.Context, *PatchScheduleRequest) (*PatchScheduleResponse, error)
	// Lists matching times within a range.
	ListScheduleMatchingTimes(context.Context, *ListScheduleMatchingTimesRequest) (*ListScheduleMatchingTimesResponse, error)
	// Deletes a schedule, removing it from the system.
	// (-- api-linter: core::0135::method-signature=disabled
	//     aip.dev/not-precedent: DeleteSchedule doesn't follow Google API format --)
	// (-- api-linter: core::0135::response-message-name=disabled
	//     aip.dev/not-precedent: DeleteSchedule doesn't follow Google API format --)
	DeleteSchedule(context.Context, *DeleteScheduleRequest) (*DeleteScheduleResponse, error)
	// List all schedules in a namespace.
	ListSchedules(context.Context, *ListSchedulesRequest) (*ListSchedulesResponse, error)
	// Allows users to specify sets of worker build id versions on a per task queue basis. Versions
	// are ordered, and may be either compatible with some extant version, or a new incompatible
	// version, forming sets of ids which are incompatible with each other, but whose contained
	// members are compatible with one another.
	//
	// A single build id may be mapped to multiple task queues using this API for cases where a single process hosts
	// multiple workers.
	//
	// To query which workers can be retired, use the `GetWorkerTaskReachability` API.
	//
	// NOTE: The number of task queues mapped to a single build id is limited by the `limit.taskQueuesPerBuildId`
	// (default is 20), if this limit is exceeded this API will error with a FailedPrecondition.
	//
	// (-- api-linter: core::0134::response-message-name=disabled
	//     aip.dev/not-precedent: UpdateWorkerBuildIdCompatibility RPC doesn't follow Google API format. --)
	// (-- api-linter: core::0134::method-signature=disabled
	//     aip.dev/not-precedent: UpdateWorkerBuildIdCompatibility RPC doesn't follow Google API format. --)
	UpdateWorkerBuildIdCompatibility(context.Context, *UpdateWorkerBuildIdCompatibilityRequest) (*UpdateWorkerBuildIdCompatibilityResponse, error)
	// Fetches the worker build id versioning sets for a task queue.
	GetWorkerBuildIdCompatibility(context.Context, *GetWorkerBuildIdCompatibilityRequest) (*GetWorkerBuildIdCompatibilityResponse, error)
	// Fetches task reachability to determine whether a worker may be retired.
	// The request may specify task queues to query for or let the server fetch all task queues mapped to the given
	// build IDs.
	//
	// When requesting a large number of task queues or all task queues associated with the given build ids in a
	// namespace, all task queues will be listed in the response but some of them may not contain reachability
	// information due to a server enforced limit. When reaching the limit, task queues that reachability information
	// could not be retrieved for will be marked with a single TASK_REACHABILITY_UNSPECIFIED entry. The caller may issue
	// another call to get the reachability for those task queues.
	//
	// Open source users can adjust this limit by setting the server's dynamic config value for
	// `limit.reachabilityTaskQueueScan` with the caveat that this call can strain the visibility store.
	GetWorkerTaskReachability(context.Context, *GetWorkerTaskReachabilityRequest) (*GetWorkerTaskReachabilityResponse, error)
	// Invokes the specified update function on user workflow code.
	// (-- api-linter: core::0134=disabled
	//     aip.dev/not-precedent: UpdateWorkflowExecution doesn't follow Google API format --)
	UpdateWorkflowExecution(context.Context, *UpdateWorkflowExecutionRequest) (*UpdateWorkflowExecutionResponse, error)
	// Polls a workflow execution for the outcome of a workflow execution update
	// previously issued through the UpdateWorkflowExecution RPC. The effective
	// timeout on this call will be shorter of the the caller-supplied gRPC
	// timeout and the server's configured long-poll timeout.
	// (-- api-linter: core::0134=disabled
	//     aip.dev/not-precedent: UpdateWorkflowExecution doesn't follow Google API format --)
	PollWorkflowExecutionUpdate(context.Context, *PollWorkflowExecutionUpdateRequest) (*PollWorkflowExecutionUpdateResponse, error)
	// StartBatchOperation starts a new batch operation
	StartBatchOperation(context.Context, *StartBatchOperationRequest) (*StartBatchOperationResponse, error)
	// StopBatchOperation stops a batch operation
	StopBatchOperation(context.Context, *StopBatchOperationRequest) (*StopBatchOperationResponse, error)
	// DescribeBatchOperation returns the information about a batch operation
	DescribeBatchOperation(context.Context, *DescribeBatchOperationRequest) (*DescribeBatchOperationResponse, error)
	// ListBatchOperations returns a list of batch operations
	ListBatchOperations(context.Context, *ListBatchOperationsRequest) (*ListBatchOperationsResponse, error)
}

// UnimplementedWorkflowServiceServer can be embedded to have forward compatible implementations.
type UnimplementedWorkflowServiceServer struct {
}

func (*UnimplementedWorkflowServiceServer) RegisterNamespace(ctx context.Context, req *RegisterNamespaceRequest) (*RegisterNamespaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterNamespace not implemented")
}
func (*UnimplementedWorkflowServiceServer) DescribeNamespace(ctx context.Context, req *DescribeNamespaceRequest) (*DescribeNamespaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeNamespace not implemented")
}
func (*UnimplementedWorkflowServiceServer) ListNamespaces(ctx context.Context, req *ListNamespacesRequest) (*ListNamespacesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNamespaces not implemented")
}
func (*UnimplementedWorkflowServiceServer) UpdateNamespace(ctx context.Context, req *UpdateNamespaceRequest) (*UpdateNamespaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNamespace not implemented")
}
func (*UnimplementedWorkflowServiceServer) DeprecateNamespace(ctx context.Context, req *DeprecateNamespaceRequest) (*DeprecateNamespaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeprecateNamespace not implemented")
}
func (*UnimplementedWorkflowServiceServer) StartWorkflowExecution(ctx context.Context, req *StartWorkflowExecutionRequest) (*StartWorkflowExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartWorkflowExecution not implemented")
}
func (*UnimplementedWorkflowServiceServer) GetWorkflowExecutionHistory(ctx context.Context, req *GetWorkflowExecutionHistoryRequest) (*GetWorkflowExecutionHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkflowExecutionHistory not implemented")
}
func (*UnimplementedWorkflowServiceServer) GetWorkflowExecutionHistoryReverse(ctx context.Context, req *GetWorkflowExecutionHistoryReverseRequest) (*GetWorkflowExecutionHistoryReverseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkflowExecutionHistoryReverse not implemented")
}
func (*UnimplementedWorkflowServiceServer) PollWorkflowTaskQueue(ctx context.Context, req *PollWorkflowTaskQueueRequest) (*PollWorkflowTaskQueueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PollWorkflowTaskQueue not implemented")
}
func (*UnimplementedWorkflowServiceServer) RespondWorkflowTaskCompleted(ctx context.Context, req *RespondWorkflowTaskCompletedRequest) (*RespondWorkflowTaskCompletedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondWorkflowTaskCompleted not implemented")
}
func (*UnimplementedWorkflowServiceServer) RespondWorkflowTaskFailed(ctx context.Context, req *RespondWorkflowTaskFailedRequest) (*RespondWorkflowTaskFailedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondWorkflowTaskFailed not implemented")
}
func (*UnimplementedWorkflowServiceServer) PollActivityTaskQueue(ctx context.Context, req *PollActivityTaskQueueRequest) (*PollActivityTaskQueueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PollActivityTaskQueue not implemented")
}
func (*UnimplementedWorkflowServiceServer) RecordActivityTaskHeartbeat(ctx context.Context, req *RecordActivityTaskHeartbeatRequest) (*RecordActivityTaskHeartbeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecordActivityTaskHeartbeat not implemented")
}
func (*UnimplementedWorkflowServiceServer) RecordActivityTaskHeartbeatById(ctx context.Context, req *RecordActivityTaskHeartbeatByIdRequest) (*RecordActivityTaskHeartbeatByIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecordActivityTaskHeartbeatById not implemented")
}
func (*UnimplementedWorkflowServiceServer) RespondActivityTaskCompleted(ctx context.Context, req *RespondActivityTaskCompletedRequest) (*RespondActivityTaskCompletedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondActivityTaskCompleted not implemented")
}
func (*UnimplementedWorkflowServiceServer) RespondActivityTaskCompletedById(ctx context.Context, req *RespondActivityTaskCompletedByIdRequest) (*RespondActivityTaskCompletedByIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondActivityTaskCompletedById not implemented")
}
func (*UnimplementedWorkflowServiceServer) RespondActivityTaskFailed(ctx context.Context, req *RespondActivityTaskFailedRequest) (*RespondActivityTaskFailedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondActivityTaskFailed not implemented")
}
func (*UnimplementedWorkflowServiceServer) RespondActivityTaskFailedById(ctx context.Context, req *RespondActivityTaskFailedByIdRequest) (*RespondActivityTaskFailedByIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondActivityTaskFailedById not implemented")
}
func (*UnimplementedWorkflowServiceServer) RespondActivityTaskCanceled(ctx context.Context, req *RespondActivityTaskCanceledRequest) (*RespondActivityTaskCanceledResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondActivityTaskCanceled not implemented")
}
func (*UnimplementedWorkflowServiceServer) RespondActivityTaskCanceledById(ctx context.Context, req *RespondActivityTaskCanceledByIdRequest) (*RespondActivityTaskCanceledByIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondActivityTaskCanceledById not implemented")
}
func (*UnimplementedWorkflowServiceServer) RequestCancelWorkflowExecution(ctx context.Context, req *RequestCancelWorkflowExecutionRequest) (*RequestCancelWorkflowExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestCancelWorkflowExecution not implemented")
}
func (*UnimplementedWorkflowServiceServer) SignalWorkflowExecution(ctx context.Context, req *SignalWorkflowExecutionRequest) (*SignalWorkflowExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignalWorkflowExecution not implemented")
}
func (*UnimplementedWorkflowServiceServer) SignalWithStartWorkflowExecution(ctx context.Context, req *SignalWithStartWorkflowExecutionRequest) (*SignalWithStartWorkflowExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignalWithStartWorkflowExecution not implemented")
}
func (*UnimplementedWorkflowServiceServer) ResetWorkflowExecution(ctx context.Context, req *ResetWorkflowExecutionRequest) (*ResetWorkflowExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetWorkflowExecution not implemented")
}
func (*UnimplementedWorkflowServiceServer) TerminateWorkflowExecution(ctx context.Context, req *TerminateWorkflowExecutionRequest) (*TerminateWorkflowExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TerminateWorkflowExecution not implemented")
}
func (*UnimplementedWorkflowServiceServer) DeleteWorkflowExecution(ctx context.Context, req *DeleteWorkflowExecutionRequest) (*DeleteWorkflowExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteWorkflowExecution not implemented")
}
func (*UnimplementedWorkflowServiceServer) ListOpenWorkflowExecutions(ctx context.Context, req *ListOpenWorkflowExecutionsRequest) (*ListOpenWorkflowExecutionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListOpenWorkflowExecutions not implemented")
}
func (*UnimplementedWorkflowServiceServer) ListClosedWorkflowExecutions(ctx context.Context, req *ListClosedWorkflowExecutionsRequest) (*ListClosedWorkflowExecutionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListClosedWorkflowExecutions not implemented")
}
func (*UnimplementedWorkflowServiceServer) ListWorkflowExecutions(ctx context.Context, req *ListWorkflowExecutionsRequest) (*ListWorkflowExecutionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListWorkflowExecutions not implemented")
}
func (*UnimplementedWorkflowServiceServer) ListArchivedWorkflowExecutions(ctx context.Context, req *ListArchivedWorkflowExecutionsRequest) (*ListArchivedWorkflowExecutionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListArchivedWorkflowExecutions not implemented")
}
func (*UnimplementedWorkflowServiceServer) ScanWorkflowExecutions(ctx context.Context, req *ScanWorkflowExecutionsRequest) (*ScanWorkflowExecutionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ScanWorkflowExecutions not implemented")
}
func (*UnimplementedWorkflowServiceServer) CountWorkflowExecutions(ctx context.Context, req *CountWorkflowExecutionsRequest) (*CountWorkflowExecutionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountWorkflowExecutions not implemented")
}
func (*UnimplementedWorkflowServiceServer) GetSearchAttributes(ctx context.Context, req *GetSearchAttributesRequest) (*GetSearchAttributesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSearchAttributes not implemented")
}
func (*UnimplementedWorkflowServiceServer) RespondQueryTaskCompleted(ctx context.Context, req *RespondQueryTaskCompletedRequest) (*RespondQueryTaskCompletedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondQueryTaskCompleted not implemented")
}
func (*UnimplementedWorkflowServiceServer) ResetStickyTaskQueue(ctx context.Context, req *ResetStickyTaskQueueRequest) (*ResetStickyTaskQueueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetStickyTaskQueue not implemented")
}
func (*UnimplementedWorkflowServiceServer) QueryWorkflow(ctx context.Context, req *QueryWorkflowRequest) (*QueryWorkflowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryWorkflow not implemented")
}
func (*UnimplementedWorkflowServiceServer) DescribeWorkflowExecution(ctx context.Context, req *DescribeWorkflowExecutionRequest) (*DescribeWorkflowExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeWorkflowExecution not implemented")
}
func (*UnimplementedWorkflowServiceServer) DescribeTaskQueue(ctx context.Context, req *DescribeTaskQueueRequest) (*DescribeTaskQueueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeTaskQueue not implemented")
}
func (*UnimplementedWorkflowServiceServer) GetClusterInfo(ctx context.Context, req *GetClusterInfoRequest) (*GetClusterInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterInfo not implemented")
}
func (*UnimplementedWorkflowServiceServer) GetSystemInfo(ctx context.Context, req *GetSystemInfoRequest) (*GetSystemInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSystemInfo not implemented")
}
func (*UnimplementedWorkflowServiceServer) ListTaskQueuePartitions(ctx context.Context, req *ListTaskQueuePartitionsRequest) (*ListTaskQueuePartitionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTaskQueuePartitions not implemented")
}
func (*UnimplementedWorkflowServiceServer) CreateSchedule(ctx context.Context, req *CreateScheduleRequest) (*CreateScheduleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSchedule not implemented")
}
func (*UnimplementedWorkflowServiceServer) DescribeSchedule(ctx context.Context, req *DescribeScheduleRequest) (*DescribeScheduleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeSchedule not implemented")
}
func (*UnimplementedWorkflowServiceServer) UpdateSchedule(ctx context.Context, req *UpdateScheduleRequest) (*UpdateScheduleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSchedule not implemented")
}
func (*UnimplementedWorkflowServiceServer) PatchSchedule(ctx context.Context, req *PatchScheduleRequest) (*PatchScheduleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PatchSchedule not implemented")
}
func (*UnimplementedWorkflowServiceServer) ListScheduleMatchingTimes(ctx context.Context, req *ListScheduleMatchingTimesRequest) (*ListScheduleMatchingTimesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListScheduleMatchingTimes not implemented")
}
func (*UnimplementedWorkflowServiceServer) DeleteSchedule(ctx context.Context, req *DeleteScheduleRequest) (*DeleteScheduleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSchedule not implemented")
}
func (*UnimplementedWorkflowServiceServer) ListSchedules(ctx context.Context, req *ListSchedulesRequest) (*ListSchedulesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSchedules not implemented")
}
func (*UnimplementedWorkflowServiceServer) UpdateWorkerBuildIdCompatibility(ctx context.Context, req *UpdateWorkerBuildIdCompatibilityRequest) (*UpdateWorkerBuildIdCompatibilityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateWorkerBuildIdCompatibility not implemented")
}
func (*UnimplementedWorkflowServiceServer) GetWorkerBuildIdCompatibility(ctx context.Context, req *GetWorkerBuildIdCompatibilityRequest) (*GetWorkerBuildIdCompatibilityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkerBuildIdCompatibility not implemented")
}
func (*UnimplementedWorkflowServiceServer) GetWorkerTaskReachability(ctx context.Context, req *GetWorkerTaskReachabilityRequest) (*GetWorkerTaskReachabilityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkerTaskReachability not implemented")
}
func (*UnimplementedWorkflowServiceServer) UpdateWorkflowExecution(ctx context.Context, req *UpdateWorkflowExecutionRequest) (*UpdateWorkflowExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateWorkflowExecution not implemented")
}
func (*UnimplementedWorkflowServiceServer) PollWorkflowExecutionUpdate(ctx context.Context, req *PollWorkflowExecutionUpdateRequest) (*PollWorkflowExecutionUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PollWorkflowExecutionUpdate not implemented")
}
func (*UnimplementedWorkflowServiceServer) StartBatchOperation(ctx context.Context, req *StartBatchOperationRequest) (*StartBatchOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartBatchOperation not implemented")
}
func (*UnimplementedWorkflowServiceServer) StopBatchOperation(ctx context.Context, req *StopBatchOperationRequest) (*StopBatchOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopBatchOperation not implemented")
}
func (*UnimplementedWorkflowServiceServer) DescribeBatchOperation(ctx context.Context, req *DescribeBatchOperationRequest) (*DescribeBatchOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeBatchOperation not implemented")
}
func (*UnimplementedWorkflowServiceServer) ListBatchOperations(ctx context.Context, req *ListBatchOperationsRequest) (*ListBatchOperationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBatchOperations not implemented")
}

func RegisterWorkflowServiceServer(s *grpc.Server, srv WorkflowServiceServer) {
	s.RegisterService(&_WorkflowService_serviceDesc, srv)
}

func _WorkflowService_RegisterNamespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterNamespaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RegisterNamespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/RegisterNamespace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RegisterNamespace(ctx, req.(*RegisterNamespaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_DescribeNamespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeNamespaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).DescribeNamespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/DescribeNamespace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).DescribeNamespace(ctx, req.(*DescribeNamespaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ListNamespaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNamespacesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ListNamespaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/ListNamespaces",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ListNamespaces(ctx, req.(*ListNamespacesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_UpdateNamespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateNamespaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).UpdateNamespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/UpdateNamespace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).UpdateNamespace(ctx, req.(*UpdateNamespaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_DeprecateNamespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeprecateNamespaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).DeprecateNamespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/DeprecateNamespace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).DeprecateNamespace(ctx, req.(*DeprecateNamespaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_StartWorkflowExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartWorkflowExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).StartWorkflowExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/StartWorkflowExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).StartWorkflowExecution(ctx, req.(*StartWorkflowExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_GetWorkflowExecutionHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWorkflowExecutionHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).GetWorkflowExecutionHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/GetWorkflowExecutionHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).GetWorkflowExecutionHistory(ctx, req.(*GetWorkflowExecutionHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_GetWorkflowExecutionHistoryReverse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWorkflowExecutionHistoryReverseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).GetWorkflowExecutionHistoryReverse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/GetWorkflowExecutionHistoryReverse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).GetWorkflowExecutionHistoryReverse(ctx, req.(*GetWorkflowExecutionHistoryReverseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_PollWorkflowTaskQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PollWorkflowTaskQueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).PollWorkflowTaskQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/PollWorkflowTaskQueue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).PollWorkflowTaskQueue(ctx, req.(*PollWorkflowTaskQueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RespondWorkflowTaskCompleted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondWorkflowTaskCompletedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RespondWorkflowTaskCompleted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/RespondWorkflowTaskCompleted",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RespondWorkflowTaskCompleted(ctx, req.(*RespondWorkflowTaskCompletedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RespondWorkflowTaskFailed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondWorkflowTaskFailedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RespondWorkflowTaskFailed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/RespondWorkflowTaskFailed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RespondWorkflowTaskFailed(ctx, req.(*RespondWorkflowTaskFailedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_PollActivityTaskQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PollActivityTaskQueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).PollActivityTaskQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/PollActivityTaskQueue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).PollActivityTaskQueue(ctx, req.(*PollActivityTaskQueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RecordActivityTaskHeartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordActivityTaskHeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RecordActivityTaskHeartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/RecordActivityTaskHeartbeat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RecordActivityTaskHeartbeat(ctx, req.(*RecordActivityTaskHeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RecordActivityTaskHeartbeatById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordActivityTaskHeartbeatByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RecordActivityTaskHeartbeatById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/RecordActivityTaskHeartbeatById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RecordActivityTaskHeartbeatById(ctx, req.(*RecordActivityTaskHeartbeatByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RespondActivityTaskCompleted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondActivityTaskCompletedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RespondActivityTaskCompleted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskCompleted",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RespondActivityTaskCompleted(ctx, req.(*RespondActivityTaskCompletedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RespondActivityTaskCompletedById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondActivityTaskCompletedByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RespondActivityTaskCompletedById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskCompletedById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RespondActivityTaskCompletedById(ctx, req.(*RespondActivityTaskCompletedByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RespondActivityTaskFailed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondActivityTaskFailedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RespondActivityTaskFailed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskFailed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RespondActivityTaskFailed(ctx, req.(*RespondActivityTaskFailedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RespondActivityTaskFailedById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondActivityTaskFailedByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RespondActivityTaskFailedById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskFailedById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RespondActivityTaskFailedById(ctx, req.(*RespondActivityTaskFailedByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RespondActivityTaskCanceled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondActivityTaskCanceledRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RespondActivityTaskCanceled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskCanceled",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RespondActivityTaskCanceled(ctx, req.(*RespondActivityTaskCanceledRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RespondActivityTaskCanceledById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondActivityTaskCanceledByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RespondActivityTaskCanceledById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskCanceledById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RespondActivityTaskCanceledById(ctx, req.(*RespondActivityTaskCanceledByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RequestCancelWorkflowExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestCancelWorkflowExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RequestCancelWorkflowExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/RequestCancelWorkflowExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RequestCancelWorkflowExecution(ctx, req.(*RequestCancelWorkflowExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_SignalWorkflowExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignalWorkflowExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).SignalWorkflowExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/SignalWorkflowExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).SignalWorkflowExecution(ctx, req.(*SignalWorkflowExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_SignalWithStartWorkflowExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignalWithStartWorkflowExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).SignalWithStartWorkflowExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/SignalWithStartWorkflowExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).SignalWithStartWorkflowExecution(ctx, req.(*SignalWithStartWorkflowExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ResetWorkflowExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetWorkflowExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ResetWorkflowExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/ResetWorkflowExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ResetWorkflowExecution(ctx, req.(*ResetWorkflowExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_TerminateWorkflowExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TerminateWorkflowExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).TerminateWorkflowExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/TerminateWorkflowExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).TerminateWorkflowExecution(ctx, req.(*TerminateWorkflowExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_DeleteWorkflowExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteWorkflowExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).DeleteWorkflowExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/DeleteWorkflowExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).DeleteWorkflowExecution(ctx, req.(*DeleteWorkflowExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ListOpenWorkflowExecutions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOpenWorkflowExecutionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ListOpenWorkflowExecutions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/ListOpenWorkflowExecutions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ListOpenWorkflowExecutions(ctx, req.(*ListOpenWorkflowExecutionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ListClosedWorkflowExecutions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListClosedWorkflowExecutionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ListClosedWorkflowExecutions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/ListClosedWorkflowExecutions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ListClosedWorkflowExecutions(ctx, req.(*ListClosedWorkflowExecutionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ListWorkflowExecutions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListWorkflowExecutionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ListWorkflowExecutions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/ListWorkflowExecutions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ListWorkflowExecutions(ctx, req.(*ListWorkflowExecutionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ListArchivedWorkflowExecutions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListArchivedWorkflowExecutionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ListArchivedWorkflowExecutions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/ListArchivedWorkflowExecutions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ListArchivedWorkflowExecutions(ctx, req.(*ListArchivedWorkflowExecutionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ScanWorkflowExecutions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScanWorkflowExecutionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ScanWorkflowExecutions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/ScanWorkflowExecutions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ScanWorkflowExecutions(ctx, req.(*ScanWorkflowExecutionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_CountWorkflowExecutions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountWorkflowExecutionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).CountWorkflowExecutions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/CountWorkflowExecutions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).CountWorkflowExecutions(ctx, req.(*CountWorkflowExecutionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_GetSearchAttributes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSearchAttributesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).GetSearchAttributes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/GetSearchAttributes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).GetSearchAttributes(ctx, req.(*GetSearchAttributesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RespondQueryTaskCompleted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondQueryTaskCompletedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RespondQueryTaskCompleted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/RespondQueryTaskCompleted",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RespondQueryTaskCompleted(ctx, req.(*RespondQueryTaskCompletedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ResetStickyTaskQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetStickyTaskQueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ResetStickyTaskQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/ResetStickyTaskQueue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ResetStickyTaskQueue(ctx, req.(*ResetStickyTaskQueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_QueryWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).QueryWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/QueryWorkflow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).QueryWorkflow(ctx, req.(*QueryWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_DescribeWorkflowExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeWorkflowExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).DescribeWorkflowExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/DescribeWorkflowExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).DescribeWorkflowExecution(ctx, req.(*DescribeWorkflowExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_DescribeTaskQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeTaskQueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).DescribeTaskQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/DescribeTaskQueue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).DescribeTaskQueue(ctx, req.(*DescribeTaskQueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_GetClusterInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClusterInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).GetClusterInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/GetClusterInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).GetClusterInfo(ctx, req.(*GetClusterInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_GetSystemInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSystemInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).GetSystemInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/GetSystemInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).GetSystemInfo(ctx, req.(*GetSystemInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ListTaskQueuePartitions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTaskQueuePartitionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ListTaskQueuePartitions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/ListTaskQueuePartitions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ListTaskQueuePartitions(ctx, req.(*ListTaskQueuePartitionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_CreateSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateScheduleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).CreateSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/CreateSchedule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).CreateSchedule(ctx, req.(*CreateScheduleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_DescribeSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeScheduleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).DescribeSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/DescribeSchedule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).DescribeSchedule(ctx, req.(*DescribeScheduleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_UpdateSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateScheduleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).UpdateSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/UpdateSchedule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).UpdateSchedule(ctx, req.(*UpdateScheduleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_PatchSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchScheduleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).PatchSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/PatchSchedule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).PatchSchedule(ctx, req.(*PatchScheduleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ListScheduleMatchingTimes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListScheduleMatchingTimesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ListScheduleMatchingTimes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/ListScheduleMatchingTimes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ListScheduleMatchingTimes(ctx, req.(*ListScheduleMatchingTimesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_DeleteSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteScheduleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).DeleteSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/DeleteSchedule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).DeleteSchedule(ctx, req.(*DeleteScheduleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ListSchedules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSchedulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ListSchedules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/ListSchedules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ListSchedules(ctx, req.(*ListSchedulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_UpdateWorkerBuildIdCompatibility_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateWorkerBuildIdCompatibilityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).UpdateWorkerBuildIdCompatibility(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/UpdateWorkerBuildIdCompatibility",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).UpdateWorkerBuildIdCompatibility(ctx, req.(*UpdateWorkerBuildIdCompatibilityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_GetWorkerBuildIdCompatibility_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWorkerBuildIdCompatibilityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).GetWorkerBuildIdCompatibility(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/GetWorkerBuildIdCompatibility",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).GetWorkerBuildIdCompatibility(ctx, req.(*GetWorkerBuildIdCompatibilityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_GetWorkerTaskReachability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWorkerTaskReachabilityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).GetWorkerTaskReachability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/GetWorkerTaskReachability",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).GetWorkerTaskReachability(ctx, req.(*GetWorkerTaskReachabilityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_UpdateWorkflowExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateWorkflowExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).UpdateWorkflowExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/UpdateWorkflowExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).UpdateWorkflowExecution(ctx, req.(*UpdateWorkflowExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_PollWorkflowExecutionUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PollWorkflowExecutionUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).PollWorkflowExecutionUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/PollWorkflowExecutionUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).PollWorkflowExecutionUpdate(ctx, req.(*PollWorkflowExecutionUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_StartBatchOperation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartBatchOperationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).StartBatchOperation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/StartBatchOperation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).StartBatchOperation(ctx, req.(*StartBatchOperationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_StopBatchOperation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopBatchOperationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).StopBatchOperation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/StopBatchOperation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).StopBatchOperation(ctx, req.(*StopBatchOperationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_DescribeBatchOperation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeBatchOperationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).DescribeBatchOperation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/DescribeBatchOperation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).DescribeBatchOperation(ctx, req.(*DescribeBatchOperationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ListBatchOperations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBatchOperationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ListBatchOperations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/ListBatchOperations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ListBatchOperations(ctx, req.(*ListBatchOperationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _WorkflowService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "temporal.api.workflowservice.v1.WorkflowService",
	HandlerType: (*WorkflowServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterNamespace",
			Handler:    _WorkflowService_RegisterNamespace_Handler,
		},
		{
			MethodName: "DescribeNamespace",
			Handler:    _WorkflowService_DescribeNamespace_Handler,
		},
		{
			MethodName: "ListNamespaces",
			Handler:    _WorkflowService_ListNamespaces_Handler,
		},
		{
			MethodName: "UpdateNamespace",
			Handler:    _WorkflowService_UpdateNamespace_Handler,
		},
		{
			MethodName: "DeprecateNamespace",
			Handler:    _WorkflowService_DeprecateNamespace_Handler,
		},
		{
			MethodName: "StartWorkflowExecution",
			Handler:    _WorkflowService_StartWorkflowExecution_Handler,
		},
		{
			MethodName: "GetWorkflowExecutionHistory",
			Handler:    _WorkflowService_GetWorkflowExecutionHistory_Handler,
		},
		{
			MethodName: "GetWorkflowExecutionHistoryReverse",
			Handler:    _WorkflowService_GetWorkflowExecutionHistoryReverse_Handler,
		},
		{
			MethodName: "PollWorkflowTaskQueue",
			Handler:    _WorkflowService_PollWorkflowTaskQueue_Handler,
		},
		{
			MethodName: "RespondWorkflowTaskCompleted",
			Handler:    _WorkflowService_RespondWorkflowTaskCompleted_Handler,
		},
		{
			MethodName: "RespondWorkflowTaskFailed",
			Handler:    _WorkflowService_RespondWorkflowTaskFailed_Handler,
		},
		{
			MethodName: "PollActivityTaskQueue",
			Handler:    _WorkflowService_PollActivityTaskQueue_Handler,
		},
		{
			MethodName: "RecordActivityTaskHeartbeat",
			Handler:    _WorkflowService_RecordActivityTaskHeartbeat_Handler,
		},
		{
			MethodName: "RecordActivityTaskHeartbeatById",
			Handler:    _WorkflowService_RecordActivityTaskHeartbeatById_Handler,
		},
		{
			MethodName: "RespondActivityTaskCompleted",
			Handler:    _WorkflowService_RespondActivityTaskCompleted_Handler,
		},
		{
			MethodName: "RespondActivityTaskCompletedById",
			Handler:    _WorkflowService_RespondActivityTaskCompletedById_Handler,
		},
		{
			MethodName: "RespondActivityTaskFailed",
			Handler:    _WorkflowService_RespondActivityTaskFailed_Handler,
		},
		{
			MethodName: "RespondActivityTaskFailedById",
			Handler:    _WorkflowService_RespondActivityTaskFailedById_Handler,
		},
		{
			MethodName: "RespondActivityTaskCanceled",
			Handler:    _WorkflowService_RespondActivityTaskCanceled_Handler,
		},
		{
			MethodName: "RespondActivityTaskCanceledById",
			Handler:    _WorkflowService_RespondActivityTaskCanceledById_Handler,
		},
		{
			MethodName: "RequestCancelWorkflowExecution",
			Handler:    _WorkflowService_RequestCancelWorkflowExecution_Handler,
		},
		{
			MethodName: "SignalWorkflowExecution",
			Handler:    _WorkflowService_SignalWorkflowExecution_Handler,
		},
		{
			MethodName: "SignalWithStartWorkflowExecution",
			Handler:    _WorkflowService_SignalWithStartWorkflowExecution_Handler,
		},
		{
			MethodName: "ResetWorkflowExecution",
			Handler:    _WorkflowService_ResetWorkflowExecution_Handler,
		},
		{
			MethodName: "TerminateWorkflowExecution",
			Handler:    _WorkflowService_TerminateWorkflowExecution_Handler,
		},
		{
			MethodName: "DeleteWorkflowExecution",
			Handler:    _WorkflowService_DeleteWorkflowExecution_Handler,
		},
		{
			MethodName: "ListOpenWorkflowExecutions",
			Handler:    _WorkflowService_ListOpenWorkflowExecutions_Handler,
		},
		{
			MethodName: "ListClosedWorkflowExecutions",
			Handler:    _WorkflowService_ListClosedWorkflowExecutions_Handler,
		},
		{
			MethodName: "ListWorkflowExecutions",
			Handler:    _WorkflowService_ListWorkflowExecutions_Handler,
		},
		{
			MethodName: "ListArchivedWorkflowExecutions",
			Handler:    _WorkflowService_ListArchivedWorkflowExecutions_Handler,
		},
		{
			MethodName: "ScanWorkflowExecutions",
			Handler:    _WorkflowService_ScanWorkflowExecutions_Handler,
		},
		{
			MethodName: "CountWorkflowExecutions",
			Handler:    _WorkflowService_CountWorkflowExecutions_Handler,
		},
		{
			MethodName: "GetSearchAttributes",
			Handler:    _WorkflowService_GetSearchAttributes_Handler,
		},
		{
			MethodName: "RespondQueryTaskCompleted",
			Handler:    _WorkflowService_RespondQueryTaskCompleted_Handler,
		},
		{
			MethodName: "ResetStickyTaskQueue",
			Handler:    _WorkflowService_ResetStickyTaskQueue_Handler,
		},
		{
			MethodName: "QueryWorkflow",
			Handler:    _WorkflowService_QueryWorkflow_Handler,
		},
		{
			MethodName: "DescribeWorkflowExecution",
			Handler:    _WorkflowService_DescribeWorkflowExecution_Handler,
		},
		{
			MethodName: "DescribeTaskQueue",
			Handler:    _WorkflowService_DescribeTaskQueue_Handler,
		},
		{
			MethodName: "GetClusterInfo",
			Handler:    _WorkflowService_GetClusterInfo_Handler,
		},
		{
			MethodName: "GetSystemInfo",
			Handler:    _WorkflowService_GetSystemInfo_Handler,
		},
		{
			MethodName: "ListTaskQueuePartitions",
			Handler:    _WorkflowService_ListTaskQueuePartitions_Handler,
		},
		{
			MethodName: "CreateSchedule",
			Handler:    _WorkflowService_CreateSchedule_Handler,
		},
		{
			MethodName: "DescribeSchedule",
			Handler:    _WorkflowService_DescribeSchedule_Handler,
		},
		{
			MethodName: "UpdateSchedule",
			Handler:    _WorkflowService_UpdateSchedule_Handler,
		},
		{
			MethodName: "PatchSchedule",
			Handler:    _WorkflowService_PatchSchedule_Handler,
		},
		{
			MethodName: "ListScheduleMatchingTimes",
			Handler:    _WorkflowService_ListScheduleMatchingTimes_Handler,
		},
		{
			MethodName: "DeleteSchedule",
			Handler:    _WorkflowService_DeleteSchedule_Handler,
		},
		{
			MethodName: "ListSchedules",
			Handler:    _WorkflowService_ListSchedules_Handler,
		},
		{
			MethodName: "UpdateWorkerBuildIdCompatibility",
			Handler:    _WorkflowService_UpdateWorkerBuildIdCompatibility_Handler,
		},
		{
			MethodName: "GetWorkerBuildIdCompatibility",
			Handler:    _WorkflowService_GetWorkerBuildIdCompatibility_Handler,
		},
		{
			MethodName: "GetWorkerTaskReachability",
			Handler:    _WorkflowService_GetWorkerTaskReachability_Handler,
		},
		{
			MethodName: "UpdateWorkflowExecution",
			Handler:    _WorkflowService_UpdateWorkflowExecution_Handler,
		},
		{
			MethodName: "PollWorkflowExecutionUpdate",
			Handler:    _WorkflowService_PollWorkflowExecutionUpdate_Handler,
		},
		{
			MethodName: "StartBatchOperation",
			Handler:    _WorkflowService_StartBatchOperation_Handler,
		},
		{
			MethodName: "StopBatchOperation",
			Handler:    _WorkflowService_StopBatchOperation_Handler,
		},
		{
			MethodName: "DescribeBatchOperation",
			Handler:    _WorkflowService_DescribeBatchOperation_Handler,
		},
		{
			MethodName: "ListBatchOperations",
			Handler:    _WorkflowService_ListBatchOperations_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "temporal/api/workflowservice/v1/service.proto",
}
