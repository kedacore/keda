// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// plugins:
// - protoc-gen-go-grpc
// - protoc
// source: temporal/api/workflowservice/v1/service.proto

package workflowservice

import (
	context "context"

	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	WorkflowService_RegisterNamespace_FullMethodName                     = "/temporal.api.workflowservice.v1.WorkflowService/RegisterNamespace"
	WorkflowService_DescribeNamespace_FullMethodName                     = "/temporal.api.workflowservice.v1.WorkflowService/DescribeNamespace"
	WorkflowService_ListNamespaces_FullMethodName                        = "/temporal.api.workflowservice.v1.WorkflowService/ListNamespaces"
	WorkflowService_UpdateNamespace_FullMethodName                       = "/temporal.api.workflowservice.v1.WorkflowService/UpdateNamespace"
	WorkflowService_DeprecateNamespace_FullMethodName                    = "/temporal.api.workflowservice.v1.WorkflowService/DeprecateNamespace"
	WorkflowService_StartWorkflowExecution_FullMethodName                = "/temporal.api.workflowservice.v1.WorkflowService/StartWorkflowExecution"
	WorkflowService_ExecuteMultiOperation_FullMethodName                 = "/temporal.api.workflowservice.v1.WorkflowService/ExecuteMultiOperation"
	WorkflowService_GetWorkflowExecutionHistory_FullMethodName           = "/temporal.api.workflowservice.v1.WorkflowService/GetWorkflowExecutionHistory"
	WorkflowService_GetWorkflowExecutionHistoryReverse_FullMethodName    = "/temporal.api.workflowservice.v1.WorkflowService/GetWorkflowExecutionHistoryReverse"
	WorkflowService_PollWorkflowTaskQueue_FullMethodName                 = "/temporal.api.workflowservice.v1.WorkflowService/PollWorkflowTaskQueue"
	WorkflowService_RespondWorkflowTaskCompleted_FullMethodName          = "/temporal.api.workflowservice.v1.WorkflowService/RespondWorkflowTaskCompleted"
	WorkflowService_RespondWorkflowTaskFailed_FullMethodName             = "/temporal.api.workflowservice.v1.WorkflowService/RespondWorkflowTaskFailed"
	WorkflowService_PollActivityTaskQueue_FullMethodName                 = "/temporal.api.workflowservice.v1.WorkflowService/PollActivityTaskQueue"
	WorkflowService_RecordActivityTaskHeartbeat_FullMethodName           = "/temporal.api.workflowservice.v1.WorkflowService/RecordActivityTaskHeartbeat"
	WorkflowService_RecordActivityTaskHeartbeatById_FullMethodName       = "/temporal.api.workflowservice.v1.WorkflowService/RecordActivityTaskHeartbeatById"
	WorkflowService_RespondActivityTaskCompleted_FullMethodName          = "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskCompleted"
	WorkflowService_RespondActivityTaskCompletedById_FullMethodName      = "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskCompletedById"
	WorkflowService_RespondActivityTaskFailed_FullMethodName             = "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskFailed"
	WorkflowService_RespondActivityTaskFailedById_FullMethodName         = "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskFailedById"
	WorkflowService_RespondActivityTaskCanceled_FullMethodName           = "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskCanceled"
	WorkflowService_RespondActivityTaskCanceledById_FullMethodName       = "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskCanceledById"
	WorkflowService_RequestCancelWorkflowExecution_FullMethodName        = "/temporal.api.workflowservice.v1.WorkflowService/RequestCancelWorkflowExecution"
	WorkflowService_SignalWorkflowExecution_FullMethodName               = "/temporal.api.workflowservice.v1.WorkflowService/SignalWorkflowExecution"
	WorkflowService_SignalWithStartWorkflowExecution_FullMethodName      = "/temporal.api.workflowservice.v1.WorkflowService/SignalWithStartWorkflowExecution"
	WorkflowService_ResetWorkflowExecution_FullMethodName                = "/temporal.api.workflowservice.v1.WorkflowService/ResetWorkflowExecution"
	WorkflowService_TerminateWorkflowExecution_FullMethodName            = "/temporal.api.workflowservice.v1.WorkflowService/TerminateWorkflowExecution"
	WorkflowService_DeleteWorkflowExecution_FullMethodName               = "/temporal.api.workflowservice.v1.WorkflowService/DeleteWorkflowExecution"
	WorkflowService_ListOpenWorkflowExecutions_FullMethodName            = "/temporal.api.workflowservice.v1.WorkflowService/ListOpenWorkflowExecutions"
	WorkflowService_ListClosedWorkflowExecutions_FullMethodName          = "/temporal.api.workflowservice.v1.WorkflowService/ListClosedWorkflowExecutions"
	WorkflowService_ListWorkflowExecutions_FullMethodName                = "/temporal.api.workflowservice.v1.WorkflowService/ListWorkflowExecutions"
	WorkflowService_ListArchivedWorkflowExecutions_FullMethodName        = "/temporal.api.workflowservice.v1.WorkflowService/ListArchivedWorkflowExecutions"
	WorkflowService_ScanWorkflowExecutions_FullMethodName                = "/temporal.api.workflowservice.v1.WorkflowService/ScanWorkflowExecutions"
	WorkflowService_CountWorkflowExecutions_FullMethodName               = "/temporal.api.workflowservice.v1.WorkflowService/CountWorkflowExecutions"
	WorkflowService_GetSearchAttributes_FullMethodName                   = "/temporal.api.workflowservice.v1.WorkflowService/GetSearchAttributes"
	WorkflowService_RespondQueryTaskCompleted_FullMethodName             = "/temporal.api.workflowservice.v1.WorkflowService/RespondQueryTaskCompleted"
	WorkflowService_ResetStickyTaskQueue_FullMethodName                  = "/temporal.api.workflowservice.v1.WorkflowService/ResetStickyTaskQueue"
	WorkflowService_ShutdownWorker_FullMethodName                        = "/temporal.api.workflowservice.v1.WorkflowService/ShutdownWorker"
	WorkflowService_QueryWorkflow_FullMethodName                         = "/temporal.api.workflowservice.v1.WorkflowService/QueryWorkflow"
	WorkflowService_DescribeWorkflowExecution_FullMethodName             = "/temporal.api.workflowservice.v1.WorkflowService/DescribeWorkflowExecution"
	WorkflowService_DescribeTaskQueue_FullMethodName                     = "/temporal.api.workflowservice.v1.WorkflowService/DescribeTaskQueue"
	WorkflowService_GetClusterInfo_FullMethodName                        = "/temporal.api.workflowservice.v1.WorkflowService/GetClusterInfo"
	WorkflowService_GetSystemInfo_FullMethodName                         = "/temporal.api.workflowservice.v1.WorkflowService/GetSystemInfo"
	WorkflowService_ListTaskQueuePartitions_FullMethodName               = "/temporal.api.workflowservice.v1.WorkflowService/ListTaskQueuePartitions"
	WorkflowService_CreateSchedule_FullMethodName                        = "/temporal.api.workflowservice.v1.WorkflowService/CreateSchedule"
	WorkflowService_DescribeSchedule_FullMethodName                      = "/temporal.api.workflowservice.v1.WorkflowService/DescribeSchedule"
	WorkflowService_UpdateSchedule_FullMethodName                        = "/temporal.api.workflowservice.v1.WorkflowService/UpdateSchedule"
	WorkflowService_PatchSchedule_FullMethodName                         = "/temporal.api.workflowservice.v1.WorkflowService/PatchSchedule"
	WorkflowService_ListScheduleMatchingTimes_FullMethodName             = "/temporal.api.workflowservice.v1.WorkflowService/ListScheduleMatchingTimes"
	WorkflowService_DeleteSchedule_FullMethodName                        = "/temporal.api.workflowservice.v1.WorkflowService/DeleteSchedule"
	WorkflowService_ListSchedules_FullMethodName                         = "/temporal.api.workflowservice.v1.WorkflowService/ListSchedules"
	WorkflowService_UpdateWorkerBuildIdCompatibility_FullMethodName      = "/temporal.api.workflowservice.v1.WorkflowService/UpdateWorkerBuildIdCompatibility"
	WorkflowService_GetWorkerBuildIdCompatibility_FullMethodName         = "/temporal.api.workflowservice.v1.WorkflowService/GetWorkerBuildIdCompatibility"
	WorkflowService_UpdateWorkerVersioningRules_FullMethodName           = "/temporal.api.workflowservice.v1.WorkflowService/UpdateWorkerVersioningRules"
	WorkflowService_GetWorkerVersioningRules_FullMethodName              = "/temporal.api.workflowservice.v1.WorkflowService/GetWorkerVersioningRules"
	WorkflowService_GetWorkerTaskReachability_FullMethodName             = "/temporal.api.workflowservice.v1.WorkflowService/GetWorkerTaskReachability"
	WorkflowService_DescribeDeployment_FullMethodName                    = "/temporal.api.workflowservice.v1.WorkflowService/DescribeDeployment"
	WorkflowService_DescribeWorkerDeploymentVersion_FullMethodName       = "/temporal.api.workflowservice.v1.WorkflowService/DescribeWorkerDeploymentVersion"
	WorkflowService_ListDeployments_FullMethodName                       = "/temporal.api.workflowservice.v1.WorkflowService/ListDeployments"
	WorkflowService_GetDeploymentReachability_FullMethodName             = "/temporal.api.workflowservice.v1.WorkflowService/GetDeploymentReachability"
	WorkflowService_GetCurrentDeployment_FullMethodName                  = "/temporal.api.workflowservice.v1.WorkflowService/GetCurrentDeployment"
	WorkflowService_SetCurrentDeployment_FullMethodName                  = "/temporal.api.workflowservice.v1.WorkflowService/SetCurrentDeployment"
	WorkflowService_SetWorkerDeploymentCurrentVersion_FullMethodName     = "/temporal.api.workflowservice.v1.WorkflowService/SetWorkerDeploymentCurrentVersion"
	WorkflowService_DescribeWorkerDeployment_FullMethodName              = "/temporal.api.workflowservice.v1.WorkflowService/DescribeWorkerDeployment"
	WorkflowService_DeleteWorkerDeployment_FullMethodName                = "/temporal.api.workflowservice.v1.WorkflowService/DeleteWorkerDeployment"
	WorkflowService_DeleteWorkerDeploymentVersion_FullMethodName         = "/temporal.api.workflowservice.v1.WorkflowService/DeleteWorkerDeploymentVersion"
	WorkflowService_SetWorkerDeploymentRampingVersion_FullMethodName     = "/temporal.api.workflowservice.v1.WorkflowService/SetWorkerDeploymentRampingVersion"
	WorkflowService_ListWorkerDeployments_FullMethodName                 = "/temporal.api.workflowservice.v1.WorkflowService/ListWorkerDeployments"
	WorkflowService_UpdateWorkerDeploymentVersionMetadata_FullMethodName = "/temporal.api.workflowservice.v1.WorkflowService/UpdateWorkerDeploymentVersionMetadata"
	WorkflowService_UpdateWorkflowExecution_FullMethodName               = "/temporal.api.workflowservice.v1.WorkflowService/UpdateWorkflowExecution"
	WorkflowService_PollWorkflowExecutionUpdate_FullMethodName           = "/temporal.api.workflowservice.v1.WorkflowService/PollWorkflowExecutionUpdate"
	WorkflowService_StartBatchOperation_FullMethodName                   = "/temporal.api.workflowservice.v1.WorkflowService/StartBatchOperation"
	WorkflowService_StopBatchOperation_FullMethodName                    = "/temporal.api.workflowservice.v1.WorkflowService/StopBatchOperation"
	WorkflowService_DescribeBatchOperation_FullMethodName                = "/temporal.api.workflowservice.v1.WorkflowService/DescribeBatchOperation"
	WorkflowService_ListBatchOperations_FullMethodName                   = "/temporal.api.workflowservice.v1.WorkflowService/ListBatchOperations"
	WorkflowService_PollNexusTaskQueue_FullMethodName                    = "/temporal.api.workflowservice.v1.WorkflowService/PollNexusTaskQueue"
	WorkflowService_RespondNexusTaskCompleted_FullMethodName             = "/temporal.api.workflowservice.v1.WorkflowService/RespondNexusTaskCompleted"
	WorkflowService_RespondNexusTaskFailed_FullMethodName                = "/temporal.api.workflowservice.v1.WorkflowService/RespondNexusTaskFailed"
	WorkflowService_UpdateActivityOptions_FullMethodName                 = "/temporal.api.workflowservice.v1.WorkflowService/UpdateActivityOptions"
	WorkflowService_UpdateWorkflowExecutionOptions_FullMethodName        = "/temporal.api.workflowservice.v1.WorkflowService/UpdateWorkflowExecutionOptions"
	WorkflowService_PauseActivity_FullMethodName                         = "/temporal.api.workflowservice.v1.WorkflowService/PauseActivity"
	WorkflowService_UnpauseActivity_FullMethodName                       = "/temporal.api.workflowservice.v1.WorkflowService/UnpauseActivity"
	WorkflowService_ResetActivity_FullMethodName                         = "/temporal.api.workflowservice.v1.WorkflowService/ResetActivity"
	WorkflowService_CreateWorkflowRule_FullMethodName                    = "/temporal.api.workflowservice.v1.WorkflowService/CreateWorkflowRule"
	WorkflowService_DescribeWorkflowRule_FullMethodName                  = "/temporal.api.workflowservice.v1.WorkflowService/DescribeWorkflowRule"
	WorkflowService_DeleteWorkflowRule_FullMethodName                    = "/temporal.api.workflowservice.v1.WorkflowService/DeleteWorkflowRule"
	WorkflowService_ListWorkflowRules_FullMethodName                     = "/temporal.api.workflowservice.v1.WorkflowService/ListWorkflowRules"
	WorkflowService_TriggerWorkflowRule_FullMethodName                   = "/temporal.api.workflowservice.v1.WorkflowService/TriggerWorkflowRule"
	WorkflowService_RecordWorkerHeartbeat_FullMethodName                 = "/temporal.api.workflowservice.v1.WorkflowService/RecordWorkerHeartbeat"
	WorkflowService_ListWorkers_FullMethodName                           = "/temporal.api.workflowservice.v1.WorkflowService/ListWorkers"
	WorkflowService_UpdateTaskQueueConfig_FullMethodName                 = "/temporal.api.workflowservice.v1.WorkflowService/UpdateTaskQueueConfig"
	WorkflowService_FetchWorkerConfig_FullMethodName                     = "/temporal.api.workflowservice.v1.WorkflowService/FetchWorkerConfig"
	WorkflowService_UpdateWorkerConfig_FullMethodName                    = "/temporal.api.workflowservice.v1.WorkflowService/UpdateWorkerConfig"
)

// WorkflowServiceClient is the client API for WorkflowService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// WorkflowService API defines how Temporal SDKs and other clients interact with the Temporal server
// to create and interact with workflows and activities.
//
// Users are expected to call `StartWorkflowExecution` to create a new workflow execution.
//
// To drive workflows, a worker using a Temporal SDK must exist which regularly polls for workflow
// and activity tasks from the service. For each workflow task, the sdk must process the
// (incremental or complete) event history and respond back with any newly generated commands.
//
// For each activity task, the worker is expected to execute the user's code which implements that
// activity, responding with completion or failure.
type WorkflowServiceClient interface {
	// RegisterNamespace creates a new namespace which can be used as a container for all resources.
	//
	// A Namespace is a top level entity within Temporal, and is used as a container for resources
	// like workflow executions, task queues, etc. A Namespace acts as a sandbox and provides
	// isolation for all resources within the namespace. All resources belongs to exactly one
	// namespace.
	RegisterNamespace(ctx context.Context, in *RegisterNamespaceRequest, opts ...grpc.CallOption) (*RegisterNamespaceResponse, error)
	// DescribeNamespace returns the information and configuration for a registered namespace.
	DescribeNamespace(ctx context.Context, in *DescribeNamespaceRequest, opts ...grpc.CallOption) (*DescribeNamespaceResponse, error)
	// ListNamespaces returns the information and configuration for all namespaces.
	ListNamespaces(ctx context.Context, in *ListNamespacesRequest, opts ...grpc.CallOption) (*ListNamespacesResponse, error)
	// UpdateNamespace is used to update the information and configuration of a registered
	// namespace.
	UpdateNamespace(ctx context.Context, in *UpdateNamespaceRequest, opts ...grpc.CallOption) (*UpdateNamespaceResponse, error)
	// DeprecateNamespace is used to update the state of a registered namespace to DEPRECATED.
	//
	// Once the namespace is deprecated it cannot be used to start new workflow executions. Existing
	// workflow executions will continue to run on deprecated namespaces.
	// Deprecated.
	//
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: Deprecated --)
	DeprecateNamespace(ctx context.Context, in *DeprecateNamespaceRequest, opts ...grpc.CallOption) (*DeprecateNamespaceResponse, error)
	// StartWorkflowExecution starts a new workflow execution.
	//
	// It will create the execution with a `WORKFLOW_EXECUTION_STARTED` event in its history and
	// also schedule the first workflow task. Returns `WorkflowExecutionAlreadyStarted`, if an
	// instance already exists with same workflow id.
	StartWorkflowExecution(ctx context.Context, in *StartWorkflowExecutionRequest, opts ...grpc.CallOption) (*StartWorkflowExecutionResponse, error)
	// ExecuteMultiOperation executes multiple operations within a single workflow.
	//
	// Operations are started atomically, meaning if *any* operation fails to be started, none are,
	// and the request fails. Upon start, the API returns only when *all* operations have a response.
	//
	// Upon failure, it returns `MultiOperationExecutionFailure` where the status code
	// equals the status code of the *first* operation that failed to be started.
	//
	// NOTE: Experimental API.
	ExecuteMultiOperation(ctx context.Context, in *ExecuteMultiOperationRequest, opts ...grpc.CallOption) (*ExecuteMultiOperationResponse, error)
	// GetWorkflowExecutionHistory returns the history of specified workflow execution. Fails with
	// `NotFound` if the specified workflow execution is unknown to the service.
	GetWorkflowExecutionHistory(ctx context.Context, in *GetWorkflowExecutionHistoryRequest, opts ...grpc.CallOption) (*GetWorkflowExecutionHistoryResponse, error)
	// GetWorkflowExecutionHistoryReverse returns the history of specified workflow execution in reverse
	// order (starting from last event). Fails with`NotFound` if the specified workflow execution is
	// unknown to the service.
	GetWorkflowExecutionHistoryReverse(ctx context.Context, in *GetWorkflowExecutionHistoryReverseRequest, opts ...grpc.CallOption) (*GetWorkflowExecutionHistoryReverseResponse, error)
	// PollWorkflowTaskQueue is called by workers to make progress on workflows.
	//
	// A WorkflowTask is dispatched to callers for active workflow executions with pending workflow
	// tasks. The worker is expected to call `RespondWorkflowTaskCompleted` when it is done
	// processing the task. The service will create a `WorkflowTaskStarted` event in the history for
	// this task before handing it to the worker.
	//
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: We do not expose worker API to HTTP. --)
	PollWorkflowTaskQueue(ctx context.Context, in *PollWorkflowTaskQueueRequest, opts ...grpc.CallOption) (*PollWorkflowTaskQueueResponse, error)
	// RespondWorkflowTaskCompleted is called by workers to successfully complete workflow tasks
	// they received from `PollWorkflowTaskQueue`.
	//
	// Completing a WorkflowTask will write a `WORKFLOW_TASK_COMPLETED` event to the workflow's
	// history, along with events corresponding to whatever commands the SDK generated while
	// executing the task (ex timer started, activity task scheduled, etc).
	//
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: We do not expose worker API to HTTP. --)
	RespondWorkflowTaskCompleted(ctx context.Context, in *RespondWorkflowTaskCompletedRequest, opts ...grpc.CallOption) (*RespondWorkflowTaskCompletedResponse, error)
	// RespondWorkflowTaskFailed is called by workers to indicate the processing of a workflow task
	// failed.
	//
	// This results in a `WORKFLOW_TASK_FAILED` event written to the history, and a new workflow
	// task will be scheduled. This API can be used to report unhandled failures resulting from
	// applying the workflow task.
	//
	// Temporal will only append first WorkflowTaskFailed event to the history of workflow execution
	// for consecutive failures.
	//
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: We do not expose worker API to HTTP. --)
	RespondWorkflowTaskFailed(ctx context.Context, in *RespondWorkflowTaskFailedRequest, opts ...grpc.CallOption) (*RespondWorkflowTaskFailedResponse, error)
	// PollActivityTaskQueue is called by workers to process activity tasks from a specific task
	// queue.
	//
	// The worker is expected to call one of the `RespondActivityTaskXXX` methods when it is done
	// processing the task.
	//
	// An activity task is dispatched whenever a `SCHEDULE_ACTIVITY_TASK` command is produced during
	// workflow execution. An in memory `ACTIVITY_TASK_STARTED` event is written to mutable state
	// before the task is dispatched to the worker. The started event, and the final event
	// (`ACTIVITY_TASK_COMPLETED` / `ACTIVITY_TASK_FAILED` / `ACTIVITY_TASK_TIMED_OUT`) will both be
	// written permanently to Workflow execution history when Activity is finished. This is done to
	// avoid writing many events in the case of a failure/retry loop.
	//
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: We do not expose worker API to HTTP. --)
	PollActivityTaskQueue(ctx context.Context, in *PollActivityTaskQueueRequest, opts ...grpc.CallOption) (*PollActivityTaskQueueResponse, error)
	// RecordActivityTaskHeartbeat is optionally called by workers while they execute activities.
	//
	// If worker fails to heartbeat within the `heartbeat_timeout` interval for the activity task,
	// then it will be marked as timed out and an `ACTIVITY_TASK_TIMED_OUT` event will be written to
	// the workflow history. Calling `RecordActivityTaskHeartbeat` will fail with `NotFound` in
	// such situations, in that event, the SDK should request cancellation of the activity.
	RecordActivityTaskHeartbeat(ctx context.Context, in *RecordActivityTaskHeartbeatRequest, opts ...grpc.CallOption) (*RecordActivityTaskHeartbeatResponse, error)
	// See `RecordActivityTaskHeartbeat`. This version allows clients to record heartbeats by
	// namespace/workflow id/activity id instead of task token.
	//
	// (-- api-linter: core::0136::prepositions=disabled
	//
	//	aip.dev/not-precedent: "By" is used to indicate request type. --)
	RecordActivityTaskHeartbeatById(ctx context.Context, in *RecordActivityTaskHeartbeatByIdRequest, opts ...grpc.CallOption) (*RecordActivityTaskHeartbeatByIdResponse, error)
	// RespondActivityTaskCompleted is called by workers when they successfully complete an activity
	// task.
	//
	// This results in a new `ACTIVITY_TASK_COMPLETED` event being written to the workflow history
	// and a new workflow task created for the workflow. Fails with `NotFound` if the task token is
	// no longer valid due to activity timeout, already being completed, or never having existed.
	RespondActivityTaskCompleted(ctx context.Context, in *RespondActivityTaskCompletedRequest, opts ...grpc.CallOption) (*RespondActivityTaskCompletedResponse, error)
	// See `RecordActivityTaskCompleted`. This version allows clients to record completions by
	// namespace/workflow id/activity id instead of task token.
	//
	// (-- api-linter: core::0136::prepositions=disabled
	//
	//	aip.dev/not-precedent: "By" is used to indicate request type. --)
	RespondActivityTaskCompletedById(ctx context.Context, in *RespondActivityTaskCompletedByIdRequest, opts ...grpc.CallOption) (*RespondActivityTaskCompletedByIdResponse, error)
	// RespondActivityTaskFailed is called by workers when processing an activity task fails.
	//
	// This results in a new `ACTIVITY_TASK_FAILED` event being written to the workflow history and
	// a new workflow task created for the workflow. Fails with `NotFound` if the task token is no
	// longer valid due to activity timeout, already being completed, or never having existed.
	RespondActivityTaskFailed(ctx context.Context, in *RespondActivityTaskFailedRequest, opts ...grpc.CallOption) (*RespondActivityTaskFailedResponse, error)
	// See `RecordActivityTaskFailed`. This version allows clients to record failures by
	// namespace/workflow id/activity id instead of task token.
	//
	// (-- api-linter: core::0136::prepositions=disabled
	//
	//	aip.dev/not-precedent: "By" is used to indicate request type. --)
	RespondActivityTaskFailedById(ctx context.Context, in *RespondActivityTaskFailedByIdRequest, opts ...grpc.CallOption) (*RespondActivityTaskFailedByIdResponse, error)
	// RespondActivityTaskFailed is called by workers when processing an activity task fails.
	//
	// This results in a new `ACTIVITY_TASK_CANCELED` event being written to the workflow history
	// and a new workflow task created for the workflow. Fails with `NotFound` if the task token is
	// no longer valid due to activity timeout, already being completed, or never having existed.
	RespondActivityTaskCanceled(ctx context.Context, in *RespondActivityTaskCanceledRequest, opts ...grpc.CallOption) (*RespondActivityTaskCanceledResponse, error)
	// See `RecordActivityTaskCanceled`. This version allows clients to record failures by
	// namespace/workflow id/activity id instead of task token.
	//
	// (-- api-linter: core::0136::prepositions=disabled
	//
	//	aip.dev/not-precedent: "By" is used to indicate request type. --)
	RespondActivityTaskCanceledById(ctx context.Context, in *RespondActivityTaskCanceledByIdRequest, opts ...grpc.CallOption) (*RespondActivityTaskCanceledByIdResponse, error)
	// RequestCancelWorkflowExecution is called by workers when they want to request cancellation of
	// a workflow execution.
	//
	// This results in a new `WORKFLOW_EXECUTION_CANCEL_REQUESTED` event being written to the
	// workflow history and a new workflow task created for the workflow. It returns success if the requested
	// workflow is already closed. It fails with 'NotFound' if the requested workflow doesn't exist.
	RequestCancelWorkflowExecution(ctx context.Context, in *RequestCancelWorkflowExecutionRequest, opts ...grpc.CallOption) (*RequestCancelWorkflowExecutionResponse, error)
	// SignalWorkflowExecution is used to send a signal to a running workflow execution.
	//
	// This results in a `WORKFLOW_EXECUTION_SIGNALED` event recorded in the history and a workflow
	// task being created for the execution.
	SignalWorkflowExecution(ctx context.Context, in *SignalWorkflowExecutionRequest, opts ...grpc.CallOption) (*SignalWorkflowExecutionResponse, error)
	// SignalWithStartWorkflowExecution is used to ensure a signal is sent to a workflow, even if
	// it isn't yet started.
	//
	// If the workflow is running, a `WORKFLOW_EXECUTION_SIGNALED` event is recorded in the history
	// and a workflow task is generated.
	//
	// If the workflow is not running or not found, then the workflow is created with
	// `WORKFLOW_EXECUTION_STARTED` and `WORKFLOW_EXECUTION_SIGNALED` events in its history, and a
	// workflow task is generated.
	//
	// (-- api-linter: core::0136::prepositions=disabled
	//
	//	aip.dev/not-precedent: "With" is used to indicate combined operation. --)
	SignalWithStartWorkflowExecution(ctx context.Context, in *SignalWithStartWorkflowExecutionRequest, opts ...grpc.CallOption) (*SignalWithStartWorkflowExecutionResponse, error)
	// ResetWorkflowExecution will reset an existing workflow execution to a specified
	// `WORKFLOW_TASK_COMPLETED` event (exclusive). It will immediately terminate the current
	// execution instance.
	// TODO: Does exclusive here mean *just* the completed event, or also WFT started? Otherwise the task is doomed to time out?
	ResetWorkflowExecution(ctx context.Context, in *ResetWorkflowExecutionRequest, opts ...grpc.CallOption) (*ResetWorkflowExecutionResponse, error)
	// TerminateWorkflowExecution terminates an existing workflow execution by recording a
	// `WORKFLOW_EXECUTION_TERMINATED` event in the history and immediately terminating the
	// execution instance.
	TerminateWorkflowExecution(ctx context.Context, in *TerminateWorkflowExecutionRequest, opts ...grpc.CallOption) (*TerminateWorkflowExecutionResponse, error)
	// DeleteWorkflowExecution asynchronously deletes a specific Workflow Execution (when
	// WorkflowExecution.run_id is provided) or the latest Workflow Execution (when
	// WorkflowExecution.run_id is not provided). If the Workflow Execution is Running, it will be
	// terminated before deletion.
	//
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: Workflow deletion not exposed to HTTP, users should use cancel or terminate. --)
	DeleteWorkflowExecution(ctx context.Context, in *DeleteWorkflowExecutionRequest, opts ...grpc.CallOption) (*DeleteWorkflowExecutionResponse, error)
	// ListOpenWorkflowExecutions is a visibility API to list the open executions in a specific namespace.
	//
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: HTTP users should use ListWorkflowExecutions instead. --)
	ListOpenWorkflowExecutions(ctx context.Context, in *ListOpenWorkflowExecutionsRequest, opts ...grpc.CallOption) (*ListOpenWorkflowExecutionsResponse, error)
	// ListClosedWorkflowExecutions is a visibility API to list the closed executions in a specific namespace.
	//
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: HTTP users should use ListWorkflowExecutions instead. --)
	ListClosedWorkflowExecutions(ctx context.Context, in *ListClosedWorkflowExecutionsRequest, opts ...grpc.CallOption) (*ListClosedWorkflowExecutionsResponse, error)
	// ListWorkflowExecutions is a visibility API to list workflow executions in a specific namespace.
	ListWorkflowExecutions(ctx context.Context, in *ListWorkflowExecutionsRequest, opts ...grpc.CallOption) (*ListWorkflowExecutionsResponse, error)
	// ListArchivedWorkflowExecutions is a visibility API to list archived workflow executions in a specific namespace.
	ListArchivedWorkflowExecutions(ctx context.Context, in *ListArchivedWorkflowExecutionsRequest, opts ...grpc.CallOption) (*ListArchivedWorkflowExecutionsResponse, error)
	// ScanWorkflowExecutions is a visibility API to list large amount of workflow executions in a specific namespace without order.
	//
	// Deprecated: Replaced with `ListWorkflowExecutions`.
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: HTTP users should use ListWorkflowExecutions instead. --)
	ScanWorkflowExecutions(ctx context.Context, in *ScanWorkflowExecutionsRequest, opts ...grpc.CallOption) (*ScanWorkflowExecutionsResponse, error)
	// CountWorkflowExecutions is a visibility API to count of workflow executions in a specific namespace.
	CountWorkflowExecutions(ctx context.Context, in *CountWorkflowExecutionsRequest, opts ...grpc.CallOption) (*CountWorkflowExecutionsResponse, error)
	// GetSearchAttributes is a visibility API to get all legal keys that could be used in list APIs
	//
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: We do not expose this search attribute API to HTTP (but may expose on OperatorService). --)
	GetSearchAttributes(ctx context.Context, in *GetSearchAttributesRequest, opts ...grpc.CallOption) (*GetSearchAttributesResponse, error)
	// RespondQueryTaskCompleted is called by workers to complete queries which were delivered on
	// the `query` (not `queries`) field of a `PollWorkflowTaskQueueResponse`.
	//
	// Completing the query will unblock the corresponding client call to `QueryWorkflow` and return
	// the query result a response.
	//
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: We do not expose worker API to HTTP. --)
	RespondQueryTaskCompleted(ctx context.Context, in *RespondQueryTaskCompletedRequest, opts ...grpc.CallOption) (*RespondQueryTaskCompletedResponse, error)
	// ResetStickyTaskQueue resets the sticky task queue related information in the mutable state of
	// a given workflow. This is prudent for workers to perform if a workflow has been paged out of
	// their cache.
	//
	// Things cleared are:
	// 1. StickyTaskQueue
	// 2. StickyScheduleToStartTimeout
	//
	// When possible, ShutdownWorker should be preferred over
	// ResetStickyTaskQueue (particularly when a worker is shutting down or
	// cycling).
	//
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: We do not expose worker API to HTTP. --)
	ResetStickyTaskQueue(ctx context.Context, in *ResetStickyTaskQueueRequest, opts ...grpc.CallOption) (*ResetStickyTaskQueueResponse, error)
	// ShutdownWorker is used to indicate that the given sticky task
	// queue is no longer being polled by its worker. Following the completion of
	// ShutdownWorker, newly-added workflow tasks will instead be placed
	// in the normal task queue, eligible for any worker to pick up.
	//
	// ShutdownWorker should be called by workers while shutting down,
	// after they've shut down their pollers. If another sticky poll
	// request is issued, the sticky task queue will be revived.
	//
	// As of Temporal Server v1.25.0, ShutdownWorker hasn't yet been implemented.
	//
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: We do not expose worker API to HTTP. --)
	ShutdownWorker(ctx context.Context, in *ShutdownWorkerRequest, opts ...grpc.CallOption) (*ShutdownWorkerResponse, error)
	// QueryWorkflow requests a query be executed for a specified workflow execution.
	QueryWorkflow(ctx context.Context, in *QueryWorkflowRequest, opts ...grpc.CallOption) (*QueryWorkflowResponse, error)
	// DescribeWorkflowExecution returns information about the specified workflow execution.
	DescribeWorkflowExecution(ctx context.Context, in *DescribeWorkflowExecutionRequest, opts ...grpc.CallOption) (*DescribeWorkflowExecutionResponse, error)
	// DescribeTaskQueue returns the following information about the target task queue, broken down by Build ID:
	//   - List of pollers
	//   - Workflow Reachability status
	//   - Backlog info for Workflow and/or Activity tasks
	DescribeTaskQueue(ctx context.Context, in *DescribeTaskQueueRequest, opts ...grpc.CallOption) (*DescribeTaskQueueResponse, error)
	// GetClusterInfo returns information about temporal cluster
	GetClusterInfo(ctx context.Context, in *GetClusterInfoRequest, opts ...grpc.CallOption) (*GetClusterInfoResponse, error)
	// GetSystemInfo returns information about the system.
	GetSystemInfo(ctx context.Context, in *GetSystemInfoRequest, opts ...grpc.CallOption) (*GetSystemInfoResponse, error)
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: We do not expose this low-level API to HTTP. --)
	ListTaskQueuePartitions(ctx context.Context, in *ListTaskQueuePartitionsRequest, opts ...grpc.CallOption) (*ListTaskQueuePartitionsResponse, error)
	// Creates a new schedule.
	CreateSchedule(ctx context.Context, in *CreateScheduleRequest, opts ...grpc.CallOption) (*CreateScheduleResponse, error)
	// Returns the schedule description and current state of an existing schedule.
	DescribeSchedule(ctx context.Context, in *DescribeScheduleRequest, opts ...grpc.CallOption) (*DescribeScheduleResponse, error)
	// Changes the configuration or state of an existing schedule.
	UpdateSchedule(ctx context.Context, in *UpdateScheduleRequest, opts ...grpc.CallOption) (*UpdateScheduleResponse, error)
	// Makes a specific change to a schedule or triggers an immediate action.
	PatchSchedule(ctx context.Context, in *PatchScheduleRequest, opts ...grpc.CallOption) (*PatchScheduleResponse, error)
	// Lists matching times within a range.
	ListScheduleMatchingTimes(ctx context.Context, in *ListScheduleMatchingTimesRequest, opts ...grpc.CallOption) (*ListScheduleMatchingTimesResponse, error)
	// Deletes a schedule, removing it from the system.
	DeleteSchedule(ctx context.Context, in *DeleteScheduleRequest, opts ...grpc.CallOption) (*DeleteScheduleResponse, error)
	// List all schedules in a namespace.
	ListSchedules(ctx context.Context, in *ListSchedulesRequest, opts ...grpc.CallOption) (*ListSchedulesResponse, error)
	// Deprecated. Use `UpdateWorkerVersioningRules`.
	//
	// Allows users to specify sets of worker build id versions on a per task queue basis. Versions
	// are ordered, and may be either compatible with some extant version, or a new incompatible
	// version, forming sets of ids which are incompatible with each other, but whose contained
	// members are compatible with one another.
	//
	// A single build id may be mapped to multiple task queues using this API for cases where a single process hosts
	// multiple workers.
	//
	// To query which workers can be retired, use the `GetWorkerTaskReachability` API.
	//
	// NOTE: The number of task queues mapped to a single build id is limited by the `limit.taskQueuesPerBuildId`
	// (default is 20), if this limit is exceeded this API will error with a FailedPrecondition.
	//
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: We do yet expose versioning API to HTTP. --)
	UpdateWorkerBuildIdCompatibility(ctx context.Context, in *UpdateWorkerBuildIdCompatibilityRequest, opts ...grpc.CallOption) (*UpdateWorkerBuildIdCompatibilityResponse, error)
	// Deprecated. Use `GetWorkerVersioningRules`.
	// Fetches the worker build id versioning sets for a task queue.
	GetWorkerBuildIdCompatibility(ctx context.Context, in *GetWorkerBuildIdCompatibilityRequest, opts ...grpc.CallOption) (*GetWorkerBuildIdCompatibilityResponse, error)
	// Use this API to manage Worker Versioning Rules for a given Task Queue. There are two types of
	// rules: Build ID Assignment rules and Compatible Build ID Redirect rules.
	//
	// Assignment rules determine how to assign new executions to a Build IDs. Their primary
	// use case is to specify the latest Build ID but they have powerful features for gradual rollout
	// of a new Build ID.
	//
	// Once a workflow execution is assigned to a Build ID and it completes its first Workflow Task,
	// the workflow stays on the assigned Build ID regardless of changes in assignment rules. This
	// eliminates the need for compatibility between versions when you only care about using the new
	// version for new workflows and let existing workflows finish in their own version.
	//
	// Activities, Child Workflows and Continue-as-New executions have the option to inherit the
	// Build ID of their parent/previous workflow or use the latest assignment rules to independently
	// select a Build ID.
	//
	// Redirect rules should only be used when you want to move workflows and activities assigned to
	// one Build ID (source) to another compatible Build ID (target). You are responsible to make sure
	// the target Build ID of a redirect rule is able to process event histories made by the source
	// Build ID by using [Patching](https://docs.temporal.io/workflows#patching) or other means.
	//
	// WARNING: Worker Versioning is not yet stable and the API and behavior may change incompatibly.
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: We do yet expose versioning API to HTTP. --)
	UpdateWorkerVersioningRules(ctx context.Context, in *UpdateWorkerVersioningRulesRequest, opts ...grpc.CallOption) (*UpdateWorkerVersioningRulesResponse, error)
	// Fetches the Build ID assignment and redirect rules for a Task Queue.
	// WARNING: Worker Versioning is not yet stable and the API and behavior may change incompatibly.
	GetWorkerVersioningRules(ctx context.Context, in *GetWorkerVersioningRulesRequest, opts ...grpc.CallOption) (*GetWorkerVersioningRulesResponse, error)
	// Deprecated. Use `DescribeTaskQueue`.
	//
	// Fetches task reachability to determine whether a worker may be retired.
	// The request may specify task queues to query for or let the server fetch all task queues mapped to the given
	// build IDs.
	//
	// When requesting a large number of task queues or all task queues associated with the given build ids in a
	// namespace, all task queues will be listed in the response but some of them may not contain reachability
	// information due to a server enforced limit. When reaching the limit, task queues that reachability information
	// could not be retrieved for will be marked with a single TASK_REACHABILITY_UNSPECIFIED entry. The caller may issue
	// another call to get the reachability for those task queues.
	//
	// Open source users can adjust this limit by setting the server's dynamic config value for
	// `limit.reachabilityTaskQueueScan` with the caveat that this call can strain the visibility store.
	GetWorkerTaskReachability(ctx context.Context, in *GetWorkerTaskReachabilityRequest, opts ...grpc.CallOption) (*GetWorkerTaskReachabilityResponse, error)
	// Describes a worker deployment.
	// Experimental. This API might significantly change or be removed in a future release.
	// Deprecated. Replaced with `DescribeWorkerDeploymentVersion`.
	DescribeDeployment(ctx context.Context, in *DescribeDeploymentRequest, opts ...grpc.CallOption) (*DescribeDeploymentResponse, error)
	// Describes a worker deployment version.
	// Experimental. This API might significantly change or be removed in a future release.
	DescribeWorkerDeploymentVersion(ctx context.Context, in *DescribeWorkerDeploymentVersionRequest, opts ...grpc.CallOption) (*DescribeWorkerDeploymentVersionResponse, error)
	// Lists worker deployments in the namespace. Optionally can filter based on deployment series
	// name.
	// Experimental. This API might significantly change or be removed in a future release.
	// Deprecated. Replaced with `ListWorkerDeployments`.
	ListDeployments(ctx context.Context, in *ListDeploymentsRequest, opts ...grpc.CallOption) (*ListDeploymentsResponse, error)
	// Returns the reachability level of a worker deployment to help users decide when it is time
	// to decommission a deployment. Reachability level is calculated based on the deployment's
	// `status` and existing workflows that depend on the given deployment for their execution.
	// Calculating reachability is relatively expensive. Therefore, server might return a recently
	// cached value. In such a case, the `last_update_time` will inform you about the actual
	// reachability calculation time.
	// Experimental. This API might significantly change or be removed in a future release.
	// Deprecated. Replaced with `DrainageInfo` returned by `DescribeWorkerDeploymentVersion`.
	GetDeploymentReachability(ctx context.Context, in *GetDeploymentReachabilityRequest, opts ...grpc.CallOption) (*GetDeploymentReachabilityResponse, error)
	// Returns the current deployment (and its info) for a given deployment series.
	// Experimental. This API might significantly change or be removed in a future release.
	// Deprecated. Replaced by `current_version` returned by `DescribeWorkerDeployment`.
	GetCurrentDeployment(ctx context.Context, in *GetCurrentDeploymentRequest, opts ...grpc.CallOption) (*GetCurrentDeploymentResponse, error)
	// Sets a deployment as the current deployment for its deployment series. Can optionally update
	// the metadata of the deployment as well.
	// Experimental. This API might significantly change or be removed in a future release.
	// Deprecated. Replaced by `SetWorkerDeploymentCurrentVersion`.
	SetCurrentDeployment(ctx context.Context, in *SetCurrentDeploymentRequest, opts ...grpc.CallOption) (*SetCurrentDeploymentResponse, error)
	// Set/unset the Current Version of a Worker Deployment. Automatically unsets the Ramping
	// Version if it is the Version being set as Current.
	// Experimental. This API might significantly change or be removed in a future release.
	SetWorkerDeploymentCurrentVersion(ctx context.Context, in *SetWorkerDeploymentCurrentVersionRequest, opts ...grpc.CallOption) (*SetWorkerDeploymentCurrentVersionResponse, error)
	// Describes a Worker Deployment.
	// Experimental. This API might significantly change or be removed in a future release.
	DescribeWorkerDeployment(ctx context.Context, in *DescribeWorkerDeploymentRequest, opts ...grpc.CallOption) (*DescribeWorkerDeploymentResponse, error)
	// Deletes records of (an old) Deployment. A deployment can only be deleted if
	// it has no Version in it.
	// Experimental. This API might significantly change or be removed in a future release.
	DeleteWorkerDeployment(ctx context.Context, in *DeleteWorkerDeploymentRequest, opts ...grpc.CallOption) (*DeleteWorkerDeploymentResponse, error)
	// Used for manual deletion of Versions. User can delete a Version only when all the
	// following conditions are met:
	//   - It is not the Current or Ramping Version of its Deployment.
	//   - It has no active pollers (none of the task queues in the Version have pollers)
	//   - It is not draining (see WorkerDeploymentVersionInfo.drainage_info). This condition
	//     can be skipped by passing `skip-drainage=true`.
	//
	// Experimental. This API might significantly change or be removed in a future release.
	DeleteWorkerDeploymentVersion(ctx context.Context, in *DeleteWorkerDeploymentVersionRequest, opts ...grpc.CallOption) (*DeleteWorkerDeploymentVersionResponse, error)
	// Set/unset the Ramping Version of a Worker Deployment and its ramp percentage. Can be used for
	// gradual ramp to unversioned workers too.
	// Experimental. This API might significantly change or be removed in a future release.
	SetWorkerDeploymentRampingVersion(ctx context.Context, in *SetWorkerDeploymentRampingVersionRequest, opts ...grpc.CallOption) (*SetWorkerDeploymentRampingVersionResponse, error)
	// Lists all Worker Deployments that are tracked in the Namespace.
	// Experimental. This API might significantly change or be removed in a future release.
	ListWorkerDeployments(ctx context.Context, in *ListWorkerDeploymentsRequest, opts ...grpc.CallOption) (*ListWorkerDeploymentsResponse, error)
	// Updates the user-given metadata attached to a Worker Deployment Version.
	// Experimental. This API might significantly change or be removed in a future release.
	UpdateWorkerDeploymentVersionMetadata(ctx context.Context, in *UpdateWorkerDeploymentVersionMetadataRequest, opts ...grpc.CallOption) (*UpdateWorkerDeploymentVersionMetadataResponse, error)
	// Invokes the specified Update function on user Workflow code.
	UpdateWorkflowExecution(ctx context.Context, in *UpdateWorkflowExecutionRequest, opts ...grpc.CallOption) (*UpdateWorkflowExecutionResponse, error)
	// Polls a Workflow Execution for the outcome of a Workflow Update
	// previously issued through the UpdateWorkflowExecution RPC. The effective
	// timeout on this call will be shorter of the the caller-supplied gRPC
	// timeout and the server's configured long-poll timeout.
	//
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: We don't expose update polling API to HTTP in favor of a potential future non-blocking form. --)
	PollWorkflowExecutionUpdate(ctx context.Context, in *PollWorkflowExecutionUpdateRequest, opts ...grpc.CallOption) (*PollWorkflowExecutionUpdateResponse, error)
	// StartBatchOperation starts a new batch operation
	StartBatchOperation(ctx context.Context, in *StartBatchOperationRequest, opts ...grpc.CallOption) (*StartBatchOperationResponse, error)
	// StopBatchOperation stops a batch operation
	StopBatchOperation(ctx context.Context, in *StopBatchOperationRequest, opts ...grpc.CallOption) (*StopBatchOperationResponse, error)
	// DescribeBatchOperation returns the information about a batch operation
	DescribeBatchOperation(ctx context.Context, in *DescribeBatchOperationRequest, opts ...grpc.CallOption) (*DescribeBatchOperationResponse, error)
	// ListBatchOperations returns a list of batch operations
	ListBatchOperations(ctx context.Context, in *ListBatchOperationsRequest, opts ...grpc.CallOption) (*ListBatchOperationsResponse, error)
	// PollNexusTaskQueue is a long poll call used by workers to receive Nexus tasks.
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: We do not expose worker API to HTTP. --)
	PollNexusTaskQueue(ctx context.Context, in *PollNexusTaskQueueRequest, opts ...grpc.CallOption) (*PollNexusTaskQueueResponse, error)
	// RespondNexusTaskCompleted is called by workers to respond to Nexus tasks received via PollNexusTaskQueue.
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: We do not expose worker API to HTTP. --)
	RespondNexusTaskCompleted(ctx context.Context, in *RespondNexusTaskCompletedRequest, opts ...grpc.CallOption) (*RespondNexusTaskCompletedResponse, error)
	// RespondNexusTaskFailed is called by workers to fail Nexus tasks received via PollNexusTaskQueue.
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: We do not expose worker API to HTTP. --)
	RespondNexusTaskFailed(ctx context.Context, in *RespondNexusTaskFailedRequest, opts ...grpc.CallOption) (*RespondNexusTaskFailedResponse, error)
	// UpdateActivityOptions is called by the client to update the options of an activity by its ID or type.
	// If there are multiple pending activities of the provided type - all of them will be updated.
	UpdateActivityOptions(ctx context.Context, in *UpdateActivityOptionsRequest, opts ...grpc.CallOption) (*UpdateActivityOptionsResponse, error)
	// UpdateWorkflowExecutionOptions partially updates the WorkflowExecutionOptions of an existing workflow execution.
	UpdateWorkflowExecutionOptions(ctx context.Context, in *UpdateWorkflowExecutionOptionsRequest, opts ...grpc.CallOption) (*UpdateWorkflowExecutionOptionsResponse, error)
	// PauseActivity pauses the execution of an activity specified by its ID or type.
	// If there are multiple pending activities of the provided type - all of them will be paused
	//
	// Pausing an activity means:
	//   - If the activity is currently waiting for a retry or is running and subsequently fails,
	//     it will not be rescheduled until it is unpaused.
	//   - If the activity is already paused, calling this method will have no effect.
	//   - If the activity is running and finishes successfully, the activity will be completed.
	//   - If the activity is running and finishes with failure:
	//   - if there is no retry left - the activity will be completed.
	//   - if there are more retries left - the activity will be paused.
	//
	// For long-running activities:
	// - activities in paused state will send a cancellation with "activity_paused" set to 'true' in response to 'RecordActivityTaskHeartbeat'.
	// - The activity should respond to the cancellation accordingly.
	//
	// Returns a `NotFound` error if there is no pending activity with the provided ID or type
	PauseActivity(ctx context.Context, in *PauseActivityRequest, opts ...grpc.CallOption) (*PauseActivityResponse, error)
	// UnpauseActivity unpauses the execution of an activity specified by its ID or type.
	// If there are multiple pending activities of the provided type - all of them will be unpaused.
	//
	// If activity is not paused, this call will have no effect.
	// If the activity was paused while waiting for retry, it will be scheduled immediately (* see 'jitter' flag).
	// Once the activity is unpaused, all timeout timers will be regenerated.
	//
	// Flags:
	// 'jitter': the activity will be scheduled at a random time within the jitter duration.
	// 'reset_attempts': the number of attempts will be reset.
	// 'reset_heartbeat': the activity heartbeat timer and heartbeats will be reset.
	//
	// Returns a `NotFound` error if there is no pending activity with the provided ID or type
	UnpauseActivity(ctx context.Context, in *UnpauseActivityRequest, opts ...grpc.CallOption) (*UnpauseActivityResponse, error)
	// ResetActivity resets the execution of an activity specified by its ID or type.
	// If there are multiple pending activities of the provided type - all of them will be reset.
	//
	// Resetting an activity means:
	//   - number of attempts will be reset to 0.
	//   - activity timeouts will be reset.
	//   - if the activity is waiting for retry, and it is not paused or 'keep_paused' is not provided:
	//     it will be scheduled immediately (* see 'jitter' flag),
	//
	// Flags:
	//
	// 'jitter': the activity will be scheduled at a random time within the jitter duration.
	// If the activity currently paused it will be unpaused, unless 'keep_paused' flag is provided.
	// 'reset_heartbeats': the activity heartbeat timer and heartbeats will be reset.
	// 'keep_paused': if the activity is paused, it will remain paused.
	//
	// Returns a `NotFound` error if there is no pending activity with the provided ID or type.
	ResetActivity(ctx context.Context, in *ResetActivityRequest, opts ...grpc.CallOption) (*ResetActivityResponse, error)
	// Create a new workflow rule. The rules are used to control the workflow execution.
	// The rule will be applied to all running and new workflows in the namespace.
	// If the rule with such ID already exist this call will fail
	// Note: the rules are part of namespace configuration and will be stored in the namespace config.
	// Namespace config is eventually consistent.
	CreateWorkflowRule(ctx context.Context, in *CreateWorkflowRuleRequest, opts ...grpc.CallOption) (*CreateWorkflowRuleResponse, error)
	// DescribeWorkflowRule return the rule specification for existing rule id.
	// If there is no rule with such id - NOT FOUND error will be returned.
	DescribeWorkflowRule(ctx context.Context, in *DescribeWorkflowRuleRequest, opts ...grpc.CallOption) (*DescribeWorkflowRuleResponse, error)
	// Delete rule by rule id
	DeleteWorkflowRule(ctx context.Context, in *DeleteWorkflowRuleRequest, opts ...grpc.CallOption) (*DeleteWorkflowRuleResponse, error)
	// Return all namespace workflow rules
	ListWorkflowRules(ctx context.Context, in *ListWorkflowRulesRequest, opts ...grpc.CallOption) (*ListWorkflowRulesResponse, error)
	// TriggerWorkflowRule allows to:
	//   - trigger existing rule for a specific workflow execution;
	//   - trigger rule for a specific workflow execution without creating a rule;
	//
	// This is useful for one-off operations.
	TriggerWorkflowRule(ctx context.Context, in *TriggerWorkflowRuleRequest, opts ...grpc.CallOption) (*TriggerWorkflowRuleResponse, error)
	// WorkerHeartbeat receive heartbeat request from the worker.
	RecordWorkerHeartbeat(ctx context.Context, in *RecordWorkerHeartbeatRequest, opts ...grpc.CallOption) (*RecordWorkerHeartbeatResponse, error)
	// ListWorkers is a visibility API to list worker status information in a specific namespace.
	ListWorkers(ctx context.Context, in *ListWorkersRequest, opts ...grpc.CallOption) (*ListWorkersResponse, error)
	// Updates task queue configuration.
	// For the overall queue rate limit: the rate limit set by this api overrides the worker-set rate limit,
	// which uncouples the rate limit from the worker lifecycle.
	// If the overall queue rate limit is unset, the worker-set rate limit takes effect.
	UpdateTaskQueueConfig(ctx context.Context, in *UpdateTaskQueueConfigRequest, opts ...grpc.CallOption) (*UpdateTaskQueueConfigResponse, error)
	// FetchWorkerConfig returns the worker configuration for a specific worker.
	FetchWorkerConfig(ctx context.Context, in *FetchWorkerConfigRequest, opts ...grpc.CallOption) (*FetchWorkerConfigResponse, error)
	// UpdateWorkerConfig updates the worker configuration of one or more workers.
	// Can be used to partially update the worker configuration.
	// Can be used to update the configuration of multiple workers.
	UpdateWorkerConfig(ctx context.Context, in *UpdateWorkerConfigRequest, opts ...grpc.CallOption) (*UpdateWorkerConfigResponse, error)
}

type workflowServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewWorkflowServiceClient(cc grpc.ClientConnInterface) WorkflowServiceClient {
	return &workflowServiceClient{cc}
}

func (c *workflowServiceClient) RegisterNamespace(ctx context.Context, in *RegisterNamespaceRequest, opts ...grpc.CallOption) (*RegisterNamespaceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterNamespaceResponse)
	err := c.cc.Invoke(ctx, WorkflowService_RegisterNamespace_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) DescribeNamespace(ctx context.Context, in *DescribeNamespaceRequest, opts ...grpc.CallOption) (*DescribeNamespaceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DescribeNamespaceResponse)
	err := c.cc.Invoke(ctx, WorkflowService_DescribeNamespace_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ListNamespaces(ctx context.Context, in *ListNamespacesRequest, opts ...grpc.CallOption) (*ListNamespacesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListNamespacesResponse)
	err := c.cc.Invoke(ctx, WorkflowService_ListNamespaces_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) UpdateNamespace(ctx context.Context, in *UpdateNamespaceRequest, opts ...grpc.CallOption) (*UpdateNamespaceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateNamespaceResponse)
	err := c.cc.Invoke(ctx, WorkflowService_UpdateNamespace_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) DeprecateNamespace(ctx context.Context, in *DeprecateNamespaceRequest, opts ...grpc.CallOption) (*DeprecateNamespaceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeprecateNamespaceResponse)
	err := c.cc.Invoke(ctx, WorkflowService_DeprecateNamespace_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) StartWorkflowExecution(ctx context.Context, in *StartWorkflowExecutionRequest, opts ...grpc.CallOption) (*StartWorkflowExecutionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartWorkflowExecutionResponse)
	err := c.cc.Invoke(ctx, WorkflowService_StartWorkflowExecution_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ExecuteMultiOperation(ctx context.Context, in *ExecuteMultiOperationRequest, opts ...grpc.CallOption) (*ExecuteMultiOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExecuteMultiOperationResponse)
	err := c.cc.Invoke(ctx, WorkflowService_ExecuteMultiOperation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) GetWorkflowExecutionHistory(ctx context.Context, in *GetWorkflowExecutionHistoryRequest, opts ...grpc.CallOption) (*GetWorkflowExecutionHistoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetWorkflowExecutionHistoryResponse)
	err := c.cc.Invoke(ctx, WorkflowService_GetWorkflowExecutionHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) GetWorkflowExecutionHistoryReverse(ctx context.Context, in *GetWorkflowExecutionHistoryReverseRequest, opts ...grpc.CallOption) (*GetWorkflowExecutionHistoryReverseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetWorkflowExecutionHistoryReverseResponse)
	err := c.cc.Invoke(ctx, WorkflowService_GetWorkflowExecutionHistoryReverse_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) PollWorkflowTaskQueue(ctx context.Context, in *PollWorkflowTaskQueueRequest, opts ...grpc.CallOption) (*PollWorkflowTaskQueueResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PollWorkflowTaskQueueResponse)
	err := c.cc.Invoke(ctx, WorkflowService_PollWorkflowTaskQueue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RespondWorkflowTaskCompleted(ctx context.Context, in *RespondWorkflowTaskCompletedRequest, opts ...grpc.CallOption) (*RespondWorkflowTaskCompletedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RespondWorkflowTaskCompletedResponse)
	err := c.cc.Invoke(ctx, WorkflowService_RespondWorkflowTaskCompleted_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RespondWorkflowTaskFailed(ctx context.Context, in *RespondWorkflowTaskFailedRequest, opts ...grpc.CallOption) (*RespondWorkflowTaskFailedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RespondWorkflowTaskFailedResponse)
	err := c.cc.Invoke(ctx, WorkflowService_RespondWorkflowTaskFailed_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) PollActivityTaskQueue(ctx context.Context, in *PollActivityTaskQueueRequest, opts ...grpc.CallOption) (*PollActivityTaskQueueResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PollActivityTaskQueueResponse)
	err := c.cc.Invoke(ctx, WorkflowService_PollActivityTaskQueue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RecordActivityTaskHeartbeat(ctx context.Context, in *RecordActivityTaskHeartbeatRequest, opts ...grpc.CallOption) (*RecordActivityTaskHeartbeatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RecordActivityTaskHeartbeatResponse)
	err := c.cc.Invoke(ctx, WorkflowService_RecordActivityTaskHeartbeat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RecordActivityTaskHeartbeatById(ctx context.Context, in *RecordActivityTaskHeartbeatByIdRequest, opts ...grpc.CallOption) (*RecordActivityTaskHeartbeatByIdResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RecordActivityTaskHeartbeatByIdResponse)
	err := c.cc.Invoke(ctx, WorkflowService_RecordActivityTaskHeartbeatById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RespondActivityTaskCompleted(ctx context.Context, in *RespondActivityTaskCompletedRequest, opts ...grpc.CallOption) (*RespondActivityTaskCompletedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RespondActivityTaskCompletedResponse)
	err := c.cc.Invoke(ctx, WorkflowService_RespondActivityTaskCompleted_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RespondActivityTaskCompletedById(ctx context.Context, in *RespondActivityTaskCompletedByIdRequest, opts ...grpc.CallOption) (*RespondActivityTaskCompletedByIdResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RespondActivityTaskCompletedByIdResponse)
	err := c.cc.Invoke(ctx, WorkflowService_RespondActivityTaskCompletedById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RespondActivityTaskFailed(ctx context.Context, in *RespondActivityTaskFailedRequest, opts ...grpc.CallOption) (*RespondActivityTaskFailedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RespondActivityTaskFailedResponse)
	err := c.cc.Invoke(ctx, WorkflowService_RespondActivityTaskFailed_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RespondActivityTaskFailedById(ctx context.Context, in *RespondActivityTaskFailedByIdRequest, opts ...grpc.CallOption) (*RespondActivityTaskFailedByIdResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RespondActivityTaskFailedByIdResponse)
	err := c.cc.Invoke(ctx, WorkflowService_RespondActivityTaskFailedById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RespondActivityTaskCanceled(ctx context.Context, in *RespondActivityTaskCanceledRequest, opts ...grpc.CallOption) (*RespondActivityTaskCanceledResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RespondActivityTaskCanceledResponse)
	err := c.cc.Invoke(ctx, WorkflowService_RespondActivityTaskCanceled_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RespondActivityTaskCanceledById(ctx context.Context, in *RespondActivityTaskCanceledByIdRequest, opts ...grpc.CallOption) (*RespondActivityTaskCanceledByIdResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RespondActivityTaskCanceledByIdResponse)
	err := c.cc.Invoke(ctx, WorkflowService_RespondActivityTaskCanceledById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RequestCancelWorkflowExecution(ctx context.Context, in *RequestCancelWorkflowExecutionRequest, opts ...grpc.CallOption) (*RequestCancelWorkflowExecutionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RequestCancelWorkflowExecutionResponse)
	err := c.cc.Invoke(ctx, WorkflowService_RequestCancelWorkflowExecution_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) SignalWorkflowExecution(ctx context.Context, in *SignalWorkflowExecutionRequest, opts ...grpc.CallOption) (*SignalWorkflowExecutionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SignalWorkflowExecutionResponse)
	err := c.cc.Invoke(ctx, WorkflowService_SignalWorkflowExecution_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) SignalWithStartWorkflowExecution(ctx context.Context, in *SignalWithStartWorkflowExecutionRequest, opts ...grpc.CallOption) (*SignalWithStartWorkflowExecutionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SignalWithStartWorkflowExecutionResponse)
	err := c.cc.Invoke(ctx, WorkflowService_SignalWithStartWorkflowExecution_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ResetWorkflowExecution(ctx context.Context, in *ResetWorkflowExecutionRequest, opts ...grpc.CallOption) (*ResetWorkflowExecutionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResetWorkflowExecutionResponse)
	err := c.cc.Invoke(ctx, WorkflowService_ResetWorkflowExecution_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) TerminateWorkflowExecution(ctx context.Context, in *TerminateWorkflowExecutionRequest, opts ...grpc.CallOption) (*TerminateWorkflowExecutionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TerminateWorkflowExecutionResponse)
	err := c.cc.Invoke(ctx, WorkflowService_TerminateWorkflowExecution_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) DeleteWorkflowExecution(ctx context.Context, in *DeleteWorkflowExecutionRequest, opts ...grpc.CallOption) (*DeleteWorkflowExecutionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteWorkflowExecutionResponse)
	err := c.cc.Invoke(ctx, WorkflowService_DeleteWorkflowExecution_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ListOpenWorkflowExecutions(ctx context.Context, in *ListOpenWorkflowExecutionsRequest, opts ...grpc.CallOption) (*ListOpenWorkflowExecutionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListOpenWorkflowExecutionsResponse)
	err := c.cc.Invoke(ctx, WorkflowService_ListOpenWorkflowExecutions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ListClosedWorkflowExecutions(ctx context.Context, in *ListClosedWorkflowExecutionsRequest, opts ...grpc.CallOption) (*ListClosedWorkflowExecutionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListClosedWorkflowExecutionsResponse)
	err := c.cc.Invoke(ctx, WorkflowService_ListClosedWorkflowExecutions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ListWorkflowExecutions(ctx context.Context, in *ListWorkflowExecutionsRequest, opts ...grpc.CallOption) (*ListWorkflowExecutionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListWorkflowExecutionsResponse)
	err := c.cc.Invoke(ctx, WorkflowService_ListWorkflowExecutions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ListArchivedWorkflowExecutions(ctx context.Context, in *ListArchivedWorkflowExecutionsRequest, opts ...grpc.CallOption) (*ListArchivedWorkflowExecutionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListArchivedWorkflowExecutionsResponse)
	err := c.cc.Invoke(ctx, WorkflowService_ListArchivedWorkflowExecutions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ScanWorkflowExecutions(ctx context.Context, in *ScanWorkflowExecutionsRequest, opts ...grpc.CallOption) (*ScanWorkflowExecutionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScanWorkflowExecutionsResponse)
	err := c.cc.Invoke(ctx, WorkflowService_ScanWorkflowExecutions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) CountWorkflowExecutions(ctx context.Context, in *CountWorkflowExecutionsRequest, opts ...grpc.CallOption) (*CountWorkflowExecutionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CountWorkflowExecutionsResponse)
	err := c.cc.Invoke(ctx, WorkflowService_CountWorkflowExecutions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) GetSearchAttributes(ctx context.Context, in *GetSearchAttributesRequest, opts ...grpc.CallOption) (*GetSearchAttributesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSearchAttributesResponse)
	err := c.cc.Invoke(ctx, WorkflowService_GetSearchAttributes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RespondQueryTaskCompleted(ctx context.Context, in *RespondQueryTaskCompletedRequest, opts ...grpc.CallOption) (*RespondQueryTaskCompletedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RespondQueryTaskCompletedResponse)
	err := c.cc.Invoke(ctx, WorkflowService_RespondQueryTaskCompleted_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ResetStickyTaskQueue(ctx context.Context, in *ResetStickyTaskQueueRequest, opts ...grpc.CallOption) (*ResetStickyTaskQueueResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResetStickyTaskQueueResponse)
	err := c.cc.Invoke(ctx, WorkflowService_ResetStickyTaskQueue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ShutdownWorker(ctx context.Context, in *ShutdownWorkerRequest, opts ...grpc.CallOption) (*ShutdownWorkerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ShutdownWorkerResponse)
	err := c.cc.Invoke(ctx, WorkflowService_ShutdownWorker_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) QueryWorkflow(ctx context.Context, in *QueryWorkflowRequest, opts ...grpc.CallOption) (*QueryWorkflowResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryWorkflowResponse)
	err := c.cc.Invoke(ctx, WorkflowService_QueryWorkflow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) DescribeWorkflowExecution(ctx context.Context, in *DescribeWorkflowExecutionRequest, opts ...grpc.CallOption) (*DescribeWorkflowExecutionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DescribeWorkflowExecutionResponse)
	err := c.cc.Invoke(ctx, WorkflowService_DescribeWorkflowExecution_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) DescribeTaskQueue(ctx context.Context, in *DescribeTaskQueueRequest, opts ...grpc.CallOption) (*DescribeTaskQueueResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DescribeTaskQueueResponse)
	err := c.cc.Invoke(ctx, WorkflowService_DescribeTaskQueue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) GetClusterInfo(ctx context.Context, in *GetClusterInfoRequest, opts ...grpc.CallOption) (*GetClusterInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetClusterInfoResponse)
	err := c.cc.Invoke(ctx, WorkflowService_GetClusterInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) GetSystemInfo(ctx context.Context, in *GetSystemInfoRequest, opts ...grpc.CallOption) (*GetSystemInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSystemInfoResponse)
	err := c.cc.Invoke(ctx, WorkflowService_GetSystemInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ListTaskQueuePartitions(ctx context.Context, in *ListTaskQueuePartitionsRequest, opts ...grpc.CallOption) (*ListTaskQueuePartitionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTaskQueuePartitionsResponse)
	err := c.cc.Invoke(ctx, WorkflowService_ListTaskQueuePartitions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) CreateSchedule(ctx context.Context, in *CreateScheduleRequest, opts ...grpc.CallOption) (*CreateScheduleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateScheduleResponse)
	err := c.cc.Invoke(ctx, WorkflowService_CreateSchedule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) DescribeSchedule(ctx context.Context, in *DescribeScheduleRequest, opts ...grpc.CallOption) (*DescribeScheduleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DescribeScheduleResponse)
	err := c.cc.Invoke(ctx, WorkflowService_DescribeSchedule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) UpdateSchedule(ctx context.Context, in *UpdateScheduleRequest, opts ...grpc.CallOption) (*UpdateScheduleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateScheduleResponse)
	err := c.cc.Invoke(ctx, WorkflowService_UpdateSchedule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) PatchSchedule(ctx context.Context, in *PatchScheduleRequest, opts ...grpc.CallOption) (*PatchScheduleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PatchScheduleResponse)
	err := c.cc.Invoke(ctx, WorkflowService_PatchSchedule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ListScheduleMatchingTimes(ctx context.Context, in *ListScheduleMatchingTimesRequest, opts ...grpc.CallOption) (*ListScheduleMatchingTimesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListScheduleMatchingTimesResponse)
	err := c.cc.Invoke(ctx, WorkflowService_ListScheduleMatchingTimes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) DeleteSchedule(ctx context.Context, in *DeleteScheduleRequest, opts ...grpc.CallOption) (*DeleteScheduleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteScheduleResponse)
	err := c.cc.Invoke(ctx, WorkflowService_DeleteSchedule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ListSchedules(ctx context.Context, in *ListSchedulesRequest, opts ...grpc.CallOption) (*ListSchedulesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListSchedulesResponse)
	err := c.cc.Invoke(ctx, WorkflowService_ListSchedules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) UpdateWorkerBuildIdCompatibility(ctx context.Context, in *UpdateWorkerBuildIdCompatibilityRequest, opts ...grpc.CallOption) (*UpdateWorkerBuildIdCompatibilityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateWorkerBuildIdCompatibilityResponse)
	err := c.cc.Invoke(ctx, WorkflowService_UpdateWorkerBuildIdCompatibility_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) GetWorkerBuildIdCompatibility(ctx context.Context, in *GetWorkerBuildIdCompatibilityRequest, opts ...grpc.CallOption) (*GetWorkerBuildIdCompatibilityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetWorkerBuildIdCompatibilityResponse)
	err := c.cc.Invoke(ctx, WorkflowService_GetWorkerBuildIdCompatibility_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) UpdateWorkerVersioningRules(ctx context.Context, in *UpdateWorkerVersioningRulesRequest, opts ...grpc.CallOption) (*UpdateWorkerVersioningRulesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateWorkerVersioningRulesResponse)
	err := c.cc.Invoke(ctx, WorkflowService_UpdateWorkerVersioningRules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) GetWorkerVersioningRules(ctx context.Context, in *GetWorkerVersioningRulesRequest, opts ...grpc.CallOption) (*GetWorkerVersioningRulesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetWorkerVersioningRulesResponse)
	err := c.cc.Invoke(ctx, WorkflowService_GetWorkerVersioningRules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) GetWorkerTaskReachability(ctx context.Context, in *GetWorkerTaskReachabilityRequest, opts ...grpc.CallOption) (*GetWorkerTaskReachabilityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetWorkerTaskReachabilityResponse)
	err := c.cc.Invoke(ctx, WorkflowService_GetWorkerTaskReachability_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) DescribeDeployment(ctx context.Context, in *DescribeDeploymentRequest, opts ...grpc.CallOption) (*DescribeDeploymentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DescribeDeploymentResponse)
	err := c.cc.Invoke(ctx, WorkflowService_DescribeDeployment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) DescribeWorkerDeploymentVersion(ctx context.Context, in *DescribeWorkerDeploymentVersionRequest, opts ...grpc.CallOption) (*DescribeWorkerDeploymentVersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DescribeWorkerDeploymentVersionResponse)
	err := c.cc.Invoke(ctx, WorkflowService_DescribeWorkerDeploymentVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ListDeployments(ctx context.Context, in *ListDeploymentsRequest, opts ...grpc.CallOption) (*ListDeploymentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDeploymentsResponse)
	err := c.cc.Invoke(ctx, WorkflowService_ListDeployments_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) GetDeploymentReachability(ctx context.Context, in *GetDeploymentReachabilityRequest, opts ...grpc.CallOption) (*GetDeploymentReachabilityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDeploymentReachabilityResponse)
	err := c.cc.Invoke(ctx, WorkflowService_GetDeploymentReachability_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) GetCurrentDeployment(ctx context.Context, in *GetCurrentDeploymentRequest, opts ...grpc.CallOption) (*GetCurrentDeploymentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCurrentDeploymentResponse)
	err := c.cc.Invoke(ctx, WorkflowService_GetCurrentDeployment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) SetCurrentDeployment(ctx context.Context, in *SetCurrentDeploymentRequest, opts ...grpc.CallOption) (*SetCurrentDeploymentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetCurrentDeploymentResponse)
	err := c.cc.Invoke(ctx, WorkflowService_SetCurrentDeployment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) SetWorkerDeploymentCurrentVersion(ctx context.Context, in *SetWorkerDeploymentCurrentVersionRequest, opts ...grpc.CallOption) (*SetWorkerDeploymentCurrentVersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetWorkerDeploymentCurrentVersionResponse)
	err := c.cc.Invoke(ctx, WorkflowService_SetWorkerDeploymentCurrentVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) DescribeWorkerDeployment(ctx context.Context, in *DescribeWorkerDeploymentRequest, opts ...grpc.CallOption) (*DescribeWorkerDeploymentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DescribeWorkerDeploymentResponse)
	err := c.cc.Invoke(ctx, WorkflowService_DescribeWorkerDeployment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) DeleteWorkerDeployment(ctx context.Context, in *DeleteWorkerDeploymentRequest, opts ...grpc.CallOption) (*DeleteWorkerDeploymentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteWorkerDeploymentResponse)
	err := c.cc.Invoke(ctx, WorkflowService_DeleteWorkerDeployment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) DeleteWorkerDeploymentVersion(ctx context.Context, in *DeleteWorkerDeploymentVersionRequest, opts ...grpc.CallOption) (*DeleteWorkerDeploymentVersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteWorkerDeploymentVersionResponse)
	err := c.cc.Invoke(ctx, WorkflowService_DeleteWorkerDeploymentVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) SetWorkerDeploymentRampingVersion(ctx context.Context, in *SetWorkerDeploymentRampingVersionRequest, opts ...grpc.CallOption) (*SetWorkerDeploymentRampingVersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetWorkerDeploymentRampingVersionResponse)
	err := c.cc.Invoke(ctx, WorkflowService_SetWorkerDeploymentRampingVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ListWorkerDeployments(ctx context.Context, in *ListWorkerDeploymentsRequest, opts ...grpc.CallOption) (*ListWorkerDeploymentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListWorkerDeploymentsResponse)
	err := c.cc.Invoke(ctx, WorkflowService_ListWorkerDeployments_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) UpdateWorkerDeploymentVersionMetadata(ctx context.Context, in *UpdateWorkerDeploymentVersionMetadataRequest, opts ...grpc.CallOption) (*UpdateWorkerDeploymentVersionMetadataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateWorkerDeploymentVersionMetadataResponse)
	err := c.cc.Invoke(ctx, WorkflowService_UpdateWorkerDeploymentVersionMetadata_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) UpdateWorkflowExecution(ctx context.Context, in *UpdateWorkflowExecutionRequest, opts ...grpc.CallOption) (*UpdateWorkflowExecutionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateWorkflowExecutionResponse)
	err := c.cc.Invoke(ctx, WorkflowService_UpdateWorkflowExecution_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) PollWorkflowExecutionUpdate(ctx context.Context, in *PollWorkflowExecutionUpdateRequest, opts ...grpc.CallOption) (*PollWorkflowExecutionUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PollWorkflowExecutionUpdateResponse)
	err := c.cc.Invoke(ctx, WorkflowService_PollWorkflowExecutionUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) StartBatchOperation(ctx context.Context, in *StartBatchOperationRequest, opts ...grpc.CallOption) (*StartBatchOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartBatchOperationResponse)
	err := c.cc.Invoke(ctx, WorkflowService_StartBatchOperation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) StopBatchOperation(ctx context.Context, in *StopBatchOperationRequest, opts ...grpc.CallOption) (*StopBatchOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StopBatchOperationResponse)
	err := c.cc.Invoke(ctx, WorkflowService_StopBatchOperation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) DescribeBatchOperation(ctx context.Context, in *DescribeBatchOperationRequest, opts ...grpc.CallOption) (*DescribeBatchOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DescribeBatchOperationResponse)
	err := c.cc.Invoke(ctx, WorkflowService_DescribeBatchOperation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ListBatchOperations(ctx context.Context, in *ListBatchOperationsRequest, opts ...grpc.CallOption) (*ListBatchOperationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListBatchOperationsResponse)
	err := c.cc.Invoke(ctx, WorkflowService_ListBatchOperations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) PollNexusTaskQueue(ctx context.Context, in *PollNexusTaskQueueRequest, opts ...grpc.CallOption) (*PollNexusTaskQueueResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PollNexusTaskQueueResponse)
	err := c.cc.Invoke(ctx, WorkflowService_PollNexusTaskQueue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RespondNexusTaskCompleted(ctx context.Context, in *RespondNexusTaskCompletedRequest, opts ...grpc.CallOption) (*RespondNexusTaskCompletedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RespondNexusTaskCompletedResponse)
	err := c.cc.Invoke(ctx, WorkflowService_RespondNexusTaskCompleted_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RespondNexusTaskFailed(ctx context.Context, in *RespondNexusTaskFailedRequest, opts ...grpc.CallOption) (*RespondNexusTaskFailedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RespondNexusTaskFailedResponse)
	err := c.cc.Invoke(ctx, WorkflowService_RespondNexusTaskFailed_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) UpdateActivityOptions(ctx context.Context, in *UpdateActivityOptionsRequest, opts ...grpc.CallOption) (*UpdateActivityOptionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateActivityOptionsResponse)
	err := c.cc.Invoke(ctx, WorkflowService_UpdateActivityOptions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) UpdateWorkflowExecutionOptions(ctx context.Context, in *UpdateWorkflowExecutionOptionsRequest, opts ...grpc.CallOption) (*UpdateWorkflowExecutionOptionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateWorkflowExecutionOptionsResponse)
	err := c.cc.Invoke(ctx, WorkflowService_UpdateWorkflowExecutionOptions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) PauseActivity(ctx context.Context, in *PauseActivityRequest, opts ...grpc.CallOption) (*PauseActivityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PauseActivityResponse)
	err := c.cc.Invoke(ctx, WorkflowService_PauseActivity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) UnpauseActivity(ctx context.Context, in *UnpauseActivityRequest, opts ...grpc.CallOption) (*UnpauseActivityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnpauseActivityResponse)
	err := c.cc.Invoke(ctx, WorkflowService_UnpauseActivity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ResetActivity(ctx context.Context, in *ResetActivityRequest, opts ...grpc.CallOption) (*ResetActivityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResetActivityResponse)
	err := c.cc.Invoke(ctx, WorkflowService_ResetActivity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) CreateWorkflowRule(ctx context.Context, in *CreateWorkflowRuleRequest, opts ...grpc.CallOption) (*CreateWorkflowRuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateWorkflowRuleResponse)
	err := c.cc.Invoke(ctx, WorkflowService_CreateWorkflowRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) DescribeWorkflowRule(ctx context.Context, in *DescribeWorkflowRuleRequest, opts ...grpc.CallOption) (*DescribeWorkflowRuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DescribeWorkflowRuleResponse)
	err := c.cc.Invoke(ctx, WorkflowService_DescribeWorkflowRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) DeleteWorkflowRule(ctx context.Context, in *DeleteWorkflowRuleRequest, opts ...grpc.CallOption) (*DeleteWorkflowRuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteWorkflowRuleResponse)
	err := c.cc.Invoke(ctx, WorkflowService_DeleteWorkflowRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ListWorkflowRules(ctx context.Context, in *ListWorkflowRulesRequest, opts ...grpc.CallOption) (*ListWorkflowRulesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListWorkflowRulesResponse)
	err := c.cc.Invoke(ctx, WorkflowService_ListWorkflowRules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) TriggerWorkflowRule(ctx context.Context, in *TriggerWorkflowRuleRequest, opts ...grpc.CallOption) (*TriggerWorkflowRuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TriggerWorkflowRuleResponse)
	err := c.cc.Invoke(ctx, WorkflowService_TriggerWorkflowRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RecordWorkerHeartbeat(ctx context.Context, in *RecordWorkerHeartbeatRequest, opts ...grpc.CallOption) (*RecordWorkerHeartbeatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RecordWorkerHeartbeatResponse)
	err := c.cc.Invoke(ctx, WorkflowService_RecordWorkerHeartbeat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ListWorkers(ctx context.Context, in *ListWorkersRequest, opts ...grpc.CallOption) (*ListWorkersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListWorkersResponse)
	err := c.cc.Invoke(ctx, WorkflowService_ListWorkers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) UpdateTaskQueueConfig(ctx context.Context, in *UpdateTaskQueueConfigRequest, opts ...grpc.CallOption) (*UpdateTaskQueueConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateTaskQueueConfigResponse)
	err := c.cc.Invoke(ctx, WorkflowService_UpdateTaskQueueConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) FetchWorkerConfig(ctx context.Context, in *FetchWorkerConfigRequest, opts ...grpc.CallOption) (*FetchWorkerConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FetchWorkerConfigResponse)
	err := c.cc.Invoke(ctx, WorkflowService_FetchWorkerConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) UpdateWorkerConfig(ctx context.Context, in *UpdateWorkerConfigRequest, opts ...grpc.CallOption) (*UpdateWorkerConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateWorkerConfigResponse)
	err := c.cc.Invoke(ctx, WorkflowService_UpdateWorkerConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WorkflowServiceServer is the server API for WorkflowService service.
// All implementations must embed UnimplementedWorkflowServiceServer
// for forward compatibility.
//
// WorkflowService API defines how Temporal SDKs and other clients interact with the Temporal server
// to create and interact with workflows and activities.
//
// Users are expected to call `StartWorkflowExecution` to create a new workflow execution.
//
// To drive workflows, a worker using a Temporal SDK must exist which regularly polls for workflow
// and activity tasks from the service. For each workflow task, the sdk must process the
// (incremental or complete) event history and respond back with any newly generated commands.
//
// For each activity task, the worker is expected to execute the user's code which implements that
// activity, responding with completion or failure.
type WorkflowServiceServer interface {
	// RegisterNamespace creates a new namespace which can be used as a container for all resources.
	//
	// A Namespace is a top level entity within Temporal, and is used as a container for resources
	// like workflow executions, task queues, etc. A Namespace acts as a sandbox and provides
	// isolation for all resources within the namespace. All resources belongs to exactly one
	// namespace.
	RegisterNamespace(context.Context, *RegisterNamespaceRequest) (*RegisterNamespaceResponse, error)
	// DescribeNamespace returns the information and configuration for a registered namespace.
	DescribeNamespace(context.Context, *DescribeNamespaceRequest) (*DescribeNamespaceResponse, error)
	// ListNamespaces returns the information and configuration for all namespaces.
	ListNamespaces(context.Context, *ListNamespacesRequest) (*ListNamespacesResponse, error)
	// UpdateNamespace is used to update the information and configuration of a registered
	// namespace.
	UpdateNamespace(context.Context, *UpdateNamespaceRequest) (*UpdateNamespaceResponse, error)
	// DeprecateNamespace is used to update the state of a registered namespace to DEPRECATED.
	//
	// Once the namespace is deprecated it cannot be used to start new workflow executions. Existing
	// workflow executions will continue to run on deprecated namespaces.
	// Deprecated.
	//
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: Deprecated --)
	DeprecateNamespace(context.Context, *DeprecateNamespaceRequest) (*DeprecateNamespaceResponse, error)
	// StartWorkflowExecution starts a new workflow execution.
	//
	// It will create the execution with a `WORKFLOW_EXECUTION_STARTED` event in its history and
	// also schedule the first workflow task. Returns `WorkflowExecutionAlreadyStarted`, if an
	// instance already exists with same workflow id.
	StartWorkflowExecution(context.Context, *StartWorkflowExecutionRequest) (*StartWorkflowExecutionResponse, error)
	// ExecuteMultiOperation executes multiple operations within a single workflow.
	//
	// Operations are started atomically, meaning if *any* operation fails to be started, none are,
	// and the request fails. Upon start, the API returns only when *all* operations have a response.
	//
	// Upon failure, it returns `MultiOperationExecutionFailure` where the status code
	// equals the status code of the *first* operation that failed to be started.
	//
	// NOTE: Experimental API.
	ExecuteMultiOperation(context.Context, *ExecuteMultiOperationRequest) (*ExecuteMultiOperationResponse, error)
	// GetWorkflowExecutionHistory returns the history of specified workflow execution. Fails with
	// `NotFound` if the specified workflow execution is unknown to the service.
	GetWorkflowExecutionHistory(context.Context, *GetWorkflowExecutionHistoryRequest) (*GetWorkflowExecutionHistoryResponse, error)
	// GetWorkflowExecutionHistoryReverse returns the history of specified workflow execution in reverse
	// order (starting from last event). Fails with`NotFound` if the specified workflow execution is
	// unknown to the service.
	GetWorkflowExecutionHistoryReverse(context.Context, *GetWorkflowExecutionHistoryReverseRequest) (*GetWorkflowExecutionHistoryReverseResponse, error)
	// PollWorkflowTaskQueue is called by workers to make progress on workflows.
	//
	// A WorkflowTask is dispatched to callers for active workflow executions with pending workflow
	// tasks. The worker is expected to call `RespondWorkflowTaskCompleted` when it is done
	// processing the task. The service will create a `WorkflowTaskStarted` event in the history for
	// this task before handing it to the worker.
	//
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: We do not expose worker API to HTTP. --)
	PollWorkflowTaskQueue(context.Context, *PollWorkflowTaskQueueRequest) (*PollWorkflowTaskQueueResponse, error)
	// RespondWorkflowTaskCompleted is called by workers to successfully complete workflow tasks
	// they received from `PollWorkflowTaskQueue`.
	//
	// Completing a WorkflowTask will write a `WORKFLOW_TASK_COMPLETED` event to the workflow's
	// history, along with events corresponding to whatever commands the SDK generated while
	// executing the task (ex timer started, activity task scheduled, etc).
	//
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: We do not expose worker API to HTTP. --)
	RespondWorkflowTaskCompleted(context.Context, *RespondWorkflowTaskCompletedRequest) (*RespondWorkflowTaskCompletedResponse, error)
	// RespondWorkflowTaskFailed is called by workers to indicate the processing of a workflow task
	// failed.
	//
	// This results in a `WORKFLOW_TASK_FAILED` event written to the history, and a new workflow
	// task will be scheduled. This API can be used to report unhandled failures resulting from
	// applying the workflow task.
	//
	// Temporal will only append first WorkflowTaskFailed event to the history of workflow execution
	// for consecutive failures.
	//
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: We do not expose worker API to HTTP. --)
	RespondWorkflowTaskFailed(context.Context, *RespondWorkflowTaskFailedRequest) (*RespondWorkflowTaskFailedResponse, error)
	// PollActivityTaskQueue is called by workers to process activity tasks from a specific task
	// queue.
	//
	// The worker is expected to call one of the `RespondActivityTaskXXX` methods when it is done
	// processing the task.
	//
	// An activity task is dispatched whenever a `SCHEDULE_ACTIVITY_TASK` command is produced during
	// workflow execution. An in memory `ACTIVITY_TASK_STARTED` event is written to mutable state
	// before the task is dispatched to the worker. The started event, and the final event
	// (`ACTIVITY_TASK_COMPLETED` / `ACTIVITY_TASK_FAILED` / `ACTIVITY_TASK_TIMED_OUT`) will both be
	// written permanently to Workflow execution history when Activity is finished. This is done to
	// avoid writing many events in the case of a failure/retry loop.
	//
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: We do not expose worker API to HTTP. --)
	PollActivityTaskQueue(context.Context, *PollActivityTaskQueueRequest) (*PollActivityTaskQueueResponse, error)
	// RecordActivityTaskHeartbeat is optionally called by workers while they execute activities.
	//
	// If worker fails to heartbeat within the `heartbeat_timeout` interval for the activity task,
	// then it will be marked as timed out and an `ACTIVITY_TASK_TIMED_OUT` event will be written to
	// the workflow history. Calling `RecordActivityTaskHeartbeat` will fail with `NotFound` in
	// such situations, in that event, the SDK should request cancellation of the activity.
	RecordActivityTaskHeartbeat(context.Context, *RecordActivityTaskHeartbeatRequest) (*RecordActivityTaskHeartbeatResponse, error)
	// See `RecordActivityTaskHeartbeat`. This version allows clients to record heartbeats by
	// namespace/workflow id/activity id instead of task token.
	//
	// (-- api-linter: core::0136::prepositions=disabled
	//
	//	aip.dev/not-precedent: "By" is used to indicate request type. --)
	RecordActivityTaskHeartbeatById(context.Context, *RecordActivityTaskHeartbeatByIdRequest) (*RecordActivityTaskHeartbeatByIdResponse, error)
	// RespondActivityTaskCompleted is called by workers when they successfully complete an activity
	// task.
	//
	// This results in a new `ACTIVITY_TASK_COMPLETED` event being written to the workflow history
	// and a new workflow task created for the workflow. Fails with `NotFound` if the task token is
	// no longer valid due to activity timeout, already being completed, or never having existed.
	RespondActivityTaskCompleted(context.Context, *RespondActivityTaskCompletedRequest) (*RespondActivityTaskCompletedResponse, error)
	// See `RecordActivityTaskCompleted`. This version allows clients to record completions by
	// namespace/workflow id/activity id instead of task token.
	//
	// (-- api-linter: core::0136::prepositions=disabled
	//
	//	aip.dev/not-precedent: "By" is used to indicate request type. --)
	RespondActivityTaskCompletedById(context.Context, *RespondActivityTaskCompletedByIdRequest) (*RespondActivityTaskCompletedByIdResponse, error)
	// RespondActivityTaskFailed is called by workers when processing an activity task fails.
	//
	// This results in a new `ACTIVITY_TASK_FAILED` event being written to the workflow history and
	// a new workflow task created for the workflow. Fails with `NotFound` if the task token is no
	// longer valid due to activity timeout, already being completed, or never having existed.
	RespondActivityTaskFailed(context.Context, *RespondActivityTaskFailedRequest) (*RespondActivityTaskFailedResponse, error)
	// See `RecordActivityTaskFailed`. This version allows clients to record failures by
	// namespace/workflow id/activity id instead of task token.
	//
	// (-- api-linter: core::0136::prepositions=disabled
	//
	//	aip.dev/not-precedent: "By" is used to indicate request type. --)
	RespondActivityTaskFailedById(context.Context, *RespondActivityTaskFailedByIdRequest) (*RespondActivityTaskFailedByIdResponse, error)
	// RespondActivityTaskFailed is called by workers when processing an activity task fails.
	//
	// This results in a new `ACTIVITY_TASK_CANCELED` event being written to the workflow history
	// and a new workflow task created for the workflow. Fails with `NotFound` if the task token is
	// no longer valid due to activity timeout, already being completed, or never having existed.
	RespondActivityTaskCanceled(context.Context, *RespondActivityTaskCanceledRequest) (*RespondActivityTaskCanceledResponse, error)
	// See `RecordActivityTaskCanceled`. This version allows clients to record failures by
	// namespace/workflow id/activity id instead of task token.
	//
	// (-- api-linter: core::0136::prepositions=disabled
	//
	//	aip.dev/not-precedent: "By" is used to indicate request type. --)
	RespondActivityTaskCanceledById(context.Context, *RespondActivityTaskCanceledByIdRequest) (*RespondActivityTaskCanceledByIdResponse, error)
	// RequestCancelWorkflowExecution is called by workers when they want to request cancellation of
	// a workflow execution.
	//
	// This results in a new `WORKFLOW_EXECUTION_CANCEL_REQUESTED` event being written to the
	// workflow history and a new workflow task created for the workflow. It returns success if the requested
	// workflow is already closed. It fails with 'NotFound' if the requested workflow doesn't exist.
	RequestCancelWorkflowExecution(context.Context, *RequestCancelWorkflowExecutionRequest) (*RequestCancelWorkflowExecutionResponse, error)
	// SignalWorkflowExecution is used to send a signal to a running workflow execution.
	//
	// This results in a `WORKFLOW_EXECUTION_SIGNALED` event recorded in the history and a workflow
	// task being created for the execution.
	SignalWorkflowExecution(context.Context, *SignalWorkflowExecutionRequest) (*SignalWorkflowExecutionResponse, error)
	// SignalWithStartWorkflowExecution is used to ensure a signal is sent to a workflow, even if
	// it isn't yet started.
	//
	// If the workflow is running, a `WORKFLOW_EXECUTION_SIGNALED` event is recorded in the history
	// and a workflow task is generated.
	//
	// If the workflow is not running or not found, then the workflow is created with
	// `WORKFLOW_EXECUTION_STARTED` and `WORKFLOW_EXECUTION_SIGNALED` events in its history, and a
	// workflow task is generated.
	//
	// (-- api-linter: core::0136::prepositions=disabled
	//
	//	aip.dev/not-precedent: "With" is used to indicate combined operation. --)
	SignalWithStartWorkflowExecution(context.Context, *SignalWithStartWorkflowExecutionRequest) (*SignalWithStartWorkflowExecutionResponse, error)
	// ResetWorkflowExecution will reset an existing workflow execution to a specified
	// `WORKFLOW_TASK_COMPLETED` event (exclusive). It will immediately terminate the current
	// execution instance.
	// TODO: Does exclusive here mean *just* the completed event, or also WFT started? Otherwise the task is doomed to time out?
	ResetWorkflowExecution(context.Context, *ResetWorkflowExecutionRequest) (*ResetWorkflowExecutionResponse, error)
	// TerminateWorkflowExecution terminates an existing workflow execution by recording a
	// `WORKFLOW_EXECUTION_TERMINATED` event in the history and immediately terminating the
	// execution instance.
	TerminateWorkflowExecution(context.Context, *TerminateWorkflowExecutionRequest) (*TerminateWorkflowExecutionResponse, error)
	// DeleteWorkflowExecution asynchronously deletes a specific Workflow Execution (when
	// WorkflowExecution.run_id is provided) or the latest Workflow Execution (when
	// WorkflowExecution.run_id is not provided). If the Workflow Execution is Running, it will be
	// terminated before deletion.
	//
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: Workflow deletion not exposed to HTTP, users should use cancel or terminate. --)
	DeleteWorkflowExecution(context.Context, *DeleteWorkflowExecutionRequest) (*DeleteWorkflowExecutionResponse, error)
	// ListOpenWorkflowExecutions is a visibility API to list the open executions in a specific namespace.
	//
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: HTTP users should use ListWorkflowExecutions instead. --)
	ListOpenWorkflowExecutions(context.Context, *ListOpenWorkflowExecutionsRequest) (*ListOpenWorkflowExecutionsResponse, error)
	// ListClosedWorkflowExecutions is a visibility API to list the closed executions in a specific namespace.
	//
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: HTTP users should use ListWorkflowExecutions instead. --)
	ListClosedWorkflowExecutions(context.Context, *ListClosedWorkflowExecutionsRequest) (*ListClosedWorkflowExecutionsResponse, error)
	// ListWorkflowExecutions is a visibility API to list workflow executions in a specific namespace.
	ListWorkflowExecutions(context.Context, *ListWorkflowExecutionsRequest) (*ListWorkflowExecutionsResponse, error)
	// ListArchivedWorkflowExecutions is a visibility API to list archived workflow executions in a specific namespace.
	ListArchivedWorkflowExecutions(context.Context, *ListArchivedWorkflowExecutionsRequest) (*ListArchivedWorkflowExecutionsResponse, error)
	// ScanWorkflowExecutions is a visibility API to list large amount of workflow executions in a specific namespace without order.
	//
	// Deprecated: Replaced with `ListWorkflowExecutions`.
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: HTTP users should use ListWorkflowExecutions instead. --)
	ScanWorkflowExecutions(context.Context, *ScanWorkflowExecutionsRequest) (*ScanWorkflowExecutionsResponse, error)
	// CountWorkflowExecutions is a visibility API to count of workflow executions in a specific namespace.
	CountWorkflowExecutions(context.Context, *CountWorkflowExecutionsRequest) (*CountWorkflowExecutionsResponse, error)
	// GetSearchAttributes is a visibility API to get all legal keys that could be used in list APIs
	//
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: We do not expose this search attribute API to HTTP (but may expose on OperatorService). --)
	GetSearchAttributes(context.Context, *GetSearchAttributesRequest) (*GetSearchAttributesResponse, error)
	// RespondQueryTaskCompleted is called by workers to complete queries which were delivered on
	// the `query` (not `queries`) field of a `PollWorkflowTaskQueueResponse`.
	//
	// Completing the query will unblock the corresponding client call to `QueryWorkflow` and return
	// the query result a response.
	//
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: We do not expose worker API to HTTP. --)
	RespondQueryTaskCompleted(context.Context, *RespondQueryTaskCompletedRequest) (*RespondQueryTaskCompletedResponse, error)
	// ResetStickyTaskQueue resets the sticky task queue related information in the mutable state of
	// a given workflow. This is prudent for workers to perform if a workflow has been paged out of
	// their cache.
	//
	// Things cleared are:
	// 1. StickyTaskQueue
	// 2. StickyScheduleToStartTimeout
	//
	// When possible, ShutdownWorker should be preferred over
	// ResetStickyTaskQueue (particularly when a worker is shutting down or
	// cycling).
	//
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: We do not expose worker API to HTTP. --)
	ResetStickyTaskQueue(context.Context, *ResetStickyTaskQueueRequest) (*ResetStickyTaskQueueResponse, error)
	// ShutdownWorker is used to indicate that the given sticky task
	// queue is no longer being polled by its worker. Following the completion of
	// ShutdownWorker, newly-added workflow tasks will instead be placed
	// in the normal task queue, eligible for any worker to pick up.
	//
	// ShutdownWorker should be called by workers while shutting down,
	// after they've shut down their pollers. If another sticky poll
	// request is issued, the sticky task queue will be revived.
	//
	// As of Temporal Server v1.25.0, ShutdownWorker hasn't yet been implemented.
	//
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: We do not expose worker API to HTTP. --)
	ShutdownWorker(context.Context, *ShutdownWorkerRequest) (*ShutdownWorkerResponse, error)
	// QueryWorkflow requests a query be executed for a specified workflow execution.
	QueryWorkflow(context.Context, *QueryWorkflowRequest) (*QueryWorkflowResponse, error)
	// DescribeWorkflowExecution returns information about the specified workflow execution.
	DescribeWorkflowExecution(context.Context, *DescribeWorkflowExecutionRequest) (*DescribeWorkflowExecutionResponse, error)
	// DescribeTaskQueue returns the following information about the target task queue, broken down by Build ID:
	//   - List of pollers
	//   - Workflow Reachability status
	//   - Backlog info for Workflow and/or Activity tasks
	DescribeTaskQueue(context.Context, *DescribeTaskQueueRequest) (*DescribeTaskQueueResponse, error)
	// GetClusterInfo returns information about temporal cluster
	GetClusterInfo(context.Context, *GetClusterInfoRequest) (*GetClusterInfoResponse, error)
	// GetSystemInfo returns information about the system.
	GetSystemInfo(context.Context, *GetSystemInfoRequest) (*GetSystemInfoResponse, error)
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: We do not expose this low-level API to HTTP. --)
	ListTaskQueuePartitions(context.Context, *ListTaskQueuePartitionsRequest) (*ListTaskQueuePartitionsResponse, error)
	// Creates a new schedule.
	CreateSchedule(context.Context, *CreateScheduleRequest) (*CreateScheduleResponse, error)
	// Returns the schedule description and current state of an existing schedule.
	DescribeSchedule(context.Context, *DescribeScheduleRequest) (*DescribeScheduleResponse, error)
	// Changes the configuration or state of an existing schedule.
	UpdateSchedule(context.Context, *UpdateScheduleRequest) (*UpdateScheduleResponse, error)
	// Makes a specific change to a schedule or triggers an immediate action.
	PatchSchedule(context.Context, *PatchScheduleRequest) (*PatchScheduleResponse, error)
	// Lists matching times within a range.
	ListScheduleMatchingTimes(context.Context, *ListScheduleMatchingTimesRequest) (*ListScheduleMatchingTimesResponse, error)
	// Deletes a schedule, removing it from the system.
	DeleteSchedule(context.Context, *DeleteScheduleRequest) (*DeleteScheduleResponse, error)
	// List all schedules in a namespace.
	ListSchedules(context.Context, *ListSchedulesRequest) (*ListSchedulesResponse, error)
	// Deprecated. Use `UpdateWorkerVersioningRules`.
	//
	// Allows users to specify sets of worker build id versions on a per task queue basis. Versions
	// are ordered, and may be either compatible with some extant version, or a new incompatible
	// version, forming sets of ids which are incompatible with each other, but whose contained
	// members are compatible with one another.
	//
	// A single build id may be mapped to multiple task queues using this API for cases where a single process hosts
	// multiple workers.
	//
	// To query which workers can be retired, use the `GetWorkerTaskReachability` API.
	//
	// NOTE: The number of task queues mapped to a single build id is limited by the `limit.taskQueuesPerBuildId`
	// (default is 20), if this limit is exceeded this API will error with a FailedPrecondition.
	//
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: We do yet expose versioning API to HTTP. --)
	UpdateWorkerBuildIdCompatibility(context.Context, *UpdateWorkerBuildIdCompatibilityRequest) (*UpdateWorkerBuildIdCompatibilityResponse, error)
	// Deprecated. Use `GetWorkerVersioningRules`.
	// Fetches the worker build id versioning sets for a task queue.
	GetWorkerBuildIdCompatibility(context.Context, *GetWorkerBuildIdCompatibilityRequest) (*GetWorkerBuildIdCompatibilityResponse, error)
	// Use this API to manage Worker Versioning Rules for a given Task Queue. There are two types of
	// rules: Build ID Assignment rules and Compatible Build ID Redirect rules.
	//
	// Assignment rules determine how to assign new executions to a Build IDs. Their primary
	// use case is to specify the latest Build ID but they have powerful features for gradual rollout
	// of a new Build ID.
	//
	// Once a workflow execution is assigned to a Build ID and it completes its first Workflow Task,
	// the workflow stays on the assigned Build ID regardless of changes in assignment rules. This
	// eliminates the need for compatibility between versions when you only care about using the new
	// version for new workflows and let existing workflows finish in their own version.
	//
	// Activities, Child Workflows and Continue-as-New executions have the option to inherit the
	// Build ID of their parent/previous workflow or use the latest assignment rules to independently
	// select a Build ID.
	//
	// Redirect rules should only be used when you want to move workflows and activities assigned to
	// one Build ID (source) to another compatible Build ID (target). You are responsible to make sure
	// the target Build ID of a redirect rule is able to process event histories made by the source
	// Build ID by using [Patching](https://docs.temporal.io/workflows#patching) or other means.
	//
	// WARNING: Worker Versioning is not yet stable and the API and behavior may change incompatibly.
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: We do yet expose versioning API to HTTP. --)
	UpdateWorkerVersioningRules(context.Context, *UpdateWorkerVersioningRulesRequest) (*UpdateWorkerVersioningRulesResponse, error)
	// Fetches the Build ID assignment and redirect rules for a Task Queue.
	// WARNING: Worker Versioning is not yet stable and the API and behavior may change incompatibly.
	GetWorkerVersioningRules(context.Context, *GetWorkerVersioningRulesRequest) (*GetWorkerVersioningRulesResponse, error)
	// Deprecated. Use `DescribeTaskQueue`.
	//
	// Fetches task reachability to determine whether a worker may be retired.
	// The request may specify task queues to query for or let the server fetch all task queues mapped to the given
	// build IDs.
	//
	// When requesting a large number of task queues or all task queues associated with the given build ids in a
	// namespace, all task queues will be listed in the response but some of them may not contain reachability
	// information due to a server enforced limit. When reaching the limit, task queues that reachability information
	// could not be retrieved for will be marked with a single TASK_REACHABILITY_UNSPECIFIED entry. The caller may issue
	// another call to get the reachability for those task queues.
	//
	// Open source users can adjust this limit by setting the server's dynamic config value for
	// `limit.reachabilityTaskQueueScan` with the caveat that this call can strain the visibility store.
	GetWorkerTaskReachability(context.Context, *GetWorkerTaskReachabilityRequest) (*GetWorkerTaskReachabilityResponse, error)
	// Describes a worker deployment.
	// Experimental. This API might significantly change or be removed in a future release.
	// Deprecated. Replaced with `DescribeWorkerDeploymentVersion`.
	DescribeDeployment(context.Context, *DescribeDeploymentRequest) (*DescribeDeploymentResponse, error)
	// Describes a worker deployment version.
	// Experimental. This API might significantly change or be removed in a future release.
	DescribeWorkerDeploymentVersion(context.Context, *DescribeWorkerDeploymentVersionRequest) (*DescribeWorkerDeploymentVersionResponse, error)
	// Lists worker deployments in the namespace. Optionally can filter based on deployment series
	// name.
	// Experimental. This API might significantly change or be removed in a future release.
	// Deprecated. Replaced with `ListWorkerDeployments`.
	ListDeployments(context.Context, *ListDeploymentsRequest) (*ListDeploymentsResponse, error)
	// Returns the reachability level of a worker deployment to help users decide when it is time
	// to decommission a deployment. Reachability level is calculated based on the deployment's
	// `status` and existing workflows that depend on the given deployment for their execution.
	// Calculating reachability is relatively expensive. Therefore, server might return a recently
	// cached value. In such a case, the `last_update_time` will inform you about the actual
	// reachability calculation time.
	// Experimental. This API might significantly change or be removed in a future release.
	// Deprecated. Replaced with `DrainageInfo` returned by `DescribeWorkerDeploymentVersion`.
	GetDeploymentReachability(context.Context, *GetDeploymentReachabilityRequest) (*GetDeploymentReachabilityResponse, error)
	// Returns the current deployment (and its info) for a given deployment series.
	// Experimental. This API might significantly change or be removed in a future release.
	// Deprecated. Replaced by `current_version` returned by `DescribeWorkerDeployment`.
	GetCurrentDeployment(context.Context, *GetCurrentDeploymentRequest) (*GetCurrentDeploymentResponse, error)
	// Sets a deployment as the current deployment for its deployment series. Can optionally update
	// the metadata of the deployment as well.
	// Experimental. This API might significantly change or be removed in a future release.
	// Deprecated. Replaced by `SetWorkerDeploymentCurrentVersion`.
	SetCurrentDeployment(context.Context, *SetCurrentDeploymentRequest) (*SetCurrentDeploymentResponse, error)
	// Set/unset the Current Version of a Worker Deployment. Automatically unsets the Ramping
	// Version if it is the Version being set as Current.
	// Experimental. This API might significantly change or be removed in a future release.
	SetWorkerDeploymentCurrentVersion(context.Context, *SetWorkerDeploymentCurrentVersionRequest) (*SetWorkerDeploymentCurrentVersionResponse, error)
	// Describes a Worker Deployment.
	// Experimental. This API might significantly change or be removed in a future release.
	DescribeWorkerDeployment(context.Context, *DescribeWorkerDeploymentRequest) (*DescribeWorkerDeploymentResponse, error)
	// Deletes records of (an old) Deployment. A deployment can only be deleted if
	// it has no Version in it.
	// Experimental. This API might significantly change or be removed in a future release.
	DeleteWorkerDeployment(context.Context, *DeleteWorkerDeploymentRequest) (*DeleteWorkerDeploymentResponse, error)
	// Used for manual deletion of Versions. User can delete a Version only when all the
	// following conditions are met:
	//   - It is not the Current or Ramping Version of its Deployment.
	//   - It has no active pollers (none of the task queues in the Version have pollers)
	//   - It is not draining (see WorkerDeploymentVersionInfo.drainage_info). This condition
	//     can be skipped by passing `skip-drainage=true`.
	//
	// Experimental. This API might significantly change or be removed in a future release.
	DeleteWorkerDeploymentVersion(context.Context, *DeleteWorkerDeploymentVersionRequest) (*DeleteWorkerDeploymentVersionResponse, error)
	// Set/unset the Ramping Version of a Worker Deployment and its ramp percentage. Can be used for
	// gradual ramp to unversioned workers too.
	// Experimental. This API might significantly change or be removed in a future release.
	SetWorkerDeploymentRampingVersion(context.Context, *SetWorkerDeploymentRampingVersionRequest) (*SetWorkerDeploymentRampingVersionResponse, error)
	// Lists all Worker Deployments that are tracked in the Namespace.
	// Experimental. This API might significantly change or be removed in a future release.
	ListWorkerDeployments(context.Context, *ListWorkerDeploymentsRequest) (*ListWorkerDeploymentsResponse, error)
	// Updates the user-given metadata attached to a Worker Deployment Version.
	// Experimental. This API might significantly change or be removed in a future release.
	UpdateWorkerDeploymentVersionMetadata(context.Context, *UpdateWorkerDeploymentVersionMetadataRequest) (*UpdateWorkerDeploymentVersionMetadataResponse, error)
	// Invokes the specified Update function on user Workflow code.
	UpdateWorkflowExecution(context.Context, *UpdateWorkflowExecutionRequest) (*UpdateWorkflowExecutionResponse, error)
	// Polls a Workflow Execution for the outcome of a Workflow Update
	// previously issued through the UpdateWorkflowExecution RPC. The effective
	// timeout on this call will be shorter of the the caller-supplied gRPC
	// timeout and the server's configured long-poll timeout.
	//
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: We don't expose update polling API to HTTP in favor of a potential future non-blocking form. --)
	PollWorkflowExecutionUpdate(context.Context, *PollWorkflowExecutionUpdateRequest) (*PollWorkflowExecutionUpdateResponse, error)
	// StartBatchOperation starts a new batch operation
	StartBatchOperation(context.Context, *StartBatchOperationRequest) (*StartBatchOperationResponse, error)
	// StopBatchOperation stops a batch operation
	StopBatchOperation(context.Context, *StopBatchOperationRequest) (*StopBatchOperationResponse, error)
	// DescribeBatchOperation returns the information about a batch operation
	DescribeBatchOperation(context.Context, *DescribeBatchOperationRequest) (*DescribeBatchOperationResponse, error)
	// ListBatchOperations returns a list of batch operations
	ListBatchOperations(context.Context, *ListBatchOperationsRequest) (*ListBatchOperationsResponse, error)
	// PollNexusTaskQueue is a long poll call used by workers to receive Nexus tasks.
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: We do not expose worker API to HTTP. --)
	PollNexusTaskQueue(context.Context, *PollNexusTaskQueueRequest) (*PollNexusTaskQueueResponse, error)
	// RespondNexusTaskCompleted is called by workers to respond to Nexus tasks received via PollNexusTaskQueue.
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: We do not expose worker API to HTTP. --)
	RespondNexusTaskCompleted(context.Context, *RespondNexusTaskCompletedRequest) (*RespondNexusTaskCompletedResponse, error)
	// RespondNexusTaskFailed is called by workers to fail Nexus tasks received via PollNexusTaskQueue.
	// (-- api-linter: core::0127::http-annotation=disabled
	//
	//	aip.dev/not-precedent: We do not expose worker API to HTTP. --)
	RespondNexusTaskFailed(context.Context, *RespondNexusTaskFailedRequest) (*RespondNexusTaskFailedResponse, error)
	// UpdateActivityOptions is called by the client to update the options of an activity by its ID or type.
	// If there are multiple pending activities of the provided type - all of them will be updated.
	UpdateActivityOptions(context.Context, *UpdateActivityOptionsRequest) (*UpdateActivityOptionsResponse, error)
	// UpdateWorkflowExecutionOptions partially updates the WorkflowExecutionOptions of an existing workflow execution.
	UpdateWorkflowExecutionOptions(context.Context, *UpdateWorkflowExecutionOptionsRequest) (*UpdateWorkflowExecutionOptionsResponse, error)
	// PauseActivity pauses the execution of an activity specified by its ID or type.
	// If there are multiple pending activities of the provided type - all of them will be paused
	//
	// Pausing an activity means:
	//   - If the activity is currently waiting for a retry or is running and subsequently fails,
	//     it will not be rescheduled until it is unpaused.
	//   - If the activity is already paused, calling this method will have no effect.
	//   - If the activity is running and finishes successfully, the activity will be completed.
	//   - If the activity is running and finishes with failure:
	//   - if there is no retry left - the activity will be completed.
	//   - if there are more retries left - the activity will be paused.
	//
	// For long-running activities:
	// - activities in paused state will send a cancellation with "activity_paused" set to 'true' in response to 'RecordActivityTaskHeartbeat'.
	// - The activity should respond to the cancellation accordingly.
	//
	// Returns a `NotFound` error if there is no pending activity with the provided ID or type
	PauseActivity(context.Context, *PauseActivityRequest) (*PauseActivityResponse, error)
	// UnpauseActivity unpauses the execution of an activity specified by its ID or type.
	// If there are multiple pending activities of the provided type - all of them will be unpaused.
	//
	// If activity is not paused, this call will have no effect.
	// If the activity was paused while waiting for retry, it will be scheduled immediately (* see 'jitter' flag).
	// Once the activity is unpaused, all timeout timers will be regenerated.
	//
	// Flags:
	// 'jitter': the activity will be scheduled at a random time within the jitter duration.
	// 'reset_attempts': the number of attempts will be reset.
	// 'reset_heartbeat': the activity heartbeat timer and heartbeats will be reset.
	//
	// Returns a `NotFound` error if there is no pending activity with the provided ID or type
	UnpauseActivity(context.Context, *UnpauseActivityRequest) (*UnpauseActivityResponse, error)
	// ResetActivity resets the execution of an activity specified by its ID or type.
	// If there are multiple pending activities of the provided type - all of them will be reset.
	//
	// Resetting an activity means:
	//   - number of attempts will be reset to 0.
	//   - activity timeouts will be reset.
	//   - if the activity is waiting for retry, and it is not paused or 'keep_paused' is not provided:
	//     it will be scheduled immediately (* see 'jitter' flag),
	//
	// Flags:
	//
	// 'jitter': the activity will be scheduled at a random time within the jitter duration.
	// If the activity currently paused it will be unpaused, unless 'keep_paused' flag is provided.
	// 'reset_heartbeats': the activity heartbeat timer and heartbeats will be reset.
	// 'keep_paused': if the activity is paused, it will remain paused.
	//
	// Returns a `NotFound` error if there is no pending activity with the provided ID or type.
	ResetActivity(context.Context, *ResetActivityRequest) (*ResetActivityResponse, error)
	// Create a new workflow rule. The rules are used to control the workflow execution.
	// The rule will be applied to all running and new workflows in the namespace.
	// If the rule with such ID already exist this call will fail
	// Note: the rules are part of namespace configuration and will be stored in the namespace config.
	// Namespace config is eventually consistent.
	CreateWorkflowRule(context.Context, *CreateWorkflowRuleRequest) (*CreateWorkflowRuleResponse, error)
	// DescribeWorkflowRule return the rule specification for existing rule id.
	// If there is no rule with such id - NOT FOUND error will be returned.
	DescribeWorkflowRule(context.Context, *DescribeWorkflowRuleRequest) (*DescribeWorkflowRuleResponse, error)
	// Delete rule by rule id
	DeleteWorkflowRule(context.Context, *DeleteWorkflowRuleRequest) (*DeleteWorkflowRuleResponse, error)
	// Return all namespace workflow rules
	ListWorkflowRules(context.Context, *ListWorkflowRulesRequest) (*ListWorkflowRulesResponse, error)
	// TriggerWorkflowRule allows to:
	//   - trigger existing rule for a specific workflow execution;
	//   - trigger rule for a specific workflow execution without creating a rule;
	//
	// This is useful for one-off operations.
	TriggerWorkflowRule(context.Context, *TriggerWorkflowRuleRequest) (*TriggerWorkflowRuleResponse, error)
	// WorkerHeartbeat receive heartbeat request from the worker.
	RecordWorkerHeartbeat(context.Context, *RecordWorkerHeartbeatRequest) (*RecordWorkerHeartbeatResponse, error)
	// ListWorkers is a visibility API to list worker status information in a specific namespace.
	ListWorkers(context.Context, *ListWorkersRequest) (*ListWorkersResponse, error)
	// Updates task queue configuration.
	// For the overall queue rate limit: the rate limit set by this api overrides the worker-set rate limit,
	// which uncouples the rate limit from the worker lifecycle.
	// If the overall queue rate limit is unset, the worker-set rate limit takes effect.
	UpdateTaskQueueConfig(context.Context, *UpdateTaskQueueConfigRequest) (*UpdateTaskQueueConfigResponse, error)
	// FetchWorkerConfig returns the worker configuration for a specific worker.
	FetchWorkerConfig(context.Context, *FetchWorkerConfigRequest) (*FetchWorkerConfigResponse, error)
	// UpdateWorkerConfig updates the worker configuration of one or more workers.
	// Can be used to partially update the worker configuration.
	// Can be used to update the configuration of multiple workers.
	UpdateWorkerConfig(context.Context, *UpdateWorkerConfigRequest) (*UpdateWorkerConfigResponse, error)
	mustEmbedUnimplementedWorkflowServiceServer()
}

// UnimplementedWorkflowServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedWorkflowServiceServer struct{}

func (UnimplementedWorkflowServiceServer) RegisterNamespace(context.Context, *RegisterNamespaceRequest) (*RegisterNamespaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterNamespace not implemented")
}
func (UnimplementedWorkflowServiceServer) DescribeNamespace(context.Context, *DescribeNamespaceRequest) (*DescribeNamespaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeNamespace not implemented")
}
func (UnimplementedWorkflowServiceServer) ListNamespaces(context.Context, *ListNamespacesRequest) (*ListNamespacesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNamespaces not implemented")
}
func (UnimplementedWorkflowServiceServer) UpdateNamespace(context.Context, *UpdateNamespaceRequest) (*UpdateNamespaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNamespace not implemented")
}
func (UnimplementedWorkflowServiceServer) DeprecateNamespace(context.Context, *DeprecateNamespaceRequest) (*DeprecateNamespaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeprecateNamespace not implemented")
}
func (UnimplementedWorkflowServiceServer) StartWorkflowExecution(context.Context, *StartWorkflowExecutionRequest) (*StartWorkflowExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartWorkflowExecution not implemented")
}
func (UnimplementedWorkflowServiceServer) ExecuteMultiOperation(context.Context, *ExecuteMultiOperationRequest) (*ExecuteMultiOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteMultiOperation not implemented")
}
func (UnimplementedWorkflowServiceServer) GetWorkflowExecutionHistory(context.Context, *GetWorkflowExecutionHistoryRequest) (*GetWorkflowExecutionHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkflowExecutionHistory not implemented")
}
func (UnimplementedWorkflowServiceServer) GetWorkflowExecutionHistoryReverse(context.Context, *GetWorkflowExecutionHistoryReverseRequest) (*GetWorkflowExecutionHistoryReverseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkflowExecutionHistoryReverse not implemented")
}
func (UnimplementedWorkflowServiceServer) PollWorkflowTaskQueue(context.Context, *PollWorkflowTaskQueueRequest) (*PollWorkflowTaskQueueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PollWorkflowTaskQueue not implemented")
}
func (UnimplementedWorkflowServiceServer) RespondWorkflowTaskCompleted(context.Context, *RespondWorkflowTaskCompletedRequest) (*RespondWorkflowTaskCompletedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondWorkflowTaskCompleted not implemented")
}
func (UnimplementedWorkflowServiceServer) RespondWorkflowTaskFailed(context.Context, *RespondWorkflowTaskFailedRequest) (*RespondWorkflowTaskFailedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondWorkflowTaskFailed not implemented")
}
func (UnimplementedWorkflowServiceServer) PollActivityTaskQueue(context.Context, *PollActivityTaskQueueRequest) (*PollActivityTaskQueueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PollActivityTaskQueue not implemented")
}
func (UnimplementedWorkflowServiceServer) RecordActivityTaskHeartbeat(context.Context, *RecordActivityTaskHeartbeatRequest) (*RecordActivityTaskHeartbeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecordActivityTaskHeartbeat not implemented")
}
func (UnimplementedWorkflowServiceServer) RecordActivityTaskHeartbeatById(context.Context, *RecordActivityTaskHeartbeatByIdRequest) (*RecordActivityTaskHeartbeatByIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecordActivityTaskHeartbeatById not implemented")
}
func (UnimplementedWorkflowServiceServer) RespondActivityTaskCompleted(context.Context, *RespondActivityTaskCompletedRequest) (*RespondActivityTaskCompletedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondActivityTaskCompleted not implemented")
}
func (UnimplementedWorkflowServiceServer) RespondActivityTaskCompletedById(context.Context, *RespondActivityTaskCompletedByIdRequest) (*RespondActivityTaskCompletedByIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondActivityTaskCompletedById not implemented")
}
func (UnimplementedWorkflowServiceServer) RespondActivityTaskFailed(context.Context, *RespondActivityTaskFailedRequest) (*RespondActivityTaskFailedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondActivityTaskFailed not implemented")
}
func (UnimplementedWorkflowServiceServer) RespondActivityTaskFailedById(context.Context, *RespondActivityTaskFailedByIdRequest) (*RespondActivityTaskFailedByIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondActivityTaskFailedById not implemented")
}
func (UnimplementedWorkflowServiceServer) RespondActivityTaskCanceled(context.Context, *RespondActivityTaskCanceledRequest) (*RespondActivityTaskCanceledResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondActivityTaskCanceled not implemented")
}
func (UnimplementedWorkflowServiceServer) RespondActivityTaskCanceledById(context.Context, *RespondActivityTaskCanceledByIdRequest) (*RespondActivityTaskCanceledByIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondActivityTaskCanceledById not implemented")
}
func (UnimplementedWorkflowServiceServer) RequestCancelWorkflowExecution(context.Context, *RequestCancelWorkflowExecutionRequest) (*RequestCancelWorkflowExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestCancelWorkflowExecution not implemented")
}
func (UnimplementedWorkflowServiceServer) SignalWorkflowExecution(context.Context, *SignalWorkflowExecutionRequest) (*SignalWorkflowExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignalWorkflowExecution not implemented")
}
func (UnimplementedWorkflowServiceServer) SignalWithStartWorkflowExecution(context.Context, *SignalWithStartWorkflowExecutionRequest) (*SignalWithStartWorkflowExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignalWithStartWorkflowExecution not implemented")
}
func (UnimplementedWorkflowServiceServer) ResetWorkflowExecution(context.Context, *ResetWorkflowExecutionRequest) (*ResetWorkflowExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetWorkflowExecution not implemented")
}
func (UnimplementedWorkflowServiceServer) TerminateWorkflowExecution(context.Context, *TerminateWorkflowExecutionRequest) (*TerminateWorkflowExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TerminateWorkflowExecution not implemented")
}
func (UnimplementedWorkflowServiceServer) DeleteWorkflowExecution(context.Context, *DeleteWorkflowExecutionRequest) (*DeleteWorkflowExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteWorkflowExecution not implemented")
}
func (UnimplementedWorkflowServiceServer) ListOpenWorkflowExecutions(context.Context, *ListOpenWorkflowExecutionsRequest) (*ListOpenWorkflowExecutionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListOpenWorkflowExecutions not implemented")
}
func (UnimplementedWorkflowServiceServer) ListClosedWorkflowExecutions(context.Context, *ListClosedWorkflowExecutionsRequest) (*ListClosedWorkflowExecutionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListClosedWorkflowExecutions not implemented")
}
func (UnimplementedWorkflowServiceServer) ListWorkflowExecutions(context.Context, *ListWorkflowExecutionsRequest) (*ListWorkflowExecutionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListWorkflowExecutions not implemented")
}
func (UnimplementedWorkflowServiceServer) ListArchivedWorkflowExecutions(context.Context, *ListArchivedWorkflowExecutionsRequest) (*ListArchivedWorkflowExecutionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListArchivedWorkflowExecutions not implemented")
}
func (UnimplementedWorkflowServiceServer) ScanWorkflowExecutions(context.Context, *ScanWorkflowExecutionsRequest) (*ScanWorkflowExecutionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ScanWorkflowExecutions not implemented")
}
func (UnimplementedWorkflowServiceServer) CountWorkflowExecutions(context.Context, *CountWorkflowExecutionsRequest) (*CountWorkflowExecutionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountWorkflowExecutions not implemented")
}
func (UnimplementedWorkflowServiceServer) GetSearchAttributes(context.Context, *GetSearchAttributesRequest) (*GetSearchAttributesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSearchAttributes not implemented")
}
func (UnimplementedWorkflowServiceServer) RespondQueryTaskCompleted(context.Context, *RespondQueryTaskCompletedRequest) (*RespondQueryTaskCompletedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondQueryTaskCompleted not implemented")
}
func (UnimplementedWorkflowServiceServer) ResetStickyTaskQueue(context.Context, *ResetStickyTaskQueueRequest) (*ResetStickyTaskQueueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetStickyTaskQueue not implemented")
}
func (UnimplementedWorkflowServiceServer) ShutdownWorker(context.Context, *ShutdownWorkerRequest) (*ShutdownWorkerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShutdownWorker not implemented")
}
func (UnimplementedWorkflowServiceServer) QueryWorkflow(context.Context, *QueryWorkflowRequest) (*QueryWorkflowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryWorkflow not implemented")
}
func (UnimplementedWorkflowServiceServer) DescribeWorkflowExecution(context.Context, *DescribeWorkflowExecutionRequest) (*DescribeWorkflowExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeWorkflowExecution not implemented")
}
func (UnimplementedWorkflowServiceServer) DescribeTaskQueue(context.Context, *DescribeTaskQueueRequest) (*DescribeTaskQueueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeTaskQueue not implemented")
}
func (UnimplementedWorkflowServiceServer) GetClusterInfo(context.Context, *GetClusterInfoRequest) (*GetClusterInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterInfo not implemented")
}
func (UnimplementedWorkflowServiceServer) GetSystemInfo(context.Context, *GetSystemInfoRequest) (*GetSystemInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSystemInfo not implemented")
}
func (UnimplementedWorkflowServiceServer) ListTaskQueuePartitions(context.Context, *ListTaskQueuePartitionsRequest) (*ListTaskQueuePartitionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTaskQueuePartitions not implemented")
}
func (UnimplementedWorkflowServiceServer) CreateSchedule(context.Context, *CreateScheduleRequest) (*CreateScheduleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSchedule not implemented")
}
func (UnimplementedWorkflowServiceServer) DescribeSchedule(context.Context, *DescribeScheduleRequest) (*DescribeScheduleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeSchedule not implemented")
}
func (UnimplementedWorkflowServiceServer) UpdateSchedule(context.Context, *UpdateScheduleRequest) (*UpdateScheduleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSchedule not implemented")
}
func (UnimplementedWorkflowServiceServer) PatchSchedule(context.Context, *PatchScheduleRequest) (*PatchScheduleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PatchSchedule not implemented")
}
func (UnimplementedWorkflowServiceServer) ListScheduleMatchingTimes(context.Context, *ListScheduleMatchingTimesRequest) (*ListScheduleMatchingTimesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListScheduleMatchingTimes not implemented")
}
func (UnimplementedWorkflowServiceServer) DeleteSchedule(context.Context, *DeleteScheduleRequest) (*DeleteScheduleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSchedule not implemented")
}
func (UnimplementedWorkflowServiceServer) ListSchedules(context.Context, *ListSchedulesRequest) (*ListSchedulesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSchedules not implemented")
}
func (UnimplementedWorkflowServiceServer) UpdateWorkerBuildIdCompatibility(context.Context, *UpdateWorkerBuildIdCompatibilityRequest) (*UpdateWorkerBuildIdCompatibilityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateWorkerBuildIdCompatibility not implemented")
}
func (UnimplementedWorkflowServiceServer) GetWorkerBuildIdCompatibility(context.Context, *GetWorkerBuildIdCompatibilityRequest) (*GetWorkerBuildIdCompatibilityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkerBuildIdCompatibility not implemented")
}
func (UnimplementedWorkflowServiceServer) UpdateWorkerVersioningRules(context.Context, *UpdateWorkerVersioningRulesRequest) (*UpdateWorkerVersioningRulesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateWorkerVersioningRules not implemented")
}
func (UnimplementedWorkflowServiceServer) GetWorkerVersioningRules(context.Context, *GetWorkerVersioningRulesRequest) (*GetWorkerVersioningRulesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkerVersioningRules not implemented")
}
func (UnimplementedWorkflowServiceServer) GetWorkerTaskReachability(context.Context, *GetWorkerTaskReachabilityRequest) (*GetWorkerTaskReachabilityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkerTaskReachability not implemented")
}
func (UnimplementedWorkflowServiceServer) DescribeDeployment(context.Context, *DescribeDeploymentRequest) (*DescribeDeploymentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeDeployment not implemented")
}
func (UnimplementedWorkflowServiceServer) DescribeWorkerDeploymentVersion(context.Context, *DescribeWorkerDeploymentVersionRequest) (*DescribeWorkerDeploymentVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeWorkerDeploymentVersion not implemented")
}
func (UnimplementedWorkflowServiceServer) ListDeployments(context.Context, *ListDeploymentsRequest) (*ListDeploymentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDeployments not implemented")
}
func (UnimplementedWorkflowServiceServer) GetDeploymentReachability(context.Context, *GetDeploymentReachabilityRequest) (*GetDeploymentReachabilityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDeploymentReachability not implemented")
}
func (UnimplementedWorkflowServiceServer) GetCurrentDeployment(context.Context, *GetCurrentDeploymentRequest) (*GetCurrentDeploymentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCurrentDeployment not implemented")
}
func (UnimplementedWorkflowServiceServer) SetCurrentDeployment(context.Context, *SetCurrentDeploymentRequest) (*SetCurrentDeploymentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCurrentDeployment not implemented")
}
func (UnimplementedWorkflowServiceServer) SetWorkerDeploymentCurrentVersion(context.Context, *SetWorkerDeploymentCurrentVersionRequest) (*SetWorkerDeploymentCurrentVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetWorkerDeploymentCurrentVersion not implemented")
}
func (UnimplementedWorkflowServiceServer) DescribeWorkerDeployment(context.Context, *DescribeWorkerDeploymentRequest) (*DescribeWorkerDeploymentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeWorkerDeployment not implemented")
}
func (UnimplementedWorkflowServiceServer) DeleteWorkerDeployment(context.Context, *DeleteWorkerDeploymentRequest) (*DeleteWorkerDeploymentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteWorkerDeployment not implemented")
}
func (UnimplementedWorkflowServiceServer) DeleteWorkerDeploymentVersion(context.Context, *DeleteWorkerDeploymentVersionRequest) (*DeleteWorkerDeploymentVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteWorkerDeploymentVersion not implemented")
}
func (UnimplementedWorkflowServiceServer) SetWorkerDeploymentRampingVersion(context.Context, *SetWorkerDeploymentRampingVersionRequest) (*SetWorkerDeploymentRampingVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetWorkerDeploymentRampingVersion not implemented")
}
func (UnimplementedWorkflowServiceServer) ListWorkerDeployments(context.Context, *ListWorkerDeploymentsRequest) (*ListWorkerDeploymentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListWorkerDeployments not implemented")
}
func (UnimplementedWorkflowServiceServer) UpdateWorkerDeploymentVersionMetadata(context.Context, *UpdateWorkerDeploymentVersionMetadataRequest) (*UpdateWorkerDeploymentVersionMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateWorkerDeploymentVersionMetadata not implemented")
}
func (UnimplementedWorkflowServiceServer) UpdateWorkflowExecution(context.Context, *UpdateWorkflowExecutionRequest) (*UpdateWorkflowExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateWorkflowExecution not implemented")
}
func (UnimplementedWorkflowServiceServer) PollWorkflowExecutionUpdate(context.Context, *PollWorkflowExecutionUpdateRequest) (*PollWorkflowExecutionUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PollWorkflowExecutionUpdate not implemented")
}
func (UnimplementedWorkflowServiceServer) StartBatchOperation(context.Context, *StartBatchOperationRequest) (*StartBatchOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartBatchOperation not implemented")
}
func (UnimplementedWorkflowServiceServer) StopBatchOperation(context.Context, *StopBatchOperationRequest) (*StopBatchOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopBatchOperation not implemented")
}
func (UnimplementedWorkflowServiceServer) DescribeBatchOperation(context.Context, *DescribeBatchOperationRequest) (*DescribeBatchOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeBatchOperation not implemented")
}
func (UnimplementedWorkflowServiceServer) ListBatchOperations(context.Context, *ListBatchOperationsRequest) (*ListBatchOperationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBatchOperations not implemented")
}
func (UnimplementedWorkflowServiceServer) PollNexusTaskQueue(context.Context, *PollNexusTaskQueueRequest) (*PollNexusTaskQueueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PollNexusTaskQueue not implemented")
}
func (UnimplementedWorkflowServiceServer) RespondNexusTaskCompleted(context.Context, *RespondNexusTaskCompletedRequest) (*RespondNexusTaskCompletedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondNexusTaskCompleted not implemented")
}
func (UnimplementedWorkflowServiceServer) RespondNexusTaskFailed(context.Context, *RespondNexusTaskFailedRequest) (*RespondNexusTaskFailedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondNexusTaskFailed not implemented")
}
func (UnimplementedWorkflowServiceServer) UpdateActivityOptions(context.Context, *UpdateActivityOptionsRequest) (*UpdateActivityOptionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateActivityOptions not implemented")
}
func (UnimplementedWorkflowServiceServer) UpdateWorkflowExecutionOptions(context.Context, *UpdateWorkflowExecutionOptionsRequest) (*UpdateWorkflowExecutionOptionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateWorkflowExecutionOptions not implemented")
}
func (UnimplementedWorkflowServiceServer) PauseActivity(context.Context, *PauseActivityRequest) (*PauseActivityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PauseActivity not implemented")
}
func (UnimplementedWorkflowServiceServer) UnpauseActivity(context.Context, *UnpauseActivityRequest) (*UnpauseActivityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnpauseActivity not implemented")
}
func (UnimplementedWorkflowServiceServer) ResetActivity(context.Context, *ResetActivityRequest) (*ResetActivityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetActivity not implemented")
}
func (UnimplementedWorkflowServiceServer) CreateWorkflowRule(context.Context, *CreateWorkflowRuleRequest) (*CreateWorkflowRuleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateWorkflowRule not implemented")
}
func (UnimplementedWorkflowServiceServer) DescribeWorkflowRule(context.Context, *DescribeWorkflowRuleRequest) (*DescribeWorkflowRuleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeWorkflowRule not implemented")
}
func (UnimplementedWorkflowServiceServer) DeleteWorkflowRule(context.Context, *DeleteWorkflowRuleRequest) (*DeleteWorkflowRuleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteWorkflowRule not implemented")
}
func (UnimplementedWorkflowServiceServer) ListWorkflowRules(context.Context, *ListWorkflowRulesRequest) (*ListWorkflowRulesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListWorkflowRules not implemented")
}
func (UnimplementedWorkflowServiceServer) TriggerWorkflowRule(context.Context, *TriggerWorkflowRuleRequest) (*TriggerWorkflowRuleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TriggerWorkflowRule not implemented")
}
func (UnimplementedWorkflowServiceServer) RecordWorkerHeartbeat(context.Context, *RecordWorkerHeartbeatRequest) (*RecordWorkerHeartbeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecordWorkerHeartbeat not implemented")
}
func (UnimplementedWorkflowServiceServer) ListWorkers(context.Context, *ListWorkersRequest) (*ListWorkersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListWorkers not implemented")
}
func (UnimplementedWorkflowServiceServer) UpdateTaskQueueConfig(context.Context, *UpdateTaskQueueConfigRequest) (*UpdateTaskQueueConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTaskQueueConfig not implemented")
}
func (UnimplementedWorkflowServiceServer) FetchWorkerConfig(context.Context, *FetchWorkerConfigRequest) (*FetchWorkerConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FetchWorkerConfig not implemented")
}
func (UnimplementedWorkflowServiceServer) UpdateWorkerConfig(context.Context, *UpdateWorkerConfigRequest) (*UpdateWorkerConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateWorkerConfig not implemented")
}
func (UnimplementedWorkflowServiceServer) mustEmbedUnimplementedWorkflowServiceServer() {}
func (UnimplementedWorkflowServiceServer) testEmbeddedByValue()                         {}

// UnsafeWorkflowServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WorkflowServiceServer will
// result in compilation errors.
type UnsafeWorkflowServiceServer interface {
	mustEmbedUnimplementedWorkflowServiceServer()
}

func RegisterWorkflowServiceServer(s grpc.ServiceRegistrar, srv WorkflowServiceServer) {
	// If the following call pancis, it indicates UnimplementedWorkflowServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&WorkflowService_ServiceDesc, srv)
}

func _WorkflowService_RegisterNamespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterNamespaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RegisterNamespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_RegisterNamespace_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RegisterNamespace(ctx, req.(*RegisterNamespaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_DescribeNamespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeNamespaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).DescribeNamespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_DescribeNamespace_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).DescribeNamespace(ctx, req.(*DescribeNamespaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ListNamespaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNamespacesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ListNamespaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_ListNamespaces_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ListNamespaces(ctx, req.(*ListNamespacesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_UpdateNamespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateNamespaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).UpdateNamespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_UpdateNamespace_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).UpdateNamespace(ctx, req.(*UpdateNamespaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_DeprecateNamespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeprecateNamespaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).DeprecateNamespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_DeprecateNamespace_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).DeprecateNamespace(ctx, req.(*DeprecateNamespaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_StartWorkflowExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartWorkflowExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).StartWorkflowExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_StartWorkflowExecution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).StartWorkflowExecution(ctx, req.(*StartWorkflowExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ExecuteMultiOperation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteMultiOperationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ExecuteMultiOperation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_ExecuteMultiOperation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ExecuteMultiOperation(ctx, req.(*ExecuteMultiOperationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_GetWorkflowExecutionHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWorkflowExecutionHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).GetWorkflowExecutionHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_GetWorkflowExecutionHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).GetWorkflowExecutionHistory(ctx, req.(*GetWorkflowExecutionHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_GetWorkflowExecutionHistoryReverse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWorkflowExecutionHistoryReverseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).GetWorkflowExecutionHistoryReverse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_GetWorkflowExecutionHistoryReverse_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).GetWorkflowExecutionHistoryReverse(ctx, req.(*GetWorkflowExecutionHistoryReverseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_PollWorkflowTaskQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PollWorkflowTaskQueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).PollWorkflowTaskQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_PollWorkflowTaskQueue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).PollWorkflowTaskQueue(ctx, req.(*PollWorkflowTaskQueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RespondWorkflowTaskCompleted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondWorkflowTaskCompletedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RespondWorkflowTaskCompleted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_RespondWorkflowTaskCompleted_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RespondWorkflowTaskCompleted(ctx, req.(*RespondWorkflowTaskCompletedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RespondWorkflowTaskFailed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondWorkflowTaskFailedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RespondWorkflowTaskFailed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_RespondWorkflowTaskFailed_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RespondWorkflowTaskFailed(ctx, req.(*RespondWorkflowTaskFailedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_PollActivityTaskQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PollActivityTaskQueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).PollActivityTaskQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_PollActivityTaskQueue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).PollActivityTaskQueue(ctx, req.(*PollActivityTaskQueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RecordActivityTaskHeartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordActivityTaskHeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RecordActivityTaskHeartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_RecordActivityTaskHeartbeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RecordActivityTaskHeartbeat(ctx, req.(*RecordActivityTaskHeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RecordActivityTaskHeartbeatById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordActivityTaskHeartbeatByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RecordActivityTaskHeartbeatById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_RecordActivityTaskHeartbeatById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RecordActivityTaskHeartbeatById(ctx, req.(*RecordActivityTaskHeartbeatByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RespondActivityTaskCompleted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondActivityTaskCompletedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RespondActivityTaskCompleted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_RespondActivityTaskCompleted_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RespondActivityTaskCompleted(ctx, req.(*RespondActivityTaskCompletedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RespondActivityTaskCompletedById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondActivityTaskCompletedByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RespondActivityTaskCompletedById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_RespondActivityTaskCompletedById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RespondActivityTaskCompletedById(ctx, req.(*RespondActivityTaskCompletedByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RespondActivityTaskFailed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondActivityTaskFailedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RespondActivityTaskFailed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_RespondActivityTaskFailed_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RespondActivityTaskFailed(ctx, req.(*RespondActivityTaskFailedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RespondActivityTaskFailedById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondActivityTaskFailedByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RespondActivityTaskFailedById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_RespondActivityTaskFailedById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RespondActivityTaskFailedById(ctx, req.(*RespondActivityTaskFailedByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RespondActivityTaskCanceled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondActivityTaskCanceledRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RespondActivityTaskCanceled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_RespondActivityTaskCanceled_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RespondActivityTaskCanceled(ctx, req.(*RespondActivityTaskCanceledRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RespondActivityTaskCanceledById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondActivityTaskCanceledByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RespondActivityTaskCanceledById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_RespondActivityTaskCanceledById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RespondActivityTaskCanceledById(ctx, req.(*RespondActivityTaskCanceledByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RequestCancelWorkflowExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestCancelWorkflowExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RequestCancelWorkflowExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_RequestCancelWorkflowExecution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RequestCancelWorkflowExecution(ctx, req.(*RequestCancelWorkflowExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_SignalWorkflowExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignalWorkflowExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).SignalWorkflowExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_SignalWorkflowExecution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).SignalWorkflowExecution(ctx, req.(*SignalWorkflowExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_SignalWithStartWorkflowExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignalWithStartWorkflowExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).SignalWithStartWorkflowExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_SignalWithStartWorkflowExecution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).SignalWithStartWorkflowExecution(ctx, req.(*SignalWithStartWorkflowExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ResetWorkflowExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetWorkflowExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ResetWorkflowExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_ResetWorkflowExecution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ResetWorkflowExecution(ctx, req.(*ResetWorkflowExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_TerminateWorkflowExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TerminateWorkflowExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).TerminateWorkflowExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_TerminateWorkflowExecution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).TerminateWorkflowExecution(ctx, req.(*TerminateWorkflowExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_DeleteWorkflowExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteWorkflowExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).DeleteWorkflowExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_DeleteWorkflowExecution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).DeleteWorkflowExecution(ctx, req.(*DeleteWorkflowExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ListOpenWorkflowExecutions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOpenWorkflowExecutionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ListOpenWorkflowExecutions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_ListOpenWorkflowExecutions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ListOpenWorkflowExecutions(ctx, req.(*ListOpenWorkflowExecutionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ListClosedWorkflowExecutions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListClosedWorkflowExecutionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ListClosedWorkflowExecutions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_ListClosedWorkflowExecutions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ListClosedWorkflowExecutions(ctx, req.(*ListClosedWorkflowExecutionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ListWorkflowExecutions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListWorkflowExecutionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ListWorkflowExecutions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_ListWorkflowExecutions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ListWorkflowExecutions(ctx, req.(*ListWorkflowExecutionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ListArchivedWorkflowExecutions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListArchivedWorkflowExecutionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ListArchivedWorkflowExecutions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_ListArchivedWorkflowExecutions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ListArchivedWorkflowExecutions(ctx, req.(*ListArchivedWorkflowExecutionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ScanWorkflowExecutions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScanWorkflowExecutionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ScanWorkflowExecutions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_ScanWorkflowExecutions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ScanWorkflowExecutions(ctx, req.(*ScanWorkflowExecutionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_CountWorkflowExecutions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountWorkflowExecutionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).CountWorkflowExecutions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_CountWorkflowExecutions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).CountWorkflowExecutions(ctx, req.(*CountWorkflowExecutionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_GetSearchAttributes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSearchAttributesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).GetSearchAttributes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_GetSearchAttributes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).GetSearchAttributes(ctx, req.(*GetSearchAttributesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RespondQueryTaskCompleted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondQueryTaskCompletedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RespondQueryTaskCompleted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_RespondQueryTaskCompleted_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RespondQueryTaskCompleted(ctx, req.(*RespondQueryTaskCompletedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ResetStickyTaskQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetStickyTaskQueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ResetStickyTaskQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_ResetStickyTaskQueue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ResetStickyTaskQueue(ctx, req.(*ResetStickyTaskQueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ShutdownWorker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShutdownWorkerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ShutdownWorker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_ShutdownWorker_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ShutdownWorker(ctx, req.(*ShutdownWorkerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_QueryWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).QueryWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_QueryWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).QueryWorkflow(ctx, req.(*QueryWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_DescribeWorkflowExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeWorkflowExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).DescribeWorkflowExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_DescribeWorkflowExecution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).DescribeWorkflowExecution(ctx, req.(*DescribeWorkflowExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_DescribeTaskQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeTaskQueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).DescribeTaskQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_DescribeTaskQueue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).DescribeTaskQueue(ctx, req.(*DescribeTaskQueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_GetClusterInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClusterInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).GetClusterInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_GetClusterInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).GetClusterInfo(ctx, req.(*GetClusterInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_GetSystemInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSystemInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).GetSystemInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_GetSystemInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).GetSystemInfo(ctx, req.(*GetSystemInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ListTaskQueuePartitions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTaskQueuePartitionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ListTaskQueuePartitions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_ListTaskQueuePartitions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ListTaskQueuePartitions(ctx, req.(*ListTaskQueuePartitionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_CreateSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateScheduleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).CreateSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_CreateSchedule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).CreateSchedule(ctx, req.(*CreateScheduleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_DescribeSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeScheduleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).DescribeSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_DescribeSchedule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).DescribeSchedule(ctx, req.(*DescribeScheduleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_UpdateSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateScheduleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).UpdateSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_UpdateSchedule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).UpdateSchedule(ctx, req.(*UpdateScheduleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_PatchSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchScheduleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).PatchSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_PatchSchedule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).PatchSchedule(ctx, req.(*PatchScheduleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ListScheduleMatchingTimes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListScheduleMatchingTimesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ListScheduleMatchingTimes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_ListScheduleMatchingTimes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ListScheduleMatchingTimes(ctx, req.(*ListScheduleMatchingTimesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_DeleteSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteScheduleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).DeleteSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_DeleteSchedule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).DeleteSchedule(ctx, req.(*DeleteScheduleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ListSchedules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSchedulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ListSchedules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_ListSchedules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ListSchedules(ctx, req.(*ListSchedulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_UpdateWorkerBuildIdCompatibility_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateWorkerBuildIdCompatibilityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).UpdateWorkerBuildIdCompatibility(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_UpdateWorkerBuildIdCompatibility_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).UpdateWorkerBuildIdCompatibility(ctx, req.(*UpdateWorkerBuildIdCompatibilityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_GetWorkerBuildIdCompatibility_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWorkerBuildIdCompatibilityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).GetWorkerBuildIdCompatibility(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_GetWorkerBuildIdCompatibility_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).GetWorkerBuildIdCompatibility(ctx, req.(*GetWorkerBuildIdCompatibilityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_UpdateWorkerVersioningRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateWorkerVersioningRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).UpdateWorkerVersioningRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_UpdateWorkerVersioningRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).UpdateWorkerVersioningRules(ctx, req.(*UpdateWorkerVersioningRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_GetWorkerVersioningRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWorkerVersioningRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).GetWorkerVersioningRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_GetWorkerVersioningRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).GetWorkerVersioningRules(ctx, req.(*GetWorkerVersioningRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_GetWorkerTaskReachability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWorkerTaskReachabilityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).GetWorkerTaskReachability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_GetWorkerTaskReachability_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).GetWorkerTaskReachability(ctx, req.(*GetWorkerTaskReachabilityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_DescribeDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeDeploymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).DescribeDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_DescribeDeployment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).DescribeDeployment(ctx, req.(*DescribeDeploymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_DescribeWorkerDeploymentVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeWorkerDeploymentVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).DescribeWorkerDeploymentVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_DescribeWorkerDeploymentVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).DescribeWorkerDeploymentVersion(ctx, req.(*DescribeWorkerDeploymentVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ListDeployments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDeploymentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ListDeployments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_ListDeployments_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ListDeployments(ctx, req.(*ListDeploymentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_GetDeploymentReachability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDeploymentReachabilityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).GetDeploymentReachability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_GetDeploymentReachability_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).GetDeploymentReachability(ctx, req.(*GetDeploymentReachabilityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_GetCurrentDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCurrentDeploymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).GetCurrentDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_GetCurrentDeployment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).GetCurrentDeployment(ctx, req.(*GetCurrentDeploymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_SetCurrentDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetCurrentDeploymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).SetCurrentDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_SetCurrentDeployment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).SetCurrentDeployment(ctx, req.(*SetCurrentDeploymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_SetWorkerDeploymentCurrentVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetWorkerDeploymentCurrentVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).SetWorkerDeploymentCurrentVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_SetWorkerDeploymentCurrentVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).SetWorkerDeploymentCurrentVersion(ctx, req.(*SetWorkerDeploymentCurrentVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_DescribeWorkerDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeWorkerDeploymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).DescribeWorkerDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_DescribeWorkerDeployment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).DescribeWorkerDeployment(ctx, req.(*DescribeWorkerDeploymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_DeleteWorkerDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteWorkerDeploymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).DeleteWorkerDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_DeleteWorkerDeployment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).DeleteWorkerDeployment(ctx, req.(*DeleteWorkerDeploymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_DeleteWorkerDeploymentVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteWorkerDeploymentVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).DeleteWorkerDeploymentVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_DeleteWorkerDeploymentVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).DeleteWorkerDeploymentVersion(ctx, req.(*DeleteWorkerDeploymentVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_SetWorkerDeploymentRampingVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetWorkerDeploymentRampingVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).SetWorkerDeploymentRampingVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_SetWorkerDeploymentRampingVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).SetWorkerDeploymentRampingVersion(ctx, req.(*SetWorkerDeploymentRampingVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ListWorkerDeployments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListWorkerDeploymentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ListWorkerDeployments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_ListWorkerDeployments_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ListWorkerDeployments(ctx, req.(*ListWorkerDeploymentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_UpdateWorkerDeploymentVersionMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateWorkerDeploymentVersionMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).UpdateWorkerDeploymentVersionMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_UpdateWorkerDeploymentVersionMetadata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).UpdateWorkerDeploymentVersionMetadata(ctx, req.(*UpdateWorkerDeploymentVersionMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_UpdateWorkflowExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateWorkflowExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).UpdateWorkflowExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_UpdateWorkflowExecution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).UpdateWorkflowExecution(ctx, req.(*UpdateWorkflowExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_PollWorkflowExecutionUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PollWorkflowExecutionUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).PollWorkflowExecutionUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_PollWorkflowExecutionUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).PollWorkflowExecutionUpdate(ctx, req.(*PollWorkflowExecutionUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_StartBatchOperation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartBatchOperationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).StartBatchOperation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_StartBatchOperation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).StartBatchOperation(ctx, req.(*StartBatchOperationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_StopBatchOperation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopBatchOperationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).StopBatchOperation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_StopBatchOperation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).StopBatchOperation(ctx, req.(*StopBatchOperationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_DescribeBatchOperation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeBatchOperationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).DescribeBatchOperation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_DescribeBatchOperation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).DescribeBatchOperation(ctx, req.(*DescribeBatchOperationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ListBatchOperations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBatchOperationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ListBatchOperations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_ListBatchOperations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ListBatchOperations(ctx, req.(*ListBatchOperationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_PollNexusTaskQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PollNexusTaskQueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).PollNexusTaskQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_PollNexusTaskQueue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).PollNexusTaskQueue(ctx, req.(*PollNexusTaskQueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RespondNexusTaskCompleted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondNexusTaskCompletedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RespondNexusTaskCompleted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_RespondNexusTaskCompleted_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RespondNexusTaskCompleted(ctx, req.(*RespondNexusTaskCompletedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RespondNexusTaskFailed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondNexusTaskFailedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RespondNexusTaskFailed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_RespondNexusTaskFailed_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RespondNexusTaskFailed(ctx, req.(*RespondNexusTaskFailedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_UpdateActivityOptions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateActivityOptionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).UpdateActivityOptions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_UpdateActivityOptions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).UpdateActivityOptions(ctx, req.(*UpdateActivityOptionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_UpdateWorkflowExecutionOptions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateWorkflowExecutionOptionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).UpdateWorkflowExecutionOptions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_UpdateWorkflowExecutionOptions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).UpdateWorkflowExecutionOptions(ctx, req.(*UpdateWorkflowExecutionOptionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_PauseActivity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PauseActivityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).PauseActivity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_PauseActivity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).PauseActivity(ctx, req.(*PauseActivityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_UnpauseActivity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnpauseActivityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).UnpauseActivity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_UnpauseActivity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).UnpauseActivity(ctx, req.(*UnpauseActivityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ResetActivity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetActivityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ResetActivity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_ResetActivity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ResetActivity(ctx, req.(*ResetActivityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_CreateWorkflowRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateWorkflowRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).CreateWorkflowRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_CreateWorkflowRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).CreateWorkflowRule(ctx, req.(*CreateWorkflowRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_DescribeWorkflowRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeWorkflowRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).DescribeWorkflowRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_DescribeWorkflowRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).DescribeWorkflowRule(ctx, req.(*DescribeWorkflowRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_DeleteWorkflowRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteWorkflowRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).DeleteWorkflowRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_DeleteWorkflowRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).DeleteWorkflowRule(ctx, req.(*DeleteWorkflowRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ListWorkflowRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListWorkflowRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ListWorkflowRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_ListWorkflowRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ListWorkflowRules(ctx, req.(*ListWorkflowRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_TriggerWorkflowRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TriggerWorkflowRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).TriggerWorkflowRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_TriggerWorkflowRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).TriggerWorkflowRule(ctx, req.(*TriggerWorkflowRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RecordWorkerHeartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordWorkerHeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RecordWorkerHeartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_RecordWorkerHeartbeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RecordWorkerHeartbeat(ctx, req.(*RecordWorkerHeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ListWorkers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListWorkersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ListWorkers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_ListWorkers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ListWorkers(ctx, req.(*ListWorkersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_UpdateTaskQueueConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTaskQueueConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).UpdateTaskQueueConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_UpdateTaskQueueConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).UpdateTaskQueueConfig(ctx, req.(*UpdateTaskQueueConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_FetchWorkerConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FetchWorkerConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).FetchWorkerConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_FetchWorkerConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).FetchWorkerConfig(ctx, req.(*FetchWorkerConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_UpdateWorkerConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateWorkerConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).UpdateWorkerConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_UpdateWorkerConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).UpdateWorkerConfig(ctx, req.(*UpdateWorkerConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// WorkflowService_ServiceDesc is the grpc.ServiceDesc for WorkflowService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WorkflowService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "temporal.api.workflowservice.v1.WorkflowService",
	HandlerType: (*WorkflowServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterNamespace",
			Handler:    _WorkflowService_RegisterNamespace_Handler,
		},
		{
			MethodName: "DescribeNamespace",
			Handler:    _WorkflowService_DescribeNamespace_Handler,
		},
		{
			MethodName: "ListNamespaces",
			Handler:    _WorkflowService_ListNamespaces_Handler,
		},
		{
			MethodName: "UpdateNamespace",
			Handler:    _WorkflowService_UpdateNamespace_Handler,
		},
		{
			MethodName: "DeprecateNamespace",
			Handler:    _WorkflowService_DeprecateNamespace_Handler,
		},
		{
			MethodName: "StartWorkflowExecution",
			Handler:    _WorkflowService_StartWorkflowExecution_Handler,
		},
		{
			MethodName: "ExecuteMultiOperation",
			Handler:    _WorkflowService_ExecuteMultiOperation_Handler,
		},
		{
			MethodName: "GetWorkflowExecutionHistory",
			Handler:    _WorkflowService_GetWorkflowExecutionHistory_Handler,
		},
		{
			MethodName: "GetWorkflowExecutionHistoryReverse",
			Handler:    _WorkflowService_GetWorkflowExecutionHistoryReverse_Handler,
		},
		{
			MethodName: "PollWorkflowTaskQueue",
			Handler:    _WorkflowService_PollWorkflowTaskQueue_Handler,
		},
		{
			MethodName: "RespondWorkflowTaskCompleted",
			Handler:    _WorkflowService_RespondWorkflowTaskCompleted_Handler,
		},
		{
			MethodName: "RespondWorkflowTaskFailed",
			Handler:    _WorkflowService_RespondWorkflowTaskFailed_Handler,
		},
		{
			MethodName: "PollActivityTaskQueue",
			Handler:    _WorkflowService_PollActivityTaskQueue_Handler,
		},
		{
			MethodName: "RecordActivityTaskHeartbeat",
			Handler:    _WorkflowService_RecordActivityTaskHeartbeat_Handler,
		},
		{
			MethodName: "RecordActivityTaskHeartbeatById",
			Handler:    _WorkflowService_RecordActivityTaskHeartbeatById_Handler,
		},
		{
			MethodName: "RespondActivityTaskCompleted",
			Handler:    _WorkflowService_RespondActivityTaskCompleted_Handler,
		},
		{
			MethodName: "RespondActivityTaskCompletedById",
			Handler:    _WorkflowService_RespondActivityTaskCompletedById_Handler,
		},
		{
			MethodName: "RespondActivityTaskFailed",
			Handler:    _WorkflowService_RespondActivityTaskFailed_Handler,
		},
		{
			MethodName: "RespondActivityTaskFailedById",
			Handler:    _WorkflowService_RespondActivityTaskFailedById_Handler,
		},
		{
			MethodName: "RespondActivityTaskCanceled",
			Handler:    _WorkflowService_RespondActivityTaskCanceled_Handler,
		},
		{
			MethodName: "RespondActivityTaskCanceledById",
			Handler:    _WorkflowService_RespondActivityTaskCanceledById_Handler,
		},
		{
			MethodName: "RequestCancelWorkflowExecution",
			Handler:    _WorkflowService_RequestCancelWorkflowExecution_Handler,
		},
		{
			MethodName: "SignalWorkflowExecution",
			Handler:    _WorkflowService_SignalWorkflowExecution_Handler,
		},
		{
			MethodName: "SignalWithStartWorkflowExecution",
			Handler:    _WorkflowService_SignalWithStartWorkflowExecution_Handler,
		},
		{
			MethodName: "ResetWorkflowExecution",
			Handler:    _WorkflowService_ResetWorkflowExecution_Handler,
		},
		{
			MethodName: "TerminateWorkflowExecution",
			Handler:    _WorkflowService_TerminateWorkflowExecution_Handler,
		},
		{
			MethodName: "DeleteWorkflowExecution",
			Handler:    _WorkflowService_DeleteWorkflowExecution_Handler,
		},
		{
			MethodName: "ListOpenWorkflowExecutions",
			Handler:    _WorkflowService_ListOpenWorkflowExecutions_Handler,
		},
		{
			MethodName: "ListClosedWorkflowExecutions",
			Handler:    _WorkflowService_ListClosedWorkflowExecutions_Handler,
		},
		{
			MethodName: "ListWorkflowExecutions",
			Handler:    _WorkflowService_ListWorkflowExecutions_Handler,
		},
		{
			MethodName: "ListArchivedWorkflowExecutions",
			Handler:    _WorkflowService_ListArchivedWorkflowExecutions_Handler,
		},
		{
			MethodName: "ScanWorkflowExecutions",
			Handler:    _WorkflowService_ScanWorkflowExecutions_Handler,
		},
		{
			MethodName: "CountWorkflowExecutions",
			Handler:    _WorkflowService_CountWorkflowExecutions_Handler,
		},
		{
			MethodName: "GetSearchAttributes",
			Handler:    _WorkflowService_GetSearchAttributes_Handler,
		},
		{
			MethodName: "RespondQueryTaskCompleted",
			Handler:    _WorkflowService_RespondQueryTaskCompleted_Handler,
		},
		{
			MethodName: "ResetStickyTaskQueue",
			Handler:    _WorkflowService_ResetStickyTaskQueue_Handler,
		},
		{
			MethodName: "ShutdownWorker",
			Handler:    _WorkflowService_ShutdownWorker_Handler,
		},
		{
			MethodName: "QueryWorkflow",
			Handler:    _WorkflowService_QueryWorkflow_Handler,
		},
		{
			MethodName: "DescribeWorkflowExecution",
			Handler:    _WorkflowService_DescribeWorkflowExecution_Handler,
		},
		{
			MethodName: "DescribeTaskQueue",
			Handler:    _WorkflowService_DescribeTaskQueue_Handler,
		},
		{
			MethodName: "GetClusterInfo",
			Handler:    _WorkflowService_GetClusterInfo_Handler,
		},
		{
			MethodName: "GetSystemInfo",
			Handler:    _WorkflowService_GetSystemInfo_Handler,
		},
		{
			MethodName: "ListTaskQueuePartitions",
			Handler:    _WorkflowService_ListTaskQueuePartitions_Handler,
		},
		{
			MethodName: "CreateSchedule",
			Handler:    _WorkflowService_CreateSchedule_Handler,
		},
		{
			MethodName: "DescribeSchedule",
			Handler:    _WorkflowService_DescribeSchedule_Handler,
		},
		{
			MethodName: "UpdateSchedule",
			Handler:    _WorkflowService_UpdateSchedule_Handler,
		},
		{
			MethodName: "PatchSchedule",
			Handler:    _WorkflowService_PatchSchedule_Handler,
		},
		{
			MethodName: "ListScheduleMatchingTimes",
			Handler:    _WorkflowService_ListScheduleMatchingTimes_Handler,
		},
		{
			MethodName: "DeleteSchedule",
			Handler:    _WorkflowService_DeleteSchedule_Handler,
		},
		{
			MethodName: "ListSchedules",
			Handler:    _WorkflowService_ListSchedules_Handler,
		},
		{
			MethodName: "UpdateWorkerBuildIdCompatibility",
			Handler:    _WorkflowService_UpdateWorkerBuildIdCompatibility_Handler,
		},
		{
			MethodName: "GetWorkerBuildIdCompatibility",
			Handler:    _WorkflowService_GetWorkerBuildIdCompatibility_Handler,
		},
		{
			MethodName: "UpdateWorkerVersioningRules",
			Handler:    _WorkflowService_UpdateWorkerVersioningRules_Handler,
		},
		{
			MethodName: "GetWorkerVersioningRules",
			Handler:    _WorkflowService_GetWorkerVersioningRules_Handler,
		},
		{
			MethodName: "GetWorkerTaskReachability",
			Handler:    _WorkflowService_GetWorkerTaskReachability_Handler,
		},
		{
			MethodName: "DescribeDeployment",
			Handler:    _WorkflowService_DescribeDeployment_Handler,
		},
		{
			MethodName: "DescribeWorkerDeploymentVersion",
			Handler:    _WorkflowService_DescribeWorkerDeploymentVersion_Handler,
		},
		{
			MethodName: "ListDeployments",
			Handler:    _WorkflowService_ListDeployments_Handler,
		},
		{
			MethodName: "GetDeploymentReachability",
			Handler:    _WorkflowService_GetDeploymentReachability_Handler,
		},
		{
			MethodName: "GetCurrentDeployment",
			Handler:    _WorkflowService_GetCurrentDeployment_Handler,
		},
		{
			MethodName: "SetCurrentDeployment",
			Handler:    _WorkflowService_SetCurrentDeployment_Handler,
		},
		{
			MethodName: "SetWorkerDeploymentCurrentVersion",
			Handler:    _WorkflowService_SetWorkerDeploymentCurrentVersion_Handler,
		},
		{
			MethodName: "DescribeWorkerDeployment",
			Handler:    _WorkflowService_DescribeWorkerDeployment_Handler,
		},
		{
			MethodName: "DeleteWorkerDeployment",
			Handler:    _WorkflowService_DeleteWorkerDeployment_Handler,
		},
		{
			MethodName: "DeleteWorkerDeploymentVersion",
			Handler:    _WorkflowService_DeleteWorkerDeploymentVersion_Handler,
		},
		{
			MethodName: "SetWorkerDeploymentRampingVersion",
			Handler:    _WorkflowService_SetWorkerDeploymentRampingVersion_Handler,
		},
		{
			MethodName: "ListWorkerDeployments",
			Handler:    _WorkflowService_ListWorkerDeployments_Handler,
		},
		{
			MethodName: "UpdateWorkerDeploymentVersionMetadata",
			Handler:    _WorkflowService_UpdateWorkerDeploymentVersionMetadata_Handler,
		},
		{
			MethodName: "UpdateWorkflowExecution",
			Handler:    _WorkflowService_UpdateWorkflowExecution_Handler,
		},
		{
			MethodName: "PollWorkflowExecutionUpdate",
			Handler:    _WorkflowService_PollWorkflowExecutionUpdate_Handler,
		},
		{
			MethodName: "StartBatchOperation",
			Handler:    _WorkflowService_StartBatchOperation_Handler,
		},
		{
			MethodName: "StopBatchOperation",
			Handler:    _WorkflowService_StopBatchOperation_Handler,
		},
		{
			MethodName: "DescribeBatchOperation",
			Handler:    _WorkflowService_DescribeBatchOperation_Handler,
		},
		{
			MethodName: "ListBatchOperations",
			Handler:    _WorkflowService_ListBatchOperations_Handler,
		},
		{
			MethodName: "PollNexusTaskQueue",
			Handler:    _WorkflowService_PollNexusTaskQueue_Handler,
		},
		{
			MethodName: "RespondNexusTaskCompleted",
			Handler:    _WorkflowService_RespondNexusTaskCompleted_Handler,
		},
		{
			MethodName: "RespondNexusTaskFailed",
			Handler:    _WorkflowService_RespondNexusTaskFailed_Handler,
		},
		{
			MethodName: "UpdateActivityOptions",
			Handler:    _WorkflowService_UpdateActivityOptions_Handler,
		},
		{
			MethodName: "UpdateWorkflowExecutionOptions",
			Handler:    _WorkflowService_UpdateWorkflowExecutionOptions_Handler,
		},
		{
			MethodName: "PauseActivity",
			Handler:    _WorkflowService_PauseActivity_Handler,
		},
		{
			MethodName: "UnpauseActivity",
			Handler:    _WorkflowService_UnpauseActivity_Handler,
		},
		{
			MethodName: "ResetActivity",
			Handler:    _WorkflowService_ResetActivity_Handler,
		},
		{
			MethodName: "CreateWorkflowRule",
			Handler:    _WorkflowService_CreateWorkflowRule_Handler,
		},
		{
			MethodName: "DescribeWorkflowRule",
			Handler:    _WorkflowService_DescribeWorkflowRule_Handler,
		},
		{
			MethodName: "DeleteWorkflowRule",
			Handler:    _WorkflowService_DeleteWorkflowRule_Handler,
		},
		{
			MethodName: "ListWorkflowRules",
			Handler:    _WorkflowService_ListWorkflowRules_Handler,
		},
		{
			MethodName: "TriggerWorkflowRule",
			Handler:    _WorkflowService_TriggerWorkflowRule_Handler,
		},
		{
			MethodName: "RecordWorkerHeartbeat",
			Handler:    _WorkflowService_RecordWorkerHeartbeat_Handler,
		},
		{
			MethodName: "ListWorkers",
			Handler:    _WorkflowService_ListWorkers_Handler,
		},
		{
			MethodName: "UpdateTaskQueueConfig",
			Handler:    _WorkflowService_UpdateTaskQueueConfig_Handler,
		},
		{
			MethodName: "FetchWorkerConfig",
			Handler:    _WorkflowService_FetchWorkerConfig_Handler,
		},
		{
			MethodName: "UpdateWorkerConfig",
			Handler:    _WorkflowService_UpdateWorkerConfig_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "temporal/api/workflowservice/v1/service.proto",
}
